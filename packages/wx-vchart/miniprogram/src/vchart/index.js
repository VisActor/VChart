!(function (t, e) {
  'object' == typeof exports && 'undefined' != typeof module
    ? e(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], e)
    : e(((t = 'undefined' != typeof globalThis ? globalThis : t || self).VChart = {}));
})(this, function (t) {
  'use strict';
  var e =
    'undefined' != typeof globalThis
      ? globalThis
      : 'undefined' != typeof window
      ? window
      : 'undefined' != typeof global
      ? global
      : 'undefined' != typeof self
      ? self
      : {};
  function i(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t;
  }
  var n = { exports: {} };
  !(function (t) {
    var e = Object.prototype.hasOwnProperty,
      i = '~';
    function n() {}
    function s(t, e, i) {
      (this.fn = t), (this.context = e), (this.once = i || !1);
    }
    function r(t, e, n, r, a) {
      if ('function' != typeof n) throw new TypeError('The listener must be a function');
      var o = new s(n, r || t, a),
        l = i ? i + e : e;
      return (
        t._events[l]
          ? t._events[l].fn
            ? (t._events[l] = [t._events[l], o])
            : t._events[l].push(o)
          : ((t._events[l] = o), t._eventsCount++),
        t
      );
    }
    function a(t, e) {
      0 == --t._eventsCount ? (t._events = new n()) : delete t._events[e];
    }
    function o() {
      (this._events = new n()), (this._eventsCount = 0);
    }
    Object.create && ((n.prototype = Object.create(null)), new n().__proto__ || (i = !1)),
      (o.prototype.eventNames = function () {
        var t,
          n,
          s = [];
        if (0 === this._eventsCount) return s;
        for (n in (t = this._events)) e.call(t, n) && s.push(i ? n.slice(1) : n);
        return Object.getOwnPropertySymbols ? s.concat(Object.getOwnPropertySymbols(t)) : s;
      }),
      (o.prototype.listeners = function (t) {
        var e = i ? i + t : t,
          n = this._events[e];
        if (!n) return [];
        if (n.fn) return [n.fn];
        for (var s = 0, r = n.length, a = new Array(r); s < r; s++) a[s] = n[s].fn;
        return a;
      }),
      (o.prototype.listenerCount = function (t) {
        var e = i ? i + t : t,
          n = this._events[e];
        return n ? (n.fn ? 1 : n.length) : 0;
      }),
      (o.prototype.emit = function (t, e, n, s, r, a) {
        var o = i ? i + t : t;
        if (!this._events[o]) return !1;
        var l,
          h,
          c = this._events[o],
          d = arguments.length;
        if (c.fn) {
          switch ((c.once && this.removeListener(t, c.fn, void 0, !0), d)) {
            case 1:
              return c.fn.call(c.context), !0;
            case 2:
              return c.fn.call(c.context, e), !0;
            case 3:
              return c.fn.call(c.context, e, n), !0;
            case 4:
              return c.fn.call(c.context, e, n, s), !0;
            case 5:
              return c.fn.call(c.context, e, n, s, r), !0;
            case 6:
              return c.fn.call(c.context, e, n, s, r, a), !0;
          }
          for (h = 1, l = new Array(d - 1); h < d; h++) l[h - 1] = arguments[h];
          c.fn.apply(c.context, l);
        } else {
          var u,
            p = c.length;
          for (h = 0; h < p; h++)
            switch ((c[h].once && this.removeListener(t, c[h].fn, void 0, !0), d)) {
              case 1:
                c[h].fn.call(c[h].context);
                break;
              case 2:
                c[h].fn.call(c[h].context, e);
                break;
              case 3:
                c[h].fn.call(c[h].context, e, n);
                break;
              case 4:
                c[h].fn.call(c[h].context, e, n, s);
                break;
              default:
                if (!l) for (u = 1, l = new Array(d - 1); u < d; u++) l[u - 1] = arguments[u];
                c[h].fn.apply(c[h].context, l);
            }
        }
        return !0;
      }),
      (o.prototype.on = function (t, e, i) {
        return r(this, t, e, i, !1);
      }),
      (o.prototype.once = function (t, e, i) {
        return r(this, t, e, i, !0);
      }),
      (o.prototype.removeListener = function (t, e, n, s) {
        var r = i ? i + t : t;
        if (!this._events[r]) return this;
        if (!e) return a(this, r), this;
        var o = this._events[r];
        if (o.fn) o.fn !== e || (s && !o.once) || (n && o.context !== n) || a(this, r);
        else {
          for (var l = 0, h = [], c = o.length; l < c; l++)
            (o[l].fn !== e || (s && !o[l].once) || (n && o[l].context !== n)) && h.push(o[l]);
          h.length ? (this._events[r] = 1 === h.length ? h[0] : h) : a(this, r);
        }
        return this;
      }),
      (o.prototype.removeAllListeners = function (t) {
        var e;
        return (
          t
            ? ((e = i ? i + t : t), this._events[e] && a(this, e))
            : ((this._events = new n()), (this._eventsCount = 0)),
          this
        );
      }),
      (o.prototype.off = o.prototype.removeListener),
      (o.prototype.addListener = o.prototype.on),
      (o.prefixed = i),
      (o.EventEmitter = o),
      (t.exports = o);
  })(n);
  var s = i(n.exports);
  var r = (t, e) => Object.prototype.toString.call(t) === `[object ${e}]`;
  var a = function (t) {
    return arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
      ? 'boolean' == typeof t
      : !0 === t || !1 === t || r(t, 'Boolean');
  };
  var o = t => 'function' == typeof t;
  var l = t => null == t;
  var h = t => null != t;
  var c = t => {
    const e = typeof t;
    return (null !== t && 'object' === e) || 'function' === e;
  };
  var d = t => 'object' == typeof t && null !== t;
  var u = function (t) {
    if (!d(t) || !r(t, 'Object')) return !1;
    if (null === Object.getPrototypeOf(t)) return !0;
    let e = t;
    for (; null !== Object.getPrototypeOf(e); ) e = Object.getPrototypeOf(e);
    return Object.getPrototypeOf(t) === e;
  };
  var p = t => void 0 === t;
  var g = function (t) {
    const e = typeof t;
    return arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
      ? 'string' === e
      : 'string' === e || r(t, 'String');
  };
  var f = t => (Array.isArray ? Array.isArray(t) : r(t, 'Array'));
  var v = function (t) {
    return null !== t && 'function' != typeof t && Number.isFinite(t.length);
  };
  var m = t => r(t, 'Date');
  var y = function (t) {
    const e = typeof t;
    return arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
      ? 'number' === e
      : 'number' === e || r(t, 'Number');
  };
  var _ = t => y(t) && Number.isFinite(t);
  var b = t => new RegExp(/^(http(s)?:\/\/)\w+[^\s]+(\.[^\s]+){1,}$/).test(t);
  var x = t => r(t, 'RegExp');
  var S = t =>
    new RegExp(/^data:image\/(?:gif|png|jpeg|bmp|webp)(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}/g).test(t);
  var w = t =>
    ({}.toString
      .call(t)
      .replace(/^\[object /, '')
      .replace(/]$/, ''));
  const A = Object.prototype;
  var k = function (t) {
    const e = t && t.constructor;
    return t === (('function' == typeof e && e.prototype) || A);
  };
  const M = Object.prototype.hasOwnProperty;
  function T(t) {
    if (l(t)) return !0;
    if (v(t)) return !t.length;
    const e = w(t);
    if ('Map' === e || 'Set' === e) return !t.size;
    if (k(t)) return !Object.keys(t).length;
    for (const e in t) if (M.call(t, e)) return !1;
    return !0;
  }
  var C = (t, e, i) => {
    const n = g(e) ? e.split('.') : e;
    for (let e = 0; e < n.length; e++) t = t ? t[n[e]] : void 0;
    return void 0 === t ? i : t;
  };
  const E = Object.prototype.hasOwnProperty;
  var P = (t, e) => null != t && E.call(t, e);
  function R(t) {
    let e;
    if (!h(t) || 'object' != typeof t) return t;
    const i = f(t),
      n = t.length;
    e = i ? new Array(n) : 'object' == typeof t ? {} : a(t) || y(t) || g(t) ? t : m(t) ? new Date(+t) : void 0;
    const s = i ? void 0 : Object.keys(Object(t));
    let r = -1;
    if (e)
      for (; ++r < (s || t).length; ) {
        const i = s ? s[r] : r,
          n = t[i];
        e[i] = R(n);
      }
    return e;
  }
  function O(t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (e) {
      if (t === e) return;
      if (h(e) && 'object' == typeof e) {
        const n = Object(e),
          s = [];
        for (const t in n) s.push(t);
        let { length: r } = s,
          a = -1;
        for (; r--; ) {
          const r = s[++a];
          h(n[r]) && 'object' == typeof n[r] ? B(t, e, r, i) : I(t, r, n[r]);
        }
      }
    }
  }
  function B(t, e, i) {
    let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    const s = t[i],
      r = e[i];
    let a = e[i],
      o = !0;
    if (f(r)) {
      if (n) a = [];
      else if (f(s)) a = s;
      else if (v(s)) {
        a = new Array(s.length);
        let t = -1;
        const e = s.length;
        for (; ++t < e; ) a[t] = s[t];
      }
    } else u(r) ? ((a = s), ('function' != typeof s && 'object' == typeof s) || (a = {})) : (o = !1);
    o && O(a, r, n), I(t, i, a);
  }
  function I(t, e, i) {
    ((void 0 !== i &&
      !(function (t, e) {
        return t === e || (Number.isNaN(t) && Number.isNaN(e));
      })(t[e], i)) ||
      (void 0 === i && !(e in t))) &&
      (t[e] = i);
  }
  function D(t) {
    let e = -1;
    const i = arguments.length <= 1 ? 0 : arguments.length - 1;
    for (; ++e < i; ) O(t, e + 1 < 1 || arguments.length <= e + 1 ? void 0 : arguments[e + 1], !0);
    return t;
  }
  function L(t, e) {
    if (!t || !u(t)) return t;
    const i = {};
    return (
      Object.keys(t).forEach(n => {
        const s = t[n];
        let r = !1;
        e.forEach(t => {
          ((g(t) && t === n) || (t instanceof RegExp && n.match(t))) && (r = !0);
        }),
          r || (i[n] = s);
      }),
      i
    );
  }
  function F(t) {
    return Object.prototype.toString.call(t);
  }
  function j(t) {
    return Object.keys(t);
  }
  function z(t, e) {
    if (t === e) return !0;
    if (typeof t != typeof e) return !1;
    if (null == t || null == e) return !1;
    if (Number.isNaN(t) && Number.isNaN(e)) return !0;
    if (F(t) !== F(e)) return !1;
    if (o(t)) return !1;
    if ('object' != typeof t) return !1;
    if (f(t)) {
      if (t.length !== e.length) return !1;
      for (let i = t.length - 1; i >= 0; i--) if (!z(t[i], e[i])) return !1;
      return !0;
    }
    if (!u(t)) return !1;
    const i = j(t),
      n = j(e);
    if (i.length !== n.length) return !1;
    i.sort(), n.sort();
    for (let t = i.length - 1; t >= 0; t--) if (i[t] != n[t]) return !1;
    for (let n = i.length - 1; n >= 0; n--) {
      const s = i[n];
      if (!z(t[s], e[s])) return !1;
    }
    return !0;
  }
  function H(t, e, i) {
    const n = (function (t) {
      if (!t) return [];
      if (Object.keys) return Object.keys(t);
      const e = [];
      for (const i in t) t.hasOwnProperty(i) && e.push(i);
      return e;
    })(e);
    for (let s = 0; s < n.length; s++) {
      const r = n[s];
      (i ? null != e[r] : null == t[r]) && (t[r] = e[r]);
    }
    return t;
  }
  function N(t, e) {
    let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    if (
      ((t = 'prototype' in t ? t.prototype : t), (e = 'prototype' in e ? e.prototype : e), Object.getOwnPropertyNames)
    ) {
      const n = Object.getOwnPropertyNames(e);
      for (let s = 0; s < n.length; s++) {
        const r = n[s];
        'constructor' !== r && (i ? null != e[r] : null == t[r]) && (t[r] = e[r]);
      }
    } else H(t, e, i);
  }
  function V(t) {
    return h(t) ? (f(t) ? t : [t]) : [];
  }
  function W(t) {
    if (v(t)) return t[t.length - 1];
  }
  function G(t) {
    if (t && f(t)) return t.reduce((t, e) => Math.min(t, e), 1 / 0);
  }
  function U(t, e) {
    if (!f(t) || !f(e)) return !1;
    if (t.length !== e.length) return !1;
    for (let i = 0; i < t.length; i++) if (t[i] !== e[i]) return !1;
    return !0;
  }
  function Y(t) {
    let e,
      i,
      n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Math.random,
      s = t.length;
    for (; s; ) (e = Math.floor(n() * s)), (i = t[--s]), (t[s] = t[e]), (t[e] = i);
    return t;
  }
  function $(t) {
    if (!f(t)) return [t];
    const e = [];
    for (const i of t) e.push(...$(i));
    return e;
  }
  function X(t, e, i) {
    h(e) || ((e = t), (t = 0)), h(i) || (i = 1);
    let n = -1;
    const s = 0 | Math.max(0, Math.ceil((e - t) / i)),
      r = new Array(s);
    for (; ++n < s; ) r[n] = t + n * i;
    return r;
  }
  function K(t, e) {
    return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
  }
  function q(t) {
    return Number(t);
  }
  function Z(t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : q;
    const n = t.length;
    if (!n) return;
    if (e <= 0 || n < 2) return i(t[0], 0, t);
    if (e >= 1) return i(t[n - 1], n - 1, t);
    const s = (n - 1) * e,
      r = Math.floor(s),
      a = i(t[r], r, t);
    return a + (i(t[r + 1], r + 1, t) - a) * (s - r);
  }
  function J(t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
      n = arguments.length > 3 ? arguments[3] : void 0;
    for (l(n) && (n = t.length); i < n; ) {
      const s = (i + n) >>> 1;
      K(t[s], e) > 0 ? (n = s) : (i = s + 1);
    }
    return i;
  }
  const Q = (t, e) => {
      let i = t;
      return !0 !== e && (i = t.sort(K)), Z(i, 0.5);
    },
    et = Math.sqrt(50),
    it = Math.sqrt(10),
    nt = Math.sqrt(2);
  function st(t, e, i) {
    const n = Math.abs(e - t) / Math.max(0, i);
    let s = Math.pow(10, Math.floor(Math.log(n) / Math.LN10));
    const r = n / s;
    return r >= et ? (s *= 10) : r >= it ? (s *= 5) : r >= nt && (s *= 2), e < t ? -s : s;
  }
  const rt = 1e-10,
    at = 1e-10;
  function ot(t, e) {
    const i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : rt,
      n = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : at) * Math.max(t, e);
    return Math.abs(t - e) <= Math.max(i, n);
  }
  function lt(t, e, i, n) {
    return t > e && !ot(t, e, i, n);
  }
  function ht(t, e, i, n) {
    return t < e && !ot(t, e, i, n);
  }
  const ct = t => {
      let e = null,
        i = null;
      return function () {
        for (var n = arguments.length, s = new Array(n), r = 0; r < n; r++) s[r] = arguments[r];
        return (e && s.every((t, i) => t === e[i])) || ((e = s), (i = t(...s))), i;
      };
    },
    dt = function (t) {
      let e = '',
        i = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0) - 1;
      for (; i >= 0; ) (e = `${e}${t}`), (i -= 1);
      return e;
    };
  var ut = function (t, e) {
    let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 'right';
    const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ' ',
      s = t + '',
      r = e - s.length;
    return r <= 0
      ? s
      : 'left' === i
      ? dt(n, r) + s
      : 'center' === i
      ? dt(n, Math.floor(r / 2)) + s + dt(n, Math.ceil(r / 2))
      : s + dt(n, r);
  };
  var pt = function (t, e, i) {
    return t < e ? e : t > i ? i : t;
  };
  var gt = (t, e, i) => {
    let [n, s] = t;
    s < n && ((n = t[1]), (s = t[0]));
    const r = s - n;
    return r >= i - e ? [e, i] : ((n = Math.min(Math.max(n, e), i - r)), [n, n + r]);
  };
  function ft(t, e) {
    let i;
    return t > e && ((i = t), (t = e), (e = i)), i => Math.max(t, Math.min(e, i));
  }
  let vt = !1;
  try {
    vt = 'function' == typeof requestAnimationFrame && 'function' == typeof cancelAnimationFrame;
  } catch (t) {
    vt = !1;
  }
  function mt(t, e, i) {
    let n,
      s,
      r,
      a,
      o,
      l,
      h = 0,
      d = !1,
      u = !1,
      p = !0;
    const g = !e && 0 !== e && vt;
    if ('function' != typeof t) throw new TypeError('Expected a function');
    function f(e) {
      const i = n,
        r = s;
      return (n = s = void 0), (h = e), (a = t.apply(r, i)), a;
    }
    function v(t, e) {
      return g ? (cancelAnimationFrame(o), requestAnimationFrame(t)) : setTimeout(t, e);
    }
    function m(t) {
      const i = t - l;
      return void 0 === l || i >= e || i < 0 || (u && t - h >= r);
    }
    function y() {
      const t = Date.now();
      if (m(t)) return b(t);
      o = v(
        y,
        (function (t) {
          const i = t - h,
            n = e - (t - l);
          return u ? Math.min(n, r - i) : n;
        })(t)
      );
    }
    function b(t) {
      return (o = void 0), p && n ? f(t) : ((n = s = void 0), a);
    }
    function x() {
      const t = Date.now(),
        i = m(t);
      for (var r = arguments.length, c = new Array(r), p = 0; p < r; p++) c[p] = arguments[p];
      if (((n = c), (s = this), (l = t), i)) {
        if (void 0 === o)
          return (function (t) {
            return (h = t), (o = v(y, e)), d ? f(t) : a;
          })(l);
        if (u) return (o = v(y, e)), f(l);
      }
      return void 0 === o && (o = v(y, e)), a;
    }
    return (
      (e = +e || 0),
      c(i) &&
        ((d = !!i.leading),
        (u = 'maxWait' in i),
        u && (r = Math.max(_(i.maxWait) ? i.maxWait : 0, e)),
        (p = 'trailing' in i ? !!i.trailing : p)),
      (x.cancel = function () {
        void 0 !== o &&
          (function (t) {
            if (g) return cancelAnimationFrame(t);
            clearTimeout(t);
          })(o),
          (h = 0),
          (n = l = s = o = void 0);
      }),
      (x.flush = function () {
        return void 0 === o ? a : b(Date.now());
      }),
      (x.pending = function () {
        return void 0 !== o;
      }),
      x
    );
  }
  function yt(t, e, i) {
    let n = !0,
      s = !0;
    if ('function' != typeof t) throw new TypeError('Expected a function');
    return (
      c(i) && ((n = 'leading' in i ? !!i.leading : n), (s = 'trailing' in i ? !!i.trailing : s)),
      mt(t, e, { leading: n, trailing: s, maxWait: e })
    );
  }
  function _t(t, e) {
    return i => t * (1 - i) + e * i;
  }
  function bt(t, e) {
    return function (i) {
      return Math.round(t * (1 - i) + e * i);
    };
  }
  vt = !1;
  const xt = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    St = new RegExp(xt.source, 'g');
  const wt =
    /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
  function At(t) {
    if (t instanceof Date) return t;
    if (g(t)) {
      const e = wt.exec(t);
      if (!e) return new Date(NaN);
      if (!e[8])
        return new Date(
          +e[1],
          +(e[2] || 1) - 1,
          +e[3] || 1,
          +e[4] || 0,
          +(e[5] || 0),
          +e[6] || 0,
          e[7] ? +e[7].substring(0, 3) : 0
        );
      let i = +e[4] || 0;
      return (
        'Z' !== e[8].toUpperCase() && (i -= +e[8].slice(0, 3)),
        new Date(
          Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, i, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0)
        )
      );
    }
    return l(t) ? new Date(NaN) : new Date(Math.round(t));
  }
  const kt = 1e-12,
    Mt = Math.PI,
    Tt = Mt / 2,
    Ct = 2 * Mt,
    Et = 2 * Math.PI,
    Pt = Math.abs,
    Rt = Math.atan2,
    Ot = Math.cos,
    Bt = Math.max,
    It = Math.min,
    Dt = Math.sin,
    Lt = Math.sqrt,
    Ft = Math.pow;
  function jt(t) {
    return t > 1 ? 0 : t < -1 ? Mt : Math.acos(t);
  }
  function zt(t) {
    return t >= 1 ? Tt : t <= -1 ? -Tt : Math.asin(t);
  }
  function Ht(t, e, i, n, s) {
    let r, a;
    return (
      'number' == typeof t && 'number' == typeof i && (r = (1 - s) * t + s * i),
      'number' == typeof e && 'number' == typeof n && (a = (1 - s) * e + s * n),
      { x: r, y: a }
    );
  }
  function Nt(t, e) {
    return t[0] * e[1] - t[1] * e[0];
  }
  function Vt(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10;
    return Math.round(t * e) / e;
  }
  function Wt(t) {
    const e = t.toString().split(/[eE]/),
      i = (e[0].split('.')[1] || '').length - (+e[1] || 0);
    return i > 0 ? i : 0;
  }
  function Gt(t, e) {
    return Vt(t + e, 10 ** Math.max(Wt(t), Wt(e)));
  }
  class Ut {
    constructor() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
        i = arguments.length > 2 ? arguments[2] : void 0,
        n = arguments.length > 3 ? arguments[3] : void 0;
      (this.x = 0), (this.y = 0), (this.x = t), (this.y = e), (this.x1 = i), (this.y1 = n);
    }
    clone() {
      return new Ut(this.x, this.y);
    }
    copyFrom(t) {
      return (
        (this.x = t.x),
        (this.y = t.y),
        (this.x1 = t.x1),
        (this.y1 = t.y1),
        (this.defined = t.defined),
        (this.context = t.context),
        this
      );
    }
    set(t, e) {
      return (this.x = t), (this.y = e), this;
    }
    add(t) {
      return y(t) ? ((this.x += t), void (this.y += t)) : ((this.x += t.x), (this.y += t.y), this);
    }
    sub(t) {
      return y(t) ? ((this.x -= t), void (this.y -= t)) : ((this.x -= t.x), (this.y -= t.y), this);
    }
    multi(t) {
      throw new Error('暂不支持');
    }
    div(t) {
      throw new Error('暂不支持');
    }
  }
  class Yt {
    static distancePP(t, e) {
      return Lt(Ft(t.x - e.x, 2) + Ft(t.y - e.y, 2));
    }
    static distanceNN(t, e, i, n) {
      return Lt(Ft(t - i, 2) + Ft(e - n, 2));
    }
    static distancePN(t, e, i) {
      return Lt(Ft(e - t.x, 2) + Ft(i - t.y, 2));
    }
    static pointAtPP(t, e, i) {
      return new Ut((e.x - t.x) * i + t.x, (e.y - t.y) * i + t.y);
    }
  }
  function $t(t, e, i) {
    const { x1: n, y1: s, x2: r, y2: a } = e;
    return i.onlyTranslate()
      ? (t !== e && t.setValue(e.x1, e.y1, e.x2, e.y2), t.translate(i.e, i.f), e)
      : (t.clear(),
        t.add(i.a * n + i.c * s + i.e, i.b * n + i.d * s + i.f),
        t.add(i.a * r + i.c * s + i.e, i.b * r + i.d * s + i.f),
        t.add(i.a * r + i.c * a + i.e, i.b * r + i.d * a + i.f),
        t.add(i.a * n + i.c * a + i.e, i.b * n + i.d * a + i.f),
        e);
  }
  class Xt {
    constructor(t) {
      t ? this.setValue(t.x1, t.y1, t.x2, t.y2) : this.clear();
    }
    clone() {
      return new Xt(this);
    }
    clear() {
      return (
        (this.x1 = +Number.MAX_VALUE),
        (this.y1 = +Number.MAX_VALUE),
        (this.x2 = -Number.MAX_VALUE),
        (this.y2 = -Number.MAX_VALUE),
        this
      );
    }
    empty() {
      return (
        this.x1 === +Number.MAX_VALUE &&
        this.y1 === +Number.MAX_VALUE &&
        this.x2 === -Number.MAX_VALUE &&
        this.y2 === -Number.MAX_VALUE
      );
    }
    equals(t) {
      return this.x1 === t.x1 && this.y1 === t.y1 && this.x2 === t.x2 && this.y2 === t.y2;
    }
    setValue() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
      return (this.x1 = t), (this.y1 = e), (this.x2 = i), (this.y2 = n), this;
    }
    set() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
      return (
        i < t ? ((this.x2 = t), (this.x1 = i)) : ((this.x1 = t), (this.x2 = i)),
        n < e ? ((this.y2 = e), (this.y1 = n)) : ((this.y1 = e), (this.y2 = n)),
        this
      );
    }
    add() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      return (
        t < this.x1 && (this.x1 = t),
        e < this.y1 && (this.y1 = e),
        t > this.x2 && (this.x2 = t),
        e > this.y2 && (this.y2 = e),
        this
      );
    }
    expand() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      return (
        f(t)
          ? ((this.y1 -= t[0]), (this.x2 += t[1]), (this.y2 += t[2]), (this.x1 -= t[3]))
          : ((this.x1 -= t), (this.y1 -= t), (this.x2 += t), (this.y2 += t)),
        this
      );
    }
    round() {
      return (
        (this.x1 = Math.floor(this.x1)),
        (this.y1 = Math.floor(this.y1)),
        (this.x2 = Math.ceil(this.x2)),
        (this.y2 = Math.ceil(this.y2)),
        this
      );
    }
    translate() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      return (this.x1 += t), (this.x2 += t), (this.y1 += e), (this.y2 += e), this;
    }
    rotate() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
      const n = this.rotatedPoints(t, e, i);
      return this.clear().add(n[0], n[1]).add(n[2], n[3]).add(n[4], n[5]).add(n[6], n[7]);
    }
    scale() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
      const s = this.scalePoints(t, e, i, n);
      return this.clear().add(s[0], s[1]).add(s[2], s[3]);
    }
    union(t) {
      return (
        t.x1 < this.x1 && (this.x1 = t.x1),
        t.y1 < this.y1 && (this.y1 = t.y1),
        t.x2 > this.x2 && (this.x2 = t.x2),
        t.y2 > this.y2 && (this.y2 = t.y2),
        this
      );
    }
    intersect(t) {
      return (
        t.x1 > this.x1 && (this.x1 = t.x1),
        t.y1 > this.y1 && (this.y1 = t.y1),
        t.x2 < this.x2 && (this.x2 = t.x2),
        t.y2 < this.y2 && (this.y2 = t.y2),
        this
      );
    }
    encloses(t) {
      return t && this.x1 <= t.x1 && this.x2 >= t.x2 && this.y1 <= t.y1 && this.y2 >= t.y2;
    }
    alignsWith(t) {
      return t && (this.x1 === t.x1 || this.x2 === t.x2 || this.y1 === t.y1 || this.y2 === t.y2);
    }
    intersects(t) {
      return t && !(this.x2 < t.x1 || this.x1 > t.x2 || this.y2 < t.y1 || this.y1 > t.y2);
    }
    contains() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      return !(t < this.x1 || t > this.x2 || e < this.y1 || e > this.y2);
    }
    containsPoint(t) {
      return !(t.x < this.x1 || t.x > this.x2 || t.y < this.y1 || t.y > this.y2);
    }
    width() {
      return this.empty() ? 0 : this.x2 - this.x1;
    }
    height() {
      return this.empty() ? 0 : this.y2 - this.y1;
    }
    scaleX() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      return (this.x1 *= t), (this.x2 *= t), this;
    }
    scaleY() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      return (this.y1 *= t), (this.y2 *= t), this;
    }
    transformWithMatrix(t) {
      return $t(this, this, t), this;
    }
    copy(t) {
      return (this.x1 = t.x1), (this.y1 = t.y1), (this.x2 = t.x2), (this.y2 = t.y2), this;
    }
    rotatedPoints(t, e, i) {
      const { x1: n, y1: s, x2: r, y2: a } = this,
        o = Math.cos(t),
        l = Math.sin(t),
        h = e - e * o + i * l,
        c = i - e * l - i * o;
      return [
        o * n - l * s + h,
        l * n + o * s + c,
        o * n - l * a + h,
        l * n + o * a + c,
        o * r - l * s + h,
        l * r + o * s + c,
        o * r - l * a + h,
        l * r + o * a + c
      ];
    }
    scalePoints(t, e, i, n) {
      const { x1: s, y1: r, x2: a, y2: o } = this;
      return [t * s + (1 - t) * i, e * r + (1 - e) * n, t * a + (1 - t) * i, e * o + (1 - e) * n];
    }
  }
  class Kt extends Xt {}
  function qt(t) {
    return t * (Math.PI / 180);
  }
  function Zt(t) {
    return (180 * t) / Math.PI;
  }
  const Jt = function () {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      if (t < 0) for (; t < -Ct; ) t += Ct;
      else if (t > 0) for (; t > Ct; ) t -= Ct;
      return t;
    },
    Qt = Jt;
  function te(t, e, i) {
    return { x: t.x + e * Math.cos(i), y: t.y + e * Math.sin(i) };
  }
  function ee(t, e) {
    return Math.atan2(e.y - t.y, e.x - t.x);
  }
  class ie {
    constructor() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
        s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
        r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
      (this.a = t), (this.b = e), (this.c = i), (this.d = n), (this.e = s), (this.f = r);
    }
    equalToMatrix(t) {
      return !(
        this.e !== t.e ||
        this.f !== t.f ||
        this.a !== t.a ||
        this.d !== t.d ||
        this.b !== t.b ||
        this.c !== t.c
      );
    }
    equalTo(t, e, i, n, s, r) {
      return !(this.e !== s || this.f !== r || this.a !== t || this.d !== n || this.b !== e || this.c !== i);
    }
    setValue(t, e, i, n, s, r) {
      return (this.a = t), (this.b = e), (this.c = i), (this.d = n), (this.e = s), (this.f = r), this;
    }
    reset() {
      return (this.a = 1), (this.b = 0), (this.c = 0), (this.d = 1), (this.e = 0), (this.f = 0), this;
    }
    getInverse() {
      const t = this.a,
        e = this.b,
        i = this.c,
        n = this.d,
        s = this.e,
        r = this.f,
        a = new ie(),
        o = t * n - e * i;
      return (
        (a.a = n / o),
        (a.b = -e / o),
        (a.c = -i / o),
        (a.d = t / o),
        (a.e = (i * r - n * s) / o),
        (a.f = -(t * r - e * s) / o),
        a
      );
    }
    rotate(t) {
      const e = Math.cos(t),
        i = Math.sin(t),
        n = this.a * e + this.c * i,
        s = this.b * e + this.d * i,
        r = this.a * -i + this.c * e,
        a = this.b * -i + this.d * e;
      return (this.a = n), (this.b = s), (this.c = r), (this.d = a), this;
    }
    rotateByCenter(t, e, i) {
      const n = Math.cos(t),
        s = Math.sin(t),
        r = (1 - n) * e + s * i,
        a = (1 - n) * i - s * e,
        o = n * this.a - s * this.b,
        l = s * this.a + n * this.b,
        h = n * this.c - s * this.d,
        c = s * this.c + n * this.d,
        d = n * this.e - s * this.f + r,
        u = s * this.e + n * this.f + a;
      return (this.a = o), (this.b = l), (this.c = h), (this.d = c), (this.e = d), (this.f = u), this;
    }
    scale(t, e) {
      return (this.a *= t), (this.b *= t), (this.c *= e), (this.d *= e), this;
    }
    setScale(t, e) {
      return (this.b = (this.b / this.a) * t), (this.c = (this.c / this.d) * e), (this.a = t), (this.d = e), this;
    }
    transform(t, e, i, n, s, r) {
      return this.multiply(t, e, i, n, s, r), this;
    }
    translate(t, e) {
      return (this.e += this.a * t + this.c * e), (this.f += this.b * t + this.d * e), this;
    }
    transpose() {
      const { a: t, b: e, c: i, d: n, e: s, f: r } = this;
      return (this.a = e), (this.b = t), (this.c = n), (this.d = i), (this.e = r), (this.f = s), this;
    }
    multiply(t, e, i, n, s, r) {
      const a = this.a,
        o = this.b,
        l = this.c,
        h = this.d,
        c = a * t + l * e,
        d = o * t + h * e,
        u = a * i + l * n,
        p = o * i + h * n,
        g = a * s + l * r + this.e,
        f = o * s + h * r + this.f;
      return (this.a = c), (this.b = d), (this.c = u), (this.d = p), (this.e = g), (this.f = f), this;
    }
    interpolate(t, e) {
      const i = new ie();
      return (
        (i.a = this.a + (t.a - this.a) * e),
        (i.b = this.b + (t.b - this.b) * e),
        (i.c = this.c + (t.c - this.c) * e),
        (i.d = this.d + (t.d - this.d) * e),
        (i.e = this.e + (t.e - this.e) * e),
        (i.f = this.f + (t.f - this.f) * e),
        i
      );
    }
    transformPoint(t, e) {
      const { a: i, b: n, c: s, d: r, e: a, f: o } = this,
        l = i * r - n * s,
        h = r / l,
        c = -n / l,
        d = -s / l,
        u = i / l,
        p = (s * o - r * a) / l,
        g = -(i * o - n * a) / l,
        { x: f, y: v } = t;
      (e.x = f * h + v * d + p), (e.y = f * c + v * u + g);
    }
    onlyTranslate() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
      return this.a === t && 0 === this.b && 0 === this.c && this.d === t;
    }
    clone() {
      return new ie(this.a, this.b, this.c, this.d, this.e, this.f);
    }
    toTransformAttrs() {
      const t = this.a,
        e = this.b,
        i = this.c,
        n = this.d,
        s = t * n - e * i,
        r = { x: this.e, y: this.f, rotateDeg: 0, scaleX: 0, scaleY: 0, skewX: 0, skewY: 0 };
      if (0 !== t || 0 !== e) {
        const a = Math.sqrt(t * t + e * e);
        (r.rotateDeg = e > 0 ? Math.acos(t / a) : -Math.acos(t / a)),
          (r.scaleX = a),
          (r.scaleY = s / a),
          (r.skewX = (t * i + e * n) / s),
          (r.skewY = 0);
      } else if (0 !== i || 0 !== n) {
        const a = Math.sqrt(i * i + n * n);
        (r.rotateDeg = Math.PI / 2 - (n > 0 ? Math.acos(-i / a) : -Math.acos(i / a))),
          (r.scaleX = s / a),
          (r.scaleY = a),
          (r.skewX = 0),
          (r.skewY = (t * i + e * n) / s);
      }
      return (r.rotateDeg = Zt(r.rotateDeg)), r;
    }
  }
  function ne(t, e, i) {
    (e /= 100), (i /= 100);
    const n = (1 - Math.abs(2 * i - 1)) * e,
      s = n * (1 - Math.abs(((t / 60) % 2) - 1)),
      r = i - n / 2;
    let a = 0,
      o = 0,
      l = 0;
    return (
      0 <= t && t < 60
        ? ((a = n), (o = s), (l = 0))
        : 60 <= t && t < 120
        ? ((a = s), (o = n), (l = 0))
        : 120 <= t && t < 180
        ? ((a = 0), (o = n), (l = s))
        : 180 <= t && t < 240
        ? ((a = 0), (o = s), (l = n))
        : 240 <= t && t < 300
        ? ((a = s), (o = 0), (l = n))
        : 300 <= t && t < 360 && ((a = n), (o = 0), (l = s)),
      (a = Math.round(255 * (a + r))),
      (o = Math.round(255 * (o + r))),
      (l = Math.round(255 * (l + r))),
      { r: a, g: o, b: l }
    );
  }
  function se(t, e, i) {
    (t /= 255), (e /= 255), (i /= 255);
    const n = Math.min(t, e, i),
      s = Math.max(t, e, i),
      r = s - n;
    let a = 0,
      o = 0,
      l = 0;
    return (
      (a = 0 === r ? 0 : s === t ? ((e - i) / r) % 6 : s === e ? (i - t) / r + 2 : (t - e) / r + 4),
      (a = Math.round(60 * a)),
      a < 0 && (a += 360),
      (l = (s + n) / 2),
      (o = 0 === r ? 0 : r / (1 - Math.abs(2 * l - 1))),
      (o = +(100 * o).toFixed(1)),
      (l = +(100 * l).toFixed(1)),
      { h: a, s: o, l: l }
    );
  }
  const re = /^#([0-9a-f]{3,8})$/,
    ae = { transparent: 4294967040 },
    oe = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
  function le(t) {
    return ((t = Math.max(0, Math.min(255, Math.round(t) || 0))) < 16 ? '0' : '') + t.toString(16);
  }
  function he(t) {
    return y(t) ? new pe(t >> 16, (t >> 8) & 255, 255 & t, 1) : f(t) ? new pe(t[0], t[1], t[2]) : new pe(255, 255, 255);
  }
  function ce(t) {
    return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
  }
  function de(t) {
    return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
  }
  let ue = class t {
    static Brighter(e) {
      let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
      return 1 === i ? e : new t(e).brighter(i).toRGBA();
    }
    static SetOpacity(e) {
      let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
      return 1 === i ? e : new t(e).setOpacity(i).toRGBA();
    }
    static getColorBrightness(e) {
      let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'hsl';
      const n = e instanceof t ? e : new t(e);
      switch (i) {
        case 'hsv':
        default:
          return n.getHSVBrightness();
        case 'hsl':
          return n.getHSLBrightness();
        case 'lum':
          return n.getLuminance();
        case 'lum2':
          return n.getLuminance2();
        case 'lum3':
          return n.getLuminance3();
      }
    }
    static parseColorString(t) {
      if (h(ae[t]))
        return (function (t) {
          return y(t)
            ? new pe(t >>> 24, (t >>> 16) & 255, (t >>> 8) & 255, 255 & t)
            : f(t)
            ? new pe(t[0], t[1], t[2], t[3])
            : new pe(255, 255, 255, 1);
        })(ae[t]);
      if (h(oe[t])) return he(oe[t]);
      const e = `${t}`.trim().toLowerCase(),
        i = re.exec(e);
      if (i) {
        const t = parseInt(i[1], 16),
          e = i[1].length;
        return 3 === e
          ? new pe(
              ((t >> 8) & 15) + (((t >> 8) & 15) << 4),
              ((t >> 4) & 15) + (((t >> 4) & 15) << 4),
              (15 & t) + ((15 & t) << 4),
              1
            )
          : 6 === e
          ? he(t)
          : 8 === e
          ? new pe((t >> 24) & 255, (t >> 16) & 255, (t >> 8) & 255, (255 & t) / 255)
          : void 0;
      }
      if (/^(rgb|RGB|rgba|RGBA)/.test(e)) {
        const t = e.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, '').split(',');
        return new pe(parseInt(t[0], 10), parseInt(t[1], 10), parseInt(t[2], 10), parseFloat(t[3]));
      }
      if (/^(hsl|HSL|hsla|HSLA)/.test(e)) {
        const t = e.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, '').split(','),
          i = ne(parseInt(t[0], 10), parseInt(t[1], 10), parseInt(t[2], 10));
        return new pe(i.r, i.g, i.b, parseFloat(t[3]));
      }
    }
    constructor(e) {
      const i = t.parseColorString(e);
      i ? (this.color = i) : (console.warn(`Warn: 传入${e}无法解析为Color`), (this.color = new pe(255, 255, 255)));
    }
    toRGBA() {
      return this.color.formatRgb();
    }
    toString() {
      return this.color.formatRgb();
    }
    toHex() {
      return this.color.formatHex();
    }
    toHsl() {
      return this.color.formatHsl();
    }
    brighter(t) {
      const { r: e, g: i, b: n } = this.color;
      return (
        (this.color.r = Math.max(0, Math.min(255, Math.floor(e * t)))),
        (this.color.g = Math.max(0, Math.min(255, Math.floor(i * t)))),
        (this.color.b = Math.max(0, Math.min(255, Math.floor(n * t)))),
        this
      );
    }
    add(t) {
      const { r: e, g: i, b: n } = this.color;
      return (
        (this.color.r += Math.min(255, e + t.color.r)),
        (this.color.g += Math.min(255, i + t.color.g)),
        (this.color.b += Math.min(255, n + t.color.b)),
        this
      );
    }
    sub(t) {
      return (
        (this.color.r = Math.max(0, this.color.r - t.color.r)),
        (this.color.g = Math.max(0, this.color.g - t.color.g)),
        (this.color.b = Math.max(0, this.color.b - t.color.b)),
        this
      );
    }
    multiply(t) {
      const { r: e, g: i, b: n } = this.color;
      return (
        (this.color.r = Math.max(0, Math.min(255, Math.floor(e * t.color.r)))),
        (this.color.g = Math.max(0, Math.min(255, Math.floor(i * t.color.g)))),
        (this.color.b = Math.max(0, Math.min(255, Math.floor(n * t.color.b)))),
        this
      );
    }
    getHSVBrightness() {
      return Math.max(this.color.r, this.color.g, this.color.b) / 255;
    }
    getHSLBrightness() {
      return (
        0.5 *
        (Math.max(this.color.r, this.color.g, this.color.b) / 255 +
          Math.min(this.color.r, this.color.g, this.color.b) / 255)
      );
    }
    setHsl(t, e, i) {
      const n = this.color.opacity,
        s = se(this.color.r, this.color.g, this.color.b),
        r = ne(
          l(t) ? s.h : pt(t, 0, 360),
          l(e) ? s.s : e >= 0 && e <= 1 ? 100 * e : e,
          l(i) ? s.l : i <= 1 && i >= 0 ? 100 * i : i
        );
      return (this.color = new pe(r.r, r.g, r.b, n)), this;
    }
    setRGB(t, e, i) {
      return !l(t) && (this.color.r = t), !l(e) && (this.color.g = e), !l(i) && (this.color.b = i), this;
    }
    setHex(t) {
      const e = `${t}`.trim().toLowerCase(),
        i = re.exec(e),
        n = parseInt(i[1], 16),
        s = i[1].length;
      return 3 === s
        ? new pe(
            ((n >> 8) & 15) + (((n >> 8) & 15) << 4),
            ((n >> 4) & 15) + (((n >> 4) & 15) << 4),
            (15 & n) + ((15 & n) << 4),
            1
          )
        : 6 === s
        ? he(n)
        : 8 === s
        ? new pe((n >> 24) & 255, (n >> 16) & 255, (n >> 8) & 255, (255 & n) / 255)
        : this;
    }
    setColorName(t) {
      const e = oe[t.toLowerCase()];
      return void 0 !== e ? this.setHex(e) : console.warn('THREE.Color: Unknown color ' + t), this;
    }
    setScalar(t) {
      return (this.color.r = t), (this.color.g = t), (this.color.b = t), this;
    }
    setOpacity() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
      return (this.color.opacity = t), this;
    }
    getLuminance() {
      return (0.2126 * this.color.r + 0.7152 * this.color.g + 0.0722 * this.color.b) / 255;
    }
    getLuminance2() {
      return (0.2627 * this.color.r + 0.678 * this.color.g + 0.0593 * this.color.b) / 255;
    }
    getLuminance3() {
      return (0.299 * this.color.r + 0.587 * this.color.g + 0.114 * this.color.b) / 255;
    }
    clone() {
      return new t(this.color.toString());
    }
    copyGammaToLinear(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
      return (
        (this.color.r = Math.pow(t.color.r, e)),
        (this.color.g = Math.pow(t.color.g, e)),
        (this.color.b = Math.pow(t.color.b, e)),
        this
      );
    }
    copyLinearToGamma(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
      const i = e > 0 ? 1 / e : 1;
      return (
        (this.color.r = Math.pow(t.color.r, i)),
        (this.color.g = Math.pow(t.color.g, i)),
        (this.color.b = Math.pow(t.color.b, i)),
        this
      );
    }
    convertGammaToLinear(t) {
      return this.copyGammaToLinear(this, t), this;
    }
    convertLinearToGamma(t) {
      return this.copyLinearToGamma(this, t), this;
    }
    copySRGBToLinear(t) {
      return (this.color.r = ce(t.color.r)), (this.color.g = ce(t.color.g)), (this.color.b = ce(t.color.b)), this;
    }
    copyLinearToSRGB(t) {
      return (this.color.r = de(t.color.r)), (this.color.g = de(t.color.g)), (this.color.b = de(t.color.b)), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
  };
  class pe {
    constructor(t, e, i, n) {
      (this.r = isNaN(+t) ? 255 : Math.max(0, Math.min(255, +t))),
        (this.g = isNaN(+e) ? 255 : Math.max(0, Math.min(255, +e))),
        (this.b = isNaN(+i) ? 255 : Math.max(0, Math.min(255, +i))),
        h(n) ? (this.opacity = isNaN(+n) ? 1 : Math.max(0, Math.min(1, +n))) : (this.opacity = 1);
    }
    formatHex() {
      return `#${le(this.r) + le(this.g) + le(this.b) + (1 === this.opacity ? '' : le(255 * this.opacity))}`;
    }
    formatRgb() {
      const t = this.opacity;
      return `${1 === t ? 'rgb(' : 'rgba('}${this.r},${this.g},${this.b}${1 === t ? ')' : `,${t})`}`;
    }
    formatHsl() {
      const t = this.opacity,
        { h: e, s: i, l: n } = se(this.r, this.g, this.b);
      return `${1 === t ? 'hsl(' : 'hsla('}${e},${i}%,${n}%${1 === t ? ')' : `,${t})`}`;
    }
    toString() {
      return this.formatHex();
    }
  }
  function ge(t) {
    let e = '',
      i = '',
      n = '';
    const s = '#' === t[0] ? 1 : 0;
    for (let r = s; r < t.length; r++)
      '#' !== t[r] && (r < s + 2 ? (e += t[r]) : r < s + 4 ? (i += t[r]) : r < s + 6 && (n += t[r]));
    return [parseInt(e, 16), parseInt(i, 16), parseInt(n, 16)];
  }
  function fe(t, e, i) {
    return Number((1 << 24) + (t << 16) + (e << 8) + i)
      .toString(16)
      .slice(1);
  }
  var ve = Object.freeze({
    __proto__: null,
    Color: ue,
    DEFAULT_COLORS: oe,
    RGB: pe,
    hexToRgb: ge,
    hslToRgb: ne,
    interpolateRgb: function (t, e) {
      const i = t.r,
        n = e.r,
        s = t.g,
        r = e.g,
        a = t.b,
        o = e.b,
        l = t.opacity,
        h = e.opacity;
      return t => {
        const e = Math.round(i * (1 - t) + n * t),
          c = Math.round(s * (1 - t) + r * t),
          d = Math.round(a * (1 - t) + o * t);
        return new pe(e, c, d, l * (1 - t) + h * t);
      };
    },
    rgbToHex: fe,
    rgbToHsl: se
  });
  function me(t, e, i) {
    (t[0] = e[0] - i[0]), (t[1] = e[1] - i[1]);
  }
  let ye, _e, be, xe, Se, we, Ae, ke;
  function Me(t, e, i, n) {
    let s,
      r = t[0],
      a = e[0],
      o = i[0],
      l = n[0];
    return (
      a < r && ((s = a), (a = r), (r = s)),
      l < o && ((s = l), (l = o), (o = s)),
      !(
        a < o ||
        l < r ||
        ((r = t[1]),
        (a = e[1]),
        (o = i[1]),
        (l = n[1]),
        a < r && ((s = a), (a = r), (r = s)),
        l < o && ((s = l), (l = o), (o = s)),
        a < o || l < r)
      )
    );
  }
  function Te(t, e, i, n) {
    if (!Me(t, e, i, n)) return !1;
    const s = [0, 0],
      r = [0, 0],
      a = [0, 0];
    if (
      (me(s, e, t),
      me(r, n, i),
      (function (t, e) {
        return Pt(t[0] - e[0]) + Pt(t[1] - e[1]) < 1e-12;
      })(s, r))
    )
      return !0;
    me(a, i, t);
    const o = Nt(a, r) / Nt(s, r);
    return o >= 0 && o <= 1 && [t[0] + s[0] * o, t[1] + s[1] * o];
  }
  function Ce(t, e, i) {
    return null === t
      ? e
      : null === e
      ? t
      : ((ye = t.x1),
        (_e = t.x2),
        (be = t.y1),
        (xe = t.y2),
        (Se = e.x1),
        (we = e.x2),
        (Ae = e.y1),
        (ke = e.y2),
        i &&
          (ye > _e && ([ye, _e] = [_e, ye]),
          be > xe && ([be, xe] = [xe, be]),
          Se > we && ([Se, we] = [we, Se]),
          Ae > ke && ([Ae, ke] = [ke, Ae])),
        ye >= we || _e <= Se || be >= ke || xe <= Ae
          ? { x1: 0, y1: 0, x2: 0, y2: 0 }
          : { x1: Math.max(ye, Se), y1: Math.max(be, Ae), x2: Math.min(_e, we), y2: Math.min(xe, ke) });
  }
  var Ee;
  function Pe(t, e, i) {
    return !(
      t &&
      e &&
      (i
        ? ((ye = t.x1),
          (_e = t.x2),
          (be = t.y1),
          (xe = t.y2),
          (Se = e.x1),
          (we = e.x2),
          (Ae = e.y1),
          (ke = e.y2),
          ye > _e && ([ye, _e] = [_e, ye]),
          be > xe && ([be, xe] = [xe, be]),
          Se > we && ([Se, we] = [we, Se]),
          Ae > ke && ([Ae, ke] = [ke, Ae]),
          ye > we || _e < Se || be > ke || xe < Ae)
        : t.x1 > e.x2 || t.x2 < e.x1 || t.y1 > e.y2 || t.y2 < e.y1)
    );
  }
  function Re(t, e) {
    return Math.abs(e[0] * t[0] + e[1] * t[1]);
  }
  function Oe(t, e) {
    let { x: i, y: n } = t,
      s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { x: 0, y: 0 };
    return {
      x: (i - s.x) * Math.cos(e) + (n - s.y) * Math.sin(e) + s.x,
      y: (i - s.x) * Math.sin(e) + (s.y - n) * Math.cos(e) + s.y
    };
  }
  function Be(t) {
    return (t / 180) * Math.PI;
  }
  function Ie(t) {
    return { x: (t.x1 + t.x2) / 2, y: (t.y1 + t.y2) / 2 };
  }
  function De(t, e) {
    const i = e ? t.angle : Be(t.angle),
      n = Ie(t);
    return [
      Oe({ x: t.x1, y: t.y1 }, i, n),
      Oe({ x: t.x2, y: t.y1 }, i, n),
      Oe({ x: t.x2, y: t.y2 }, i, n),
      Oe({ x: t.x1, y: t.y2 }, i, n)
    ];
  }
  let Le, Fe, je, ze;
  function He(t) {
    return (
      (Le = 1 / 0),
      (Fe = 1 / 0),
      (je = -1 / 0),
      (ze = -1 / 0),
      t.forEach(t => {
        Le > t.x && (Le = t.x), je < t.x && (je = t.x), Fe > t.y && (Fe = t.y), ze < t.y && (ze = t.y);
      }),
      { x1: Le, y1: Fe, x2: je, y2: ze }
    );
  }
  !(function (t) {
    (t[(t.NONE = 0)] = 'NONE'), (t[(t.BBOX1 = 1)] = 'BBOX1'), (t[(t.BBOX2 = 2)] = 'BBOX2');
  })(Ee || (Ee = {}));
  const Ne = 1e-8;
  function Ve(t, e, i, n, s) {
    for (let r = 0, a = s[s.length - 1]; r < s.length; r++) {
      const o = s[r];
      if (Me([t, e], [i, n], [o.x, o.y], [a.x, a.y])) return !0;
      a = o;
    }
    return !1;
  }
  function We(t, e, i) {
    let n = 0,
      s = t[0];
    if (!s) return !1;
    for (let r = 1; r < t.length; r++) {
      const a = t[r];
      (n += Ge(s.x, s.y, a.x, a.y, e, i)), (s = a);
    }
    const r = t[0];
    return (Ue(s.x, r.x) && Ue(s.y, r.y)) || (n += Ge(s.x, s.y, r.x, r.y, e, i)), 0 !== n;
  }
  function Ge(t, e, i, n, s, r) {
    if ((r > e && r > n) || (r < e && r < n)) return 0;
    if (n === e) return 0;
    const a = (r - e) / (n - e);
    let o = n < e ? 1 : -1;
    (1 !== a && 0 !== a) || (o = n < e ? 0.5 : -0.5);
    const l = a * (i - t) + t;
    return l === s ? 1 / 0 : l > s ? o : 0;
  }
  function Ue(t, e) {
    return Math.abs(t - e) < Ne;
  }
  const Ye = t => {
    let e = t.charCodeAt(0),
      i = 2 === t.length ? t.charCodeAt(1) : 0,
      n = e;
    return (
      55296 <= e &&
        e <= 56319 &&
        56320 <= i &&
        i <= 57343 &&
        ((e &= 1023), (i &= 1023), (n = (e << 10) | i), (n += 65536)),
      12288 === n || (65281 <= n && n <= 65376) || (65504 <= n && n <= 65510)
        ? 'F'
        : 8361 === n ||
          (65377 <= n && n <= 65470) ||
          (65474 <= n && n <= 65479) ||
          (65482 <= n && n <= 65487) ||
          (65490 <= n && n <= 65495) ||
          (65498 <= n && n <= 65500) ||
          (65512 <= n && n <= 65518)
        ? 'H'
        : (4352 <= n && n <= 4447) ||
          (4515 <= n && n <= 4519) ||
          (4602 <= n && n <= 4607) ||
          (9001 <= n && n <= 9002) ||
          (11904 <= n && n <= 11929) ||
          (11931 <= n && n <= 12019) ||
          (12032 <= n && n <= 12245) ||
          (12272 <= n && n <= 12283) ||
          (12289 <= n && n <= 12350) ||
          (12353 <= n && n <= 12438) ||
          (12441 <= n && n <= 12543) ||
          (12549 <= n && n <= 12589) ||
          (12593 <= n && n <= 12686) ||
          (12688 <= n && n <= 12730) ||
          (12736 <= n && n <= 12771) ||
          (12784 <= n && n <= 12830) ||
          (12832 <= n && n <= 12871) ||
          (12880 <= n && n <= 13054) ||
          (13056 <= n && n <= 19903) ||
          (19968 <= n && n <= 42124) ||
          (42128 <= n && n <= 42182) ||
          (43360 <= n && n <= 43388) ||
          (44032 <= n && n <= 55203) ||
          (55216 <= n && n <= 55238) ||
          (55243 <= n && n <= 55291) ||
          (63744 <= n && n <= 64255) ||
          (65040 <= n && n <= 65049) ||
          (65072 <= n && n <= 65106) ||
          (65108 <= n && n <= 65126) ||
          (65128 <= n && n <= 65131) ||
          (110592 <= n && n <= 110593) ||
          (127488 <= n && n <= 127490) ||
          (127504 <= n && n <= 127546) ||
          (127552 <= n && n <= 127560) ||
          (127568 <= n && n <= 127569) ||
          (131072 <= n && n <= 194367) ||
          (177984 <= n && n <= 196605) ||
          (196608 <= n && n <= 262141)
        ? 'W'
        : (32 <= n && n <= 126) ||
          (162 <= n && n <= 163) ||
          (165 <= n && n <= 166) ||
          172 === n ||
          175 === n ||
          (10214 <= n && n <= 10221) ||
          (10629 <= n && n <= 10630)
        ? 'Na'
        : 161 === n ||
          164 === n ||
          (167 <= n && n <= 168) ||
          170 === n ||
          (173 <= n && n <= 174) ||
          (176 <= n && n <= 180) ||
          (182 <= n && n <= 186) ||
          (188 <= n && n <= 191) ||
          198 === n ||
          208 === n ||
          (215 <= n && n <= 216) ||
          (222 <= n && n <= 225) ||
          230 === n ||
          (232 <= n && n <= 234) ||
          (236 <= n && n <= 237) ||
          240 === n ||
          (242 <= n && n <= 243) ||
          (247 <= n && n <= 250) ||
          252 === n ||
          254 === n ||
          257 === n ||
          273 === n ||
          275 === n ||
          283 === n ||
          (294 <= n && n <= 295) ||
          299 === n ||
          (305 <= n && n <= 307) ||
          312 === n ||
          (319 <= n && n <= 322) ||
          324 === n ||
          (328 <= n && n <= 331) ||
          333 === n ||
          (338 <= n && n <= 339) ||
          (358 <= n && n <= 359) ||
          363 === n ||
          462 === n ||
          464 === n ||
          466 === n ||
          468 === n ||
          470 === n ||
          472 === n ||
          474 === n ||
          476 === n ||
          593 === n ||
          609 === n ||
          708 === n ||
          711 === n ||
          (713 <= n && n <= 715) ||
          717 === n ||
          720 === n ||
          (728 <= n && n <= 731) ||
          733 === n ||
          735 === n ||
          (768 <= n && n <= 879) ||
          (913 <= n && n <= 929) ||
          (931 <= n && n <= 937) ||
          (945 <= n && n <= 961) ||
          (963 <= n && n <= 969) ||
          1025 === n ||
          (1040 <= n && n <= 1103) ||
          1105 === n ||
          8208 === n ||
          (8211 <= n && n <= 8214) ||
          (8216 <= n && n <= 8217) ||
          (8220 <= n && n <= 8221) ||
          (8224 <= n && n <= 8226) ||
          (8228 <= n && n <= 8231) ||
          8240 === n ||
          (8242 <= n && n <= 8243) ||
          8245 === n ||
          8251 === n ||
          8254 === n ||
          8308 === n ||
          8319 === n ||
          (8321 <= n && n <= 8324) ||
          8364 === n ||
          8451 === n ||
          8453 === n ||
          8457 === n ||
          8467 === n ||
          8470 === n ||
          (8481 <= n && n <= 8482) ||
          8486 === n ||
          8491 === n ||
          (8531 <= n && n <= 8532) ||
          (8539 <= n && n <= 8542) ||
          (8544 <= n && n <= 8555) ||
          (8560 <= n && n <= 8569) ||
          8585 === n ||
          (8592 <= n && n <= 8601) ||
          (8632 <= n && n <= 8633) ||
          8658 === n ||
          8660 === n ||
          8679 === n ||
          8704 === n ||
          (8706 <= n && n <= 8707) ||
          (8711 <= n && n <= 8712) ||
          8715 === n ||
          8719 === n ||
          8721 === n ||
          8725 === n ||
          8730 === n ||
          (8733 <= n && n <= 8736) ||
          8739 === n ||
          8741 === n ||
          (8743 <= n && n <= 8748) ||
          8750 === n ||
          (8756 <= n && n <= 8759) ||
          (8764 <= n && n <= 8765) ||
          8776 === n ||
          8780 === n ||
          8786 === n ||
          (8800 <= n && n <= 8801) ||
          (8804 <= n && n <= 8807) ||
          (8810 <= n && n <= 8811) ||
          (8814 <= n && n <= 8815) ||
          (8834 <= n && n <= 8835) ||
          (8838 <= n && n <= 8839) ||
          8853 === n ||
          8857 === n ||
          8869 === n ||
          8895 === n ||
          8978 === n ||
          (9312 <= n && n <= 9449) ||
          (9451 <= n && n <= 9547) ||
          (9552 <= n && n <= 9587) ||
          (9600 <= n && n <= 9615) ||
          (9618 <= n && n <= 9621) ||
          (9632 <= n && n <= 9633) ||
          (9635 <= n && n <= 9641) ||
          (9650 <= n && n <= 9651) ||
          (9654 <= n && n <= 9655) ||
          (9660 <= n && n <= 9661) ||
          (9664 <= n && n <= 9665) ||
          (9670 <= n && n <= 9672) ||
          9675 === n ||
          (9678 <= n && n <= 9681) ||
          (9698 <= n && n <= 9701) ||
          9711 === n ||
          (9733 <= n && n <= 9734) ||
          9737 === n ||
          (9742 <= n && n <= 9743) ||
          (9748 <= n && n <= 9749) ||
          9756 === n ||
          9758 === n ||
          9792 === n ||
          9794 === n ||
          (9824 <= n && n <= 9825) ||
          (9827 <= n && n <= 9829) ||
          (9831 <= n && n <= 9834) ||
          (9836 <= n && n <= 9837) ||
          9839 === n ||
          (9886 <= n && n <= 9887) ||
          (9918 <= n && n <= 9919) ||
          (9924 <= n && n <= 9933) ||
          (9935 <= n && n <= 9953) ||
          9955 === n ||
          (9960 <= n && n <= 9983) ||
          10045 === n ||
          10071 === n ||
          (10102 <= n && n <= 10111) ||
          (11093 <= n && n <= 11097) ||
          (12872 <= n && n <= 12879) ||
          (57344 <= n && n <= 63743) ||
          (65024 <= n && n <= 65039) ||
          65533 === n ||
          (127232 <= n && n <= 127242) ||
          (127248 <= n && n <= 127277) ||
          (127280 <= n && n <= 127337) ||
          (127344 <= n && n <= 127386) ||
          (917760 <= n && n <= 917999) ||
          (983040 <= n && n <= 1048573) ||
          (1048576 <= n && n <= 1114109)
        ? 'A'
        : 'N'
    );
  };
  class $e {
    constructor(t, e) {
      (this._numberCharSize = null),
        (this._fullCharSize = null),
        (this._letterCharSize = null),
        (this._specialCharSizeMap = {}),
        (this._canvas = null),
        (this._context = null),
        (this._contextSaved = !1),
        (this._notSupportCanvas = !1),
        (this._notSupportVRender = !1),
        (this._userSpec = {}),
        (this.specialCharSet = '-/: .,@%\'"~'),
        (this._option = t),
        (this._userSpec = null != e ? e : {}),
        (this.textSpec = this._initSpec()),
        h(t.specialCharSet) && (this.specialCharSet = t.specialCharSet),
        (this._standardMethod = h(t.getTextBounds)
          ? this.fullMeasure.bind(this)
          : this.measureWithNaiveCanvas.bind(this));
    }
    initContext() {
      if (this._notSupportCanvas) return !1;
      if (
        (l(this._canvas) &&
          (h(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()),
          l(this._canvas) &&
            'undefined' != typeof window &&
            void 0 !== window.document &&
            h(globalThis.document) &&
            (this._canvas = globalThis.document.createElement('canvas'))),
        l(this._context) && h(this._canvas))
      ) {
        const t = this._canvas.getContext('2d');
        h(t) &&
          (t.save(),
          (t.font = (function (t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const {
              fontStyle: i = e.fontStyle,
              fontVariant: n = e.fontVariant,
              fontWeight: s = e.fontWeight,
              fontSize: r = e.fontSize,
              fontFamily: a = e.fontFamily
            } = t;
            return (i ? i + ' ' : '') + (n ? n + ' ' : '') + (s ? s + ' ' : '') + r + 'px ' + (a || 'sans-serif');
          })(this.textSpec)),
          (this._contextSaved = !0),
          (this._context = t));
      }
      return !l(this._context) || ((this._notSupportCanvas = !0), !1);
    }
    _initSpec() {
      var t, e, i;
      const { defaultFontParams: n = {} } = this._option,
        {
          fontStyle: s = n.fontStyle,
          fontVariant: r = n.fontVariant,
          fontWeight: a = null !== (t = n.fontWeight) && void 0 !== t ? t : 'normal',
          fontSize: o = null !== (e = n.fontSize) && void 0 !== e ? e : 12,
          fontFamily: l = null !== (i = n.fontFamily) && void 0 !== i ? i : 'sans-serif',
          align: h,
          textAlign: c = null != h ? h : 'center',
          baseline: d,
          textBaseline: u = null != d ? d : 'middle',
          ellipsis: p,
          limit: g,
          lineHeight: f = o
        } = this._userSpec;
      return {
        fontStyle: s,
        fontVariant: r,
        fontFamily: l,
        fontSize: o,
        fontWeight: a,
        textAlign: c,
        textBaseline: u,
        ellipsis: p,
        limit: g,
        lineHeight: f
      };
    }
    measure(t, e) {
      switch (e) {
        case 'vrender':
        case 'canopus':
          return this.fullMeasure(t);
        case 'canvas':
          return this.measureWithNaiveCanvas(t);
        case 'simple':
          return this.quickMeasureWithoutCanvas(t);
        default:
          return this.quickMeasure(t);
      }
    }
    fullMeasure(t) {
      if (l(t)) return { width: 0, height: 0 };
      if (l(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(t);
      const {
        fontFamily: e,
        fontSize: i,
        fontWeight: n,
        textAlign: s,
        textBaseline: r,
        ellipsis: a,
        limit: o,
        lineHeight: h
      } = this.textSpec;
      let c;
      try {
        const l = this._option.getTextBounds({
          text: t,
          fontFamily: e,
          fontSize: i,
          fontWeight: n,
          textAlign: s,
          textBaseline: r,
          ellipsis: !!a,
          maxLineWidth: o || 1 / 0,
          lineHeight: h
        });
        c = { width: l.width(), height: l.height() };
      } catch (e) {
        (this._notSupportVRender = !0), (c = this.measureWithNaiveCanvas(t));
      }
      return c;
    }
    measureWithNaiveCanvas(t) {
      return this._measureReduce(t, this._measureWithNaiveCanvas.bind(this));
    }
    _measureWithNaiveCanvas(t) {
      if (!this.initContext()) return this._quickMeasureWithoutCanvas(t);
      const e = this._context.measureText(t),
        { fontSize: i, lineHeight: n } = this.textSpec;
      return { width: e.width, height: null != n ? n : i };
    }
    quickMeasure(t) {
      return this._measureReduce(t, this._quickMeasure.bind(this));
    }
    _quickMeasure(t) {
      const e = { width: 0, height: 0 };
      for (let i = 0; i < t.length; i++) {
        const n = t[i];
        let s = this._measureSpecialChar(n);
        l(s) && $e.NUMBERS_CHAR_SET.includes(n) && (s = this._measureNumberChar()),
          l(s) && ['F', 'W'].includes(Ye(n)) && (s = this._measureFullSizeChar()),
          l(s) && (s = this._measureLetterChar()),
          (e.width += s.width),
          (e.height = Math.max(e.height, s.height));
      }
      return e;
    }
    quickMeasureWithoutCanvas(t) {
      return this._measureReduce(t, this._quickMeasureWithoutCanvas.bind(this));
    }
    _quickMeasureWithoutCanvas(t) {
      const e = { width: 0, height: 0 },
        { fontSize: i, lineHeight: n } = this.textSpec;
      for (let n = 0; n < t.length; n++) {
        const s = t[n],
          r = ['F', 'W'].includes(Ye(s)) ? 1 : 0.53;
        e.width += r * i;
      }
      return (e.height = null != n ? n : i), e;
    }
    _measureReduce(t, e) {
      const { fontSize: i, lineHeight: n } = this.textSpec,
        s = { width: 0, height: 0 };
      if (l(t)) return s;
      if (f(t)) {
        const r = t.filter(h).map(t => t.toString());
        return 0 === r.length
          ? s
          : 1 === r.length
          ? e(r[0])
          : { width: r.reduce((t, i) => Math.max(t, e(i).width), 0), height: r.length * ((null != n ? n : i) + 1) + 1 };
      }
      return e(t.toString());
    }
    _measureNumberChar() {
      if (l(this._numberCharSize)) {
        const t = this._standardMethod($e.NUMBERS_CHAR_SET);
        this._numberCharSize = { width: t.width / $e.NUMBERS_CHAR_SET.length, height: t.height };
      }
      return this._numberCharSize;
    }
    _measureFullSizeChar() {
      return (
        l(this._fullCharSize) && (this._fullCharSize = this._standardMethod($e.FULL_SIZE_CHAR)), this._fullCharSize
      );
    }
    _measureLetterChar() {
      if (l(this._letterCharSize)) {
        const t = this._standardMethod($e.ALPHABET_CHAR_SET);
        this._letterCharSize = { width: t.width / $e.ALPHABET_CHAR_SET.length, height: t.height };
      }
      return this._letterCharSize;
    }
    _measureSpecialChar(t) {
      return h(this._specialCharSizeMap[t])
        ? this._specialCharSizeMap[t]
        : this.specialCharSet.includes(t)
        ? ((this._specialCharSizeMap[t] = this._standardMethod(t)), this._specialCharSizeMap[t])
        : null;
    }
    release() {
      h(this._canvas) && (this._canvas = null),
        h(this._context) &&
          (this._contextSaved && (this._context.restore(), (this._contextSaved = !1)), (this._context = null));
    }
  }
  ($e.ALPHABET_CHAR_SET = 'abcdefghijklmnopqrstuvwxyz'),
    ($e.NUMBERS_CHAR_SET = '0123456789'),
    ($e.FULL_SIZE_CHAR = '字');
  const Xe = 'undefined' != typeof console;
  function Ke(t, e, i) {
    const n = [e].concat([].slice.call(i));
    Xe && console[t].apply(console, n);
  }
  var qe;
  !(function (t) {
    (t[(t.None = 0)] = 'None'),
      (t[(t.Error = 1)] = 'Error'),
      (t[(t.Warn = 2)] = 'Warn'),
      (t[(t.Info = 3)] = 'Info'),
      (t[(t.Debug = 4)] = 'Debug');
  })(qe || (qe = {}));
  class Ze {
    static getInstance(t, e) {
      return Ze._instance && y(t) ? Ze._instance.level(t) : Ze._instance || (Ze._instance = new Ze(t, e)), Ze._instance;
    }
    static setInstance(t) {
      return (Ze._instance = t);
    }
    static setInstanceLevel(t) {
      Ze._instance ? Ze._instance.level(t) : (Ze._instance = new Ze(t));
    }
    static clearInstance() {
      Ze._instance = null;
    }
    constructor() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qe.None,
        e = arguments.length > 1 ? arguments[1] : void 0;
      (this._onErrorHandler = []), (this._level = t), (this._method = e);
    }
    addErrorHandler(t) {
      this._onErrorHandler.find(e => e === t) || this._onErrorHandler.push(t);
    }
    removeErrorHandler(t) {
      const e = this._onErrorHandler.findIndex(e => e === t);
      e < 0 || this._onErrorHandler.splice(e, 1);
    }
    callErrorHandler() {
      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
      this._onErrorHandler.forEach(t => t(...e));
    }
    canLogInfo() {
      return this._level >= qe.Info;
    }
    canLogDebug() {
      return this._level >= qe.Debug;
    }
    canLogError() {
      return this._level >= qe.Error;
    }
    canLogWarn() {
      return this._level >= qe.Warn;
    }
    level(t) {
      return arguments.length ? ((this._level = +t), this) : this._level;
    }
    error() {
      for (var t, e = arguments.length, i = new Array(e), n = 0; n < e; n++) i[n] = arguments[n];
      return (
        this._level >= qe.Error &&
          (this._onErrorHandler.length
            ? this.callErrorHandler(...i)
            : Ke(null !== (t = this._method) && void 0 !== t ? t : 'error', 'ERROR', i)),
        this
      );
    }
    warn() {
      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
      return this._level >= qe.Warn && Ke(this._method || 'warn', 'WARN', e), this;
    }
    info() {
      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
      return this._level >= qe.Info && Ke(this._method || 'log', 'INFO', e), this;
    }
    debug() {
      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
      return this._level >= qe.Debug && Ke(this._method || 'log', 'DEBUG', e), this;
    }
  }
  function Je(t) {
    if (_(t)) return [t, t, t, t];
    if (f(t)) {
      const e = t.length;
      if (1 === e) {
        const e = t[0];
        return [e, e, e, e];
      }
      if (2 === e) {
        const [e, i] = t;
        return [e, i, e, i];
      }
      if (3 === e) {
        const [e, i, n] = t;
        return [e, i, n, i];
      }
      if (4 === e) return t;
    }
    if (c(t)) {
      const { top: e = 0, right: i = 0, bottom: n = 0, left: s = 0 } = t;
      return [e, i, n, s];
    }
    return [0, 0, 0, 0];
  }
  function Qe(t) {
    return t ? 'getUTCFullYear' : 'getFullYear';
  }
  function ti(t) {
    return t ? 'getUTCMonth' : 'getMonth';
  }
  function ei(t) {
    return t ? 'getUTCDate' : 'getDate';
  }
  function ii(t) {
    return t ? 'getUTCHours' : 'getHours';
  }
  function ni(t) {
    return t ? 'getUTCMinutes' : 'getMinutes';
  }
  function si(t) {
    return t ? 'getUTCSeconds' : 'getSeconds';
  }
  function ri(t) {
    return t ? 'getUTCMilliseconds' : 'getMilliseconds';
  }
  function ai(t) {
    return t ? 'setUTCFullYear' : 'setFullYear';
  }
  Ze._instance = null;
  const oi = 1e3,
    li = 6e4,
    hi = 36e5,
    ci = 24 * hi,
    di = 31 * ci,
    ui = 365 * ci,
    pi = t => (t.setMonth(0, 1), t.setHours(0, 0, 0, 0), t),
    gi = (t, e) => (t.setFullYear(t.getFullYear() + e), t),
    fi = (t, e) => e.getFullYear() - t.getFullYear(),
    vi = t => t.getFullYear(),
    mi = t => (t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0), t),
    yi = (t, e) => (t.setUTCFullYear(t.getUTCFullYear() + e), t),
    _i = (t, e) => e.getUTCFullYear() - t.getUTCFullYear(),
    bi = t => t.getUTCFullYear(),
    xi = t => (t.setDate(1), t.setHours(0, 0, 0, 0), t),
    Si = (t, e) => (t.setMonth(t.getMonth() + e), t),
    wi = (t, e) => e.getMonth() - t.getMonth() + 12 * (e.getFullYear() - t.getFullYear()),
    Ai = t => t.getMonth(),
    ki = t => (t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0), t),
    Mi = (t, e) => (t.setUTCMonth(t.getUTCMonth() + e), t),
    Ti = (t, e) => e.getUTCMonth() - t.getUTCMonth() + 12 * (e.getUTCFullYear() - t.getUTCFullYear()),
    Ci = t => t.getUTCMonth(),
    Ei = t => (t.setHours(0, 0, 0, 0), t),
    Pi = (t, e) => (t.setDate(t.getDate() + e), t),
    Ri = (t, e) => (+e - +t - 6e4 * (e.getTimezoneOffset() - t.getTimezoneOffset())) / ci,
    Oi = t => t.getDate() - 1,
    Bi = t => (t.setUTCHours(0, 0, 0, 0), t),
    Ii = (t, e) => (t.setUTCDate(t.getUTCDate() + e), t),
    Di = (t, e) => (+e - +t) / ci,
    Li = t => t.getUTCDate() - 1,
    Fi = t => (t.setTime(+t - t.getMilliseconds() - 1e3 * t.getSeconds() - 6e4 * t.getMinutes()), t),
    ji = (t, e) => (t.setHours(t.getHours() + e), t),
    zi = (t, e) => (+e - +t) / hi,
    Hi = t => t.getHours(),
    Ni = t => (t.setTime(+t - t.getUTCMilliseconds() - 1e3 * t.getUTCSeconds() - 6e4 * t.getUTCMinutes()), t),
    Vi = (t, e) => (t.setUTCHours(t.getUTCHours() + e), t),
    Wi = t => t.getUTCHours(),
    Gi = t => (t.setTime(+t - t.getMilliseconds() - 1e3 * t.getSeconds()), t),
    Ui = (t, e) => (t.setMinutes(t.getMinutes() + e), t),
    Yi = (t, e) => (+e - +t) / 6e4,
    $i = t => t.getMinutes(),
    Xi = t => (t.setTime(+t - t.getUTCMilliseconds() - 1e3 * t.getUTCSeconds()), t),
    Ki = (t, e) => (t.setUTCMinutes(t.getUTCMinutes() + e), t),
    qi = t => t.getUTCMinutes(),
    Zi = t => (t.setTime(+t - t.getMilliseconds()), t),
    Ji = (t, e) => (t.setSeconds(t.getSeconds() + e), t),
    Qi = (t, e) => (+e - +t) / 1e3,
    tn = t => t.getSeconds(),
    en = t => (t.setTime(+t - t.getUTCMilliseconds()), t),
    nn = (t, e) => (t.setUTCSeconds(t.getUTCSeconds() + e), t),
    sn = t => t.getUTCSeconds(),
    rn = t => t,
    an = (t, e) => (t.setTime(+t + e), t),
    on = (t, e) => +e - +t,
    ln = (t, e) => i => {
      const n = new Date(+i - 1);
      return e(n, 1), t(n), n;
    },
    hn = (t, e) => {
      let { floor: i, offset: n, field: s, count: r } = e;
      const a = Math.floor(t);
      if (!Number.isFinite(a) || a <= 0) return null;
      if (a <= 1) return { floor: i, offset: n, ceil: ln(i, n) };
      const o = ((t, e) => (i, n) => {
          const s = new Date(),
            r = new Date();
          return s.setTime(+i), r.setTime(+n), t(s), t(r), Math.floor(e(s, r));
        })(i, r),
        l = s ? t => s(t) % a == 0 : t => o(0, t) % a == 0,
        h = t => {
          if (!Number.isNaN(+t)) for (i(t); !l(t); ) t.setTime(+t - 1), i(t);
          return t;
        },
        c = (t, e) => {
          if (!Number.isNaN(+t))
            if (a < 0) for (; ++e <= 0; ) for (n(t, -1); !l(t); ) n(t, -1);
            else for (; --e >= 0; ) for (n(t, 1); !l(t); ) n(t, 1);
          return t;
        };
      return { floor: h, offset: c, ceil: ln(h, c) };
    };
  function cn(t) {
    let e,
      i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
      n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    if (!t) return { width: i, height: n };
    try {
      e = null === window || void 0 === window ? void 0 : window.getComputedStyle;
    } catch (t) {
      e = () => ({});
    }
    const s = e(t),
      r = parseFloat(s.width) - parseFloat(s.paddingLeft) - parseFloat(s.paddingRight) || t.clientWidth - 1,
      a = parseFloat(s.height) - parseFloat(s.paddingTop) - parseFloat(s.paddingBottom) || t.clientHeight - 1;
    return { width: r <= 0 ? i : r, height: a <= 0 ? n : a };
  }
  var dn = 6371008.8,
    un = {
      centimeters: 637100880,
      centimetres: 637100880,
      degrees: 57.22891354143274,
      feet: 20902260.511392,
      inches: 39.37 * dn,
      kilometers: 6371.0088,
      kilometres: 6371.0088,
      meters: dn,
      metres: dn,
      miles: 3958.761333810546,
      millimeters: 6371008800,
      millimetres: 6371008800,
      nauticalmiles: dn / 1852,
      radians: 1,
      yards: 6967335.223679999
    };
  function pn(t, e, i) {
    void 0 === i && (i = {});
    var n = { type: 'Feature' };
    return (
      (0 === i.id || i.id) && (n.id = i.id), i.bbox && (n.bbox = i.bbox), (n.properties = e || {}), (n.geometry = t), n
    );
  }
  function gn(t, e) {
    void 0 === e && (e = {});
    var i = { type: 'FeatureCollection' };
    return e.id && (i.id = e.id), e.bbox && (i.bbox = e.bbox), (i.features = t), i;
  }
  function fn(t, e) {
    if (!t) return !1;
    if (!e) return !1;
    const i = 'Feature' === (r = e).type ? r.geometry : r,
      n = i.type,
      s = e.bbox;
    var r;
    let a = i.coordinates;
    if (
      s &&
      !0 ===
        (function (t, e, i) {
          return (
            !e ||
            (i
              ? ((ye = e.x1),
                (_e = e.x2),
                (be = e.y1),
                (xe = e.y2),
                ye > _e && ([ye, _e] = [_e, ye]),
                be > xe && ([be, xe] = [xe, be]),
                t.x >= ye && t.x <= _e && t.y >= be && t.y <= xe)
              : t.x >= e.x1 && t.x <= e.x2 && t.y >= e.y1 && t.y <= e.y2)
          );
        })(t, { x1: s[0], x2: s[1], y1: s[1], y2: s[3] }, !0)
    )
      return !1;
    'Polygon' === n && (a = [a]);
    let o = !1;
    for (let e = 0; e < a.length; ++e)
      for (let i = 0; i < a[e].length; ++i)
        if (
          We(
            a[e][i].map(t => ({ x: t[0], y: t[1] })),
            t.x,
            t.y
          )
        )
          return (o = !0), o;
    return o;
  }
  function vn(t, e, i) {
    let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
    const s = qt(t[0]),
      r = qt(t[1]),
      a = qt(i),
      o = (function (t, e) {
        void 0 === e && (e = 'kilometers');
        var i = un[e];
        if (!i) throw new Error(e + ' units is invalid');
        return t / i;
      })(e, n.units),
      l = Math.asin(Math.sin(r) * Math.cos(o) + Math.cos(r) * Math.sin(o) * Math.cos(a));
    return {
      x: Zt(s + Math.atan2(Math.sin(a) * Math.sin(o) * Math.cos(r), Math.cos(o) - Math.sin(r) * Math.sin(l))),
      y: Zt(l)
    };
  }
  /*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */ function mn(t, e) {
    var i = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
    if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
      var s = 0;
      for (n = Object.getOwnPropertySymbols(t); s < n.length; s++)
        e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (i[n[s]] = t[n[s]]);
    }
    return i;
  }
  function yn(t, e, i, n) {
    return new (i || (i = Promise))(function (s, r) {
      function a(t) {
        try {
          l(n.next(t));
        } catch (t) {
          r(t);
        }
      }
      function o(t) {
        try {
          l(n.throw(t));
        } catch (t) {
          r(t);
        }
      }
      function l(t) {
        var e;
        t.done
          ? s(t.value)
          : ((e = t.value),
            e instanceof i
              ? e
              : new i(function (t) {
                  t(e);
                })).then(a, o);
      }
      l((n = n.apply(t, e || [])).next());
    });
  }
  const _n = t => t;
  var bn, xn;
  (t.RenderModeEnum = void 0),
    ((bn = t.RenderModeEnum || (t.RenderModeEnum = {}))['desktop-browser'] = 'desktop-browser'),
    (bn['mobile-browser'] = 'mobile-browser'),
    (bn.node = 'node'),
    (bn.worker = 'worker'),
    (bn.miniApp = 'miniApp'),
    (bn.wx = 'wx'),
    (bn['desktop-miniApp'] = 'desktop-miniApp'),
    (bn.lynx = 'lynx'),
    (function (t) {
      (t.cartesianAxis = 'cartesianAxis'),
        (t.cartesianBandAxis = 'cartesianAxis-band'),
        (t.cartesianLinearAxis = 'cartesianAxis-linear'),
        (t.cartesianTimeAxis = 'cartesianAxis-time'),
        (t.cartesianLogAxis = 'cartesianAxis-log'),
        (t.cartesianSymlogAxis = 'cartesianAxis-symlog'),
        (t.polarAxis = 'polarAxis'),
        (t.polarBandAxis = 'polarAxis-band'),
        (t.polarLinearAxis = 'polarAxis-linear'),
        (t.crosshair = 'crosshair'),
        (t.cartesianCrosshair = 'cartesianCrosshair'),
        (t.polarCrosshair = 'polarCrosshair'),
        (t.dataZoom = 'dataZoom'),
        (t.geoCoordinate = 'geoCoordinate'),
        (t.indicator = 'indicator'),
        (t.discreteLegend = 'discreteLegend'),
        (t.continuousLegend = 'continuousLegend'),
        (t.colorLegend = 'colorLegend'),
        (t.sizeLegend = 'sizeLegend'),
        (t.mapLabel = 'mapLabel'),
        (t.markLine = 'markLine'),
        (t.markArea = 'markArea'),
        (t.markPoint = 'markPoint'),
        (t.tooltip = 'tooltip'),
        (t.title = 'title'),
        (t.player = 'player'),
        (t.scrollBar = 'scrollBar'),
        (t.label = 'label'),
        (t.totalLabel = 'totalLabel'),
        (t.brush = 'brush'),
        (t.poptip = 'poptip'),
        (t.customMark = 'customMark');
    })(xn || (xn = {}));
  function Sn() {
    return new wn();
  }
  function wn() {
    this.reset();
  }
  wn.prototype = {
    constructor: wn,
    reset: function () {
      this.s = this.t = 0;
    },
    add: function (t) {
      kn(An, t, this.t), kn(this, An.s, this.s), this.s ? (this.t += An.t) : (this.s = An.t);
    },
    valueOf: function () {
      return this.s;
    }
  };
  var An = new wn();
  function kn(t, e, i) {
    var n = (t.s = e + i),
      s = n - e,
      r = n - s;
    t.t = e - r + (i - s);
  }
  var Mn = 1e-6,
    Tn = Math.PI,
    Cn = Tn / 2,
    En = Tn / 4,
    Pn = 2 * Tn,
    Rn = 180 / Tn,
    On = Tn / 180,
    Bn = Math.abs,
    In = Math.atan,
    Dn = Math.atan2,
    Ln = Math.cos,
    Fn = Math.exp,
    jn = Math.log,
    zn = Math.pow,
    Hn = Math.sin,
    Nn =
      Math.sign ||
      function (t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0;
      },
    Vn = Math.sqrt,
    Wn = Math.tan;
  function Gn(t) {
    return t > 1 ? 0 : t < -1 ? Tn : Math.acos(t);
  }
  function Un(t) {
    return t > 1 ? Cn : t < -1 ? -Cn : Math.asin(t);
  }
  function Yn() {}
  function $n(t, e) {
    t && Kn.hasOwnProperty(t.type) && Kn[t.type](t, e);
  }
  var Xn = {
      Feature: function (t, e) {
        $n(t.geometry, e);
      },
      FeatureCollection: function (t, e) {
        for (var i = t.features, n = -1, s = i.length; ++n < s; ) $n(i[n].geometry, e);
      }
    },
    Kn = {
      Sphere: function (t, e) {
        e.sphere();
      },
      Point: function (t, e) {
        (t = t.coordinates), e.point(t[0], t[1], t[2]);
      },
      MultiPoint: function (t, e) {
        for (var i = t.coordinates, n = -1, s = i.length; ++n < s; ) (t = i[n]), e.point(t[0], t[1], t[2]);
      },
      LineString: function (t, e) {
        qn(t.coordinates, e, 0);
      },
      MultiLineString: function (t, e) {
        for (var i = t.coordinates, n = -1, s = i.length; ++n < s; ) qn(i[n], e, 0);
      },
      Polygon: function (t, e) {
        Zn(t.coordinates, e);
      },
      MultiPolygon: function (t, e) {
        for (var i = t.coordinates, n = -1, s = i.length; ++n < s; ) Zn(i[n], e);
      },
      GeometryCollection: function (t, e) {
        for (var i = t.geometries, n = -1, s = i.length; ++n < s; ) $n(i[n], e);
      }
    };
  function qn(t, e, i) {
    var n,
      s = -1,
      r = t.length - i;
    for (e.lineStart(); ++s < r; ) (n = t[s]), e.point(n[0], n[1], n[2]);
    e.lineEnd();
  }
  function Zn(t, e) {
    var i = -1,
      n = t.length;
    for (e.polygonStart(); ++i < n; ) qn(t[i], e, 1);
    e.polygonEnd();
  }
  function Jn(t, e) {
    t && Xn.hasOwnProperty(t.type) ? Xn[t.type](t, e) : $n(t, e);
  }
  function Qn(t) {
    return [Dn(t[1], t[0]), Un(t[2])];
  }
  function ts(t) {
    var e = t[0],
      i = t[1],
      n = Ln(i);
    return [n * Ln(e), n * Hn(e), Hn(i)];
  }
  function es(t, e) {
    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
  }
  function is(t, e) {
    return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]];
  }
  function ns(t, e) {
    (t[0] += e[0]), (t[1] += e[1]), (t[2] += e[2]);
  }
  function ss(t, e) {
    return [t[0] * e, t[1] * e, t[2] * e];
  }
  function rs(t) {
    var e = Vn(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
    (t[0] /= e), (t[1] /= e), (t[2] /= e);
  }
  function as(t, e) {
    function i(i, n) {
      return (i = t(i, n)), e(i[0], i[1]);
    }
    return (
      t.invert &&
        e.invert &&
        (i.invert = function (i, n) {
          return (i = e.invert(i, n)) && t.invert(i[0], i[1]);
        }),
      i
    );
  }
  function os(t, e) {
    return [Bn(t) > Tn ? t + Math.round(-t / Pn) * Pn : t, e];
  }
  function ls(t, e, i) {
    return (t %= Pn) ? (e || i ? as(cs(t), ds(e, i)) : cs(t)) : e || i ? ds(e, i) : os;
  }
  function hs(t) {
    return function (e, i) {
      return [(e += t) > Tn ? e - Pn : e < -Tn ? e + Pn : e, i];
    };
  }
  function cs(t) {
    var e = hs(t);
    return (e.invert = hs(-t)), e;
  }
  function ds(t, e) {
    var i = Ln(t),
      n = Hn(t),
      s = Ln(e),
      r = Hn(e);
    function a(t, e) {
      var a = Ln(e),
        o = Ln(t) * a,
        l = Hn(t) * a,
        h = Hn(e),
        c = h * i + o * n;
      return [Dn(l * s - c * r, o * i - h * n), Un(c * s + l * r)];
    }
    return (
      (a.invert = function (t, e) {
        var a = Ln(e),
          o = Ln(t) * a,
          l = Hn(t) * a,
          h = Hn(e),
          c = h * s - l * r;
        return [Dn(l * s + h * r, o * i + c * n), Un(c * i - o * n)];
      }),
      a
    );
  }
  function us(t, e) {
    ((e = ts(e))[0] -= t), rs(e);
    var i = Gn(-e[1]);
    return ((-e[2] < 0 ? -i : i) + Pn - Mn) % Pn;
  }
  function ps() {
    var t,
      e = [];
    return {
      point: function (e, i, n) {
        t.push([e, i, n]);
      },
      lineStart: function () {
        e.push((t = []));
      },
      lineEnd: Yn,
      rejoin: function () {
        e.length > 1 && e.push(e.pop().concat(e.shift()));
      },
      result: function () {
        var i = e;
        return (e = []), (t = null), i;
      }
    };
  }
  function gs(t, e) {
    return Bn(t[0] - e[0]) < Mn && Bn(t[1] - e[1]) < Mn;
  }
  function fs(t, e, i, n) {
    (this.x = t), (this.z = e), (this.o = i), (this.e = n), (this.v = !1), (this.n = this.p = null);
  }
  function vs(t, e, i, n, s) {
    var r,
      a,
      o = [],
      l = [];
    if (
      (t.forEach(function (t) {
        if (!((e = t.length - 1) <= 0)) {
          var e,
            i,
            n = t[0],
            a = t[e];
          if (gs(n, a)) {
            if (!n[2] && !a[2]) {
              for (s.lineStart(), r = 0; r < e; ++r) s.point((n = t[r])[0], n[1]);
              return void s.lineEnd();
            }
            a[0] += 2 * Mn;
          }
          o.push((i = new fs(n, t, null, !0))),
            l.push((i.o = new fs(n, null, i, !1))),
            o.push((i = new fs(a, t, null, !1))),
            l.push((i.o = new fs(a, null, i, !0)));
        }
      }),
      o.length)
    ) {
      for (l.sort(e), ms(o), ms(l), r = 0, a = l.length; r < a; ++r) l[r].e = i = !i;
      for (var h, c, d = o[0]; ; ) {
        for (var u = d, p = !0; u.v; ) if ((u = u.n) === d) return;
        (h = u.z), s.lineStart();
        do {
          if (((u.v = u.o.v = !0), u.e)) {
            if (p) for (r = 0, a = h.length; r < a; ++r) s.point((c = h[r])[0], c[1]);
            else n(u.x, u.n.x, 1, s);
            u = u.n;
          } else {
            if (p) for (h = u.p.z, r = h.length - 1; r >= 0; --r) s.point((c = h[r])[0], c[1]);
            else n(u.x, u.p.x, -1, s);
            u = u.p;
          }
          (h = (u = u.o).z), (p = !p);
        } while (!u.v);
        s.lineEnd();
      }
    }
  }
  function ms(t) {
    if ((e = t.length)) {
      for (var e, i, n = 0, s = t[0]; ++n < e; ) (s.n = i = t[n]), (i.p = s), (s = i);
      (s.n = i = t[0]), (i.p = s);
    }
  }
  os.invert = os;
  var ys = Sn();
  function _s(t) {
    return Bn(t[0]) <= Tn ? t[0] : Nn(t[0]) * (((Bn(t[0]) + Tn) % Pn) - Tn);
  }
  function bs(t, e) {
    return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
  }
  function xs(t) {
    for (var e, i, n, s = t.length, r = -1, a = 0; ++r < s; ) a += t[r].length;
    for (i = new Array(a); --s >= 0; ) for (e = (n = t[s]).length; --e >= 0; ) i[--a] = n[e];
    return i;
  }
  function Ss(t, e, i, n) {
    return function (s) {
      var r,
        a,
        o,
        l = e(s),
        h = ps(),
        c = e(h),
        d = !1,
        u = {
          point: p,
          lineStart: f,
          lineEnd: v,
          polygonStart: function () {
            (u.point = m), (u.lineStart = y), (u.lineEnd = _), (a = []), (r = []);
          },
          polygonEnd: function () {
            (u.point = p), (u.lineStart = f), (u.lineEnd = v), (a = xs(a));
            var t = (function (t, e) {
              var i = _s(e),
                n = e[1],
                s = Hn(n),
                r = [Hn(i), -Ln(i), 0],
                a = 0,
                o = 0;
              ys.reset(), 1 === s ? (n = Cn + Mn) : -1 === s && (n = -Cn - Mn);
              for (var l = 0, h = t.length; l < h; ++l)
                if ((d = (c = t[l]).length))
                  for (
                    var c, d, u = c[d - 1], p = _s(u), g = u[1] / 2 + En, f = Hn(g), v = Ln(g), m = 0;
                    m < d;
                    ++m, p = _, f = x, v = S, u = y
                  ) {
                    var y = c[m],
                      _ = _s(y),
                      b = y[1] / 2 + En,
                      x = Hn(b),
                      S = Ln(b),
                      w = _ - p,
                      A = w >= 0 ? 1 : -1,
                      k = A * w,
                      M = k > Tn,
                      T = f * x;
                    if (
                      (ys.add(Dn(T * A * Hn(k), v * S + T * Ln(k))), (a += M ? w + A * Pn : w), M ^ (p >= i) ^ (_ >= i))
                    ) {
                      var C = is(ts(u), ts(y));
                      rs(C);
                      var E = is(r, C);
                      rs(E);
                      var P = (M ^ (w >= 0) ? -1 : 1) * Un(E[2]);
                      (n > P || (n === P && (C[0] || C[1]))) && (o += M ^ (w >= 0) ? 1 : -1);
                    }
                  }
              return (a < -Mn || (a < Mn && ys < -Mn)) ^ (1 & o);
            })(r, n);
            a.length
              ? (d || (s.polygonStart(), (d = !0)), vs(a, As, t, i, s))
              : t && (d || (s.polygonStart(), (d = !0)), s.lineStart(), i(null, null, 1, s), s.lineEnd()),
              d && (s.polygonEnd(), (d = !1)),
              (a = r = null);
          },
          sphere: function () {
            s.polygonStart(), s.lineStart(), i(null, null, 1, s), s.lineEnd(), s.polygonEnd();
          }
        };
      function p(e, i) {
        t(e, i) && s.point(e, i);
      }
      function g(t, e) {
        l.point(t, e);
      }
      function f() {
        (u.point = g), l.lineStart();
      }
      function v() {
        (u.point = p), l.lineEnd();
      }
      function m(t, e) {
        o.push([t, e]), c.point(t, e);
      }
      function y() {
        c.lineStart(), (o = []);
      }
      function _() {
        m(o[0][0], o[0][1]), c.lineEnd();
        var t,
          e,
          i,
          n,
          l = c.clean(),
          u = h.result(),
          p = u.length;
        if ((o.pop(), r.push(o), (o = null), p))
          if (1 & l) {
            if ((e = (i = u[0]).length - 1) > 0) {
              for (d || (s.polygonStart(), (d = !0)), s.lineStart(), t = 0; t < e; ++t) s.point((n = i[t])[0], n[1]);
              s.lineEnd();
            }
          } else p > 1 && 2 & l && u.push(u.pop().concat(u.shift())), a.push(u.filter(ws));
      }
      return u;
    };
  }
  function ws(t) {
    return t.length > 1;
  }
  function As(t, e) {
    return ((t = t.x)[0] < 0 ? t[1] - Cn - Mn : Cn - t[1]) - ((e = e.x)[0] < 0 ? e[1] - Cn - Mn : Cn - e[1]);
  }
  !(function (t) {
    var e;
    1 === t.length &&
      ((e = t),
      (t = function (t, i) {
        return bs(e(t), i);
      }));
  })(bs);
  var ks = Ss(
    function () {
      return !0;
    },
    function (t) {
      var e,
        i = NaN,
        n = NaN,
        s = NaN;
      return {
        lineStart: function () {
          t.lineStart(), (e = 1);
        },
        point: function (r, a) {
          var o = r > 0 ? Tn : -Tn,
            l = Bn(r - i);
          Bn(l - Tn) < Mn
            ? (t.point(i, (n = (n + a) / 2 > 0 ? Cn : -Cn)),
              t.point(s, n),
              t.lineEnd(),
              t.lineStart(),
              t.point(o, n),
              t.point(r, n),
              (e = 0))
            : s !== o &&
              l >= Tn &&
              (Bn(i - s) < Mn && (i -= s * Mn),
              Bn(r - o) < Mn && (r -= o * Mn),
              (n = (function (t, e, i, n) {
                var s,
                  r,
                  a = Hn(t - i);
                return Bn(a) > Mn
                  ? In((Hn(e) * (r = Ln(n)) * Hn(i) - Hn(n) * (s = Ln(e)) * Hn(t)) / (s * r * a))
                  : (e + n) / 2;
              })(i, n, r, a)),
              t.point(s, n),
              t.lineEnd(),
              t.lineStart(),
              t.point(o, n),
              (e = 0)),
            t.point((i = r), (n = a)),
            (s = o);
        },
        lineEnd: function () {
          t.lineEnd(), (i = n = NaN);
        },
        clean: function () {
          return 2 - e;
        }
      };
    },
    function (t, e, i, n) {
      var s;
      if (null == t)
        (s = i * Cn),
          n.point(-Tn, s),
          n.point(0, s),
          n.point(Tn, s),
          n.point(Tn, 0),
          n.point(Tn, -s),
          n.point(0, -s),
          n.point(-Tn, -s),
          n.point(-Tn, 0),
          n.point(-Tn, s);
      else if (Bn(t[0] - e[0]) > Mn) {
        var r = t[0] < e[0] ? Tn : -Tn;
        (s = (i * r) / 2), n.point(-r, s), n.point(0, s), n.point(r, s);
      } else n.point(e[0], e[1]);
    },
    [-Tn, -Cn]
  );
  function Ms(t) {
    var e = Ln(t),
      i = 6 * On,
      n = e > 0,
      s = Bn(e) > Mn;
    function r(t, i) {
      return Ln(t) * Ln(i) > e;
    }
    function a(t, i, n) {
      var s = [1, 0, 0],
        r = is(ts(t), ts(i)),
        a = es(r, r),
        o = r[0],
        l = a - o * o;
      if (!l) return !n && t;
      var h = (e * a) / l,
        c = (-e * o) / l,
        d = is(s, r),
        u = ss(s, h);
      ns(u, ss(r, c));
      var p = d,
        g = es(u, p),
        f = es(p, p),
        v = g * g - f * (es(u, u) - 1);
      if (!(v < 0)) {
        var m = Vn(v),
          y = ss(p, (-g - m) / f);
        if ((ns(y, u), (y = Qn(y)), !n)) return y;
        var _,
          b = t[0],
          x = i[0],
          S = t[1],
          w = i[1];
        x < b && ((_ = b), (b = x), (x = _));
        var A = x - b,
          k = Bn(A - Tn) < Mn;
        if (
          (!k && w < S && ((_ = S), (S = w), (w = _)),
          k || A < Mn
            ? k
              ? (S + w > 0) ^ (y[1] < (Bn(y[0] - b) < Mn ? S : w))
              : S <= y[1] && y[1] <= w
            : (A > Tn) ^ (b <= y[0] && y[0] <= x))
        ) {
          var M = ss(p, (-g + m) / f);
          return ns(M, u), [y, Qn(M)];
        }
      }
    }
    function o(e, i) {
      var s = n ? t : Tn - t,
        r = 0;
      return e < -s ? (r |= 1) : e > s && (r |= 2), i < -s ? (r |= 4) : i > s && (r |= 8), r;
    }
    return Ss(
      r,
      function (t) {
        var e, i, l, h, c;
        return {
          lineStart: function () {
            (h = l = !1), (c = 1);
          },
          point: function (d, u) {
            var p,
              g = [d, u],
              f = r(d, u),
              v = n ? (f ? 0 : o(d, u)) : f ? o(d + (d < 0 ? Tn : -Tn), u) : 0;
            if (
              (!e && (h = l = f) && t.lineStart(),
              f !== l && (!(p = a(e, g)) || gs(e, p) || gs(g, p)) && (g[2] = 1),
              f !== l)
            )
              (c = 0),
                f
                  ? (t.lineStart(), (p = a(g, e)), t.point(p[0], p[1]))
                  : ((p = a(e, g)), t.point(p[0], p[1], 2), t.lineEnd()),
                (e = p);
            else if (s && e && n ^ f) {
              var m;
              v & i ||
                !(m = a(g, e, !0)) ||
                ((c = 0),
                n
                  ? (t.lineStart(), t.point(m[0][0], m[0][1]), t.point(m[1][0], m[1][1]), t.lineEnd())
                  : (t.point(m[1][0], m[1][1]), t.lineEnd(), t.lineStart(), t.point(m[0][0], m[0][1], 3)));
            }
            !f || (e && gs(e, g)) || t.point(g[0], g[1]), (e = g), (l = f), (i = v);
          },
          lineEnd: function () {
            l && t.lineEnd(), (e = null);
          },
          clean: function () {
            return c | ((h && l) << 1);
          }
        };
      },
      function (e, n, s, r) {
        !(function (t, e, i, n, s, r) {
          if (i) {
            var a = Ln(e),
              o = Hn(e),
              l = n * i;
            null == s
              ? ((s = e + n * Pn), (r = e - l / 2))
              : ((s = us(a, s)), (r = us(a, r)), (n > 0 ? s < r : s > r) && (s += n * Pn));
            for (var h, c = s; n > 0 ? c > r : c < r; c -= l)
              (h = Qn([a, -o * Ln(c), -o * Hn(c)])), t.point(h[0], h[1]);
          }
        })(r, t, i, s, e, n);
      },
      n ? [0, -t] : [-Tn, t - Tn]
    );
  }
  var Ts = 1e9,
    Cs = -Ts;
  function Es(t, e, i, n) {
    function s(s, r) {
      return t <= s && s <= i && e <= r && r <= n;
    }
    function r(s, r, o, h) {
      var c = 0,
        d = 0;
      if (null == s || (c = a(s, o)) !== (d = a(r, o)) || (l(s, r) < 0) ^ (o > 0))
        do {
          h.point(0 === c || 3 === c ? t : i, c > 1 ? n : e);
        } while ((c = (c + o + 4) % 4) !== d);
      else h.point(r[0], r[1]);
    }
    function a(n, s) {
      return Bn(n[0] - t) < Mn
        ? s > 0
          ? 0
          : 3
        : Bn(n[0] - i) < Mn
        ? s > 0
          ? 2
          : 1
        : Bn(n[1] - e) < Mn
        ? s > 0
          ? 1
          : 0
        : s > 0
        ? 3
        : 2;
    }
    function o(t, e) {
      return l(t.x, e.x);
    }
    function l(t, e) {
      var i = a(t, 1),
        n = a(e, 1);
      return i !== n ? i - n : 0 === i ? e[1] - t[1] : 1 === i ? t[0] - e[0] : 2 === i ? t[1] - e[1] : e[0] - t[0];
    }
    return function (a) {
      var l,
        h,
        c,
        d,
        u,
        p,
        g,
        f,
        v,
        m,
        y,
        _ = a,
        b = ps(),
        x = {
          point: S,
          lineStart: function () {
            (x.point = w), h && h.push((c = []));
            (m = !0), (v = !1), (g = f = NaN);
          },
          lineEnd: function () {
            l && (w(d, u), p && v && b.rejoin(), l.push(b.result()));
            (x.point = S), v && _.lineEnd();
          },
          polygonStart: function () {
            (_ = b), (l = []), (h = []), (y = !0);
          },
          polygonEnd: function () {
            var e = (function () {
                for (var e = 0, i = 0, s = h.length; i < s; ++i)
                  for (var r, a, o = h[i], l = 1, c = o.length, d = o[0], u = d[0], p = d[1]; l < c; ++l)
                    (r = u),
                      (a = p),
                      (u = (d = o[l])[0]),
                      (p = d[1]),
                      a <= n
                        ? p > n && (u - r) * (n - a) > (p - a) * (t - r) && ++e
                        : p <= n && (u - r) * (n - a) < (p - a) * (t - r) && --e;
                return e;
              })(),
              i = y && e,
              s = (l = xs(l)).length;
            (i || s) &&
              (a.polygonStart(),
              i && (a.lineStart(), r(null, null, 1, a), a.lineEnd()),
              s && vs(l, o, e, r, a),
              a.polygonEnd());
            (_ = a), (l = h = c = null);
          }
        };
      function S(t, e) {
        s(t, e) && _.point(t, e);
      }
      function w(r, a) {
        var o = s(r, a);
        if ((h && c.push([r, a]), m)) (d = r), (u = a), (p = o), (m = !1), o && (_.lineStart(), _.point(r, a));
        else if (o && v) _.point(r, a);
        else {
          var l = [(g = Math.max(Cs, Math.min(Ts, g))), (f = Math.max(Cs, Math.min(Ts, f)))],
            b = [(r = Math.max(Cs, Math.min(Ts, r))), (a = Math.max(Cs, Math.min(Ts, a)))];
          !(function (t, e, i, n, s, r) {
            var a,
              o = t[0],
              l = t[1],
              h = 0,
              c = 1,
              d = e[0] - o,
              u = e[1] - l;
            if (((a = i - o), d || !(a > 0))) {
              if (((a /= d), d < 0)) {
                if (a < h) return;
                a < c && (c = a);
              } else if (d > 0) {
                if (a > c) return;
                a > h && (h = a);
              }
              if (((a = s - o), d || !(a < 0))) {
                if (((a /= d), d < 0)) {
                  if (a > c) return;
                  a > h && (h = a);
                } else if (d > 0) {
                  if (a < h) return;
                  a < c && (c = a);
                }
                if (((a = n - l), u || !(a > 0))) {
                  if (((a /= u), u < 0)) {
                    if (a < h) return;
                    a < c && (c = a);
                  } else if (u > 0) {
                    if (a > c) return;
                    a > h && (h = a);
                  }
                  if (((a = r - l), u || !(a < 0))) {
                    if (((a /= u), u < 0)) {
                      if (a > c) return;
                      a > h && (h = a);
                    } else if (u > 0) {
                      if (a < h) return;
                      a < c && (c = a);
                    }
                    return (
                      h > 0 && ((t[0] = o + h * d), (t[1] = l + h * u)),
                      c < 1 && ((e[0] = o + c * d), (e[1] = l + c * u)),
                      !0
                    );
                  }
                }
              }
            }
          })(l, b, t, e, i, n)
            ? o && (_.lineStart(), _.point(r, a), (y = !1))
            : (v || (_.lineStart(), _.point(l[0], l[1])), _.point(b[0], b[1]), o || _.lineEnd(), (y = !1));
        }
        (g = r), (f = a), (v = o);
      }
      return x;
    };
  }
  function Ps(t) {
    return t;
  }
  var Rs,
    Os,
    Bs,
    Is,
    Ds = Sn(),
    Ls = Sn(),
    Fs = {
      point: Yn,
      lineStart: Yn,
      lineEnd: Yn,
      polygonStart: function () {
        (Fs.lineStart = js), (Fs.lineEnd = Ns);
      },
      polygonEnd: function () {
        (Fs.lineStart = Fs.lineEnd = Fs.point = Yn), Ds.add(Bn(Ls)), Ls.reset();
      },
      result: function () {
        var t = Ds / 2;
        return Ds.reset(), t;
      }
    };
  function js() {
    Fs.point = zs;
  }
  function zs(t, e) {
    (Fs.point = Hs), (Rs = Bs = t), (Os = Is = e);
  }
  function Hs(t, e) {
    Ls.add(Is * t - Bs * e), (Bs = t), (Is = e);
  }
  function Ns() {
    Hs(Rs, Os);
  }
  var Vs = Fs,
    Ws = 1 / 0,
    Gs = Ws,
    Us = -Ws,
    Ys = Us;
  var $s,
    Xs,
    Ks,
    qs,
    Zs = {
      point: function (t, e) {
        t < Ws && (Ws = t);
        t > Us && (Us = t);
        e < Gs && (Gs = e);
        e > Ys && (Ys = e);
      },
      lineStart: Yn,
      lineEnd: Yn,
      polygonStart: Yn,
      polygonEnd: Yn,
      result: function () {
        var t = [
          [Ws, Gs],
          [Us, Ys]
        ];
        return (Us = Ys = -(Gs = Ws = 1 / 0)), t;
      }
    },
    Js = 0,
    Qs = 0,
    tr = 0,
    er = 0,
    ir = 0,
    nr = 0,
    sr = 0,
    rr = 0,
    ar = 0,
    or = {
      point: lr,
      lineStart: hr,
      lineEnd: ur,
      polygonStart: function () {
        (or.lineStart = pr), (or.lineEnd = gr);
      },
      polygonEnd: function () {
        (or.point = lr), (or.lineStart = hr), (or.lineEnd = ur);
      },
      result: function () {
        var t = ar ? [sr / ar, rr / ar] : nr ? [er / nr, ir / nr] : tr ? [Js / tr, Qs / tr] : [NaN, NaN];
        return (Js = Qs = tr = er = ir = nr = sr = rr = ar = 0), t;
      }
    };
  function lr(t, e) {
    (Js += t), (Qs += e), ++tr;
  }
  function hr() {
    or.point = cr;
  }
  function cr(t, e) {
    (or.point = dr), lr((Ks = t), (qs = e));
  }
  function dr(t, e) {
    var i = t - Ks,
      n = e - qs,
      s = Vn(i * i + n * n);
    (er += (s * (Ks + t)) / 2), (ir += (s * (qs + e)) / 2), (nr += s), lr((Ks = t), (qs = e));
  }
  function ur() {
    or.point = lr;
  }
  function pr() {
    or.point = fr;
  }
  function gr() {
    vr($s, Xs);
  }
  function fr(t, e) {
    (or.point = vr), lr(($s = Ks = t), (Xs = qs = e));
  }
  function vr(t, e) {
    var i = t - Ks,
      n = e - qs,
      s = Vn(i * i + n * n);
    (er += (s * (Ks + t)) / 2),
      (ir += (s * (qs + e)) / 2),
      (nr += s),
      (sr += (s = qs * t - Ks * e) * (Ks + t)),
      (rr += s * (qs + e)),
      (ar += 3 * s),
      lr((Ks = t), (qs = e));
  }
  var mr = or;
  function yr(t) {
    this._context = t;
  }
  yr.prototype = {
    _radius: 4.5,
    pointRadius: function (t) {
      return (this._radius = t), this;
    },
    polygonStart: function () {
      this._line = 0;
    },
    polygonEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._point = 0;
    },
    lineEnd: function () {
      0 === this._line && this._context.closePath(), (this._point = NaN);
    },
    point: function (t, e) {
      switch (this._point) {
        case 0:
          this._context.moveTo(t, e), (this._point = 1);
          break;
        case 1:
          this._context.lineTo(t, e);
          break;
        default:
          this._context.moveTo(t + this._radius, e), this._context.arc(t, e, this._radius, 0, Pn);
      }
    },
    result: Yn
  };
  var _r,
    br,
    xr,
    Sr,
    wr,
    Ar = Sn(),
    kr = {
      point: Yn,
      lineStart: function () {
        kr.point = Mr;
      },
      lineEnd: function () {
        _r && Tr(br, xr), (kr.point = Yn);
      },
      polygonStart: function () {
        _r = !0;
      },
      polygonEnd: function () {
        _r = null;
      },
      result: function () {
        var t = +Ar;
        return Ar.reset(), t;
      }
    };
  function Mr(t, e) {
    (kr.point = Tr), (br = Sr = t), (xr = wr = e);
  }
  function Tr(t, e) {
    (Sr -= t), (wr -= e), Ar.add(Vn(Sr * Sr + wr * wr)), (Sr = t), (wr = e);
  }
  var Cr = kr;
  function Er() {
    this._string = [];
  }
  function Pr(t) {
    return 'm0,' + t + 'a' + t + ',' + t + ' 0 1,1 0,' + -2 * t + 'a' + t + ',' + t + ' 0 1,1 0,' + 2 * t + 'z';
  }
  function Rr(t, e) {
    var i,
      n,
      s = 4.5;
    function r(t) {
      return t && ('function' == typeof s && n.pointRadius(+s.apply(this, arguments)), Jn(t, i(n))), n.result();
    }
    return (
      (r.area = function (t) {
        return Jn(t, i(Vs)), Vs.result();
      }),
      (r.measure = function (t) {
        return Jn(t, i(Cr)), Cr.result();
      }),
      (r.bounds = function (t) {
        return Jn(t, i(Zs)), Zs.result();
      }),
      (r.centroid = function (t) {
        return Jn(t, i(mr)), mr.result();
      }),
      (r.projection = function (e) {
        return arguments.length ? ((i = null == e ? ((t = null), Ps) : (t = e).stream), r) : t;
      }),
      (r.context = function (t) {
        return arguments.length
          ? ((n = null == t ? ((e = null), new Er()) : new yr((e = t))), 'function' != typeof s && n.pointRadius(s), r)
          : e;
      }),
      (r.pointRadius = function (t) {
        return arguments.length ? ((s = 'function' == typeof t ? t : (n.pointRadius(+t), +t)), r) : s;
      }),
      r.projection(t).context(e)
    );
  }
  function Or(t) {
    return function (e) {
      var i = new Br();
      for (var n in t) i[n] = t[n];
      return (i.stream = e), i;
    };
  }
  function Br() {}
  function Ir(t, e, i) {
    var n = t.clipExtent && t.clipExtent();
    return (
      t.scale(150).translate([0, 0]),
      null != n && t.clipExtent(null),
      Jn(i, t.stream(Zs)),
      e(Zs.result()),
      null != n && t.clipExtent(n),
      t
    );
  }
  function Dr(t, e, i) {
    return Ir(
      t,
      function (i) {
        var n = e[1][0] - e[0][0],
          s = e[1][1] - e[0][1],
          r = Math.min(n / (i[1][0] - i[0][0]), s / (i[1][1] - i[0][1])),
          a = +e[0][0] + (n - r * (i[1][0] + i[0][0])) / 2,
          o = +e[0][1] + (s - r * (i[1][1] + i[0][1])) / 2;
        t.scale(150 * r).translate([a, o]);
      },
      i
    );
  }
  function Lr(t, e, i) {
    return Dr(t, [[0, 0], e], i);
  }
  function Fr(t, e, i) {
    return Ir(
      t,
      function (i) {
        var n = +e,
          s = n / (i[1][0] - i[0][0]),
          r = (n - s * (i[1][0] + i[0][0])) / 2,
          a = -s * i[0][1];
        t.scale(150 * s).translate([r, a]);
      },
      i
    );
  }
  function jr(t, e, i) {
    return Ir(
      t,
      function (i) {
        var n = +e,
          s = n / (i[1][1] - i[0][1]),
          r = -s * i[0][0],
          a = (n - s * (i[1][1] + i[0][1])) / 2;
        t.scale(150 * s).translate([r, a]);
      },
      i
    );
  }
  (Er.prototype = {
    _radius: 4.5,
    _circle: Pr(4.5),
    pointRadius: function (t) {
      return (t = +t) !== this._radius && ((this._radius = t), (this._circle = null)), this;
    },
    polygonStart: function () {
      this._line = 0;
    },
    polygonEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._point = 0;
    },
    lineEnd: function () {
      0 === this._line && this._string.push('Z'), (this._point = NaN);
    },
    point: function (t, e) {
      switch (this._point) {
        case 0:
          this._string.push('M', t, ',', e), (this._point = 1);
          break;
        case 1:
          this._string.push('L', t, ',', e);
          break;
        default:
          null == this._circle && (this._circle = Pr(this._radius)), this._string.push('M', t, ',', e, this._circle);
      }
    },
    result: function () {
      if (this._string.length) {
        var t = this._string.join('');
        return (this._string = []), t;
      }
      return null;
    }
  }),
    (Br.prototype = {
      constructor: Br,
      point: function (t, e) {
        this.stream.point(t, e);
      },
      sphere: function () {
        this.stream.sphere();
      },
      lineStart: function () {
        this.stream.lineStart();
      },
      lineEnd: function () {
        this.stream.lineEnd();
      },
      polygonStart: function () {
        this.stream.polygonStart();
      },
      polygonEnd: function () {
        this.stream.polygonEnd();
      }
    });
  var zr = 16,
    Hr = Ln(30 * On);
  function Nr(t, e) {
    return +e
      ? (function (t, e) {
          function i(n, s, r, a, o, l, h, c, d, u, p, g, f, v) {
            var m = h - n,
              y = c - s,
              _ = m * m + y * y;
            if (_ > 4 * e && f--) {
              var b = a + u,
                x = o + p,
                S = l + g,
                w = Vn(b * b + x * x + S * S),
                A = Un((S /= w)),
                k = Bn(Bn(S) - 1) < Mn || Bn(r - d) < Mn ? (r + d) / 2 : Dn(x, b),
                M = t(k, A),
                T = M[0],
                C = M[1],
                E = T - n,
                P = C - s,
                R = y * E - m * P;
              ((R * R) / _ > e || Bn((m * E + y * P) / _ - 0.5) > 0.3 || a * u + o * p + l * g < Hr) &&
                (i(n, s, r, a, o, l, T, C, k, (b /= w), (x /= w), S, f, v),
                v.point(T, C),
                i(T, C, k, b, x, S, h, c, d, u, p, g, f, v));
            }
          }
          return function (e) {
            var n,
              s,
              r,
              a,
              o,
              l,
              h,
              c,
              d,
              u,
              p,
              g,
              f = {
                point: v,
                lineStart: m,
                lineEnd: _,
                polygonStart: function () {
                  e.polygonStart(), (f.lineStart = b);
                },
                polygonEnd: function () {
                  e.polygonEnd(), (f.lineStart = m);
                }
              };
            function v(i, n) {
              (i = t(i, n)), e.point(i[0], i[1]);
            }
            function m() {
              (c = NaN), (f.point = y), e.lineStart();
            }
            function y(n, s) {
              var r = ts([n, s]),
                a = t(n, s);
              i(c, d, h, u, p, g, (c = a[0]), (d = a[1]), (h = n), (u = r[0]), (p = r[1]), (g = r[2]), zr, e),
                e.point(c, d);
            }
            function _() {
              (f.point = v), e.lineEnd();
            }
            function b() {
              m(), (f.point = x), (f.lineEnd = S);
            }
            function x(t, e) {
              y((n = t), e), (s = c), (r = d), (a = u), (o = p), (l = g), (f.point = y);
            }
            function S() {
              i(c, d, h, u, p, g, s, r, n, a, o, l, zr, e), (f.lineEnd = _), _();
            }
            return f;
          };
        })(t, e)
      : (function (t) {
          return Or({
            point: function (e, i) {
              (e = t(e, i)), this.stream.point(e[0], e[1]);
            }
          });
        })(t);
  }
  var Vr = Or({
    point: function (t, e) {
      this.stream.point(t * On, e * On);
    }
  });
  function Wr(t, e, i, n, s) {
    function r(r, a) {
      return [e + t * (r *= n), i - t * (a *= s)];
    }
    return (
      (r.invert = function (r, a) {
        return [((r - e) / t) * n, ((i - a) / t) * s];
      }),
      r
    );
  }
  function Gr(t, e, i, n, s, r) {
    var a = Ln(r),
      o = Hn(r),
      l = a * t,
      h = o * t,
      c = a / t,
      d = o / t,
      u = (o * i - a * e) / t,
      p = (o * e + a * i) / t;
    function g(t, r) {
      return [l * (t *= n) - h * (r *= s) + e, i - h * t - l * r];
    }
    return (
      (g.invert = function (t, e) {
        return [n * (c * t - d * e + u), s * (p - d * t - c * e)];
      }),
      g
    );
  }
  function Ur(t) {
    return Yr(function () {
      return t;
    })();
  }
  function Yr(t) {
    var e,
      i,
      n,
      s,
      r,
      a,
      o,
      l,
      h,
      c,
      d = 150,
      u = 480,
      p = 250,
      g = 0,
      f = 0,
      v = 0,
      m = 0,
      y = 0,
      _ = 0,
      b = 1,
      x = 1,
      S = null,
      w = ks,
      A = null,
      k = Ps,
      M = 0.5;
    function T(t) {
      return l(t[0] * On, t[1] * On);
    }
    function C(t) {
      return (t = l.invert(t[0], t[1])) && [t[0] * Rn, t[1] * Rn];
    }
    function E() {
      var t = Gr(d, 0, 0, b, x, _).apply(null, e(g, f)),
        n = (_ ? Gr : Wr)(d, u - t[0], p - t[1], b, x, _);
      return (i = ls(v, m, y)), (o = as(e, n)), (l = as(i, o)), (a = Nr(o, M)), P();
    }
    function P() {
      return (h = c = null), T;
    }
    return (
      (T.stream = function (t) {
        return h && c === t
          ? h
          : (h = Vr(
              (function (t) {
                return Or({
                  point: function (e, i) {
                    var n = t(e, i);
                    return this.stream.point(n[0], n[1]);
                  }
                });
              })(i)(w(a(k((c = t)))))
            ));
      }),
      (T.preclip = function (t) {
        return arguments.length ? ((w = t), (S = void 0), P()) : w;
      }),
      (T.postclip = function (t) {
        return arguments.length ? ((k = t), (A = n = s = r = null), P()) : k;
      }),
      (T.clipAngle = function (t) {
        return arguments.length ? ((w = +t ? Ms((S = t * On)) : ((S = null), ks)), P()) : S * Rn;
      }),
      (T.clipExtent = function (t) {
        return arguments.length
          ? ((k =
              null == t
                ? ((A = n = s = r = null), Ps)
                : Es((A = +t[0][0]), (n = +t[0][1]), (s = +t[1][0]), (r = +t[1][1]))),
            P())
          : null == A
          ? null
          : [
              [A, n],
              [s, r]
            ];
      }),
      (T.scale = function (t) {
        return arguments.length ? ((d = +t), E()) : d;
      }),
      (T.translate = function (t) {
        return arguments.length ? ((u = +t[0]), (p = +t[1]), E()) : [u, p];
      }),
      (T.center = function (t) {
        return arguments.length ? ((g = (t[0] % 360) * On), (f = (t[1] % 360) * On), E()) : [g * Rn, f * Rn];
      }),
      (T.rotate = function (t) {
        return arguments.length
          ? ((v = (t[0] % 360) * On), (m = (t[1] % 360) * On), (y = t.length > 2 ? (t[2] % 360) * On : 0), E())
          : [v * Rn, m * Rn, y * Rn];
      }),
      (T.angle = function (t) {
        return arguments.length ? ((_ = (t % 360) * On), E()) : _ * Rn;
      }),
      (T.reflectX = function (t) {
        return arguments.length ? ((b = t ? -1 : 1), E()) : b < 0;
      }),
      (T.reflectY = function (t) {
        return arguments.length ? ((x = t ? -1 : 1), E()) : x < 0;
      }),
      (T.precision = function (t) {
        return arguments.length ? ((a = Nr(o, (M = t * t))), P()) : Vn(M);
      }),
      (T.fitExtent = function (t, e) {
        return Dr(T, t, e);
      }),
      (T.fitSize = function (t, e) {
        return Lr(T, t, e);
      }),
      (T.fitWidth = function (t, e) {
        return Fr(T, t, e);
      }),
      (T.fitHeight = function (t, e) {
        return jr(T, t, e);
      }),
      function () {
        return (e = t.apply(this, arguments)), (T.invert = e.invert && C), E();
      }
    );
  }
  function $r(t) {
    var e = 0,
      i = Tn / 3,
      n = Yr(t),
      s = n(e, i);
    return (
      (s.parallels = function (t) {
        return arguments.length ? n((e = t[0] * On), (i = t[1] * On)) : [e * Rn, i * Rn];
      }),
      s
    );
  }
  function Xr(t, e) {
    var i = Hn(t),
      n = (i + Hn(e)) / 2;
    if (Bn(n) < Mn)
      return (function (t) {
        var e = Ln(t);
        function i(t, i) {
          return [t * e, Hn(i) / e];
        }
        return (
          (i.invert = function (t, i) {
            return [t / e, Un(i * e)];
          }),
          i
        );
      })(t);
    var s = 1 + i * (2 * n - i),
      r = Vn(s) / n;
    function a(t, e) {
      var i = Vn(s - 2 * n * Hn(e)) / n;
      return [i * Hn((t *= n)), r - i * Ln(t)];
    }
    return (
      (a.invert = function (t, e) {
        var i = r - e,
          a = Dn(t, Bn(i)) * Nn(i);
        return i * n < 0 && (a -= Tn * Nn(t) * Nn(i)), [a / n, Un((s - (t * t + i * i) * n * n) / (2 * n))];
      }),
      a
    );
  }
  function Kr() {
    return $r(Xr).scale(155.424).center([0, 33.6442]);
  }
  function qr() {
    return Kr().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
  }
  function Zr(t) {
    return function (e, i) {
      var n = Ln(e),
        s = Ln(i),
        r = t(n * s);
      return [r * s * Hn(e), r * Hn(i)];
    };
  }
  function Jr(t) {
    return function (e, i) {
      var n = Vn(e * e + i * i),
        s = t(n),
        r = Hn(s),
        a = Ln(s);
      return [Dn(e * r, n * a), Un(n && (i * r) / n)];
    };
  }
  var Qr = Zr(function (t) {
    return Vn(2 / (1 + t));
  });
  Qr.invert = Jr(function (t) {
    return 2 * Un(t / 2);
  });
  var ta = Zr(function (t) {
    return (t = Gn(t)) && t / Hn(t);
  });
  function ea(t, e) {
    return [t, jn(Wn((Cn + e) / 2))];
  }
  function ia(t) {
    var e,
      i,
      n,
      s = Ur(t),
      r = s.center,
      a = s.scale,
      o = s.translate,
      l = s.clipExtent,
      h = null;
    function c() {
      var r = Tn * a(),
        o = s(
          (function (t) {
            function e(e) {
              return ((e = t(e[0] * On, e[1] * On))[0] *= Rn), (e[1] *= Rn), e;
            }
            return (
              (t = ls(t[0] * On, t[1] * On, t.length > 2 ? t[2] * On : 0)),
              (e.invert = function (e) {
                return ((e = t.invert(e[0] * On, e[1] * On))[0] *= Rn), (e[1] *= Rn), e;
              }),
              e
            );
          })(s.rotate()).invert([0, 0])
        );
      return l(
        null == h
          ? [
              [o[0] - r, o[1] - r],
              [o[0] + r, o[1] + r]
            ]
          : t === ea
          ? [
              [Math.max(o[0] - r, h), e],
              [Math.min(o[0] + r, i), n]
            ]
          : [
              [h, Math.max(o[1] - r, e)],
              [i, Math.min(o[1] + r, n)]
            ]
      );
    }
    return (
      (s.scale = function (t) {
        return arguments.length ? (a(t), c()) : a();
      }),
      (s.translate = function (t) {
        return arguments.length ? (o(t), c()) : o();
      }),
      (s.center = function (t) {
        return arguments.length ? (r(t), c()) : r();
      }),
      (s.clipExtent = function (t) {
        return arguments.length
          ? (null == t ? (h = e = i = n = null) : ((h = +t[0][0]), (e = +t[0][1]), (i = +t[1][0]), (n = +t[1][1])), c())
          : null == h
          ? null
          : [
              [h, e],
              [i, n]
            ];
      }),
      c()
    );
  }
  function na(t) {
    return Wn((Cn + t) / 2);
  }
  function sa(t, e) {
    var i = Ln(t),
      n = t === e ? Hn(t) : jn(i / Ln(e)) / jn(na(e) / na(t)),
      s = (i * zn(na(t), n)) / n;
    if (!n) return ea;
    function r(t, e) {
      s > 0 ? e < -Cn + Mn && (e = -Cn + Mn) : e > Cn - Mn && (e = Cn - Mn);
      var i = s / zn(na(e), n);
      return [i * Hn(n * t), s - i * Ln(n * t)];
    }
    return (
      (r.invert = function (t, e) {
        var i = s - e,
          r = Nn(n) * Vn(t * t + i * i),
          a = Dn(t, Bn(i)) * Nn(i);
        return i * n < 0 && (a -= Tn * Nn(t) * Nn(i)), [a / n, 2 * In(zn(s / r, 1 / n)) - Cn];
      }),
      r
    );
  }
  function ra(t, e) {
    return [t, e];
  }
  function aa(t, e) {
    var i = Ln(t),
      n = t === e ? Hn(t) : (i - Ln(e)) / (e - t),
      s = i / n + t;
    if (Bn(n) < Mn) return ra;
    function r(t, e) {
      var i = s - e,
        r = n * t;
      return [i * Hn(r), s - i * Ln(r)];
    }
    return (
      (r.invert = function (t, e) {
        var i = s - e,
          r = Dn(t, Bn(i)) * Nn(i);
        return i * n < 0 && (r -= Tn * Nn(t) * Nn(i)), [r / n, s - Nn(n) * Vn(t * t + i * i)];
      }),
      r
    );
  }
  (ta.invert = Jr(function (t) {
    return t;
  })),
    (ea.invert = function (t, e) {
      return [t, 2 * In(Fn(e)) - Cn];
    }),
    (ra.invert = ra);
  var oa = 1.340264,
    la = -0.081106,
    ha = 893e-6,
    ca = 0.003796,
    da = Vn(3) / 2;
  function ua(t, e) {
    var i = Un(da * Hn(e)),
      n = i * i,
      s = n * n * n;
    return [(t * Ln(i)) / (da * (oa + 3 * la * n + s * (7 * ha + 9 * ca * n))), i * (oa + la * n + s * (ha + ca * n))];
  }
  function pa(t, e) {
    var i = Ln(e),
      n = Ln(t) * i;
    return [(i * Hn(t)) / n, Hn(e) / n];
  }
  function ga(t, e) {
    var i = e * e,
      n = i * i;
    return [
      t * (0.8707 - 0.131979 * i + n * (n * (0.003971 * i - 0.001529 * n) - 0.013791)),
      e * (1.007226 + i * (0.015085 + n * (0.028874 * i - 0.044475 - 0.005916 * n)))
    ];
  }
  function fa(t, e) {
    return [Ln(e) * Hn(t), Hn(e)];
  }
  function va(t, e) {
    var i = Ln(e),
      n = 1 + Ln(t) * i;
    return [(i * Hn(t)) / n, Hn(e) / n];
  }
  function ma(t, e) {
    return [jn(Wn((Cn + e) / 2)), -t];
  }
  function ya(t) {
    return t;
  }
  function _a(t, e) {
    var i = e.id,
      n = e.bbox,
      s = null == e.properties ? {} : e.properties,
      r = (function (t, e) {
        var i = (function (t) {
            if (null == t) return ya;
            var e,
              i,
              n = t.scale[0],
              s = t.scale[1],
              r = t.translate[0],
              a = t.translate[1];
            return function (t, o) {
              o || (e = i = 0);
              var l = 2,
                h = t.length,
                c = new Array(h);
              for (c[0] = (e += t[0]) * n + r, c[1] = (i += t[1]) * s + a; l < h; ) (c[l] = t[l]), ++l;
              return c;
            };
          })(t.transform),
          n = t.arcs;
        function s(t, e) {
          e.length && e.pop();
          for (var s = n[t < 0 ? ~t : t], r = 0, a = s.length; r < a; ++r) e.push(i(s[r], r));
          t < 0 &&
            (function (t, e) {
              for (var i, n = t.length, s = n - e; s < --n; ) (i = t[s]), (t[s++] = t[n]), (t[n] = i);
            })(e, a);
        }
        function r(t) {
          return i(t);
        }
        function a(t) {
          for (var e = [], i = 0, n = t.length; i < n; ++i) s(t[i], e);
          return e.length < 2 && e.push(e[0]), e;
        }
        function o(t) {
          for (var e = a(t); e.length < 4; ) e.push(e[0]);
          return e;
        }
        function l(t) {
          return t.map(o);
        }
        function h(t) {
          var e,
            i = t.type;
          switch (i) {
            case 'GeometryCollection':
              return { type: i, geometries: t.geometries.map(h) };
            case 'Point':
              e = r(t.coordinates);
              break;
            case 'MultiPoint':
              e = t.coordinates.map(r);
              break;
            case 'LineString':
              e = a(t.arcs);
              break;
            case 'MultiLineString':
              e = t.arcs.map(a);
              break;
            case 'Polygon':
              e = l(t.arcs);
              break;
            case 'MultiPolygon':
              e = t.arcs.map(l);
              break;
            default:
              return null;
          }
          return { type: i, coordinates: e };
        }
        return h(e);
      })(t, e);
    return null == i && null == n
      ? { type: 'Feature', properties: s, geometry: r }
      : null == n
      ? { type: 'Feature', id: i, properties: s, geometry: r }
      : { type: 'Feature', id: i, bbox: n, properties: s, geometry: r };
  }
  (ua.invert = function (t, e) {
    for (
      var i, n = e, s = n * n, r = s * s * s, a = 0;
      a < 12 &&
      ((r =
        (s =
          (n -= i = (n * (oa + la * s + r * (ha + ca * s)) - e) / (oa + 3 * la * s + r * (7 * ha + 9 * ca * s))) * n) *
        s *
        s),
      !(Bn(i) < 1e-12));
      ++a
    );
    return [(da * t * (oa + 3 * la * s + r * (7 * ha + 9 * ca * s))) / Ln(n), Un(Hn(n) / da)];
  }),
    (pa.invert = Jr(In)),
    (ga.invert = function (t, e) {
      var i,
        n = e,
        s = 25;
      do {
        var r = n * n,
          a = r * r;
        n -= i =
          (n * (1.007226 + r * (0.015085 + a * (0.028874 * r - 0.044475 - 0.005916 * a))) - e) /
          (1.007226 + r * (0.045255 + a * (0.259866 * r - 0.311325 - 0.005916 * 11 * a)));
      } while (Bn(i) > Mn && --s > 0);
      return [t / (0.8707 + (r = n * n) * (r * (r * r * r * (0.003971 - 0.001529 * r) - 0.013791) - 0.131979)), n];
    }),
    (fa.invert = Jr(Un)),
    (va.invert = Jr(function (t) {
      return 2 * In(t);
    })),
    (ma.invert = function (t, e) {
      return [-e, 2 * In(Fn(t)) - Cn];
    });
  var ba = { exports: {} },
    xa = function (t, e) {
      (this.p1 = t), (this.p2 = e);
    };
  (xa.prototype.rise = function () {
    return this.p2[1] - this.p1[1];
  }),
    (xa.prototype.run = function () {
      return this.p2[0] - this.p1[0];
    }),
    (xa.prototype.slope = function () {
      return this.rise() / this.run();
    }),
    (xa.prototype.yIntercept = function () {
      return this.p1[1] - this.p1[0] * this.slope(this.p1, this.p2);
    }),
    (xa.prototype.isVertical = function () {
      return !isFinite(this.slope());
    }),
    (xa.prototype.isHorizontal = function () {
      return this.p1[1] == this.p2[1];
    }),
    (xa.prototype._perpendicularDistanceHorizontal = function (t) {
      return Math.abs(this.p1[1] - t[1]);
    }),
    (xa.prototype._perpendicularDistanceVertical = function (t) {
      return Math.abs(this.p1[0] - t[0]);
    }),
    (xa.prototype._perpendicularDistanceHasSlope = function (t) {
      var e = this.slope(),
        i = this.yIntercept();
      return Math.abs(e * t[0] - t[1] + i) / Math.sqrt(Math.pow(e, 2) + 1);
    }),
    (xa.prototype.perpendicularDistance = function (t) {
      return this.isVertical()
        ? this._perpendicularDistanceVertical(t)
        : this.isHorizontal()
        ? this._perpendicularDistanceHorizontal(t)
        : this._perpendicularDistanceHasSlope(t);
    });
  var Sa = xa,
    wa = function (t, e) {
      for (var i = 0, n = 0, s = 1; s <= t.length - 2; s++) {
        var r = new Sa(t[0], t[t.length - 1]).perpendicularDistance(t[s]);
        r > i && ((n = s), (i = r));
      }
      if (i > e)
        var a = wa(t.slice(0, n), e),
          o = wa(t.slice(n, t.length), e),
          l = a.concat(o);
      else l = t.length > 1 ? [t[0], t[t.length - 1]] : [t[0]];
      return l;
    },
    Aa = wa;
  !(function (t) {
    var e = Aa;
    function i(e, i) {
      var n = e.geometry,
        s = n.type;
      if ('LineString' === s) n.coordinates = t.exports.simplify(n.coordinates, i);
      else if ('Polygon' === s || 'MultiLineString' === s)
        for (var r = 0; r < n.coordinates.length; r++) n.coordinates[r] = t.exports.simplify(n.coordinates[r], i);
      else if ('MultiPolygon' === s)
        for (var a = 0; a < n.coordinates.length; a++)
          for (var o = 0; o < n.coordinates[a].length; o++)
            n.coordinates[a][o] = t.exports.simplify(n.coordinates[a][o], i);
      return e;
    }
    (t.exports = function (t, e, n) {
      return (
        n || (t = JSON.parse(JSON.stringify(t))),
        t.features
          ? (function (t, e) {
              for (var n = 0; n < t.features.length; n++) t.features[n] = i(t.features[n], e);
              return t;
            })(t, e)
          : t.type && 'Feature' === t.type
          ? i(t, e)
          : new Error('FeatureCollection or individual Feature required')
      );
    }),
      (t.exports.simplify = function (t, i) {
        return e(t, i);
      });
  })(ba);
  var ka = i(ba.exports);
  const Ma = function (t) {
    for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) i[n - 1] = arguments[n];
    return (function (t) {
      t || (t = {});
      let e = -1;
      const i = arguments.length <= 1 ? 0 : arguments.length - 1;
      for (; ++e < i; ) Ca(t, e + 1 < 1 || arguments.length <= e + 1 ? void 0 : arguments[e + 1]);
      return t;
    })(R(t), ...i);
  };
  function Ta(t, e, i) {
    const n = e[i];
    if (void 0 === n) t[i] = null;
    else if (c(n)) {
      c(t[i]) || (t[i] = {});
      for (const e in n) Ta(t[i], n, e);
    } else t[i] = n;
  }
  function Ca(t, e) {
    if (c(e) && t !== e) for (const i in e) Ta(t, e, i);
  }
  const Ea = { tolerance: 0.01 },
    Pa = (t, e) => {
      const i = Ma(Ea, e),
        { tolerance: n } = i;
      return ka(t, n);
    };
  var Ra;
  !(function (t) {
    (t.DSV = 'dsv'),
      (t.TREE = 'tree'),
      (t.GEO = 'geo'),
      (t.BYTE = 'bytejson'),
      (t.HEX = 'hex'),
      (t.GRAPH = 'graph'),
      (t.TABLE = 'table'),
      (t.GEO_GRATICULE = 'geo-graticule');
  })(Ra || (Ra = {}));
  const Oa = (t, e) => {
    var i, n;
    if (!(null == e ? void 0 : e.fields)) return t;
    if (0 === t.length) return t;
    const s = e.fields,
      r = t[0],
      a = {},
      o = [];
    for (const e in s)
      if (Object.prototype.hasOwnProperty.call(s, e)) {
        const l = s[e];
        if (!l.type) {
          let n = r;
          e in r || (n = null !== (i = t.find(t => e in t)) && void 0 !== i ? i : r),
            (l.type = 'number' == typeof n[e] ? 'linear' : 'ordinal');
        }
        let h;
        if (
          ('number' == typeof l.sortIndex &&
            ((h = {
              key: e,
              type: l.type,
              index: l.sortIndex,
              sortIndex: {},
              sortIndexCount: 0,
              sortReverse: !0 === l.sortReverse
            }),
            o.push(h)),
          (null === (n = l.domain) || void 0 === n ? void 0 : n.length) > 0)
        )
          if ('ordinal' === l.type) {
            (l._domainCache = {}), (a[e] = l);
            const t = {};
            l.domain.forEach((e, i) => {
              (t[e] = i), (l._domainCache[e] = i);
            }),
              h && ((h.sortIndex = t), (h.sortIndexCount = l.domain.length));
          } else l.domain.length >= 2 && (a[e] = l);
      }
    return (
      Object.keys(a).length > 0 &&
        (t = t.filter(t => {
          for (const e in a) {
            const i = a[e];
            if ('ordinal' === i.type) {
              if (!(t[e] in i._domainCache)) return !1;
            } else if (i.domain[0] > t[e] || i.domain[1] < t[e]) return !1;
          }
          return !0;
        })),
      o.sort((t, e) => t.index - e.index),
      t.sort((t, e) =>
        (function (t, e, i) {
          for (let n = 0; n < i.length; n++) {
            const s = i[n];
            let r = 0;
            if (
              ('ordinal' === s.type
                ? (void 0 === s.sortIndex[e[s.key]] && (s.sortIndex[e[s.key]] = s.sortIndexCount++),
                  void 0 === s.sortIndex[t[s.key]] && (s.sortIndex[t[s.key]] = s.sortIndexCount++),
                  (r = s.sortIndex[t[s.key]] - s.sortIndex[e[s.key]]))
                : 'linear' === s.type && (r = t[s.key] - e[s.key]),
              s.sortReverse && (r = -r),
              0 !== r)
            )
              return r;
          }
          return 0;
        })(t, e, o)
      ),
      t
    );
  };
  var Ba = {},
    Ia = {};
  function Da(t) {
    return new Function(
      'd',
      'return {' +
        t
          .map(function (t, e) {
            return JSON.stringify(t) + ': d[' + e + '] || ""';
          })
          .join(',') +
        '}'
    );
  }
  function La(t) {
    var e = Object.create(null),
      i = [];
    return (
      t.forEach(function (t) {
        for (var n in t) n in e || i.push((e[n] = n));
      }),
      i
    );
  }
  function Fa(t, e) {
    var i = t + '',
      n = i.length;
    return n < e ? new Array(e - n + 1).join(0) + i : i;
  }
  function ja(t) {
    var e,
      i = t.getUTCHours(),
      n = t.getUTCMinutes(),
      s = t.getUTCSeconds(),
      r = t.getUTCMilliseconds();
    return isNaN(t)
      ? 'Invalid Date'
      : ((e = t.getUTCFullYear()) < 0 ? '-' + Fa(-e, 6) : e > 9999 ? '+' + Fa(e, 6) : Fa(e, 4)) +
          '-' +
          Fa(t.getUTCMonth() + 1, 2) +
          '-' +
          Fa(t.getUTCDate(), 2) +
          (r
            ? 'T' + Fa(i, 2) + ':' + Fa(n, 2) + ':' + Fa(s, 2) + '.' + Fa(r, 3) + 'Z'
            : s
            ? 'T' + Fa(i, 2) + ':' + Fa(n, 2) + ':' + Fa(s, 2) + 'Z'
            : n || i
            ? 'T' + Fa(i, 2) + ':' + Fa(n, 2) + 'Z'
            : '');
  }
  function za(t) {
    var e = new RegExp('["' + t + '\n\r]'),
      i = t.charCodeAt(0);
    function n(t, e) {
      var n,
        s = [],
        r = t.length,
        a = 0,
        o = 0,
        l = r <= 0,
        h = !1;
      function c() {
        if (l) return Ia;
        if (h) return (h = !1), Ba;
        var e,
          n,
          s = a;
        if (34 === t.charCodeAt(s)) {
          for (; (a++ < r && 34 !== t.charCodeAt(a)) || 34 === t.charCodeAt(++a); );
          return (
            (e = a) >= r
              ? (l = !0)
              : 10 === (n = t.charCodeAt(a++))
              ? (h = !0)
              : 13 === n && ((h = !0), 10 === t.charCodeAt(a) && ++a),
            t.slice(s + 1, e - 1).replace(/""/g, '"')
          );
        }
        for (; a < r; ) {
          if (10 === (n = t.charCodeAt((e = a++)))) h = !0;
          else if (13 === n) (h = !0), 10 === t.charCodeAt(a) && ++a;
          else if (n !== i) continue;
          return t.slice(s, e);
        }
        return (l = !0), t.slice(s, r);
      }
      for (10 === t.charCodeAt(r - 1) && --r, 13 === t.charCodeAt(r - 1) && --r; (n = c()) !== Ia; ) {
        for (var d = []; n !== Ba && n !== Ia; ) d.push(n), (n = c());
        (e && null == (d = e(d, o++))) || s.push(d);
      }
      return s;
    }
    function s(e, i) {
      return e.map(function (e) {
        return i
          .map(function (t) {
            return a(e[t]);
          })
          .join(t);
      });
    }
    function r(e) {
      return e.map(a).join(t);
    }
    function a(t) {
      return null == t ? '' : t instanceof Date ? ja(t) : e.test((t += '')) ? '"' + t.replace(/"/g, '""') + '"' : t;
    }
    return {
      parse: function (t, e) {
        var i,
          s,
          r = n(t, function (t, n) {
            if (i) return i(t, n - 1);
            (s = t),
              (i = e
                ? (function (t, e) {
                    var i = Da(t);
                    return function (n, s) {
                      return e(i(n), s, t);
                    };
                  })(t, e)
                : Da(t));
          });
        return (r.columns = s || []), r;
      },
      parseRows: n,
      format: function (e, i) {
        return null == i && (i = La(e)), [i.map(a).join(t)].concat(s(e, i)).join('\n');
      },
      formatBody: function (t, e) {
        return null == e && (e = La(t)), s(t, e).join('\n');
      },
      formatRows: function (t) {
        return t.map(r).join('\n');
      },
      formatRow: r,
      formatValue: a
    };
  }
  var Ha = za(',').parse,
    Na = za('\t').parse;
  const Va = { delimiter: ',' },
    Wa = function (t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      (arguments.length > 2 ? arguments[2] : void 0).type = Ra.DSV;
      const i = Ma(Va, e),
        { delimiter: n } = i;
      if (!g(n)) throw new TypeError('Invalid delimiter: must be a string!');
      return za(n).parse(t);
    },
    Ga = function (t) {
      return ((arguments.length > 2 ? arguments[2] : void 0).type = Ra.DSV), Ha(t);
    },
    Ua = function (t) {
      return ((arguments.length > 2 ? arguments[2] : void 0).type = Ra.DSV), Na(t);
    };
  function Ya(t) {
    if (!t) throw new Error('geojson is required');
    switch (t.type) {
      case 'Feature':
        return $a(t);
      case 'FeatureCollection':
        return (function (t) {
          var e = { type: 'FeatureCollection' };
          return (
            Object.keys(t).forEach(function (i) {
              switch (i) {
                case 'type':
                case 'features':
                  return;
                default:
                  e[i] = t[i];
              }
            }),
            (e.features = t.features.map(function (t) {
              return $a(t);
            })),
            e
          );
        })(t);
      case 'Point':
      case 'LineString':
      case 'Polygon':
      case 'MultiPoint':
      case 'MultiLineString':
      case 'MultiPolygon':
      case 'GeometryCollection':
        return Ka(t);
      default:
        throw new Error('unknown GeoJSON type');
    }
  }
  function $a(t) {
    var e = { type: 'Feature' };
    return (
      Object.keys(t).forEach(function (i) {
        switch (i) {
          case 'type':
          case 'properties':
          case 'geometry':
            return;
          default:
            e[i] = t[i];
        }
      }),
      (e.properties = Xa(t.properties)),
      (e.geometry = Ka(t.geometry)),
      e
    );
  }
  function Xa(t) {
    var e = {};
    return t
      ? (Object.keys(t).forEach(function (i) {
          var n = t[i];
          'object' == typeof n
            ? null === n
              ? (e[i] = null)
              : Array.isArray(n)
              ? (e[i] = n.map(function (t) {
                  return t;
                }))
              : (e[i] = Xa(n))
            : (e[i] = n);
        }),
        e)
      : e;
  }
  function Ka(t) {
    var e = { type: t.type };
    return (
      t.bbox && (e.bbox = t.bbox),
      'GeometryCollection' === t.type
        ? ((e.geometries = t.geometries.map(function (t) {
            return Ka(t);
          })),
          e)
        : ((e.coordinates = qa(t.coordinates)), e)
    );
  }
  function qa(t) {
    var e = t;
    return 'object' != typeof e[0]
      ? e.slice()
      : e.map(function (t) {
          return qa(t);
        });
  }
  function Za(t) {
    if (Array.isArray(t)) return t;
    if ('Feature' === t.type) {
      if (null !== t.geometry) return t.geometry.coordinates;
    } else if (t.coordinates) return t.coordinates;
    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');
  }
  function Ja(t) {
    for (var e, i, n = Za(t), s = 0, r = 1; r < n.length; )
      (e = i || n[0]), (s += ((i = n[r])[0] - e[0]) * (i[1] + e[1])), r++;
    return s > 0;
  }
  function Qa(t, e) {
    if ('Feature' === t.type) e(t, 0);
    else if ('FeatureCollection' === t.type) for (var i = 0; i < t.features.length && !1 !== e(t.features[i], i); i++);
  }
  function to(t, e) {
    var i,
      n,
      s,
      r,
      a,
      o,
      l,
      h,
      c,
      d,
      u = 0,
      p = 'FeatureCollection' === t.type,
      g = 'Feature' === t.type,
      f = p ? t.features.length : 1;
    for (i = 0; i < f; i++) {
      for (
        o = p ? t.features[i].geometry : g ? t.geometry : t,
          h = p ? t.features[i].properties : g ? t.properties : {},
          c = p ? t.features[i].bbox : g ? t.bbox : void 0,
          d = p ? t.features[i].id : g ? t.id : void 0,
          a = (l = !!o && 'GeometryCollection' === o.type) ? o.geometries.length : 1,
          s = 0;
        s < a;
        s++
      )
        if (null !== (r = l ? o.geometries[s] : o))
          switch (r.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon':
              if (!1 === e(r, u, h, c, d)) return !1;
              break;
            case 'GeometryCollection':
              for (n = 0; n < r.geometries.length; n++) if (!1 === e(r.geometries[n], u, h, c, d)) return !1;
              break;
            default:
              throw new Error('Unknown Geometry Type');
          }
        else if (!1 === e(null, u, h, c, d)) return !1;
      u++;
    }
  }
  function eo(t, e) {
    if (!(i = e = e || {}) || i.constructor !== Object) throw new Error('options is invalid');
    var i,
      n = e.reverse || !1,
      s = e.mutate || !1;
    if (!t) throw new Error('<geojson> is required');
    if ('boolean' != typeof n) throw new Error('<reverse> must be a boolean');
    if ('boolean' != typeof s) throw new Error('<mutate> must be a boolean');
    !1 === s && (t = Ya(t));
    var r = [];
    switch (t.type) {
      case 'GeometryCollection':
        return (
          to(t, function (t) {
            io(t, n);
          }),
          t
        );
      case 'FeatureCollection':
        return (
          Qa(t, function (t) {
            Qa(io(t, n), function (t) {
              r.push(t);
            });
          }),
          gn(r)
        );
    }
    return io(t, n);
  }
  function io(t, e) {
    switch ('Feature' === t.type ? t.geometry.type : t.type) {
      case 'GeometryCollection':
        return (
          to(t, function (t) {
            io(t, e);
          }),
          t
        );
      case 'LineString':
        return no(Za(t), e), t;
      case 'Polygon':
        return so(Za(t), e), t;
      case 'MultiLineString':
        return (
          Za(t).forEach(function (t) {
            no(t, e);
          }),
          t
        );
      case 'MultiPolygon':
        return (
          Za(t).forEach(function (t) {
            so(t, e);
          }),
          t
        );
      case 'Point':
      case 'MultiPoint':
        return t;
    }
  }
  function no(t, e) {
    Ja(t) === e && t.reverse();
  }
  function so(t, e) {
    Ja(t[0]) !== e && t[0].reverse();
    for (var i = 1; i < t.length; i++) Ja(t[i]) === e && t[i].reverse();
  }
  function ro(t) {
    if (!t) throw new Error('geojson is required');
    var e = [];
    return (
      (function (t, e) {
        to(t, function (t, i, n, s, r) {
          var a,
            o = null === t ? null : t.type;
          switch (o) {
            case null:
            case 'Point':
            case 'LineString':
            case 'Polygon':
              return !1 !== e(pn(t, n, { bbox: s, id: r }), i, 0) && void 0;
          }
          switch (o) {
            case 'MultiPoint':
              a = 'Point';
              break;
            case 'MultiLineString':
              a = 'LineString';
              break;
            case 'MultiPolygon':
              a = 'Polygon';
          }
          for (var l = 0; l < t.coordinates.length; l++) {
            var h = t.coordinates[l];
            if (!1 === e(pn({ type: a, coordinates: h }, n), i, l)) return !1;
          }
        });
      })(t, function (t) {
        e.push(t);
      }),
      gn(e)
    );
  }
  const ao = Rr(),
    oo = { centroid: !1, name: !1, bbox: !1, rewind: !1 },
    lo = t => {
      if (t.geometry.type.startsWith('Multi')) {
        const e = ro(t).features[0];
        return Object.assign(Object.assign({}, e), e.properties);
      }
      return Object.assign(Object.assign({}, t), t.properties);
    },
    ho = function (t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      (arguments.length > 2 ? arguments[2] : void 0).type = Ra.GEO;
      const i = Ma(oo, e),
        { centroid: n, name: s, bbox: r, rewind: a } = i;
      if (Array.isArray(t))
        return (t => {
          const e = [];
          return (
            t.forEach(t => {
              'FeatureCollection' === t.type
                ? t.features.forEach(t => {
                    e.push(lo(t));
                  })
                : e.push(lo(t));
            }),
            e
          );
        })(t);
      let o = t.features;
      return (
        a && (o = eo(t, { reverse: !c(a) || a.reverse }).features),
        o.forEach(t => {
          if (n) {
            const e = ao.centroid(t);
            (t.centroidX = e[0]), (t.centroidY = e[1]);
          }
          if ((s && (t.name = t.properties.name), r)) {
            const e = ao.bounds(t);
            t.bbox = e;
          }
        }),
        (t.features = o),
        t
      );
    },
    co = {},
    uo = (t, e, i) => {
      i.type = Ra.GEO;
      const n = Ma(oo, co, e),
        { object: s } = n;
      if (!g(s)) throw new TypeError('Invalid object: must be a string!');
      const r =
        ((a = t),
        'string' == typeof (o = t.objects[s]) && (o = a.objects[o]),
        'GeometryCollection' === o.type
          ? {
              type: 'FeatureCollection',
              features: o.geometries.map(function (t) {
                return _a(a, t);
              })
            }
          : _a(a, o));
      var a, o;
      return ho(r, n, i);
    },
    po = (t, e, i) => {
      const n = !a(null == e ? void 0 : e.dependencyUpdate) || (null == e ? void 0 : e.dependencyUpdate);
      if (!t || !f(t)) throw new TypeError('Invalid data: must be DataView array!');
      return (
        f(i.rawData) &&
          i.rawData.forEach(t => {
            t.target &&
              (t.target.removeListener('change', i.reRunAllTransform),
              t.target.removeListener('markRunning', i.markRunning));
          }),
        n &&
          t.forEach(t => {
            t.target.addListener('change', i.reRunAllTransform), t.target.addListener('markRunning', i.markRunning);
          }),
        t
      );
    };
  let go = 0;
  function fo() {
    return (
      go > 1e8 && (go = 0), (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'dataset') + '_' + go++
    );
  }
  class vo {
    constructor(t) {
      let e;
      (this.options = t),
        (this.isDataSet = !0),
        (this.transformMap = {}),
        (this.parserMap = {}),
        (this.dataViewMap = {}),
        (this.target = new s()),
        (this._callMap = new Map()),
        (e = (null == t ? void 0 : t.name) ? t.name : fo('dataset')),
        (this.name = e);
    }
    getDataView(t) {
      return this.dataViewMap[t];
    }
    setDataView(t, e) {
      if (this.dataViewMap[t]) throw new Error(`Error: dataView ${t} 之前已存在，请重新命名`);
      this.dataViewMap[t] = e;
    }
    removeDataView(t) {
      (this.dataViewMap[t] = null), delete this.dataViewMap[t];
    }
    registerParser(t, e) {
      this.parserMap[t] && console.warn(`Warn: transform ${t} 之前已注册，执行覆盖逻辑`), (this.parserMap[t] = e);
    }
    removeParser(t) {
      (this.parserMap[t] = null), delete this.parserMap[t];
    }
    getParser(t) {
      return this.parserMap[t] || this.parserMap.default;
    }
    registerTransform(t, e) {
      this.transformMap[t] && console.warn(`Warn: transform ${t} 之前已注册，执行覆盖逻辑`), (this.transformMap[t] = e);
    }
    removeTransform(t) {
      (this.transformMap[t] = null), delete this.transformMap[t];
    }
    getTransform(t) {
      return this.transformMap[t];
    }
    multipleDataViewAddListener(t, e, i) {
      let n = this._callMap.get(i);
      n ||
        (n = () => {
          t.some(t => t.isRunning) || i();
        }),
        t.forEach(t => {
          t.target.addListener(e, n);
        }),
        this._callMap.set(i, n);
    }
    allDataViewAddListener(t, e) {
      this.multipleDataViewAddListener(Object.values(this.dataViewMap), t, e);
    }
    multipleDataViewRemoveListener(t, e, i) {
      const n = this._callMap.get(i);
      n &&
        t.forEach(t => {
          t.target.removeListener(e, n);
        }),
        this._callMap.delete(i);
    }
    multipleDataViewUpdateInParse(t) {
      t.forEach(t => {
        var e;
        return null === (e = this.getDataView(t.name)) || void 0 === e ? void 0 : e.markRunning();
      }),
        t.forEach(t => {
          var e;
          return null === (e = this.getDataView(t.name)) || void 0 === e ? void 0 : e.parseNewData(t.data, t.options);
        });
    }
    multipleDataViewUpdateInRawData(t) {
      t.forEach(t => {
        var e;
        return null === (e = this.getDataView(t.name)) || void 0 === e ? void 0 : e.markRunning();
      }),
        t.forEach(t => {
          var e;
          return null === (e = this.getDataView(t.name)) || void 0 === e ? void 0 : e.updateRawData(t.data, t.options);
        });
    }
    destroy() {
      (this.transformMap = null),
        (this.parserMap = null),
        (this.dataViewMap = null),
        (this._callMap = null),
        this.target.removeAllListeners();
    }
  }
  const mo = '_data-view-diff-rank';
  class yo {
    constructor(t, e) {
      var i = this;
      let n;
      (this.dataSet = t),
        (this.options = e),
        (this.isDataView = !0),
        (this.target = new s()),
        (this.parseOption = null),
        (this.transformsArr = []),
        (this.isRunning = !1),
        (this.rawData = {}),
        (this.history = !1),
        (this.historyData = []),
        (this.parserData = {}),
        (this.latestData = {}),
        (this._fields = null),
        (this._diffData = !1),
        (this._diffKeys = null),
        (this._diffMap = new Map()),
        (this._diffRank = 0),
        (this.reRunAllTransform = function () {
          let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { pushHistory: !0, emitMessage: !0 };
          return (
            (i.isRunning = !0),
            i.resetTransformData(),
            i.transformsArr.forEach(e => {
              i.executeTransform(e, Object.assign(Object.assign({}, t), { emitMessage: !1 })),
                i.isLastTransform(e) && i.diffLastData();
            }),
            (i.isRunning = !1),
            !1 !== (null == t ? void 0 : t.emitMessage) && i.target.emit('change', []),
            i
          );
        }),
        (this.markRunning = () => {
          (this.isRunning = !0), this.target.emit('markRunning', []);
        }),
        (n = (null == e ? void 0 : e.name) ? e.name : fo('dataview')),
        (this.name = n),
        (null == e ? void 0 : e.history) && (this.history = e.history),
        this.dataSet.setDataView(n, this),
        this.setFields(null == e ? void 0 : e.fields);
    }
    parse(t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      var n;
      (this.isRunning = !0), i && this.target.emit('beforeParse', []), e && (this.parseOption = e);
      const s = this.cloneParseData(t, e);
      if (null == e ? void 0 : e.type) {
        e = R(e);
        const t = (
          null !== (n = this.dataSet.getParser(e.type)) && void 0 !== n ? n : this.dataSet.getParser('bytejson')
        )(s, e.options, this);
        (this.rawData = s), (this.parserData = t), this.history && this.historyData.push(s, t), (this.latestData = t);
      } else (this.parserData = s), (this.rawData = s), this.history && this.historyData.push(s), (this.latestData = s);
      return (this.isRunning = !1), i && this.target.emit('afterParse', []), this;
    }
    transform(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      if (((this.isRunning = !0), t && t.type)) {
        let i = !0;
        if ('fields' === t.type) {
          this._fields = t.options.fields;
          const e = this.transformsArr.findIndex(e => e.type === t.type);
          e >= 0 && ((i = !1), (this.transformsArr[e].options.fields = this._fields));
        }
        if ((i && this.transformsArr.push(t), e)) {
          const e = this.isLastTransform(t);
          (t = R(t)), this.executeTransform(t), e && this.diffLastData();
        }
      }
      return this.sortTransform(), (this.isRunning = !1), this;
    }
    isLastTransform(t) {
      return this.transformsArr[this.transformsArr.length - 1] === t;
    }
    sortTransform() {
      this.transformsArr.sort((t, e) => {
        var i, n;
        return (null !== (i = t.level) && void 0 !== i ? i : 0) - (null !== (n = e.level) && void 0 !== n ? n : 0);
      });
    }
    executeTransform(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { pushHistory: !0, emitMessage: !0 };
      const { pushHistory: i, emitMessage: n } = e,
        s = this.dataSet.getTransform(t.type)(this.latestData, t.options);
      this.history && !1 !== i && this.historyData.push(s),
        (this.latestData = s),
        !1 !== n && this.target.emit('change', []);
    }
    resetTransformData() {
      (this.latestData = this.parserData),
        this.history && ((this.historyData.length = 0), this.historyData.push(this.rawData, this.parserData));
    }
    enableDiff(t) {
      (this._diffData = !0), (this._diffKeys = t);
    }
    disableDiff() {
      (this._diffData = !1), this.resetDiff();
    }
    resetDiff() {
      (this._diffMap = new Map()), (this._diffRank = 0);
    }
    diffLastData() {
      var t;
      if (!this._diffData) return;
      if (!this.latestData.forEach) return;
      if (!(null === (t = this._diffKeys) || void 0 === t ? void 0 : t.length)) return;
      const e = this._diffRank + 1;
      if (0 === this._diffRank)
        this.latestData.forEach(t => {
          (t[mo] = e),
            this._diffMap.set(
              this._diffKeys.reduce((e, i) => e + t[i], ''),
              t
            );
        }),
          (this.latestDataAUD = { add: Array.from(this.latestData), del: [], update: [] });
      else {
        let t;
        (this.latestDataAUD = { add: [], del: [], update: [] }),
          this.latestData.forEach(i => {
            (i[mo] = e),
              (t = this._diffKeys.reduce((t, e) => t + i[e], '')),
              this._diffMap.get(t) ? this.latestDataAUD.update.push(i) : this.latestDataAUD.add.push(i),
              this._diffMap.set(t, i);
          }),
          this._diffMap.forEach((t, i) => {
            t[mo] < e && (this.latestDataAUD.del.push(t), this._diffMap.delete(i));
          });
      }
      this._diffRank = e;
    }
    cloneParseData(t, e) {
      let i = !1;
      return t instanceof yo || !0 !== (null == e ? void 0 : e.clone) || (i = !0), i ? R(t) : t;
    }
    parseNewData(t, e) {
      this.parse(t, e || this.parseOption), this.reRunAllTransform();
    }
    updateRawData(t, e) {
      const i = this.cloneParseData(t, e);
      (this.rawData = i), (this.parserData = i), (this.latestData = i), this.reRunAllTransform();
    }
    getFields() {
      var t;
      return this._fields
        ? this._fields
        : 'dataview' === (null === (t = this.parseOption) || void 0 === t ? void 0 : t.type) &&
          1 === this.rawData.length &&
          this.rawData[0].getFields
        ? this.rawData[0].getFields()
        : null;
    }
    setFields(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      this._fields = t && e ? D({}, this._fields, t) : t;
      const i = this.transformsArr.find(t => 'fields' === t.type);
      !l(this._fields) && l(i)
        ? (this.dataSet.registerTransform('fields', Oa),
          this.transform({ type: 'fields', options: { fields: this._fields } }, !1))
        : i && (i.options.fields = this._fields);
    }
    destroy() {
      this.dataSet.removeDataView(this.name),
        this.resetDiff(),
        (this.latestData = null),
        (this.rawData = null),
        (this.parserData = null),
        (this.transformsArr = null),
        (this.target = null);
    }
  }
  class _o {
    static getInstance() {
      return _o.instance || (_o.instance = new _o()), _o.instance;
    }
    constructor() {
      (this.locale_shortWeekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']),
        (this.locale_periods = ['AM', 'PM']),
        (this.locale_weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']),
        (this.locale_shortMonths = [
          'Jan',
          'Feb',
          'Mar',
          'Apr',
          'May',
          'Jun',
          'Jul',
          'Aug',
          'Sep',
          'Oct',
          'Nov',
          'Dec'
        ]),
        (this.numberRe = /^\s*\d+/),
        (this.pads = { '-': '', _: ' ', 0: '0' }),
        (this.requoteRe = /[\\^$*+?|[\]().{}]/g),
        (this.locale_months = [
          'January',
          'February',
          'March',
          'April',
          'May',
          'June',
          'July',
          'August',
          'September',
          'October',
          'November',
          'December'
        ]),
        (this.formatShortWeekday = t => this.locale_shortWeekdays[t.getDay()]),
        (this.formatWeekday = t => this.locale_weekdays[t.getDay()]),
        (this.formatShortMonth = t => this.locale_shortMonths[t.getMonth()]),
        (this.formatMonth = t => this.locale_months[t.getMonth()]),
        (this.formatDayOfMonth = (t, e) => this.pad(t.getDate(), e, 2)),
        (this.formatHour24 = (t, e) => this.pad(t.getHours(), e, 2)),
        (this.formatHour12 = (t, e) => this.pad(t.getHours() % 12 || 12, e, 2)),
        (this.formatMilliseconds = (t, e) => this.pad(t.getMilliseconds(), e, 3)),
        (this.formatMonthNumber = (t, e) => this.pad(t.getMonth() + 1, e, 2)),
        (this.formatMinutes = (t, e) => this.pad(t.getMinutes(), e, 2)),
        (this.formatPeriod = t => this.locale_periods[+(t.getHours() >= 12)]),
        (this.formatSeconds = (t, e) => this.pad(t.getSeconds(), e, 2)),
        (this.formatFullYear = (t, e) => this.pad(t.getFullYear() % 1e4, e, 4)),
        (this.formatUTCShortWeekday = t => this.locale_shortWeekdays[t.getUTCDay()]),
        (this.formatUTCWeekday = t => this.locale_weekdays[t.getUTCDay()]),
        (this.formatUTCShortMonth = t => this.locale_shortMonths[t.getUTCMonth()]),
        (this.formatUTCMonth = t => this.locale_months[t.getUTCMonth()]),
        (this.formatUTCDayOfMonth = (t, e) => this.pad(t.getUTCDate(), e, 2)),
        (this.formatUTCHour24 = (t, e) => this.pad(t.getUTCHours(), e, 2)),
        (this.formatUTCHour12 = (t, e) => this.pad(t.getUTCHours() % 12 || 12, e, 2)),
        (this.formatUTCMilliseconds = (t, e) => this.pad(t.getUTCMilliseconds(), e, 3)),
        (this.formatUTCMonthNumber = (t, e) => this.pad(t.getUTCMonth() + 1, e, 2)),
        (this.formatUTCMinutes = (t, e) => this.pad(t.getUTCMinutes(), e, 2)),
        (this.formatUTCPeriod = t => this.locale_periods[+(t.getUTCHours() >= 12)]),
        (this.formatUTCSeconds = (t, e) => this.pad(t.getUTCSeconds(), e, 2)),
        (this.formatUTCFullYear = (t, e) => this.pad(t.getUTCFullYear() % 1e4, e, 4)),
        (this.formats = {
          a: this.formatShortWeekday,
          A: this.formatWeekday,
          b: this.formatShortMonth,
          B: this.formatMonth,
          d: this.formatDayOfMonth,
          e: this.formatDayOfMonth,
          H: this.formatHour24,
          I: this.formatHour12,
          L: this.formatMilliseconds,
          m: this.formatMonthNumber,
          M: this.formatMinutes,
          p: this.formatPeriod,
          S: this.formatSeconds,
          Y: this.formatFullYear
        }),
        (this.utcFormats = {
          a: this.formatUTCShortWeekday,
          A: this.formatUTCWeekday,
          b: this.formatUTCShortMonth,
          B: this.formatUTCMonth,
          d: this.formatUTCDayOfMonth,
          e: this.formatUTCDayOfMonth,
          H: this.formatUTCHour24,
          I: this.formatUTCHour12,
          L: this.formatUTCMilliseconds,
          m: this.formatUTCMonthNumber,
          M: this.formatUTCMinutes,
          p: this.formatUTCPeriod,
          S: this.formatUTCSeconds,
          Y: this.formatUTCFullYear
        }),
        (this.parseShortWeekday = (t, e, i) => {
          const n = this.shortWeekdayRe.exec(e.slice(i));
          return n ? ((t.w = this.shortWeekdayLookup.get(n[0].toLowerCase())), i + n[0].length) : -1;
        }),
        (this.parseWeekday = (t, e, i) => {
          const n = this.weekdayRe.exec(e.slice(i));
          return n ? ((t.w = this.weekdayLookup.get(n[0].toLowerCase())), i + n[0].length) : -1;
        }),
        (this.parseShortMonth = (t, e, i) => {
          const n = this.shortMonthRe.exec(e.slice(i));
          return n ? ((t.m = this.shortMonthLookup.get(n[0].toLowerCase())), i + n[0].length) : -1;
        }),
        (this.parseMonth = (t, e, i) => {
          const n = this.monthRe.exec(e.slice(i));
          return n ? ((t.m = this.monthLookup.get(n[0].toLowerCase())), i + n[0].length) : -1;
        }),
        (this.parseDayOfMonth = (t, e, i) => {
          const n = this.numberRe.exec(e.slice(i, i + 2));
          return n ? ((t.d = +n[0]), i + n[0].length) : -1;
        }),
        (this.parseHour24 = (t, e, i) => {
          const n = this.numberRe.exec(e.slice(i, i + 2));
          return n ? ((t.H = +n[0]), i + n[0].length) : -1;
        }),
        (this.parseMilliseconds = (t, e, i) => {
          const n = this.numberRe.exec(e.slice(i, i + 3));
          return n ? ((t.L = +n[0]), i + n[0].length) : -1;
        }),
        (this.parseMonthNumber = (t, e, i) => {
          const n = this.numberRe.exec(e.slice(i, i + 2));
          return n ? ((t.m = n - 1), i + n[0].length) : -1;
        }),
        (this.parseMinutes = (t, e, i) => {
          const n = this.numberRe.exec(e.slice(i, i + 2));
          return n ? ((t.M = +n[0]), i + n[0].length) : -1;
        }),
        (this.parsePeriod = (t, e, i) => {
          const n = this.periodRe.exec(e.slice(i));
          return n ? ((t.p = this.periodLookup.get(n[0].toLowerCase())), i + n[0].length) : -1;
        }),
        (this.parseSeconds = (t, e, i) => {
          const n = this.numberRe.exec(e.slice(i, i + 2));
          return n ? ((t.S = +n[0]), i + n[0].length) : -1;
        }),
        (this.parseFullYear = (t, e, i) => {
          const n = this.numberRe.exec(e.slice(i, i + 4));
          return n ? ((t.y = +n[0]), i + n[0].length) : -1;
        }),
        (this.parses = {
          a: this.parseShortWeekday,
          A: this.parseWeekday,
          b: this.parseShortMonth,
          B: this.parseMonth,
          d: this.parseDayOfMonth,
          e: this.parseDayOfMonth,
          H: this.parseHour24,
          I: this.parseHour24,
          L: this.parseMilliseconds,
          m: this.parseMonthNumber,
          M: this.parseMinutes,
          p: this.parsePeriod,
          S: this.parseSeconds,
          Y: this.parseFullYear
        }),
        (this.timeFormat = (t, e) => this.newFormat(t, this.formats)(new Date(this.getFullTimeStamp(e)))),
        (this.timeUTCFormat = (t, e) => this.newFormat(t, this.utcFormats)(new Date(this.getFullTimeStamp(e)))),
        (this.timeParse = (t, e) => this.newParse(t, !1)(e + '')),
        (this.requoteF = this.requote.bind(this)),
        (this.periodRe = this.formatRe(this.locale_periods)),
        (this.periodLookup = this.formatLookup(this.locale_periods)),
        (this.weekdayRe = this.formatRe(this.locale_weekdays)),
        (this.weekdayLookup = this.formatLookup(this.locale_weekdays)),
        (this.shortWeekdayRe = this.formatRe(this.locale_shortWeekdays)),
        (this.shortWeekdayLookup = this.formatLookup(this.locale_shortWeekdays)),
        (this.monthRe = this.formatRe(this.locale_months)),
        (this.monthLookup = this.formatLookup(this.locale_months)),
        (this.shortMonthRe = this.formatRe(this.locale_shortMonths)),
        (this.shortMonthLookup = this.formatLookup(this.locale_shortMonths));
    }
    requote(t) {
      return t.replace(this.requoteRe, '\\$&');
    }
    localDate(t) {
      if (0 <= t.y && t.y < 100) {
        const e = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L);
        return e.setFullYear(t.y), e;
      }
      return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L);
    }
    utcDate(t) {
      if (0 <= t.y && t.y < 100) {
        const e = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L));
        return e.setUTCFullYear(t.y), e;
      }
      return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L));
    }
    newDate(t, e, i) {
      return { y: t, m: e, d: i, H: 0, M: 0, S: 0, L: 0 };
    }
    formatRe(t) {
      return new RegExp('^(?:' + t.map(this.requoteF).join('|') + ')', 'i');
    }
    formatLookup(t) {
      return new Map(t.map((t, e) => [t.toLowerCase(), e]));
    }
    pad(t, e, i) {
      const n = t < 0 ? '-' : '',
        s = (n ? -t : t) + '',
        r = s.length;
      return n + (r < i ? new Array(i - r + 1).join(e) + s : s);
    }
    parseSpecifier(t, e, i, n) {
      let s = 0;
      const r = e.length,
        a = i.length;
      let o, l;
      for (; s < r; ) {
        if (n >= a) return -1;
        if (((o = e.charCodeAt(s++)), 37 === o)) {
          if (((o = e.charAt(s++)), (l = this.parses[o in this.pads ? e.charAt(s++) : o]), !l || (n = l(t, i, n)) < 0))
            return -1;
        } else if (o !== i.charCodeAt(n++)) return -1;
      }
      return n;
    }
    newParse(t, e) {
      const i = this;
      return function (n) {
        const s = i.newDate(1900, void 0, 1);
        return i.parseSpecifier(s, t, (n += ''), 0) !== n.length
          ? null
          : 'Q' in s
          ? new Date(s.Q)
          : 's' in s
          ? new Date(1e3 * s.s + ('L' in s ? s.L : 0))
          : (e && !('Z' in s) && (s.Z = 0),
            'p' in s && (s.H = (s.H % 12) + 12 * s.p),
            void 0 === s.m && (s.m = 'q' in s ? s.q : 0),
            'Z' in s ? ((s.H += (s.Z / 100) | 0), (s.M += s.Z % 100), i.utcDate(s)) : i.localDate(s));
      };
    }
    newFormat(t, e) {
      const i = this;
      return function (n) {
        const s = [];
        let r = -1,
          a = 0;
        const o = t.length;
        let l, h, c;
        for (n instanceof Date || (n = new Date(+n)); ++r < o; )
          37 === t.charCodeAt(r) &&
            (s.push(t.slice(a, r)),
            (h = i.pads[(l = t.charAt(++r))]) ? (l = t.charAt(++r)) : (h = 'e' === l ? ' ' : '0'),
            (c = e[l]),
            (l = c(n, h)),
            s.push(l),
            (a = r + 1));
        return s.push(t.slice(a, r)), s.join('');
      };
    }
    getFullTimeStamp(t) {
      const e = parseInt(t + '', 10);
      return 10 === String(e).length ? 1e3 * e : e;
    }
  }
  function bo(t, e) {
    const i = new Set(V(t)),
      n = new Set(V(e));
    if (i.size !== n.size) return !1;
    for (const t of i.values()) if (!n.has(t)) return !1;
    return !0;
  }
  const { Color: xo } = ve,
    So = (t, e) => (
      o(Ao.warnHandler) && Ao.warnHandler.call(null, t, e),
      e ? Ze.getInstance().warn(`[VChart warn]: ${t}`, e) : Ze.getInstance().warn(`[VChart warn]: ${t}`)
    ),
    wo = (t, e, i) => {
      if (!o(Ao.errorHandler)) throw new Error(t);
      Ao.errorHandler.call(null, t, e);
    },
    Ao = { silent: !1, warnHandler: !1, errorHandler: !1 },
    ko = 'undefined' != typeof window && void 0 !== window.document,
    Mo = ko ? globalThis.document : void 0;
  function To(t) {
    return ('desktop-browser' === t || 'mobile-browser' === t) && ko;
  }
  function Co(t) {
    return 'miniApp' === t || 'mobile-browser' === t;
  }
  function Eo(t) {
    return t.includes('miniApp') || 'lynx' === t || 'wx' === t;
  }
  let Po = 0;
  function Ro() {
    return Po >= 9999999 && (Po = 0), Po++;
  }
  function Oo(t) {
    return !l(t) && (!!y(t) || +t == +t);
  }
  function Bo(t) {
    return !(!t || 0 === t.length) && !l(t[0]) && !l(t[0].dataId) && f(t[0].fields);
  }
  const Io = (t, e, i) => ((t.fields = e || []), (t.fname = i), t);
  const Do = t => e => C(e, t),
    Lo = t => {
      Ze.getInstance().error(t);
    },
    Fo = function (t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      if (o(t)) return t;
      const n = (t => {
          const e = [],
            i = t.length;
          let n,
            s,
            r,
            a = null,
            o = 0,
            l = '';
          t += '';
          const h = () => {
            e.push(l + t.substring(n, s)), (l = ''), (n = s + 1);
          };
          for (n = 0, s = 0; s < i; s += 1)
            if (((r = t[s]), '\\' === r)) (l += t.substring(n, s)), (l += t.substring(++s, ++s)), (n = s);
            else if (r === a) h(), (a = null), (o = -1);
            else {
              if (a) continue;
              (n === o && '"' === r) || (n === o && "'" === r)
                ? ((n = s + 1), (a = r))
                : '.' !== r || o
                ? '[' === r
                  ? (s > n && h(), (n = s + 1), (o = n))
                  : ']' === r && (o || Lo('Access path missing open bracket: ' + t), o > 0 && h(), (o = 0), (n = s + 1))
                : s > n
                ? h()
                : (n = s + 1);
            }
          return (
            o && Lo('Access path missing closing bracket: ' + t),
            a && Lo('Access path missing closing quote: ' + t),
            s > n && ((s += 1), h()),
            e
          );
        })(t),
        s = 1 === n.length ? n[0] : t;
      return Io(((i && i.get) || Do)(n), [s], e || s);
    },
    jo = function (t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      if (f(t)) {
        const n = t.map(t => Fo(t, e, i));
        return t => n.map(e => e(t));
      }
      return Fo(t, e, i);
    };
  jo('id');
  const zo = Io(
      function (t) {
        return t;
      },
      [],
      'identity'
    ),
    Ho = Io(
      function () {
        return 0;
      },
      [],
      'zero'
    );
  Io(
    function () {
      return 1;
    },
    [],
    'one'
  ),
    Io(
      function () {
        return !0;
      },
      [],
      'true'
    ),
    Io(
      function () {
        return !1;
      },
      [],
      'false'
    ),
    Io(
      function () {
        return {};
      },
      [],
      'emptyObject'
    );
  const No = (t, e) => {
      if ((t < e || l(t)) && !l(e)) return -1;
      if ((t > e || l(e)) && !l(t)) return 1;
      const i = e instanceof Date ? +e : e,
        n = t instanceof Date ? +t : t;
      return Number.isNaN(n) && !Number.isNaN(i) ? -1 : Number.isNaN(i) && !Number.isNaN(n) ? 1 : 0;
    },
    Vo = (t, e) => {
      return 1 === t.length
        ? ((i = t[0]), (n = e[0]), (t, e) => No(i(t), i(e)) * n)
        : ((t, e, i) => (
            e.push(0),
            (n, s) => {
              let r,
                a = 0,
                o = -1;
              for (; 0 === a && o + 1 < i; ) (o += 1), (r = t[o]), (a = No(r(n), r(s)));
              return a * e[o];
            }
          ))(t, e, t.length);
      var i, n;
    },
    Wo = function (t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      const n = V(e) || [],
        s = [],
        r = [],
        a = {},
        h = i.comparator || Vo;
      return (
        V(t).forEach((t, e) => {
          if (l(t)) return;
          s.push('desc' === n[e] ? -1 : 1);
          const h = o(t) ? t : jo(t, null, i);
          var c;
          r.push(h),
            ((c = h), (l(c) ? null : c.fields) || []).forEach(t => {
              a[t] = 1;
            });
        }),
        0 === r.length ? null : Io(h(r, s), Object.keys(a))
      );
    },
    Go = (t, e) => {
      const i = o(e) ? e : t => t;
      let n, s;
      if (t && t.length) {
        const e = t.length;
        for (let r = 0; r < e; r += 1) {
          let e = i(t[r]);
          l(e) ||
            !y((e = +e)) ||
            Number.isNaN(e) ||
            (l(n) ? ((n = e), (s = e)) : ((n = Math.min(n, e)), (s = Math.max(s, e))));
        }
        return [n, s];
      }
      return [n, s];
    },
    Uo = function (t, e, i) {
      let n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      if (e === i) return !0;
      if (l(e) || l(i)) return l(e) && l(i);
      if (!d(e) && !d(i)) return e === i;
      const s = f(e) ? e : e[t],
        r = f(i) ? i : i[t];
      return (
        s === r ||
        (!1 !== n &&
          (f(r)
            ? !(!f(s) || r.length !== s.length || !r.every((t, e) => t === s[e]))
            : !!c(r) &&
              !(!c(s) || Object.keys(r).length !== Object.keys(s).length || !Object.keys(r).every(t => Uo(t, r, s)))))
      );
    },
    Yo = (t, e) => (l(t) ? e : g(t) ? (e * parseFloat(t)) / 100 : t);
  function $o(t, e, i, n) {
    let s,
      r,
      a = -1;
    t.forEach(t => {
      (s = e(t)), (r = i(t)), !l(s) && (s = +s) >= s && !l(r) && (r = +r) >= r && n(s, r, ++a);
    });
  }
  function Xo(t, e, i, n, s) {
    let r = 0,
      a = 0;
    return (
      $o(t, e, i, (t, e) => {
        const i = e - s(t),
          o = e - n;
        (r += i * i), (a += o * o);
      }),
      1 - r / a
    );
  }
  function Ko(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t => t.x,
      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t => t.y,
      n = 0,
      s = 0,
      r = 0,
      a = 0,
      o = 0;
    $o(t, e, i, (t, e) => {
      ++o, (n += (t - n) / o), (s += (e - s) / o), (r += (t * e - r) / o), (a += (t * t - a) / o);
    });
    const l = (function (t, e, i, n) {
        const s = n - t * t,
          r = Math.abs(s) < 1e-24 ? 0 : (i - t * e) / s;
        return [e - r * t, r];
      })(n, s, r, a),
      h = t => l[0] + l[1] * t;
    return { coef: l, predict: h, rSquared: Xo(t, e, i, s, h) };
  }
  var qo;
  function Zo(t) {
    switch (t) {
      case qo.Linear:
      case qo.Log:
      case qo.Pow:
      case qo.Sqrt:
      case qo.Symlog:
      case qo.Time:
        return !0;
      default:
        return !1;
    }
  }
  function Jo(t) {
    switch (t) {
      case qo.Linear:
      case qo.Log:
      case qo.Pow:
      case qo.Sqrt:
      case qo.Symlog:
      case qo.Time:
      case qo.Ordinal:
      case qo.Point:
      case qo.Band:
        return !0;
      default:
        return !1;
    }
  }
  function Qo(t) {
    switch (t) {
      case qo.Ordinal:
      case qo.Point:
      case qo.Band:
        return !0;
      default:
        return !1;
    }
  }
  !(function (t) {
    (t.Identity = 'identity'),
      (t.Linear = 'linear'),
      (t.Log = 'log'),
      (t.Pow = 'pow'),
      (t.Sqrt = 'sqrt'),
      (t.Symlog = 'symlog'),
      (t.Time = 'time'),
      (t.Quantile = 'quantile'),
      (t.Quantize = 'quantize'),
      (t.Threshold = 'threshold'),
      (t.Ordinal = 'ordinal'),
      (t.Point = 'point'),
      (t.Band = 'band');
  })(qo || (qo = {}));
  class tl {
    _calculateWholeRange(t) {
      if (this._wholeRange) return this._wholeRange;
      if (this._rangeFactor && 2 === t.length) {
        const e = (t[1] - t[0]) / (this._rangeFactor[1] - this._rangeFactor[0]),
          i = t[0] - e * this._rangeFactor[0],
          n = i,
          s = e + i;
        return (this._wholeRange = [n, s]), this._wholeRange;
      }
      return t;
    }
    rangeFactor(t, e) {
      return t
        ? (2 === t.length && t.every(t => t >= 0 && t <= 1) && ((this._wholeRange = null), (this._rangeFactor = t)),
          this)
        : this._rangeFactor;
    }
    unknown(t) {
      return arguments.length ? ((this._unknown = t), this) : this._unknown;
    }
  }
  const el = Symbol('implicit');
  class il extends tl {
    specified(t) {
      var e;
      return t
        ? ((this._specified = Object.assign(null !== (e = this._specified) && void 0 !== e ? e : {}, t)), this)
        : Object.assign({}, this._specified);
    }
    _getSpecifiedValue(t) {
      if (this._specified) return this._specified[t];
    }
    constructor() {
      super(),
        (this.type = qo.Ordinal),
        (this._index = new Map()),
        (this._domain = []),
        (this._ordinalRange = []),
        (this._unknown = el);
    }
    clone() {
      return new il().domain(this._domain).range(this._ordinalRange).unknown(this._unknown);
    }
    calculateVisibleDomain(t) {
      return this._rangeFactor && 2 === t.length ? [this.invert(t[0]), this.invert(t[1])] : this._domain;
    }
    scale(t) {
      const e = `${t}`,
        i = this._getSpecifiedValue(e);
      if (void 0 !== i) return i;
      let n = this._index.get(e);
      if (!n) {
        if (this._unknown !== el) return this._unknown;
        (n = this._domain.push(t)), this._index.set(e, n);
      }
      return this._ordinalRange[(n - 1) % this._ordinalRange.length];
    }
    invert(t) {
      let e = 0;
      for (; e < this._ordinalRange.length && this._ordinalRange[e] !== t; ) e++;
      return this._domain[(e - 1) % this._domain.length];
    }
    domain(t) {
      if (!t) return this._domain.slice();
      (this._domain = []), (this._index = new Map());
      for (const e of t) {
        const t = `${e}`;
        this._index.has(t) || this._index.set(t, this._domain.push(e));
      }
      return this;
    }
    range(t) {
      if (!t) return this._ordinalRange.slice();
      const e = Array.from(t);
      return (this._ordinalRange = e), this;
    }
  }
  function nl(t) {
    return t;
  }
  const sl = t => e => e < 0 ? -Math.pow(-e, t) : Math.pow(e, t),
    rl = t => (t < 0 ? -Math.sqrt(-t) : Math.sqrt(t)),
    al = t => (t < 0 ? -t * t : t * t),
    ol = t => -Math.log(-t),
    ll = t => -Math.exp(-t),
    hl = t => (isFinite(t) ? Math.pow(10, t) : t < 0 ? 0 : t),
    cl = t => (10 === t ? hl : t === Math.E ? Math.exp : e => Math.pow(t, e)),
    dl = t =>
      t === Math.E ? Math.log : 10 === t ? Math.log10 : 2 === t ? Math.log2 : ((t = Math.log(t)), e => Math.log(e) / t),
    ul = t => e => Math.sign(e) * Math.log1p(Math.abs(e / t)),
    pl = t => e => Math.sign(e) * Math.expm1(Math.abs(e)) * t;
  function gl(t, e) {
    if (((t = Number(t)), (e = Number(e)), (e -= t))) return i => (i - t) / e;
    const i = Number.isNaN(e) ? NaN : 0.5;
    return () => i;
  }
  function fl(t, e, i) {
    const n = t[0],
      s = t[1],
      r = e[0],
      a = e[1];
    let o, l;
    return s < n ? ((o = gl(s, n)), (l = i(a, r))) : ((o = gl(n, s)), (l = i(r, a))), t => l(o(t));
  }
  function vl(t, e, i) {
    let n;
    return (n = 1 === t ? t + 2 * i : t - e + 2 * i), t ? (n > 0 ? n : 1) : 0;
  }
  function ml(t, e, i) {
    const n = Math.min(t.length, e.length) - 1,
      s = new Array(n),
      r = new Array(n);
    let a = -1;
    for (t[n] < t[0] && ((t = t.slice().reverse()), (e = e.slice().reverse())); ++a < n; )
      (s[a] = gl(t[a], t[a + 1])), (r[a] = i(e[a], e[a + 1]));
    return function (e) {
      const i = J(t, e, 1, n) - 1;
      return r[i](s[i](e));
    };
  }
  const yl = (t, e) => {
      const i = t.slice();
      let n = 0,
        s = i.length - 1,
        r = i[n],
        a = i[s];
      return a < r && (([n, s] = [s, n]), ([r, a] = [a, r])), (i[n] = e.floor(r)), (i[s] = e.ceil(a)), i;
    },
    _l = function (t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      const i = Math.floor(Math.log10(t)),
        n = t / Math.pow(10, i);
      let s;
      return (
        (s = e ? (n < 1.5 ? 1 : n < 3 ? 2 : n < 7 ? 5 : 10) : n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10),
        s * Math.pow(10, i)
      );
    };
  function bl(t, e, i, n) {
    let s;
    const r = [];
    let a;
    if (((e = Math.floor(+e)), (t = Math.floor(+t)), !(i = Math.floor(+i)))) return [];
    if (t === e) return [t];
    if ((s = e < t)) {
      const i = t;
      (t = e), (e = i);
    }
    let o = ft(1, e - t + 1)(i);
    if (((a = Math.floor((e - t + 1) / o)), !n))
      for (; Math.ceil((e - t + 1) / a) > i && o > 1; ) (o -= 1), (a = Math.floor((e - t) / o));
    let l = t;
    for (; l <= e; ) r.push(l), (l += a);
    return s && r.reverse(), r;
  }
  class xl extends il {
    constructor(t) {
      super(),
        (this.type = qo.Band),
        (this._range = [0, 1]),
        (this._step = void 0),
        (this._bandwidth = void 0),
        (this._isFixed = !1),
        (this._round = !1),
        (this._paddingInner = 0),
        (this._paddingOuter = 0),
        (this._align = 0.5),
        (this._unknown = void 0),
        delete this.unknown,
        this.rescale(t);
    }
    rescale(t) {
      if (t) return this;
      this._wholeRange = null;
      const e = this._calculateWholeRange(this._range),
        i = super.domain().length,
        n = e[1] < e[0];
      let s = e[Number(n) - 0];
      const r = e[1 - Number(n)],
        a = vl(i, this._paddingInner, this._paddingOuter);
      (this._step = (r - s) / Math.max(1, a || 1)),
        this._round && (this._step = Math.floor(this._step)),
        (s += (r - s - this._step * (i - this._paddingInner)) * this._align),
        this.isBandwidthFixed() || (this._bandwidth = this._step * (1 - this._paddingInner)),
        this._round &&
          ((s = Math.round(s)), this.isBandwidthFixed() || (this._bandwidth = Math.round(this._bandwidth)));
      const o = X(i).map(t => s + this._step * t);
      return super.range(n ? o.reverse() : o), this;
    }
    _calculateWholeRange(t) {
      var e, i, n, s, r;
      if (this._wholeRange) return this._wholeRange;
      if ((this._minBandwidth || this._maxBandwidth) && !this._isBandwidthFixedByUser()) {
        const e = (function (t, e, i, n, s) {
          const r = vl(t, i, n);
          let a = e / Math.max(1, r || 1);
          s && (a = Math.floor(a));
          let o = a * (1 - i);
          return s && (o = Math.round(o)), o;
        })(super.domain().length, Math.abs(t[1] - t[0]), this._paddingInner, this._paddingOuter, this._round);
        e < this._minBandwidth
          ? ((this._bandwidth = this._minBandwidth), (this._isFixed = !0))
          : e > this._maxBandwidth
          ? ((this._bandwidth = this._maxBandwidth), (this._isFixed = !0))
          : ((this._bandwidth = void 0), (this._isFixed = !1));
      }
      if (this.isBandwidthFixed()) {
        const a =
            ((i = super.domain().length),
            (n = this._bandwidth),
            (s = this._paddingInner),
            (r = this._paddingOuter),
            vl(i, s, r) * (n / (1 - s))),
          o = Math.min((t[1] - t[0]) / a, 1);
        if (null === (e = this._rangeFactor) || void 0 === e ? void 0 : e.length) {
          const [e, i] = this._rangeFactor,
            n = t[0] - a * e,
            s = n + a;
          (this._wholeRange = [n, s]), (this._rangeFactor = e + o <= 1 ? [e, e + o] : i - o >= 0 ? [i - o, i] : [0, o]);
        } else (this._rangeFactor = [0, o]), (this._wholeRange = [t[0], t[0] + a]);
        return this._wholeRange;
      }
      return super._calculateWholeRange(t);
    }
    calculateWholeRangeSize() {
      const t = this._calculateWholeRange(this._range);
      return Math.abs(t[1] - t[0]);
    }
    calculateVisibleDomain(t) {
      const e = this._domain;
      if (this._rangeFactor && e.length) {
        const i = this._getInvertIndex(t[0]),
          n = this._getInvertIndex(t[1]);
        return e.slice(Math.min(i, n), Math.max(i, n) + 1);
      }
      return e;
    }
    domain(t, e) {
      return t ? (super.domain(t), this.rescale(e)) : super.domain();
    }
    range(t, e) {
      return t ? ((this._range = [q(t[0]), q(t[1])]), this.rescale(e)) : this._range.slice();
    }
    rangeRound(t, e) {
      return (this._range = [q(t[0]), q(t[1])]), (this._round = !0), this.rescale(e);
    }
    ticks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this.calculateVisibleDomain(this._range);
      return -1 === t ? e.slice() : bl(0, e.length - 1, t, !1).map(t => e[t]);
    }
    tickData() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      return this.ticks(t).map((t, e) => ({
        index: e,
        tick: t,
        value: (this.scale(t) - this._range[0] + this._bandwidth / 2) / (this._range[1] - this._range[0])
      }));
    }
    forceTicks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this.calculateVisibleDomain(this._range);
      return bl(0, e.length - 1, t, !0)
        .filter(t => t < e.length)
        .map(t => e[t]);
    }
    stepTicks(t) {
      const e = this.calculateVisibleDomain(this._range);
      return (function (t, e, i) {
        const n = [];
        let s;
        if (((i = ft(1, (e = Math.floor(+e)) - (t = Math.floor(+t)) + 1)(Math.floor(+i))), (s = e < t))) {
          const i = t;
          (t = e), (e = i);
        }
        let r = t;
        for (; r <= e; ) n.push(r), (r += i);
        return s && n.reverse(), n;
      })(0, e.length - 1, t).map(t => e[t]);
    }
    _getInvertIndex(t) {
      let e = 0;
      const i = this.step() / 2,
        n = this.bandwidth() / 2,
        s = this._domain.length,
        r = this.range(),
        a = r[0] > r[r.length - 1];
      for (e = 0; e < s; e++) {
        const r = this.scale(this._domain[e]) + n;
        if (0 === e && ((!a && !lt(t, r + i)) || (a && !ht(t, r - i)))) break;
        if (e === s - 1) break;
        if (!ht(t, r - i) && !lt(t, r + i)) break;
      }
      return e >= 0 && e <= s - 1 ? e : s - 1;
    }
    invert(t) {
      return this._domain[this._getInvertIndex(t)];
    }
    padding(t, e) {
      return void 0 !== t
        ? ((this._paddingOuter = Math.max(0, Math.min(Array.isArray(t) ? Math.min.apply(null, t) : t))),
          (this._paddingInner = this._paddingOuter),
          this.rescale(e))
        : this._paddingInner;
    }
    paddingInner(t, e) {
      return void 0 !== t ? ((this._paddingInner = Math.max(0, Math.min(1, t))), this.rescale(e)) : this._paddingInner;
    }
    paddingOuter(t, e) {
      return void 0 !== t ? ((this._paddingOuter = Math.max(0, Math.min(1, t))), this.rescale(e)) : this._paddingOuter;
    }
    step() {
      return this._step;
    }
    round(t, e) {
      return void 0 !== t ? ((this._round = t), this.rescale(e)) : this._round;
    }
    align(t, e) {
      return void 0 !== t ? ((this._align = Math.max(0, Math.min(1, t))), this.rescale(e)) : this._align;
    }
    rangeFactor(t, e) {
      return t ? (super.rangeFactor(t), this.rescale(e)) : super.rangeFactor();
    }
    bandwidth(t, e) {
      return t
        ? ('auto' === t
            ? ((this._bandwidth = void 0), (this._isFixed = !1))
            : ((this._bandwidth = t), (this._isFixed = !0)),
          (this._userBandwidth = t),
          this.rescale(e))
        : this._bandwidth;
    }
    maxBandwidth(t, e) {
      return t ? ((this._maxBandwidth = 'auto' === t ? void 0 : t), this.rescale(e)) : this._maxBandwidth;
    }
    minBandwidth(t, e) {
      return t ? ((this._minBandwidth = 'auto' === t ? void 0 : t), this.rescale(e)) : this._minBandwidth;
    }
    isBandwidthFixed() {
      return this._isFixed && !!this._bandwidth;
    }
    _isBandwidthFixedByUser() {
      return this._isFixed && this._userBandwidth && y(this._userBandwidth);
    }
    clone() {
      var t, e, i;
      return new xl(!0)
        .domain(this._domain, !0)
        .range(this._range, !0)
        .round(this._round, !0)
        .paddingInner(this._paddingInner, !0)
        .paddingOuter(this._paddingOuter, !0)
        .align(this._align, !0)
        .bandwidth(null !== (t = this._userBandwidth) && void 0 !== t ? t : 'auto', !0)
        .maxBandwidth(null !== (e = this._maxBandwidth) && void 0 !== e ? e : 'auto', !0)
        .minBandwidth(null !== (i = this._maxBandwidth) && void 0 !== i ? i : 'auto');
    }
  }
  const { interpolateRgb: Sl } = ve;
  function wl(t, e) {
    const i = typeof e;
    let n;
    if (l(e) || 'boolean' === i) return () => e;
    if ('number' === i) return _t(t, e);
    if ('string' === i) {
      if ((n = ue.parseColorString(e))) {
        const e = Sl(ue.parseColorString(t), n);
        return t => e(t).formatRgb();
      }
      return _t(Number(t), Number(e));
    }
    return e instanceof pe
      ? Sl(t, e)
      : e instanceof ue
      ? Sl(t.color, e.color)
      : e instanceof Date
      ? (function (t, e) {
          const i = t.valueOf(),
            n = e.valueOf(),
            s = new Date();
          return t => (s.setTime(i * (1 - t) + n * t), s);
        })(t, e)
      : _t(Number(t), Number(e));
  }
  class Al extends tl {
    constructor() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nl,
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : nl;
      super(),
        (this._unknown = void 0),
        (this.transformer = t),
        (this.untransformer = e),
        (this._forceAlign = !0),
        (this._domain = [0, 1]),
        (this._range = [0, 1]),
        (this._clamp = nl),
        (this._piecewise = fl),
        (this._interpolate = wl);
    }
    calculateVisibleDomain(t) {
      var e;
      return this._rangeFactor && 2 === t.length
        ? [this.invert(t[0]), this.invert(t[1])]
        : null !== (e = this._niceDomain) && void 0 !== e
        ? e
        : this._domain;
    }
    scale(t) {
      var e;
      return (
        (t = Number(t)),
        Number.isNaN(t) || (this._domainValidator && !this._domainValidator(t))
          ? this._unknown
          : (this._output ||
              (this._output = this._piecewise(
                (null !== (e = this._niceDomain) && void 0 !== e ? e : this._domain).map(this.transformer),
                this._calculateWholeRange(this._range),
                this._interpolate
              )),
            this._output(this.transformer(this._clamp(t))))
      );
    }
    invert(t) {
      var e;
      return (
        this._input ||
          (this._input = this._piecewise(
            this._calculateWholeRange(this._range),
            (null !== (e = this._niceDomain) && void 0 !== e ? e : this._domain).map(this.transformer),
            _t
          )),
        this._clamp(this.untransformer(this._input(t)))
      );
    }
    domain(t, e) {
      var i;
      if (!t) return (null !== (i = this._niceDomain) && void 0 !== i ? i : this._domain).slice();
      (this._domainValidator = null), (this._niceType = null), (this._niceDomain = null);
      const n = Array.from(t, q);
      return (this._domain = n), this.rescale(e);
    }
    range(t, e) {
      if (!t) return this._range.slice();
      const i = Array.from(t);
      return (this._range = i), this.rescale(e);
    }
    rangeRound(t, e) {
      const i = Array.from(t);
      return (this._range = i), (this._interpolate = bt), this.rescale(e);
    }
    rescale(t) {
      var e;
      if (t) return this;
      const i = null !== (e = this._niceDomain) && void 0 !== e ? e : this._domain,
        n = i.length,
        s = this._range.length;
      let r = Math.min(n, s);
      if (n && n < s && this._forceAlign) {
        const t = s - n + 1,
          e = i[n - 1],
          a = n >= 2 ? (e - i[n - 2]) / t : 0;
        for (let s = 1; s <= t; s++) i[n - 2 + s] = e - a * (t - s);
        r = s;
      }
      return (
        void 0 === this._clamp && (this._clamp = ft(i[0], i[r - 1])),
        (this._piecewise = r > 2 ? ml : fl),
        (this._output = this._input = null),
        (this._wholeRange = null),
        this
      );
    }
    clamp(t, e, i) {
      return arguments.length ? ((this._clamp = e || (t ? void 0 : nl)), this.rescale(i)) : this._clamp !== nl;
    }
    interpolate(t, e) {
      return arguments.length ? ((this._interpolate = t), this.rescale(e)) : this._interpolate;
    }
    ticks() {
      return [];
    }
    tickData() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this.ticks(t);
      return (null != e ? e : []).map((t, e) => ({
        index: e,
        tick: t,
        value: (this.scale(t) - this._range[0]) / (this._range[1] - this._range[0])
      }));
    }
    rangeFactor(t, e) {
      return t ? (super.rangeFactor(t), (this._output = this._input = null), this) : super.rangeFactor();
    }
    forceAlignDomainRange(t) {
      return arguments.length ? ((this._forceAlign = t), this) : this._forceAlign;
    }
  }
  const kl = Math.sqrt(50),
    Ml = Math.sqrt(10),
    Tl = Math.sqrt(2),
    Cl = [1, 2, 5, 10],
    El = (t, e, i) => {
      let n = 1,
        s = t;
      const r = Math.floor((e - 1) / 2),
        a = Math.abs(t);
      return (
        t >= 0 && t <= Number.MIN_VALUE
          ? (s = 0)
          : t < 0 && t >= -Number.MIN_VALUE
          ? (s = -(e - 1))
          : !i && a < 1
          ? (n = Bl(a).step)
          : (i || a > 1) && (s = Math.floor(t) - r * n),
        n > 0
          ? (t > 0 ? (s = Math.max(s, 0)) : t < 0 && (s = Math.min(s, -(e - 1) * n)), X(0, e).map(t => s + t * n))
          : t > 0
          ? Rl(0, -(e - 1) / n, n)
          : Rl((e - 1) / n, 0, n)
      );
    },
    Pl = ct((t, e, i, n) => {
      let s,
        r,
        a,
        o,
        l = -1;
      if (((i = +i), (t = +t) == (e = +e))) return [t];
      if (Math.abs(t - e) <= Number.MIN_VALUE && i > 0) return [t];
      if (((s = e < t) && ((r = t), (t = e), (e = r)), (o = Il(t, e, i).step), !isFinite(o))) return [];
      if (o > 0) {
        let i = Math.round(t / o),
          n = Math.round(e / o);
        for (i * o < t && ++i, n * o > e && --n, a = new Array((r = n - i + 1)); ++l < r; ) a[l] = (i + l) * o;
      } else if (o < 0 && (null == n ? void 0 : n.noDecimals)) {
        o = 1;
        const i = Math.ceil(t),
          n = Math.floor(e);
        if (!(i <= n)) return [];
        for (a = new Array((r = n - i + 1)); ++l < r; ) a[l] = i + l;
      } else {
        o = -o;
        let i = Math.round(t * o),
          n = Math.round(e * o);
        for (i / o < t && ++i, n / o > e && --n, a = new Array((r = n - i + 1)); ++l < r; ) a[l] = (i + l) / o;
      }
      return s && a.reverse(), a;
    }),
    Rl = (t, e, i) => {
      let n,
        s,
        r = -1;
      if (i > 0) {
        let a = Math.floor(t / i),
          o = Math.ceil(e / i);
        for ((a + 1) * i < t && ++a, (o - 1) * i > e && --o, s = new Array((n = o - a + 1)); ++r < n; )
          s[r] = (a + r) * i;
      } else {
        i = -i;
        let a = Math.floor(t * i),
          o = Math.ceil(e * i);
        for ((a + 1) / i < t && ++a, (o - 1) / i > e && --o, s = new Array((n = o - a + 1)); ++r < n; )
          s[r] = (a + r) / i;
      }
      return s;
    },
    Ol = ct((t, e, i, n) => {
      let s, r, a;
      if (((i = +i), (t = +t) == (e = +e))) return El(t, i, null == n ? void 0 : n.noDecimals);
      if (Math.abs(t - e) <= Number.MIN_VALUE && i > 0) return El(t, i, null == n ? void 0 : n.noDecimals);
      (s = e < t) && ((a = t), (t = e), (e = a));
      const o = Il(t, e, i);
      let l = o.step;
      if (!isFinite(l)) return [];
      if (l > 0) {
        let n = 1;
        const { power: s, gap: a } = o,
          h = 10 === a ? 2 * 10 ** s : 1 * 10 ** s;
        for (; n <= 5 && ((r = Rl(t, e, l)), r.length > i + 1) && i > 2; ) (l += h), (n += 1);
        i > 2 &&
          r.length < i - 1 &&
          (r = ((t, e, i) => {
            let n;
            const s = t[0],
              r = t[t.length - 1],
              a = e - t.length;
            if (r <= 0) {
              const e = [];
              for (n = a; n >= 1; n--) e.push(s - n * i);
              return e.concat(t);
            }
            if (s >= 0) {
              for (n = 1; n <= a; n++) t.push(r + n * i);
              return t;
            }
            let o = [];
            const l = [];
            for (n = 1; n <= a; n++)
              n % 2 == 0 ? (o = [s - Math.floor(n / 2) * i].concat(o)) : l.push(r + Math.ceil(n / 2) * i);
            return o.concat(t).concat(l);
          })(r, i, l));
      } else (null == n ? void 0 : n.noDecimals) && l < 0 && (l = 1), (r = Rl(t, e, l));
      return s && r.reverse(), r;
    }),
    Bl = t => {
      const e = Math.floor(Math.log(t) / Math.LN10),
        i = t / 10 ** e;
      let n = Cl[0];
      return (
        i >= kl ? (n = Cl[3]) : i >= Ml ? (n = Cl[2]) : i >= Tl && (n = Cl[1]),
        e >= 0 ? { step: n * 10 ** e, gap: n, power: e } : { step: -(10 ** -e) / n, gap: n, power: e }
      );
    };
  function Il(t, e, i) {
    const n = (e - t) / Math.max(0, i);
    return Bl(n);
  }
  function Dl(t, e, i) {
    let n;
    if (((i = +i), (t = +t) == (e = +e) && i > 0)) return [t];
    if (
      i <= 0 ||
      0 ===
        (n = (function (t, e, i) {
          return (e - t) / Math.max(1, i - 1);
        })(t, e, i)) ||
      !isFinite(n)
    )
      return [];
    const s = new Array(i);
    for (let e = 0; e < i; e++) s[e] = t + e * n;
    return s;
  }
  function Ll(t, e, i) {
    let n,
      s,
      r = -1;
    if (((i = +i), (s = (e = +e) < (t = +t)) && ((n = t), (t = e), (e = n)), !isFinite(i) || e - t <= i)) return [t];
    const a = Math.floor((e - t) / i + 1),
      o = new Array(a);
    for (; ++r < a; ) o[r] = t + r * i;
    return s && o.reverse(), o;
  }
  function Fl(t) {
    let e,
      i,
      n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10,
      s = 0,
      r = t.length - 1,
      a = t[s],
      o = t[r],
      l = 10;
    for (o < a && ((i = a), (a = o), (o = i), (i = s), (s = r), (r = i)); l-- > 0; ) {
      if (((i = Il(a, o, n).step), i === e)) return (t[s] = a), (t[r] = o), t;
      if (i > 0) (a = Math.floor(a / i) * i), (o = Math.ceil(o / i) * i);
      else {
        if (!(i < 0)) break;
        (a = Math.ceil(a * i) / i), (o = Math.floor(o * i) / i);
      }
      e = i;
    }
  }
  function jl(t, e) {
    const i = y(e.forceMin),
      n = y(e.forceMax);
    let s = null;
    const r = [];
    let a = null;
    const o =
      i && n ? t => t >= e.forceMin && t <= e.forceMax : i ? t => t >= e.forceMin : n ? t => t <= e.forceMax : null;
    return (
      i ? (r[0] = e.forceMin) : y(e.min) && e.min <= Math.min(t[0], t[t.length - 1]) && (r[0] = e.min),
      n ? (r[1] = e.forceMax) : y(e.max) && e.max >= Math.max(t[0], t[t.length - 1]) && (r[1] = e.max),
      y(r[0]) && y(r[1])
        ? ((a = t.slice()), (a[0] = r[0]), (a[a.length - 1] = r[1]))
        : (s = y(r[0]) || y(r[1]) ? (y(r[0]) ? 'max' : 'min') : 'all'),
      { niceType: s, niceDomain: a, niceMinMax: r, domainValidator: o }
    );
  }
  const zl = (t, e, i) => (Math.abs(e - t) < 1 ? +i.toFixed(1) : Math.round(+i)),
    Hl = ct((t, e, i, n, s, r) => {
      const a = [],
        o = {},
        l = s(t),
        h = s(e);
      let c = [];
      if (Number.isInteger(n)) c = Ol(l, h, i);
      else {
        const t = (h - l) / (i - 1);
        for (let e = 0; e < i; e++) c.push(l + e * t);
      }
      return (
        c.forEach(i => {
          const s = r(i),
            l = Number.isInteger(n) ? zl(t, e, s) : zl(t, e, _l(s)),
            h = zl(
              t,
              e,
              ((t, e) => {
                let i, n;
                return e[0] < e[1] ? ((i = e[0]), (n = e[1])) : ((i = e[1]), (n = e[0])), Math.min(Math.max(t, i), n);
              })(l, [t, e])
            );
          !o[h] && !isNaN(h) && c.length > 1 && ((o[h] = 1), a.push(h));
        }),
        a
      );
    }),
    Nl = ct((t, e, i, n, s) => Dl(n(t), n(e), i).map(t => _l(s(t))));
  class Vl extends Al {
    constructor() {
      super(...arguments), (this.type = qo.Linear);
    }
    clone() {
      return new Vl()
        .domain(this._domain, !0)
        .range(this._range, !0)
        .unknown(this._unknown)
        .clamp(this.clamp(), null, !0)
        .interpolate(this._interpolate);
    }
    tickFormat() {
      return () => {};
    }
    d3Ticks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10,
        e = arguments.length > 1 ? arguments[1] : void 0;
      const i = this.calculateVisibleDomain(this._range);
      return Pl(i[0], i[i.length - 1], t, e);
    }
    ticks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10,
        e = arguments.length > 1 ? arguments[1] : void 0;
      var i;
      if (
        (this._rangeFactor && (this._rangeFactor[0] > 0 || this._rangeFactor[1] < 1) && 2 === this._range.length) ||
        !this._niceType
      )
        return this.d3Ticks(t, e);
      const n = null !== (i = this._niceDomain) && void 0 !== i ? i : this._domain,
        s = this._domain,
        r = n[0],
        a = n[n.length - 1];
      let o = Ol(s[0], s[s.length - 1], t, e);
      if (!o.length) return o;
      if ((o[0] !== r && 'max' === this._niceType) || (o[o.length - 1] !== a && 'min' === this._niceType)) {
        const t = n.slice();
        'min' === this._niceType ? (t[0] = o[0]) : (t[t.length - 1] = o[o.length - 1]),
          (this._niceDomain = t),
          this.rescale();
        const e = Math.min(t[0], t[t.length - 1]),
          i = Math.max(t[0], t[t.length - 1]);
        o = o.filter(t => t >= e && t <= i);
      } else if ('all' !== this._niceType || (o[0] === r && o[o.length - 1] === a))
        this._domainValidator && (o = o.filter(this._domainValidator));
      else {
        const t = n.slice();
        (t[0] = o[0]), (t[t.length - 1] = o[o.length - 1]), (this._niceDomain = t), this.rescale();
      }
      return o;
    }
    forceTicks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this.calculateVisibleDomain(this._range);
      return Dl(e[0], e[e.length - 1], t);
    }
    stepTicks(t) {
      const e = this.calculateVisibleDomain(this._range);
      return Ll(e[0], e[e.length - 1], t);
    }
    nice() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10,
        e = arguments.length > 1 ? arguments[1] : void 0;
      var i, n;
      const s = this._domain;
      let r = [];
      if (e) {
        const t = jl(s, e);
        if (
          ((r = t.niceMinMax), (this._domainValidator = t.domainValidator), (this._niceType = t.niceType), t.niceDomain)
        )
          return (this._niceDomain = t.niceDomain), this.rescale(), this;
      } else this._niceType = 'all';
      if (this._niceType) {
        const e = Fl(s.slice(), t);
        'min' === this._niceType
          ? (e[e.length - 1] = null !== (i = r[1]) && void 0 !== i ? i : e[e.length - 1])
          : 'max' === this._niceType && (e[0] = null !== (n = r[0]) && void 0 !== n ? n : e[0]),
          (this._niceDomain = e),
          this.rescale();
      }
      return this;
    }
    niceMin() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      this._niceType = 'min';
      const e = this._domain[this._domain.length - 1],
        i = Fl(this.domain(), t);
      return i && ((i[i.length - 1] = e), (this._niceDomain = i), this.rescale()), this;
    }
    niceMax() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      this._niceType = 'max';
      const e = this._domain[0],
        i = Fl(this._domain.slice(), t);
      return i && ((i[0] = e), (this._niceDomain = i), this.rescale()), this;
    }
  }
  function Wl(t) {
    return e => -t(-e);
  }
  class Gl extends Al {
    constructor() {
      super(dl(10), cl(10)),
        (this.type = qo.Log),
        (this._logs = this.transformer),
        (this._pows = this.untransformer),
        (this._domain = [1, 10]),
        (this._base = 10);
    }
    clone() {
      return new Gl()
        .domain(this._domain, !0)
        .range(this._range, !0)
        .unknown(this._unknown)
        .clamp(this.clamp(), null, !0)
        .interpolate(this._interpolate, !0)
        .base(this._base);
    }
    rescale(t) {
      var e;
      if (t) return this;
      super.rescale();
      const i = dl(this._base),
        n = cl(this._base);
      return (
        (null !== (e = this._niceDomain) && void 0 !== e ? e : this._domain)[0] < 0
          ? ((this._logs = Wl(i)), (this._pows = Wl(n)), (this.transformer = ol), (this.untransformer = ll))
          : ((this._logs = i), (this._pows = n), (this.transformer = i), (this.untransformer = n)),
        this
      );
    }
    base(t, e) {
      return arguments.length ? ((this._base = t), this.rescale(e)) : this._base;
    }
    tickFormat() {
      return nl;
    }
    d3Ticks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this.domain();
      let i = e[0],
        n = e[e.length - 1];
      const s = n < i;
      s && ([i, n] = [n, i]);
      let r,
        a,
        o = this._logs(i),
        l = this._logs(n),
        h = [];
      if (!(this._base % 1) && l - o < t) {
        if (((o = Math.floor(o)), (l = Math.ceil(l)), i > 0)) {
          for (; o <= l; ++o)
            for (r = 1; r < this._base; ++r)
              if (((a = o < 0 ? r / this._pows(-o) : r * this._pows(o)), !(a < i))) {
                if (a > n) break;
                h.push(a);
              }
        } else
          for (; o <= l; ++o)
            for (r = this._base - 1; r >= 1; --r)
              if (((a = o > 0 ? r / this._pows(-o) : r * this._pows(o)), !(a < i))) {
                if (a > n) break;
                h.push(a);
              }
        2 * h.length < t && (h = Ol(i, n, t));
      } else h = Ol(o, l, Math.min(l - o, t)).map(this._pows);
      return s ? h.reverse() : h;
    }
    ticks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this.calculateVisibleDomain(this._range);
      return Hl(e[0], e[e.length - 1], t, this._base, this.transformer, this.untransformer);
    }
    forceTicks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this.calculateVisibleDomain(this._range);
      return Nl(e[0], e[e.length - 1], t, this.transformer, this.untransformer);
    }
    stepTicks(t) {
      const e = this.calculateVisibleDomain(this._range);
      return Nl(e[0], e[e.length - 1], t, this.transformer, this.untransformer);
    }
    nice() {
      let t = arguments.length > 1 ? arguments[1] : void 0;
      var e, i;
      const n = this._domain;
      let s = [],
        r = null;
      if (t) {
        const e = jl(n, t);
        if (((s = e.niceMinMax), (this._domainValidator = e.domainValidator), (r = e.niceType), e.niceDomain))
          return (this._niceDomain = e.niceDomain), this.rescale(), this;
      } else r = 'all';
      if (r) {
        const t = yl(n.slice(), {
          floor: t => this._pows(Math.floor(this._logs(t))),
          ceil: t => this._pows(Math.ceil(this._logs(t)))
        });
        return (
          'min' === r
            ? (t[t.length - 1] = null !== (e = s[1]) && void 0 !== e ? e : t[t.length - 1])
            : 'max' === r && (t[0] = null !== (i = s[0]) && void 0 !== i ? i : t[0]),
          (this._niceDomain = t),
          this.rescale(),
          this
        );
      }
      return this;
    }
    niceMin() {
      const t = this._domain[this._domain.length - 1];
      this.nice();
      const e = this._domain.slice();
      return this._domain && ((e[e.length - 1] = t), (this._niceDomain = e), this.rescale()), this;
    }
    niceMax() {
      const t = this._domain[0];
      this.nice();
      const e = this._domain.slice();
      return this._domain && ((e[0] = t), (this._niceDomain = e), this.rescale()), this;
    }
  }
  class Ul extends xl {
    constructor(t) {
      super(!1),
        (this.type = qo.Point),
        (this._padding = 0),
        this.paddingInner(1, t),
        (this.padding = this.paddingOuter),
        (this.paddingInner = void 0),
        (this.paddingOuter = void 0);
    }
  }
  class Yl extends Vl {
    constructor() {
      super(), (this.type = qo.Pow), (this._exponent = 1);
    }
    clone() {
      return new Yl()
        .domain(this._domain, !0)
        .range(this._range, !0)
        .unknown(this._unknown)
        .clamp(this.clamp(), null, !0)
        .interpolate(this._interpolate, !0)
        .exponent(this._exponent);
    }
    rescale(t) {
      return (
        t ||
          (1 === this._exponent
            ? ((this.transformer = nl), (this.untransformer = nl))
            : 0.5 === this._exponent
            ? ((this.transformer = rl), (this.untransformer = al))
            : ((this.transformer = sl(this._exponent)), (this.untransformer = sl(1 / this._exponent))),
          super.rescale()),
        this
      );
    }
    exponent(t, e) {
      return arguments.length ? ((this._exponent = t), this.rescale(e)) : this._exponent;
    }
  }
  class $l {
    constructor() {
      (this.type = qo.Quantile), (this._range = []), (this._domain = []), (this._thresholds = []);
    }
    unknown(t) {
      return arguments.length ? ((this._unknown = t), this) : this._unknown;
    }
    rescale(t) {
      if (t) return this;
      let e = 0;
      const i = Math.max(1, this._range.length);
      for (this._thresholds = new Array(i - 1); ++e < i; ) this._thresholds[e - 1] = Z(this._domain, e / i);
      return this;
    }
    scale(t) {
      return _(t) ? this._range[J(this._thresholds, t)] : this._unknown;
    }
    invertExtent(t) {
      const e = this._range.indexOf(t);
      return e < 0
        ? [NaN, NaN]
        : [
            e > 0 ? this._thresholds[e - 1] : this._domain[0],
            e < this._thresholds.length ? this._thresholds[e] : this._domain[this._domain.length - 1]
          ];
    }
    quantiles() {
      return this._thresholds.slice();
    }
    domain(t, e) {
      if (!t) return this._domain.slice();
      this._domain = [];
      for (const e of t) l(e) || Number.isNaN(+e) || this._domain.push(+e);
      return this._domain.sort(K), this.rescale(e);
    }
    range(t, e) {
      if (!t) return this._range.slice();
      const i = Array.from(t);
      return U(this._range, i) ? this : ((this._range = i), this.rescale(e));
    }
    clone() {
      return new $l().domain(this._domain, !0).range(this._range).unknown(this._unknown);
    }
  }
  class Xl {
    constructor() {
      (this.type = qo.Quantile),
        (this._range = [0, 1]),
        (this._domain = [0.5]),
        (this.x0 = 0),
        (this.x1 = 1),
        (this.n = 1);
    }
    unknown(t) {
      return arguments.length ? ((this._unknown = t), this) : this._unknown;
    }
    rescale(t) {
      if (t) return this;
      let e = -1;
      for (this._domain = new Array(this.n); ++e < this.n; )
        this._domain[e] = ((e + 1) * this.x1 - (e - this.n) * this.x0) / (this.n + 1);
      return this;
    }
    scale(t) {
      return _(t) ? this._range[J(this._domain, t, 0, this.n)] : this._unknown;
    }
    invertExtent(t) {
      const e = this._range.indexOf(t);
      return e < 0
        ? [NaN, NaN]
        : e < 1
        ? [this.x0, this._domain[0]]
        : e >= this.n
        ? [this._domain[this.n - 1], this.x1]
        : [this._domain[e - 1], this._domain[e]];
    }
    thresholds() {
      return this._domain.slice();
    }
    domain(t, e) {
      if (!t) return [this.x0, this.x1];
      const i = Array.from(t);
      return (this.x0 = +i[0]), (this.x1 = +i[1]), this.rescale(e);
    }
    range(t, e) {
      if (!t) return this._range.slice();
      const i = Array.from(t);
      return U(this._range, i) ? this : ((this.n = i.length - 1), (this._range = i), this.rescale(e));
    }
    clone() {
      return new Xl().domain([this.x0, this.x1], !0).range(this._range).unknown(this._unknown);
    }
    ticks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this.domain();
      return Ol(e[0], e[e.length - 1], t);
    }
    forceTicks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this.domain();
      return Dl(e[0], e[e.length - 1], t);
    }
    stepTicks(t) {
      const e = this.domain();
      return Ll(e[0], e[e.length - 1], t);
    }
    nice() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = Fl(this.domain(), t);
      return e ? this.domain(e) : this;
    }
    niceMin() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this._domain[this._domain.length - 1],
        i = Fl(this.domain(), t);
      return i && ((i[i.length - 1] = e), this.domain(i)), this;
    }
    niceMax() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this._domain[0],
        i = Fl(this.domain(), t);
      return i && ((i[0] = e), this.domain(i)), this;
    }
  }
  class Kl extends Vl {
    constructor() {
      super(rl, al), (this.type = qo.Sqrt);
    }
    clone() {
      return new Kl()
        .domain(this._domain, !0)
        .range(this._range, !0)
        .unknown(this._unknown)
        .clamp(this.clamp(), null, !0)
        .interpolate(this._interpolate);
    }
  }
  class ql extends Vl {
    constructor() {
      super(ul(1), pl(1)), (this.type = qo.Symlog), (this._const = 1);
    }
    clone() {
      return new ql()
        .domain(this._domain, !0)
        .range(this._range, !0)
        .unknown(this._unknown)
        .clamp(this.clamp(), null, !0)
        .interpolate(this._interpolate, !0)
        .constant(this._const);
    }
    constant(t, e) {
      return arguments.length
        ? ((this._const = t), (this.transformer = ul(t)), (this.untransformer = pl(t)), this.rescale(e))
        : this._const;
    }
    ticks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this.calculateVisibleDomain(this._range);
      return Hl(e[0], e[e.length - 1], t, this._const, this.transformer, this.untransformer);
    }
    forceTicks() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
      const e = this.calculateVisibleDomain(this._range);
      return Nl(e[0], e[e.length - 1], t, this.transformer, this.untransformer);
    }
    stepTicks(t) {
      const e = this.calculateVisibleDomain(this._range);
      return Nl(e[0], e[e.length - 1], t, this.transformer, this.untransformer);
    }
    nice() {
      let t = arguments.length > 1 ? arguments[1] : void 0;
      var e, i;
      const n = this._domain;
      let s = [],
        r = null;
      if (t) {
        const e = jl(n, t);
        if (((s = e.niceMinMax), (this._domainValidator = e.domainValidator), (r = e.niceType), e.niceDomain))
          return (this._niceDomain = e.niceDomain), this.rescale(), this;
      } else r = 'all';
      if (r) {
        const t = yl(n.slice(), {
          floor: t => this.untransformer(Math.floor(this.transformer(t))),
          ceil: t => this.untransformer(Math.ceil(this.transformer(t)))
        });
        return (
          'min' === r
            ? (t[t.length - 1] = null !== (e = s[1]) && void 0 !== e ? e : t[t.length - 1])
            : 'max' === r && (t[0] = null !== (i = s[0]) && void 0 !== i ? i : t[0]),
          (this._niceDomain = t),
          this.rescale(),
          this
        );
      }
      return this;
    }
    niceMin() {
      const t = this._domain[this._domain.length - 1];
      this.nice();
      const e = this._domain.slice();
      return this._domain && ((e[e.length - 1] = t), (this._niceDomain = e), this.rescale()), this;
    }
    niceMax() {
      const t = this._domain[0];
      this.nice();
      const e = this._domain.slice();
      return this._domain && ((e[0] = t), (this._niceDomain = e), this.rescale()), this;
    }
  }
  class Zl {
    constructor() {
      (this.type = qo.Threshold), (this._range = [0, 1]), (this._domain = [0.5]), (this.n = 1);
    }
    unknown(t) {
      return arguments.length ? ((this._unknown = t), this) : this._unknown;
    }
    scale(t) {
      return !l(t) && _(+t) ? this._range[J(this._domain, t, 0, this.n)] : this._unknown;
    }
    invertExtent(t) {
      const e = this._range.indexOf(t);
      return [this._domain[e - 1], this._domain[e]];
    }
    domain(t) {
      return t
        ? ((this._domain = Array.from(t)), (this.n = Math.min(this._domain.length, this._range.length - 1)), this)
        : this._domain.slice();
    }
    range(t) {
      return t
        ? ((this._range = Array.from(t)), (this.n = Math.min(this._domain.length, this._range.length - 1)), this)
        : this._range.slice();
    }
    clone() {
      return new Zl().domain(this._domain).range(this._range).unknown(this._unknown);
    }
  }
  const Jl = [
    ['second', 1, oi],
    ['second', 5, 5e3],
    ['second', 10, 1e4],
    ['second', 30, 3e4],
    ['minute', 1, li],
    ['minute', 5, 3e5],
    ['minute', 10, 6e5],
    ['minute', 30, 18e5],
    ['hour', 1, hi],
    ['hour', 3, 3 * hi],
    ['hour', 6, 6 * hi],
    ['hour', 12, 12 * hi],
    ['day', 1, ci],
    ['day', 2, 2 * ci],
    ['day', 7, 7 * ci],
    ['month', 1, di],
    ['month', 3, 3 * di],
    ['month', 6, 6 * di],
    ['year', 1, 365 * ci]
  ];
  function Ql(t) {
    return +At(t);
  }
  function th(t, e, i, n) {
    const s = (+e - +t) / i,
      r = J(
        Jl.map(t => t[2]),
        s
      );
    if (r === Jl.length) {
      const s = Math.max(st(+t / ui, +e / ui, i), 1),
        r = t => (
          t[ai(n)](Math.floor(t[Qe(n)]() / s) * s),
          t[
            (function (t) {
              return t ? 'setUTCMonth' : 'setMonth';
            })(n)
          ](0, 1),
          t[
            (function (t) {
              return t ? 'setUTCHours' : 'setHours';
            })(n)
          ](0, 0, 0, 0),
          t
        ),
        a = (t, e) => (t[ai(n)](t[Qe(n)]() + e * s), t);
      return { floor: r, offset: a, ceil: ln(r, a) };
    }
    if (0 === r) {
      const n = Math.max(st(+t, +e, i), 1),
        s = t => (t.setTime(Math.floor(+t / n) * n), t),
        r = (t, e) => (t.setTime(+t + e * n), t);
      return { floor: s, offset: r, ceil: ln(s, r) };
    }
    const [a, o] = Jl[s / Jl[r - 1][2] < Jl[r][2] / s ? r - 1 : r],
      l = ((t, e) =>
        'year' === t && e
          ? { floor: mi, offset: yi, count: _i, field: bi }
          : 'month' === t && e
          ? { floor: ki, offset: Mi, count: Ti, field: Ci }
          : 'day' === t && e
          ? { floor: Bi, offset: Ii, count: Di, field: Li }
          : 'hour' === t && e
          ? { floor: Ni, offset: Vi, count: zi, field: Wi }
          : 'minute' === t && e
          ? { floor: Xi, offset: Ki, count: Yi, field: qi }
          : 'second' === t && e
          ? { floor: en, offset: nn, count: Qi, field: sn }
          : 'year' === t
          ? { floor: pi, offset: gi, count: fi, field: vi }
          : 'month' === t
          ? { floor: xi, offset: Si, count: wi, field: Ai }
          : 'day' === t
          ? { floor: Ei, offset: Pi, count: Ri, field: Oi }
          : 'hour' === t
          ? { floor: Fi, offset: ji, count: zi, field: Hi }
          : 'minute' === t
          ? { floor: Gi, offset: Ui, count: Yi, field: $i }
          : 'second' === t
          ? { floor: Zi, offset: Ji, count: Qi, field: tn }
          : { floor: rn, offset: an, count: on })(a, n);
    return hn(o, l);
  }
  class eh extends Al {
    constructor() {
      let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      super(),
        (this.type = qo.Time),
        (this._domain = t ? [Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)] : [+new Date(2e3, 0, 1), +new Date(2e3, 0, 2)]),
        (this._isUtc = t);
    }
    invert(t) {
      return new Date(super.invert(t));
    }
    domain(t, e) {
      if (!t) return this._domain.map(At);
      const i = Array.from(t, Ql);
      return (this._domain = i), this.rescale(e);
    }
    ticks(t) {
      const e = this.domain();
      let i = e[0],
        n = e[e.length - 1];
      const s = n < i;
      s && ([i, n] = [n, i]);
      let r = t;
      (y(t) || l(t)) && (r = th(i, n, l(t) ? 10 : t, this._isUtc)), (i = r.ceil(i));
      const a = [];
      let o = +i,
        h = 0;
      for (; o <= +n && h < 100; ) a.push(new Date(o)), (o = +r.offset(new Date(o), 1)), h++;
      return s ? a.reverse() : a;
    }
    tickFormat(t, e) {
      return (
        (i =
          null == e
            ? (function (t, e) {
                const i = At(t),
                  n = i[ti(e)]() + 1,
                  s = i[ei(e)](),
                  r = i[ii(e)](),
                  a = i[ni(e)](),
                  o = i[si(e)](),
                  l = 0 === i[ri(e)](),
                  h = l && 0 === o,
                  c = h && 0 === a,
                  d = c && 0 === r,
                  u = d && 1 === s;
                return u && 1 === n
                  ? 'YYYY'
                  : u
                  ? 'YYYY-MM'
                  : d
                  ? 'YYYY-MM-DD'
                  : c
                  ? 'HH'
                  : h
                  ? 'HH:mm'
                  : l
                  ? 'HH:mm:ss'
                  : 'HH:mm:ss SSS';
              })(this._domain[0], this._isUtc)
            : e),
        (n = this._isUtc),
        t => {
          const e = At(t),
            s = e[Qe(n)](),
            r = e[ti(n)]() + 1,
            a = Math.floor((r - 1) / 3) + 1,
            o = e[ei(n)](),
            l = e['get' + (n ? 'UTC' : '') + 'Day'](),
            h = e[ii(n)](),
            c = ((h - 1) % 12) + 1,
            d = e[ni(n)](),
            u = e[si(n)](),
            p = e[ri(n)]();
          return (i || '')
            .replace(/YYYY/g, ut(s + '', 4, '0', 'left'))
            .replace(/yyyy/g, s + '')
            .replace(/yy/g, (s % 100) + '')
            .replace(/Q/g, a + '')
            .replace(/MM/g, ut(r, 2, '0', 'left'))
            .replace(/M/g, r + '')
            .replace(/dd/g, ut(o, 2, '0', 'left'))
            .replace(/d/g, o + '')
            .replace(/e/g, l + '')
            .replace(/HH/g, ut(h, 2, '0', 'left'))
            .replace(/H/g, h + '')
            .replace(/hh/g, ut(c + '', 2, '0', 'left'))
            .replace(/h/g, c + '')
            .replace(/mm/g, ut(d, 2, '0', 'left'))
            .replace(/m/g, d + '')
            .replace(/ss/g, ut(u, 2, '0', 'left'))
            .replace(/s/g, u + '')
            .replace(/SSS/g, ut(p, 3, '0', 'left'))
            .replace(/S/g, p + '');
        }
      );
      var i, n;
    }
    clone() {
      return new eh(this._isUtc)
        .domain(this.domain(), !0)
        .range(this._range, !0)
        .unknown(this._unknown)
        .clamp(this.clamp(), null, !0)
        .interpolate(this._interpolate);
    }
    nice(t) {
      const e = this.domain();
      let i = t;
      return (
        (y(t) || l(t)) && (i = th(e[0], e[e.length - 1], l(t) ? 10 : t, this._isUtc)), i && this.domain(yl(e, i)), this
      );
    }
    utc() {
      return this._isUtc;
    }
  }
  const ih = Symbol('implicit');
  class nh {
    constructor() {
      this.type = qo.Identity;
    }
    specified(t) {
      var e;
      return t
        ? ((this._specified = Object.assign(null !== (e = this._specified) && void 0 !== e ? e : {}, t)), this)
        : Object.assign({}, this._specified);
    }
    _getSpecifiedValue(t) {
      if (this._specified) return this._specified[t];
    }
    clone() {
      return new nh().unknown(this._unknown).domain(this._domain).specified(this._specified);
    }
    scale(t) {
      const e = `${t}`,
        i = this._getSpecifiedValue(e);
      return void 0 !== i ? i : this._unknown !== ih && this._domain && !this._domain.includes(t) ? this._unknown : t;
    }
    invert(t) {
      return t;
    }
    domain(t) {
      return t ? ((this._domain = t), this) : this._domain ? this._domain.slice() : void 0;
    }
    range(t) {
      return t ? this : this._domain ? this._domain.slice() : void 0;
    }
    unknown(t) {
      return arguments.length ? ((this._unknown = t), this) : this._unknown;
    }
  }
  var sh = function (t) {
      return t && t.Math == Math && t;
    },
    rh =
      sh('object' == typeof globalThis && globalThis) ||
      sh('object' == typeof window && window) ||
      sh('object' == typeof self && self) ||
      sh('object' == typeof e && e) ||
      (function () {
        return this;
      })() ||
      e ||
      Function('return this')(),
    ah = {},
    oh = function (t) {
      try {
        return !!t();
      } catch (t) {
        return !0;
      }
    },
    lh = !oh(function () {
      return (
        7 !=
        Object.defineProperty({}, 1, {
          get: function () {
            return 7;
          }
        })[1]
      );
    }),
    hh = !oh(function () {
      var t = function () {}.bind();
      return 'function' != typeof t || t.hasOwnProperty('prototype');
    }),
    ch = hh,
    dh = Function.prototype.call,
    uh = ch
      ? dh.bind(dh)
      : function () {
          return dh.apply(dh, arguments);
        },
    ph = {},
    gh = {}.propertyIsEnumerable,
    fh = Object.getOwnPropertyDescriptor,
    vh = fh && !gh.call({ 1: 2 }, 1);
  ph.f = vh
    ? function (t) {
        var e = fh(this, t);
        return !!e && e.enumerable;
      }
    : gh;
  var mh,
    yh,
    _h = function (t, e) {
      return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e };
    },
    bh = hh,
    xh = Function.prototype,
    Sh = xh.call,
    wh = bh && xh.bind.bind(Sh, Sh),
    Ah = bh
      ? wh
      : function (t) {
          return function () {
            return Sh.apply(t, arguments);
          };
        },
    kh = Ah,
    Mh = kh({}.toString),
    Th = kh(''.slice),
    Ch = function (t) {
      return Th(Mh(t), 8, -1);
    },
    Eh = oh,
    Ph = Ch,
    Rh = Object,
    Oh = Ah(''.split),
    Bh = Eh(function () {
      return !Rh('z').propertyIsEnumerable(0);
    })
      ? function (t) {
          return 'String' == Ph(t) ? Oh(t, '') : Rh(t);
        }
      : Rh,
    Ih = function (t) {
      return null == t;
    },
    Dh = Ih,
    Lh = TypeError,
    Fh = function (t) {
      if (Dh(t)) throw Lh("Can't call method on " + t);
      return t;
    },
    jh = Bh,
    zh = Fh,
    Hh = function (t) {
      return jh(zh(t));
    },
    Nh = 'object' == typeof document && document.all,
    Vh = { all: Nh, IS_HTMLDDA: void 0 === Nh && void 0 !== Nh },
    Wh = Vh.all,
    Gh = Vh.IS_HTMLDDA
      ? function (t) {
          return 'function' == typeof t || t === Wh;
        }
      : function (t) {
          return 'function' == typeof t;
        },
    Uh = Gh,
    Yh = Vh.all,
    $h = Vh.IS_HTMLDDA
      ? function (t) {
          return 'object' == typeof t ? null !== t : Uh(t) || t === Yh;
        }
      : function (t) {
          return 'object' == typeof t ? null !== t : Uh(t);
        },
    Xh = rh,
    Kh = Gh,
    qh = function (t, e) {
      return arguments.length < 2 ? ((i = Xh[t]), Kh(i) ? i : void 0) : Xh[t] && Xh[t][e];
      var i;
    },
    Zh = Ah({}.isPrototypeOf),
    Jh = rh,
    Qh = ('undefined' != typeof navigator && String(navigator.userAgent)) || '',
    tc = Jh.process,
    ec = Jh.Deno,
    ic = (tc && tc.versions) || (ec && ec.version),
    nc = ic && ic.v8;
  nc && (yh = (mh = nc.split('.'))[0] > 0 && mh[0] < 4 ? 1 : +(mh[0] + mh[1])),
    !yh && Qh && (!(mh = Qh.match(/Edge\/(\d+)/)) || mh[1] >= 74) && (mh = Qh.match(/Chrome\/(\d+)/)) && (yh = +mh[1]);
  var sc = yh,
    rc = oh,
    ac = rh.String,
    oc =
      !!Object.getOwnPropertySymbols &&
      !rc(function () {
        var t = Symbol();
        return !ac(t) || !(Object(t) instanceof Symbol) || (!Symbol.sham && sc && sc < 41);
      }),
    lc = oc && !Symbol.sham && 'symbol' == typeof Symbol.iterator,
    hc = qh,
    cc = Gh,
    dc = Zh,
    uc = Object,
    pc = lc
      ? function (t) {
          return 'symbol' == typeof t;
        }
      : function (t) {
          var e = hc('Symbol');
          return cc(e) && dc(e.prototype, uc(t));
        },
    gc = String,
    fc = function (t) {
      try {
        return gc(t);
      } catch (t) {
        return 'Object';
      }
    },
    vc = Gh,
    mc = fc,
    yc = TypeError,
    _c = function (t) {
      if (vc(t)) return t;
      throw yc(mc(t) + ' is not a function');
    },
    bc = _c,
    xc = Ih,
    Sc = function (t, e) {
      var i = t[e];
      return xc(i) ? void 0 : bc(i);
    },
    wc = uh,
    Ac = Gh,
    kc = $h,
    Mc = TypeError,
    Tc = { exports: {} },
    Cc = rh,
    Ec = Object.defineProperty,
    Pc = function (t, e) {
      try {
        Ec(Cc, t, { value: e, configurable: !0, writable: !0 });
      } catch (i) {
        Cc[t] = e;
      }
      return e;
    },
    Rc = Pc,
    Oc = '__core-js_shared__',
    Bc = rh[Oc] || Rc(Oc, {}),
    Ic = Bc;
  (Tc.exports = function (t, e) {
    return Ic[t] || (Ic[t] = void 0 !== e ? e : {});
  })('versions', []).push({
    version: '3.31.1',
    mode: 'global',
    copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',
    license: 'https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE',
    source: 'https://github.com/zloirock/core-js'
  });
  var Dc = Tc.exports,
    Lc = Fh,
    Fc = Object,
    jc = function (t) {
      return Fc(Lc(t));
    },
    zc = jc,
    Hc = Ah({}.hasOwnProperty),
    Nc =
      Object.hasOwn ||
      function (t, e) {
        return Hc(zc(t), e);
      },
    Vc = Ah,
    Wc = 0,
    Gc = Math.random(),
    Uc = Vc((1).toString),
    Yc = function (t) {
      return 'Symbol(' + (void 0 === t ? '' : t) + ')_' + Uc(++Wc + Gc, 36);
    },
    $c = Dc,
    Xc = Nc,
    Kc = Yc,
    qc = oc,
    Zc = lc,
    Jc = rh.Symbol,
    Qc = $c('wks'),
    td = Zc ? Jc.for || Jc : (Jc && Jc.withoutSetter) || Kc,
    ed = function (t) {
      return Xc(Qc, t) || (Qc[t] = qc && Xc(Jc, t) ? Jc[t] : td('Symbol.' + t)), Qc[t];
    },
    id = uh,
    nd = $h,
    sd = pc,
    rd = Sc,
    ad = function (t, e) {
      var i, n;
      if ('string' === e && Ac((i = t.toString)) && !kc((n = wc(i, t)))) return n;
      if (Ac((i = t.valueOf)) && !kc((n = wc(i, t)))) return n;
      if ('string' !== e && Ac((i = t.toString)) && !kc((n = wc(i, t)))) return n;
      throw Mc("Can't convert object to primitive value");
    },
    od = TypeError,
    ld = ed('toPrimitive'),
    hd = function (t, e) {
      if (!nd(t) || sd(t)) return t;
      var i,
        n = rd(t, ld);
      if (n) {
        if ((void 0 === e && (e = 'default'), (i = id(n, t, e)), !nd(i) || sd(i))) return i;
        throw od("Can't convert object to primitive value");
      }
      return void 0 === e && (e = 'number'), ad(t, e);
    },
    cd = pc,
    dd = function (t) {
      var e = hd(t, 'string');
      return cd(e) ? e : e + '';
    },
    ud = $h,
    pd = rh.document,
    gd = ud(pd) && ud(pd.createElement),
    fd = function (t) {
      return gd ? pd.createElement(t) : {};
    },
    vd = fd,
    md =
      !lh &&
      !oh(function () {
        return (
          7 !=
          Object.defineProperty(vd('div'), 'a', {
            get: function () {
              return 7;
            }
          }).a
        );
      }),
    yd = lh,
    _d = uh,
    bd = ph,
    xd = _h,
    Sd = Hh,
    wd = dd,
    Ad = Nc,
    kd = md,
    Md = Object.getOwnPropertyDescriptor;
  ah.f = yd
    ? Md
    : function (t, e) {
        if (((t = Sd(t)), (e = wd(e)), kd))
          try {
            return Md(t, e);
          } catch (t) {}
        if (Ad(t, e)) return xd(!_d(bd.f, t, e), t[e]);
      };
  var Td = {},
    Cd =
      lh &&
      oh(function () {
        return 42 != Object.defineProperty(function () {}, 'prototype', { value: 42, writable: !1 }).prototype;
      }),
    Ed = $h,
    Pd = String,
    Rd = TypeError,
    Od = function (t) {
      if (Ed(t)) return t;
      throw Rd(Pd(t) + ' is not an object');
    },
    Bd = lh,
    Id = md,
    Dd = Cd,
    Ld = Od,
    Fd = dd,
    jd = TypeError,
    zd = Object.defineProperty,
    Hd = Object.getOwnPropertyDescriptor,
    Nd = 'enumerable',
    Vd = 'configurable',
    Wd = 'writable';
  Td.f = Bd
    ? Dd
      ? function (t, e, i) {
          if (
            (Ld(t),
            (e = Fd(e)),
            Ld(i),
            'function' == typeof t && 'prototype' === e && 'value' in i && Wd in i && !i[Wd])
          ) {
            var n = Hd(t, e);
            n &&
              n[Wd] &&
              ((t[e] = i.value),
              (i = { configurable: Vd in i ? i[Vd] : n[Vd], enumerable: Nd in i ? i[Nd] : n[Nd], writable: !1 }));
          }
          return zd(t, e, i);
        }
      : zd
    : function (t, e, i) {
        if ((Ld(t), (e = Fd(e)), Ld(i), Id))
          try {
            return zd(t, e, i);
          } catch (t) {}
        if ('get' in i || 'set' in i) throw jd('Accessors not supported');
        return 'value' in i && (t[e] = i.value), t;
      };
  var Gd = Td,
    Ud = _h,
    Yd = lh
      ? function (t, e, i) {
          return Gd.f(t, e, Ud(1, i));
        }
      : function (t, e, i) {
          return (t[e] = i), t;
        },
    $d = { exports: {} },
    Xd = lh,
    Kd = Nc,
    qd = Function.prototype,
    Zd = Xd && Object.getOwnPropertyDescriptor,
    Jd = Kd(qd, 'name'),
    Qd = {
      EXISTS: Jd,
      PROPER: Jd && 'something' === function () {}.name,
      CONFIGURABLE: Jd && (!Xd || (Xd && Zd(qd, 'name').configurable))
    },
    tu = Gh,
    eu = Bc,
    iu = Ah(Function.toString);
  tu(eu.inspectSource) ||
    (eu.inspectSource = function (t) {
      return iu(t);
    });
  var nu,
    su,
    ru,
    au = eu.inspectSource,
    ou = Gh,
    lu = rh.WeakMap,
    hu = ou(lu) && /native code/.test(String(lu)),
    cu = Yc,
    du = Dc('keys'),
    uu = function (t) {
      return du[t] || (du[t] = cu(t));
    },
    pu = {},
    gu = hu,
    fu = rh,
    vu = $h,
    mu = Yd,
    yu = Nc,
    _u = Bc,
    bu = uu,
    xu = pu,
    Su = 'Object already initialized',
    wu = fu.TypeError,
    Au = fu.WeakMap;
  if (gu || _u.state) {
    var ku = _u.state || (_u.state = new Au());
    (ku.get = ku.get),
      (ku.has = ku.has),
      (ku.set = ku.set),
      (nu = function (t, e) {
        if (ku.has(t)) throw wu(Su);
        return (e.facade = t), ku.set(t, e), e;
      }),
      (su = function (t) {
        return ku.get(t) || {};
      }),
      (ru = function (t) {
        return ku.has(t);
      });
  } else {
    var Mu = bu('state');
    (xu[Mu] = !0),
      (nu = function (t, e) {
        if (yu(t, Mu)) throw wu(Su);
        return (e.facade = t), mu(t, Mu, e), e;
      }),
      (su = function (t) {
        return yu(t, Mu) ? t[Mu] : {};
      }),
      (ru = function (t) {
        return yu(t, Mu);
      });
  }
  var Tu = {
      set: nu,
      get: su,
      has: ru,
      enforce: function (t) {
        return ru(t) ? su(t) : nu(t, {});
      },
      getterFor: function (t) {
        return function (e) {
          var i;
          if (!vu(e) || (i = su(e)).type !== t) throw wu('Incompatible receiver, ' + t + ' required');
          return i;
        };
      }
    },
    Cu = Ah,
    Eu = oh,
    Pu = Gh,
    Ru = Nc,
    Ou = lh,
    Bu = Qd.CONFIGURABLE,
    Iu = au,
    Du = Tu.enforce,
    Lu = Tu.get,
    Fu = String,
    ju = Object.defineProperty,
    zu = Cu(''.slice),
    Hu = Cu(''.replace),
    Nu = Cu([].join),
    Vu =
      Ou &&
      !Eu(function () {
        return 8 !== ju(function () {}, 'length', { value: 8 }).length;
      }),
    Wu = String(String).split('String'),
    Gu = ($d.exports = function (t, e, i) {
      'Symbol(' === zu(Fu(e), 0, 7) && (e = '[' + Hu(Fu(e), /^Symbol\(([^)]*)\)/, '$1') + ']'),
        i && i.getter && (e = 'get ' + e),
        i && i.setter && (e = 'set ' + e),
        (!Ru(t, 'name') || (Bu && t.name !== e)) && (Ou ? ju(t, 'name', { value: e, configurable: !0 }) : (t.name = e)),
        Vu && i && Ru(i, 'arity') && t.length !== i.arity && ju(t, 'length', { value: i.arity });
      try {
        i && Ru(i, 'constructor') && i.constructor
          ? Ou && ju(t, 'prototype', { writable: !1 })
          : t.prototype && (t.prototype = void 0);
      } catch (t) {}
      var n = Du(t);
      return Ru(n, 'source') || (n.source = Nu(Wu, 'string' == typeof e ? e : '')), t;
    });
  Function.prototype.toString = Gu(function () {
    return (Pu(this) && Lu(this).source) || Iu(this);
  }, 'toString');
  var Uu = $d.exports,
    Yu = Gh,
    $u = Td,
    Xu = Uu,
    Ku = Pc,
    qu = function (t, e, i, n) {
      n || (n = {});
      var s = n.enumerable,
        r = void 0 !== n.name ? n.name : e;
      if ((Yu(i) && Xu(i, r, n), n.global)) s ? (t[e] = i) : Ku(e, i);
      else {
        try {
          n.unsafe ? t[e] && (s = !0) : delete t[e];
        } catch (t) {}
        s
          ? (t[e] = i)
          : $u.f(t, e, { value: i, enumerable: !1, configurable: !n.nonConfigurable, writable: !n.nonWritable });
      }
      return t;
    },
    Zu = {},
    Ju = Math.ceil,
    Qu = Math.floor,
    tp =
      Math.trunc ||
      function (t) {
        var e = +t;
        return (e > 0 ? Qu : Ju)(e);
      },
    ep = function (t) {
      var e = +t;
      return e != e || 0 === e ? 0 : tp(e);
    },
    ip = ep,
    np = Math.max,
    sp = Math.min,
    rp = function (t, e) {
      var i = ip(t);
      return i < 0 ? np(i + e, 0) : sp(i, e);
    },
    ap = ep,
    op = Math.min,
    lp = function (t) {
      return t > 0 ? op(ap(t), 9007199254740991) : 0;
    },
    hp = function (t) {
      return lp(t.length);
    },
    cp = Hh,
    dp = rp,
    up = hp,
    pp = function (t) {
      return function (e, i, n) {
        var s,
          r = cp(e),
          a = up(r),
          o = dp(n, a);
        if (t && i != i) {
          for (; a > o; ) if ((s = r[o++]) != s) return !0;
        } else for (; a > o; o++) if ((t || o in r) && r[o] === i) return t || o || 0;
        return !t && -1;
      };
    },
    gp = { includes: pp(!0), indexOf: pp(!1) },
    fp = Nc,
    vp = Hh,
    mp = gp.indexOf,
    yp = pu,
    _p = Ah([].push),
    bp = function (t, e) {
      var i,
        n = vp(t),
        s = 0,
        r = [];
      for (i in n) !fp(yp, i) && fp(n, i) && _p(r, i);
      for (; e.length > s; ) fp(n, (i = e[s++])) && (~mp(r, i) || _p(r, i));
      return r;
    },
    xp = [
      'constructor',
      'hasOwnProperty',
      'isPrototypeOf',
      'propertyIsEnumerable',
      'toLocaleString',
      'toString',
      'valueOf'
    ],
    Sp = bp,
    wp = xp.concat('length', 'prototype');
  Zu.f =
    Object.getOwnPropertyNames ||
    function (t) {
      return Sp(t, wp);
    };
  var Ap = {};
  Ap.f = Object.getOwnPropertySymbols;
  var kp = qh,
    Mp = Zu,
    Tp = Ap,
    Cp = Od,
    Ep = Ah([].concat),
    Pp =
      kp('Reflect', 'ownKeys') ||
      function (t) {
        var e = Mp.f(Cp(t)),
          i = Tp.f;
        return i ? Ep(e, i(t)) : e;
      },
    Rp = Nc,
    Op = Pp,
    Bp = ah,
    Ip = Td,
    Dp = oh,
    Lp = Gh,
    Fp = /#|\.prototype\./,
    jp = function (t, e) {
      var i = Hp[zp(t)];
      return i == Vp || (i != Np && (Lp(e) ? Dp(e) : !!e));
    },
    zp = (jp.normalize = function (t) {
      return String(t).replace(Fp, '.').toLowerCase();
    }),
    Hp = (jp.data = {}),
    Np = (jp.NATIVE = 'N'),
    Vp = (jp.POLYFILL = 'P'),
    Wp = jp,
    Gp = rh,
    Up = ah.f,
    Yp = Yd,
    $p = qu,
    Xp = Pc,
    Kp = function (t, e, i) {
      for (var n = Op(e), s = Ip.f, r = Bp.f, a = 0; a < n.length; a++) {
        var o = n[a];
        Rp(t, o) || (i && Rp(i, o)) || s(t, o, r(e, o));
      }
    },
    qp = Wp,
    Zp = function (t, e) {
      var i,
        n,
        s,
        r,
        a,
        o = t.target,
        l = t.global,
        h = t.stat;
      if ((i = l ? Gp : h ? Gp[o] || Xp(o, {}) : (Gp[o] || {}).prototype))
        for (n in e) {
          if (
            ((r = e[n]),
            (s = t.dontCallGetSet ? (a = Up(i, n)) && a.value : i[n]),
            !qp(l ? n : o + (h ? '.' : '#') + n, t.forced) && void 0 !== s)
          ) {
            if (typeof r == typeof s) continue;
            Kp(r, s);
          }
          (t.sham || (s && s.sham)) && Yp(r, 'sham', !0), $p(i, n, r, t);
        }
    },
    Jp = { exports: {} },
    Qp = {},
    tg = dd,
    eg = Td,
    ig = _h,
    ng = rp,
    sg = hp,
    rg = function (t, e, i) {
      var n = tg(e);
      n in t ? eg.f(t, n, ig(0, i)) : (t[n] = i);
    },
    ag = Array,
    og = Math.max,
    lg = Ch,
    hg = Hh,
    cg = Zu.f,
    dg = function (t, e, i) {
      for (var n = sg(t), s = ng(e, n), r = ng(void 0 === i ? n : i, n), a = ag(og(r - s, 0)), o = 0; s < r; s++, o++)
        rg(a, o, t[s]);
      return (a.length = o), a;
    },
    ug = 'object' == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  Qp.f = function (t) {
    return ug && 'Window' == lg(t)
      ? (function (t) {
          try {
            return cg(t);
          } catch (t) {
            return dg(ug);
          }
        })(t)
      : cg(hg(t));
  };
  var pg = oh(function () {
      if ('function' == typeof ArrayBuffer) {
        var t = new ArrayBuffer(8);
        Object.isExtensible(t) && Object.defineProperty(t, 'a', { value: 8 });
      }
    }),
    gg = oh,
    fg = $h,
    vg = Ch,
    mg = pg,
    yg = Object.isExtensible,
    _g =
      gg(function () {
        yg(1);
      }) || mg
        ? function (t) {
            return !!fg(t) && (!mg || 'ArrayBuffer' != vg(t)) && (!yg || yg(t));
          }
        : yg,
    bg = !oh(function () {
      return Object.isExtensible(Object.preventExtensions({}));
    }),
    xg = Zp,
    Sg = Ah,
    wg = pu,
    Ag = $h,
    kg = Nc,
    Mg = Td.f,
    Tg = Zu,
    Cg = Qp,
    Eg = _g,
    Pg = bg,
    Rg = !1,
    Og = Yc('meta'),
    Bg = 0,
    Ig = function (t) {
      Mg(t, Og, { value: { objectID: 'O' + Bg++, weakData: {} } });
    },
    Dg = (Jp.exports = {
      enable: function () {
        (Dg.enable = function () {}), (Rg = !0);
        var t = Tg.f,
          e = Sg([].splice),
          i = {};
        (i[Og] = 1),
          t(i).length &&
            ((Tg.f = function (i) {
              for (var n = t(i), s = 0, r = n.length; s < r; s++)
                if (n[s] === Og) {
                  e(n, s, 1);
                  break;
                }
              return n;
            }),
            xg({ target: 'Object', stat: !0, forced: !0 }, { getOwnPropertyNames: Cg.f }));
      },
      fastKey: function (t, e) {
        if (!Ag(t)) return 'symbol' == typeof t ? t : ('string' == typeof t ? 'S' : 'P') + t;
        if (!kg(t, Og)) {
          if (!Eg(t)) return 'F';
          if (!e) return 'E';
          Ig(t);
        }
        return t[Og].objectID;
      },
      getWeakData: function (t, e) {
        if (!kg(t, Og)) {
          if (!Eg(t)) return !0;
          if (!e) return !1;
          Ig(t);
        }
        return t[Og].weakData;
      },
      onFreeze: function (t) {
        return Pg && Rg && Eg(t) && !kg(t, Og) && Ig(t), t;
      }
    });
  wg[Og] = !0;
  var Lg = Jp.exports,
    Fg = Ch,
    jg = Ah,
    zg = function (t) {
      if ('Function' === Fg(t)) return jg(t);
    },
    Hg = _c,
    Ng = hh,
    Vg = zg(zg.bind),
    Wg = function (t, e) {
      return (
        Hg(t),
        void 0 === e
          ? t
          : Ng
          ? Vg(t, e)
          : function () {
              return t.apply(e, arguments);
            }
      );
    },
    Gg = {},
    Ug = Gg,
    Yg = ed('iterator'),
    $g = Array.prototype,
    Xg = {};
  Xg[ed('toStringTag')] = 'z';
  var Kg = '[object z]' === String(Xg),
    qg = Gh,
    Zg = Ch,
    Jg = ed('toStringTag'),
    Qg = Object,
    tf =
      'Arguments' ==
      Zg(
        (function () {
          return arguments;
        })()
      ),
    ef = Kg
      ? Zg
      : function (t) {
          var e, i, n;
          return void 0 === t
            ? 'Undefined'
            : null === t
            ? 'Null'
            : 'string' ==
              typeof (i = (function (t, e) {
                try {
                  return t[e];
                } catch (t) {}
              })((e = Qg(t)), Jg))
            ? i
            : tf
            ? Zg(e)
            : 'Object' == (n = Zg(e)) && qg(e.callee)
            ? 'Arguments'
            : n;
        },
    nf = ef,
    sf = Sc,
    rf = Ih,
    af = Gg,
    of = ed('iterator'),
    lf = function (t) {
      if (!rf(t)) return sf(t, of) || sf(t, '@@iterator') || af[nf(t)];
    },
    hf = uh,
    cf = _c,
    df = Od,
    uf = fc,
    pf = lf,
    gf = TypeError,
    ff = uh,
    vf = Od,
    mf = Sc,
    yf = Wg,
    _f = uh,
    bf = Od,
    xf = fc,
    Sf = function (t) {
      return void 0 !== t && (Ug.Array === t || $g[Yg] === t);
    },
    wf = hp,
    Af = Zh,
    kf = function (t, e) {
      var i = arguments.length < 2 ? pf(t) : e;
      if (cf(i)) return df(hf(i, t));
      throw gf(uf(t) + ' is not iterable');
    },
    Mf = lf,
    Tf = function (t, e, i) {
      var n, s;
      vf(t);
      try {
        if (!(n = mf(t, 'return'))) {
          if ('throw' === e) throw i;
          return i;
        }
        n = ff(n, t);
      } catch (t) {
        (s = !0), (n = t);
      }
      if ('throw' === e) throw i;
      if (s) throw n;
      return vf(n), i;
    },
    Cf = TypeError,
    Ef = function (t, e) {
      (this.stopped = t), (this.result = e);
    },
    Pf = Ef.prototype,
    Rf = function (t, e, i) {
      var n,
        s,
        r,
        a,
        o,
        l,
        h,
        c = i && i.that,
        d = !(!i || !i.AS_ENTRIES),
        u = !(!i || !i.IS_RECORD),
        p = !(!i || !i.IS_ITERATOR),
        g = !(!i || !i.INTERRUPTED),
        f = yf(e, c),
        v = function (t) {
          return n && Tf(n, 'normal', t), new Ef(!0, t);
        },
        m = function (t) {
          return d ? (bf(t), g ? f(t[0], t[1], v) : f(t[0], t[1])) : g ? f(t, v) : f(t);
        };
      if (u) n = t.iterator;
      else if (p) n = t;
      else {
        if (!(s = Mf(t))) throw Cf(xf(t) + ' is not iterable');
        if (Sf(s)) {
          for (r = 0, a = wf(t); a > r; r++) if ((o = m(t[r])) && Af(Pf, o)) return o;
          return new Ef(!1);
        }
        n = kf(t, s);
      }
      for (l = u ? t.next : n.next; !(h = _f(l, n)).done; ) {
        try {
          o = m(h.value);
        } catch (t) {
          Tf(n, 'throw', t);
        }
        if ('object' == typeof o && o && Af(Pf, o)) return o;
      }
      return new Ef(!1);
    },
    Of = Zh,
    Bf = TypeError,
    If = function (t, e) {
      if (Of(e, t)) return t;
      throw Bf('Incorrect invocation');
    },
    Df = ed('iterator'),
    Lf = !1;
  try {
    var Ff = 0,
      jf = {
        next: function () {
          return { done: !!Ff++ };
        },
        return: function () {
          Lf = !0;
        }
      };
    (jf[Df] = function () {
      return this;
    }),
      Array.from(jf, function () {
        throw 2;
      });
  } catch (Lo) {}
  var zf = Td.f,
    Hf = Nc,
    Nf = ed('toStringTag'),
    Vf = function (t, e, i) {
      t && !i && (t = t.prototype), t && !Hf(t, Nf) && zf(t, Nf, { configurable: !0, value: e });
    },
    Wf = Ah,
    Gf = _c,
    Uf = Gh,
    Yf = String,
    $f = TypeError,
    Xf = function (t, e, i) {
      try {
        return Wf(Gf(Object.getOwnPropertyDescriptor(t, e)[i]));
      } catch (t) {}
    },
    Kf = Od,
    qf = function (t) {
      if ('object' == typeof t || Uf(t)) return t;
      throw $f("Can't set " + Yf(t) + ' as a prototype');
    },
    Zf =
      Object.setPrototypeOf ||
      ('__proto__' in {}
        ? (function () {
            var t,
              e = !1,
              i = {};
            try {
              (t = Xf(Object.prototype, '__proto__', 'set'))(i, []), (e = i instanceof Array);
            } catch (t) {}
            return function (i, n) {
              return Kf(i), qf(n), e ? t(i, n) : (i.__proto__ = n), i;
            };
          })()
        : void 0),
    Jf = Gh,
    Qf = $h,
    tv = Zf,
    ev = Zp,
    iv = rh,
    nv = Ah,
    sv = Wp,
    rv = qu,
    av = Lg,
    ov = Rf,
    lv = If,
    hv = Gh,
    cv = Ih,
    dv = $h,
    uv = oh,
    pv = function (t, e) {
      if (!e && !Lf) return !1;
      var i = !1;
      try {
        var n = {};
        (n[Df] = function () {
          return {
            next: function () {
              return { done: (i = !0) };
            }
          };
        }),
          t(n);
      } catch (t) {}
      return i;
    },
    gv = Vf,
    fv = function (t, e, i) {
      var n, s;
      return tv && Jf((n = e.constructor)) && n !== i && Qf((s = n.prototype)) && s !== i.prototype && tv(t, s), t;
    },
    vv = function (t, e, i) {
      var n = -1 !== t.indexOf('Map'),
        s = -1 !== t.indexOf('Weak'),
        r = n ? 'set' : 'add',
        a = iv[t],
        o = a && a.prototype,
        l = a,
        h = {},
        c = function (t) {
          var e = nv(o[t]);
          rv(
            o,
            t,
            'add' == t
              ? function (t) {
                  return e(this, 0 === t ? 0 : t), this;
                }
              : 'delete' == t
              ? function (t) {
                  return !(s && !dv(t)) && e(this, 0 === t ? 0 : t);
                }
              : 'get' == t
              ? function (t) {
                  return s && !dv(t) ? void 0 : e(this, 0 === t ? 0 : t);
                }
              : 'has' == t
              ? function (t) {
                  return !(s && !dv(t)) && e(this, 0 === t ? 0 : t);
                }
              : function (t, i) {
                  return e(this, 0 === t ? 0 : t, i), this;
                }
          );
        };
      if (
        sv(
          t,
          !hv(a) ||
            !(
              s ||
              (o.forEach &&
                !uv(function () {
                  new a().entries().next();
                }))
            )
        )
      )
        (l = i.getConstructor(e, t, n, r)), av.enable();
      else if (sv(t, !0)) {
        var d = new l(),
          u = d[r](s ? {} : -0, 1) != d,
          p = uv(function () {
            d.has(1);
          }),
          g = pv(function (t) {
            new a(t);
          }),
          f =
            !s &&
            uv(function () {
              for (var t = new a(), e = 5; e--; ) t[r](e, e);
              return !t.has(-0);
            });
        g ||
          (((l = e(function (t, e) {
            lv(t, o);
            var i = fv(new a(), t, l);
            return cv(e) || ov(e, i[r], { that: i, AS_ENTRIES: n }), i;
          })).prototype = o),
          (o.constructor = l)),
          (p || f) && (c('delete'), c('has'), n && c('get')),
          (f || u) && c(r),
          s && o.clear && delete o.clear;
      }
      return (h[t] = l), ev({ global: !0, constructor: !0, forced: l != a }, h), gv(l, t), s || i.setStrong(l, t, n), l;
    },
    mv = {},
    yv = bp,
    _v = xp,
    bv =
      Object.keys ||
      function (t) {
        return yv(t, _v);
      },
    xv = lh,
    Sv = Cd,
    wv = Td,
    Av = Od,
    kv = Hh,
    Mv = bv;
  mv.f =
    xv && !Sv
      ? Object.defineProperties
      : function (t, e) {
          Av(t);
          for (var i, n = kv(e), s = Mv(e), r = s.length, a = 0; r > a; ) wv.f(t, (i = s[a++]), n[i]);
          return t;
        };
  var Tv,
    Cv = qh('document', 'documentElement'),
    Ev = Od,
    Pv = mv,
    Rv = xp,
    Ov = pu,
    Bv = Cv,
    Iv = fd,
    Dv = 'prototype',
    Lv = 'script',
    Fv = uu('IE_PROTO'),
    jv = function () {},
    zv = function (t) {
      return '<' + Lv + '>' + t + '</' + Lv + '>';
    },
    Hv = function (t) {
      t.write(zv('')), t.close();
      var e = t.parentWindow.Object;
      return (t = null), e;
    },
    Nv = function () {
      try {
        Tv = new ActiveXObject('htmlfile');
      } catch (t) {}
      var t, e, i;
      Nv =
        'undefined' != typeof document
          ? document.domain && Tv
            ? Hv(Tv)
            : ((e = Iv('iframe')),
              (i = 'java' + Lv + ':'),
              (e.style.display = 'none'),
              Bv.appendChild(e),
              (e.src = String(i)),
              (t = e.contentWindow.document).open(),
              t.write(zv('document.F=Object')),
              t.close(),
              t.F)
          : Hv(Tv);
      for (var n = Rv.length; n--; ) delete Nv[Dv][Rv[n]];
      return Nv();
    };
  Ov[Fv] = !0;
  var Vv,
    Wv,
    Gv,
    Uv =
      Object.create ||
      function (t, e) {
        var i;
        return (
          null !== t ? ((jv[Dv] = Ev(t)), (i = new jv()), (jv[Dv] = null), (i[Fv] = t)) : (i = Nv()),
          void 0 === e ? i : Pv.f(i, e)
        );
      },
    Yv = Uu,
    $v = Td,
    Xv = function (t, e, i) {
      return i.get && Yv(i.get, e, { getter: !0 }), i.set && Yv(i.set, e, { setter: !0 }), $v.f(t, e, i);
    },
    Kv = qu,
    qv = function (t, e, i) {
      for (var n in e) Kv(t, n, e[n], i);
      return t;
    },
    Zv = !oh(function () {
      function t() {}
      return (t.prototype.constructor = null), Object.getPrototypeOf(new t()) !== t.prototype;
    }),
    Jv = Nc,
    Qv = Gh,
    tm = jc,
    em = Zv,
    im = uu('IE_PROTO'),
    nm = Object,
    sm = nm.prototype,
    rm = em
      ? nm.getPrototypeOf
      : function (t) {
          var e = tm(t);
          if (Jv(e, im)) return e[im];
          var i = e.constructor;
          return Qv(i) && e instanceof i ? i.prototype : e instanceof nm ? sm : null;
        },
    am = oh,
    om = Gh,
    lm = $h,
    hm = rm,
    cm = qu,
    dm = ed('iterator'),
    um = !1;
  [].keys && ('next' in (Gv = [].keys()) ? (Wv = hm(hm(Gv))) !== Object.prototype && (Vv = Wv) : (um = !0));
  var pm =
    !lm(Vv) ||
    am(function () {
      var t = {};
      return Vv[dm].call(t) !== t;
    });
  pm && (Vv = {}),
    om(Vv[dm]) ||
      cm(Vv, dm, function () {
        return this;
      });
  var gm = { IteratorPrototype: Vv, BUGGY_SAFARI_ITERATORS: um },
    fm = gm.IteratorPrototype,
    vm = Uv,
    mm = _h,
    ym = Vf,
    _m = Gg,
    bm = function () {
      return this;
    },
    xm = Zp,
    Sm = uh,
    wm = Gh,
    Am = function (t, e, i, n) {
      var s = e + ' Iterator';
      return (t.prototype = vm(fm, { next: mm(+!n, i) })), ym(t, s, !1), (_m[s] = bm), t;
    },
    km = rm,
    Mm = Zf,
    Tm = Vf,
    Cm = Yd,
    Em = qu,
    Pm = Gg,
    Rm = Qd.PROPER,
    Om = Qd.CONFIGURABLE,
    Bm = gm.IteratorPrototype,
    Im = gm.BUGGY_SAFARI_ITERATORS,
    Dm = ed('iterator'),
    Lm = 'keys',
    Fm = 'values',
    jm = 'entries',
    zm = function () {
      return this;
    },
    Hm = qh,
    Nm = Xv,
    Vm = lh,
    Wm = ed('species'),
    Gm = Uv,
    Um = Xv,
    Ym = qv,
    $m = Wg,
    Xm = If,
    Km = Ih,
    qm = Rf,
    Zm = function (t, e, i, n, s, r, a) {
      Am(i, e, n);
      var o,
        l,
        h,
        c = function (t) {
          if (t === s && f) return f;
          if (!Im && t in p) return p[t];
          switch (t) {
            case Lm:
            case Fm:
            case jm:
              return function () {
                return new i(this, t);
              };
          }
          return function () {
            return new i(this);
          };
        },
        d = e + ' Iterator',
        u = !1,
        p = t.prototype,
        g = p[Dm] || p['@@iterator'] || (s && p[s]),
        f = (!Im && g) || c(s),
        v = ('Array' == e && p.entries) || g;
      if (
        (v &&
          (o = km(v.call(new t()))) !== Object.prototype &&
          o.next &&
          (km(o) !== Bm && (Mm ? Mm(o, Bm) : wm(o[Dm]) || Em(o, Dm, zm)), Tm(o, d, !0)),
        Rm &&
          s == Fm &&
          g &&
          g.name !== Fm &&
          (Om
            ? Cm(p, 'name', Fm)
            : ((u = !0),
              (f = function () {
                return Sm(g, this);
              }))),
        s)
      )
        if (((l = { values: c(Fm), keys: r ? f : c(Lm), entries: c(jm) }), a))
          for (h in l) (Im || u || !(h in p)) && Em(p, h, l[h]);
        else xm({ target: e, proto: !0, forced: Im || u }, l);
      return p[Dm] !== f && Em(p, Dm, f, { name: s }), (Pm[e] = f), l;
    },
    Jm = function (t, e) {
      return { value: t, done: e };
    },
    Qm = function (t) {
      var e = Hm(t);
      Vm &&
        e &&
        !e[Wm] &&
        Nm(e, Wm, {
          configurable: !0,
          get: function () {
            return this;
          }
        });
    },
    ty = lh,
    ey = Lg.fastKey,
    iy = Tu.set,
    ny = Tu.getterFor,
    sy = {
      getConstructor: function (t, e, i, n) {
        var s = t(function (t, s) {
            Xm(t, r),
              iy(t, { type: e, index: Gm(null), first: void 0, last: void 0, size: 0 }),
              ty || (t.size = 0),
              Km(s) || qm(s, t[n], { that: t, AS_ENTRIES: i });
          }),
          r = s.prototype,
          a = ny(e),
          o = function (t, e, i) {
            var n,
              s,
              r = a(t),
              o = l(t, e);
            return (
              o
                ? (o.value = i)
                : ((r.last = o =
                    { index: (s = ey(e, !0)), key: e, value: i, previous: (n = r.last), next: void 0, removed: !1 }),
                  r.first || (r.first = o),
                  n && (n.next = o),
                  ty ? r.size++ : t.size++,
                  'F' !== s && (r.index[s] = o)),
              t
            );
          },
          l = function (t, e) {
            var i,
              n = a(t),
              s = ey(e);
            if ('F' !== s) return n.index[s];
            for (i = n.first; i; i = i.next) if (i.key == e) return i;
          };
        return (
          Ym(r, {
            clear: function () {
              for (var t = a(this), e = t.index, i = t.first; i; )
                (i.removed = !0),
                  i.previous && (i.previous = i.previous.next = void 0),
                  delete e[i.index],
                  (i = i.next);
              (t.first = t.last = void 0), ty ? (t.size = 0) : (this.size = 0);
            },
            delete: function (t) {
              var e = this,
                i = a(e),
                n = l(e, t);
              if (n) {
                var s = n.next,
                  r = n.previous;
                delete i.index[n.index],
                  (n.removed = !0),
                  r && (r.next = s),
                  s && (s.previous = r),
                  i.first == n && (i.first = s),
                  i.last == n && (i.last = r),
                  ty ? i.size-- : e.size--;
              }
              return !!n;
            },
            forEach: function (t) {
              for (
                var e, i = a(this), n = $m(t, arguments.length > 1 ? arguments[1] : void 0);
                (e = e ? e.next : i.first);

              )
                for (n(e.value, e.key, this); e && e.removed; ) e = e.previous;
            },
            has: function (t) {
              return !!l(this, t);
            }
          }),
          Ym(
            r,
            i
              ? {
                  get: function (t) {
                    var e = l(this, t);
                    return e && e.value;
                  },
                  set: function (t, e) {
                    return o(this, 0 === t ? 0 : t, e);
                  }
                }
              : {
                  add: function (t) {
                    return o(this, (t = 0 === t ? 0 : t), t);
                  }
                }
          ),
          ty &&
            Um(r, 'size', {
              configurable: !0,
              get: function () {
                return a(this).size;
              }
            }),
          s
        );
      },
      setStrong: function (t, e, i) {
        var n = e + ' Iterator',
          s = ny(e),
          r = ny(n);
        Zm(
          t,
          e,
          function (t, e) {
            iy(this, { type: n, target: t, state: s(t), kind: e, last: void 0 });
          },
          function () {
            for (var t = r(this), e = t.kind, i = t.last; i && i.removed; ) i = i.previous;
            return t.target && (t.last = i = i ? i.next : t.state.first)
              ? Jm('keys' == e ? i.key : 'values' == e ? i.value : [i.key, i.value], !1)
              : ((t.target = void 0), Jm(void 0, !0));
          },
          i ? 'entries' : 'values',
          !i,
          !0
        ),
          Qm(e);
      }
    };
  vv(
    'Map',
    function (t) {
      return function () {
        return t(this, arguments.length ? arguments[0] : void 0);
      };
    },
    sy
  );
  var ry = Ch,
    ay =
      Array.isArray ||
      function (t) {
        return 'Array' == ry(t);
      },
    oy = Ah,
    ly = oh,
    hy = Gh,
    cy = ef,
    dy = au,
    uy = function () {},
    py = [],
    gy = qh('Reflect', 'construct'),
    fy = /^\s*(?:class|function)\b/,
    vy = oy(fy.exec),
    my = !fy.exec(uy),
    yy = function (t) {
      if (!hy(t)) return !1;
      try {
        return gy(uy, py, t), !0;
      } catch (t) {
        return !1;
      }
    },
    _y = function (t) {
      if (!hy(t)) return !1;
      switch (cy(t)) {
        case 'AsyncFunction':
        case 'GeneratorFunction':
        case 'AsyncGeneratorFunction':
          return !1;
      }
      try {
        return my || !!vy(fy, dy(t));
      } catch (t) {
        return !0;
      }
    };
  _y.sham = !0;
  var by =
      !gy ||
      ly(function () {
        var t;
        return (
          yy(yy.call) ||
          !yy(Object) ||
          !yy(function () {
            t = !0;
          }) ||
          t
        );
      })
        ? _y
        : yy,
    xy = ay,
    Sy = by,
    wy = $h,
    Ay = ed('species'),
    ky = Array,
    My = function (t) {
      var e;
      return (
        xy(t) &&
          ((e = t.constructor),
          ((Sy(e) && (e === ky || xy(e.prototype))) || (wy(e) && null === (e = e[Ay]))) && (e = void 0)),
        void 0 === e ? ky : e
      );
    },
    Ty = Wg,
    Cy = Bh,
    Ey = jc,
    Py = hp,
    Ry = function (t, e) {
      return new (My(t))(0 === e ? 0 : e);
    },
    Oy = Ah([].push),
    By = function (t) {
      var e = 1 == t,
        i = 2 == t,
        n = 3 == t,
        s = 4 == t,
        r = 6 == t,
        a = 7 == t,
        o = 5 == t || r;
      return function (l, h, c, d) {
        for (
          var u,
            p,
            g = Ey(l),
            f = Cy(g),
            v = Ty(h, c),
            m = Py(f),
            y = 0,
            _ = d || Ry,
            b = e ? _(l, m) : i || a ? _(l, 0) : void 0;
          m > y;
          y++
        )
          if ((o || y in f) && ((p = v((u = f[y]), y, g)), t))
            if (e) b[y] = p;
            else if (p)
              switch (t) {
                case 3:
                  return !0;
                case 5:
                  return u;
                case 6:
                  return y;
                case 2:
                  Oy(b, u);
              }
            else
              switch (t) {
                case 4:
                  return !1;
                case 7:
                  Oy(b, u);
              }
        return r ? -1 : n || s ? s : b;
      };
    },
    Iy = {
      forEach: By(0),
      map: By(1),
      filter: By(2),
      some: By(3),
      every: By(4),
      find: By(5),
      findIndex: By(6),
      filterReject: By(7)
    },
    Dy = Ah,
    Ly = qv,
    Fy = Lg.getWeakData,
    jy = If,
    zy = Od,
    Hy = Ih,
    Ny = $h,
    Vy = Rf,
    Wy = Nc,
    Gy = Tu.set,
    Uy = Tu.getterFor,
    Yy = Iy.find,
    $y = Iy.findIndex,
    Xy = Dy([].splice),
    Ky = 0,
    qy = function (t) {
      return t.frozen || (t.frozen = new Zy());
    },
    Zy = function () {
      this.entries = [];
    },
    Jy = function (t, e) {
      return Yy(t.entries, function (t) {
        return t[0] === e;
      });
    };
  Zy.prototype = {
    get: function (t) {
      var e = Jy(this, t);
      if (e) return e[1];
    },
    has: function (t) {
      return !!Jy(this, t);
    },
    set: function (t, e) {
      var i = Jy(this, t);
      i ? (i[1] = e) : this.entries.push([t, e]);
    },
    delete: function (t) {
      var e = $y(this.entries, function (e) {
        return e[0] === t;
      });
      return ~e && Xy(this.entries, e, 1), !!~e;
    }
  };
  var Qy,
    t_ = {
      getConstructor: function (t, e, i, n) {
        var s = t(function (t, s) {
            jy(t, r), Gy(t, { type: e, id: Ky++, frozen: void 0 }), Hy(s) || Vy(s, t[n], { that: t, AS_ENTRIES: i });
          }),
          r = s.prototype,
          a = Uy(e),
          o = function (t, e, i) {
            var n = a(t),
              s = Fy(zy(e), !0);
            return !0 === s ? qy(n).set(e, i) : (s[n.id] = i), t;
          };
        return (
          Ly(r, {
            delete: function (t) {
              var e = a(this);
              if (!Ny(t)) return !1;
              var i = Fy(t);
              return !0 === i ? qy(e).delete(t) : i && Wy(i, e.id) && delete i[e.id];
            },
            has: function (t) {
              var e = a(this);
              if (!Ny(t)) return !1;
              var i = Fy(t);
              return !0 === i ? qy(e).has(t) : i && Wy(i, e.id);
            }
          }),
          Ly(
            r,
            i
              ? {
                  get: function (t) {
                    var e = a(this);
                    if (Ny(t)) {
                      var i = Fy(t);
                      return !0 === i ? qy(e).get(t) : i ? i[e.id] : void 0;
                    }
                  },
                  set: function (t, e) {
                    return o(this, t, e);
                  }
                }
              : {
                  add: function (t) {
                    return o(this, t, !0);
                  }
                }
          ),
          s
        );
      }
    },
    e_ = bg,
    i_ = rh,
    n_ = Ah,
    s_ = qv,
    r_ = Lg,
    a_ = vv,
    o_ = t_,
    l_ = $h,
    h_ = Tu.enforce,
    c_ = oh,
    d_ = hu,
    u_ = Object,
    p_ = Array.isArray,
    g_ = u_.isExtensible,
    f_ = u_.isFrozen,
    v_ = u_.isSealed,
    m_ = u_.freeze,
    y_ = u_.seal,
    __ = {},
    b_ = {},
    x_ = !i_.ActiveXObject && 'ActiveXObject' in i_,
    S_ = function (t) {
      return function () {
        return t(this, arguments.length ? arguments[0] : void 0);
      };
    },
    w_ = a_('WeakMap', S_, o_),
    A_ = w_.prototype,
    k_ = n_(A_.set);
  if (d_)
    if (x_) {
      (Qy = o_.getConstructor(S_, 'WeakMap', !0)), r_.enable();
      var M_ = n_(A_.delete),
        T_ = n_(A_.has),
        C_ = n_(A_.get);
      s_(A_, {
        delete: function (t) {
          if (l_(t) && !g_(t)) {
            var e = h_(this);
            return e.frozen || (e.frozen = new Qy()), M_(this, t) || e.frozen.delete(t);
          }
          return M_(this, t);
        },
        has: function (t) {
          if (l_(t) && !g_(t)) {
            var e = h_(this);
            return e.frozen || (e.frozen = new Qy()), T_(this, t) || e.frozen.has(t);
          }
          return T_(this, t);
        },
        get: function (t) {
          if (l_(t) && !g_(t)) {
            var e = h_(this);
            return e.frozen || (e.frozen = new Qy()), T_(this, t) ? C_(this, t) : e.frozen.get(t);
          }
          return C_(this, t);
        },
        set: function (t, e) {
          if (l_(t) && !g_(t)) {
            var i = h_(this);
            i.frozen || (i.frozen = new Qy()), T_(this, t) ? k_(this, t, e) : i.frozen.set(t, e);
          } else k_(this, t, e);
          return this;
        }
      });
    } else
      e_ &&
        c_(function () {
          var t = m_([]);
          return k_(new w_(), t, 1), !f_(t);
        }) &&
        s_(A_, {
          set: function (t, e) {
            var i;
            return (
              p_(t) && (f_(t) ? (i = __) : v_(t) && (i = b_)), k_(this, t, e), i == __ && m_(t), i == b_ && y_(t), this
            );
          }
        });
  var E_ = qh,
    P_ = Ah,
    R_ = Dc,
    O_ = E_('Map'),
    B_ = E_('WeakMap'),
    I_ = P_([].push),
    D_ = R_('metadata'),
    L_ = D_.store || (D_.store = new B_()),
    F_ = function (t, e, i) {
      var n = L_.get(t);
      if (!n) {
        if (!i) return;
        L_.set(t, (n = new O_()));
      }
      var s = n.get(e);
      if (!s) {
        if (!i) return;
        n.set(e, (s = new O_()));
      }
      return s;
    },
    j_ = {
      store: L_,
      getMap: F_,
      has: function (t, e, i) {
        var n = F_(e, i, !1);
        return void 0 !== n && n.has(t);
      },
      get: function (t, e, i) {
        var n = F_(e, i, !1);
        return void 0 === n ? void 0 : n.get(t);
      },
      set: function (t, e, i, n) {
        F_(i, n, !0).set(t, e);
      },
      keys: function (t, e) {
        var i = F_(t, e, !1),
          n = [];
        return (
          i &&
            i.forEach(function (t, e) {
              I_(n, e);
            }),
          n
        );
      },
      toKey: function (t) {
        return void 0 === t || 'symbol' == typeof t ? t : String(t);
      }
    },
    z_ = Od,
    H_ = j_.toKey,
    N_ = j_.set;
  Zp(
    { target: 'Reflect', stat: !0 },
    {
      defineMetadata: function (t, e, i) {
        var n = arguments.length < 4 ? void 0 : H_(arguments[3]);
        N_(t, e, z_(i), n);
      }
    }
  );
  var V_ = Od,
    W_ = j_.toKey,
    G_ = j_.getMap,
    U_ = j_.store;
  Zp(
    { target: 'Reflect', stat: !0 },
    {
      deleteMetadata: function (t, e) {
        var i = arguments.length < 3 ? void 0 : W_(arguments[2]),
          n = G_(V_(e), i, !1);
        if (void 0 === n || !n.delete(t)) return !1;
        if (n.size) return !0;
        var s = U_.get(e);
        return s.delete(i), !!s.size || U_.delete(e);
      }
    }
  );
  var Y_ = Od,
    $_ = rm,
    X_ = j_.has,
    K_ = j_.get,
    q_ = j_.toKey,
    Z_ = function (t, e, i) {
      if (X_(t, e, i)) return K_(t, e, i);
      var n = $_(e);
      return null !== n ? Z_(t, n, i) : void 0;
    };
  Zp(
    { target: 'Reflect', stat: !0 },
    {
      getMetadata: function (t, e) {
        var i = arguments.length < 3 ? void 0 : q_(arguments[2]);
        return Z_(t, Y_(e), i);
      }
    }
  );
  var J_ = Ah,
    Q_ = Map.prototype,
    tb = { Map: Map, set: J_(Q_.set), get: J_(Q_.get), has: J_(Q_.has), remove: J_(Q_.delete), proto: Q_ },
    eb = uh,
    ib = Ah,
    nb = function (t, e, i) {
      for (var n, s, r = i || t.next; !(n = eb(r, t)).done; ) if (void 0 !== (s = e(n.value))) return s;
    },
    sb = tb.Map,
    rb = tb.proto,
    ab = ib(rb.forEach),
    ob = ib(rb.entries),
    lb = ob(new sb()).next,
    hb = _c,
    cb = Ih,
    db = hp,
    ub = jc,
    pb = function (t, e, i) {
      return i
        ? nb(
            ob(t),
            function (t) {
              return e(t[1], t[0]);
            },
            lb
          )
        : ab(t, e);
    },
    gb = tb.Map,
    fb = tb.has,
    vb = tb.set,
    mb = Ah([].push),
    yb = Zp,
    _b = Ah,
    bb = j_,
    xb = Od,
    Sb = rm,
    wb = function (t) {
      var e,
        i,
        n,
        s = ub(this),
        r = db(s),
        a = [],
        o = new gb(),
        l = cb(t)
          ? function (t) {
              return t;
            }
          : hb(t);
      for (e = 0; e < r; e++) (n = l((i = s[e]))), fb(o, n) || vb(o, n, i);
      return (
        pb(o, function (t) {
          mb(a, t);
        }),
        a
      );
    },
    Ab = _b(wb),
    kb = _b([].concat),
    Mb = bb.keys,
    Tb = bb.toKey,
    Cb = function (t, e) {
      var i = Mb(t, e),
        n = Sb(t);
      if (null === n) return i;
      var s = Cb(n, e);
      return s.length ? (i.length ? Ab(kb(i, s)) : s) : i;
    };
  yb(
    { target: 'Reflect', stat: !0 },
    {
      getMetadataKeys: function (t) {
        var e = arguments.length < 2 ? void 0 : Tb(arguments[1]);
        return Cb(xb(t), e);
      }
    }
  );
  var Eb = Od,
    Pb = j_.get,
    Rb = j_.toKey;
  Zp(
    { target: 'Reflect', stat: !0 },
    {
      getOwnMetadata: function (t, e) {
        var i = arguments.length < 3 ? void 0 : Rb(arguments[2]);
        return Pb(t, Eb(e), i);
      }
    }
  );
  var Ob = Od,
    Bb = j_.keys,
    Ib = j_.toKey;
  Zp(
    { target: 'Reflect', stat: !0 },
    {
      getOwnMetadataKeys: function (t) {
        var e = arguments.length < 2 ? void 0 : Ib(arguments[1]);
        return Bb(Ob(t), e);
      }
    }
  );
  var Db = Od,
    Lb = rm,
    Fb = j_.has,
    jb = j_.toKey,
    zb = function (t, e, i) {
      if (Fb(t, e, i)) return !0;
      var n = Lb(e);
      return null !== n && zb(t, n, i);
    };
  Zp(
    { target: 'Reflect', stat: !0 },
    {
      hasMetadata: function (t, e) {
        var i = arguments.length < 3 ? void 0 : jb(arguments[2]);
        return zb(t, Db(e), i);
      }
    }
  );
  var Hb = Od,
    Nb = j_.has,
    Vb = j_.toKey;
  Zp(
    { target: 'Reflect', stat: !0 },
    {
      hasOwnMetadata: function (t, e) {
        var i = arguments.length < 3 ? void 0 : Vb(arguments[2]);
        return Nb(t, Hb(e), i);
      }
    }
  );
  var Wb = Od,
    Gb = j_.toKey,
    Ub = j_.set;
  Zp(
    { target: 'Reflect', stat: !0 },
    {
      metadata: function (t, e) {
        return function (i, n) {
          Ub(t, e, Wb(i), Gb(n));
        };
      }
    }
  );
  var Yb = 'named',
    $b = 'name',
    Xb = 'unmanaged',
    Kb = 'optional',
    qb = 'inject',
    Zb = 'multi_inject',
    Jb = 'inversify:tagged',
    Qb = 'inversify:tagged_props',
    tx = 'inversify:paramtypes',
    ex = 'post_construct',
    ix = 'pre_destroy';
  var nx = [qb, Zb, $b, Xb, Yb, Kb],
    sx = { Request: 'Request', Singleton: 'Singleton', Transient: 'Transient' },
    rx = {
      ConstantValue: 'ConstantValue',
      Constructor: 'Constructor',
      DynamicValue: 'DynamicValue',
      Factory: 'Factory',
      Function: 'Function',
      Instance: 'Instance',
      Invalid: 'Invalid',
      Provider: 'Provider'
    },
    ax = { ClassProperty: 'ClassProperty', ConstructorArgument: 'ConstructorArgument', Variable: 'Variable' },
    ox = 0;
  function lx() {
    return ox++;
  }
  var hx = (function () {
      function t(t, e) {
        (this.id = lx()),
          (this.activated = !1),
          (this.serviceIdentifier = t),
          (this.scope = e),
          (this.type = rx.Invalid),
          (this.constraint = function (t) {
            return !0;
          }),
          (this.implementationType = null),
          (this.cache = null),
          (this.factory = null),
          (this.provider = null),
          (this.onActivation = null),
          (this.onDeactivation = null),
          (this.dynamicValue = null);
      }
      return (
        (t.prototype.clone = function () {
          var e = new t(this.serviceIdentifier, this.scope);
          return (
            (e.activated = e.scope === sx.Singleton && this.activated),
            (e.implementationType = this.implementationType),
            (e.dynamicValue = this.dynamicValue),
            (e.scope = this.scope),
            (e.type = this.type),
            (e.factory = this.factory),
            (e.provider = this.provider),
            (e.constraint = this.constraint),
            (e.onActivation = this.onActivation),
            (e.onDeactivation = this.onDeactivation),
            (e.cache = this.cache),
            e
          );
        }),
        t
      );
    })(),
    cx = 'Metadata key was used more than once in a parameter:',
    dx = 'NULL argument',
    ux = 'Key Not Found',
    px = 'Ambiguous match found for serviceIdentifier:',
    gx = 'No matching bindings found for serviceIdentifier:',
    fx = 'Missing required @injectable annotation in:',
    vx = 'Missing required @inject or @multiInject annotation in:',
    mx = 'Circular dependency found:',
    yx =
      'The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.',
    _x = function () {
      for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      return (
        'The number of constructor arguments in the derived class ' +
        t[0] +
        ' must be >= than the number of constructor arguments of its base class.'
      );
    },
    bx = function (t, e) {
      return '@postConstruct error in class ' + t + ': ' + e;
    },
    xx = function (t, e) {
      return '@preDestroy error in class ' + t + ': ' + e;
    },
    Sx = function (t, e) {
      return 'onDeactivation() error in class ' + t + ': ' + e;
    },
    Ax = 'Maximum call stack size exceeded',
    kx = (function () {
      function t() {}
      return (
        (t.prototype.getConstructorMetadata = function (t) {
          return {
            compilerGeneratedMetadata: Reflect.getMetadata(tx, t),
            userGeneratedMetadata: Reflect.getMetadata(Jb, t) || {}
          };
        }),
        (t.prototype.getPropertiesMetadata = function (t) {
          return Reflect.getMetadata(Qb, t) || [];
        }),
        t
      );
    })(),
    Mx = { MultipleBindingsAvailable: 2, NoBindingsAvailable: 0, OnlyOneBindingAvailable: 1 };
  function Tx(t) {
    return t instanceof RangeError || t.message === Ax;
  }
  function Cx(t) {
    return 'function' == typeof t ? t.name : 'symbol' == typeof t ? t.toString() : t;
  }
  function Ex(t, e, i) {
    var n = '',
      s = i(t, e);
    return (
      0 !== s.length &&
        ((n = '\nRegistered bindings:'),
        s.forEach(function (t) {
          var e = 'Object';
          null !== t.implementationType && (e = Ox(t.implementationType)),
            (n = n + '\n ' + e),
            t.constraint.metaData && (n = n + ' - ' + t.constraint.metaData);
        })),
      n
    );
  }
  function Px(t, e) {
    return null !== t.parentRequest && (t.parentRequest.serviceIdentifier === e || Px(t.parentRequest, e));
  }
  function Rx(t) {
    t.childRequests.forEach(function (t) {
      if (Px(t, t.serviceIdentifier)) {
        var e = (function (t) {
          var e = (function t(e, i) {
            void 0 === i && (i = []);
            var n = Cx(e.serviceIdentifier);
            return i.push(n), null !== e.parentRequest ? t(e.parentRequest, i) : i;
          })(t);
          return e.reverse().join(' --\x3e ');
        })(t);
        throw new Error(mx + ' ' + e);
      }
      Rx(t);
    });
  }
  function Ox(t) {
    if (t.name) return t.name;
    var e = t.toString(),
      i = e.match(/^function\s*([^\s(]+)/);
    return i ? i[1] : 'Anonymous function: ' + e;
  }
  var Bx = (function () {
      function t(t) {
        (this.id = lx()), (this.container = t);
      }
      return (
        (t.prototype.addPlan = function (t) {
          this.plan = t;
        }),
        (t.prototype.setCurrentRequest = function (t) {
          this.currentRequest = t;
        }),
        t
      );
    })(),
    Ix = (function () {
      function t(t, e) {
        (this.key = t), (this.value = e);
      }
      return (
        (t.prototype.toString = function () {
          return this.key === Yb
            ? 'named: ' + String(this.value).toString() + ' '
            : 'tagged: { key:' + this.key.toString() + ', value: ' + String(this.value) + ' }';
        }),
        t
      );
    })(),
    Dx = function (t, e) {
      (this.parentContext = t), (this.rootRequest = e);
    },
    Lx = (function () {
      function t(t) {
        this._cb = t;
      }
      return (
        (t.prototype.unwrap = function () {
          return this._cb();
        }),
        t
      );
    })(),
    Fx = (function () {
      function t(t) {
        this.str = t;
      }
      return (
        (t.prototype.startsWith = function (t) {
          return 0 === this.str.indexOf(t);
        }),
        (t.prototype.endsWith = function (t) {
          var e,
            i = t.split('').reverse().join('');
          return (e = this.str.split('').reverse().join('')), this.startsWith.call({ str: e }, i);
        }),
        (t.prototype.contains = function (t) {
          return -1 !== this.str.indexOf(t);
        }),
        (t.prototype.equals = function (t) {
          return this.str === t;
        }),
        (t.prototype.value = function () {
          return this.str;
        }),
        t
      );
    })(),
    jx = (function () {
      function t(t, e, i, n) {
        (this.id = lx()), (this.type = t), (this.serviceIdentifier = i);
        var s = 'symbol' == typeof e ? e.toString().slice(7, -1) : e;
        (this.name = new Fx(s || '')), (this.identifier = e), (this.metadata = new Array());
        var r = null;
        'string' == typeof n ? (r = new Ix(Yb, n)) : n instanceof Ix && (r = n), null !== r && this.metadata.push(r);
      }
      return (
        (t.prototype.hasTag = function (t) {
          for (var e = 0, i = this.metadata; e < i.length; e++) {
            if (i[e].key === t) return !0;
          }
          return !1;
        }),
        (t.prototype.isArray = function () {
          return this.hasTag(Zb);
        }),
        (t.prototype.matchesArray = function (t) {
          return this.matchesTag(Zb)(t);
        }),
        (t.prototype.isNamed = function () {
          return this.hasTag(Yb);
        }),
        (t.prototype.isTagged = function () {
          return this.metadata.some(function (t) {
            return nx.every(function (e) {
              return t.key !== e;
            });
          });
        }),
        (t.prototype.isOptional = function () {
          return this.matchesTag(Kb)(!0);
        }),
        (t.prototype.getNamedTag = function () {
          return this.isNamed()
            ? this.metadata.filter(function (t) {
                return t.key === Yb;
              })[0]
            : null;
        }),
        (t.prototype.getCustomTags = function () {
          return this.isTagged()
            ? this.metadata.filter(function (t) {
                return nx.every(function (e) {
                  return t.key !== e;
                });
              })
            : null;
        }),
        (t.prototype.matchesNamedTag = function (t) {
          return this.matchesTag(Yb)(t);
        }),
        (t.prototype.matchesTag = function (t) {
          var e = this;
          return function (i) {
            for (var n = 0, s = e.metadata; n < s.length; n++) {
              var r = s[n];
              if (r.key === t && r.value === i) return !0;
            }
            return !1;
          };
        }),
        t
      );
    })(),
    zx = function (t, e, i) {
      if (i || 2 === arguments.length)
        for (var n, s = 0, r = e.length; s < r; s++)
          (!n && s in e) || (n || (n = Array.prototype.slice.call(e, 0, s)), (n[s] = e[s]));
      return t.concat(n || Array.prototype.slice.call(e));
    };
  function Hx(t, e, i, n) {
    var s = t.getConstructorMetadata(i),
      r = s.compilerGeneratedMetadata;
    if (void 0 === r) throw new Error(fx + ' ' + e + '.');
    var a = s.userGeneratedMetadata,
      o = Object.keys(a),
      l = 0 === i.length && o.length > 0,
      h = o.length > i.length,
      c = (function (t, e, i, n, s) {
        for (var r = [], a = 0; a < s; a++) {
          var o = Nx(a, t, e, i, n);
          null !== o && r.push(o);
        }
        return r;
      })(n, e, r, a, l || h ? o.length : i.length),
      d = Wx(t, i, e);
    return zx(zx([], c, !0), d, !0);
  }
  function Nx(t, e, i, n, s) {
    var r = s[t.toString()] || [],
      a = Ux(r),
      o = !0 !== a.unmanaged,
      l = n[t],
      h = a.inject || a.multiInject;
    if (((l = h || l) instanceof Lx && (l = l.unwrap()), o)) {
      if (!e && (l === Object || l === Function || void 0 === l))
        throw new Error(vx + ' argument ' + t + ' in class ' + i + '.');
      var c = new jx(ax.ConstructorArgument, a.targetName, l);
      return (c.metadata = r), c;
    }
    return null;
  }
  function Vx(t, e, i, n) {
    var s = t || e;
    if (void 0 === s) {
      var r = fx + ' for property ' + String(i) + ' in class ' + n + '.';
      throw new Error(r);
    }
    return s;
  }
  function Wx(t, e, i) {
    for (
      var n = t.getPropertiesMetadata(e),
        s = [],
        r = Object.getOwnPropertySymbols(n),
        a = 0,
        o = Object.keys(n).concat(r);
      a < o.length;
      a++
    ) {
      var l = o[a],
        h = n[l],
        c = Ux(h),
        d = c.targetName || l,
        u = Vx(c.inject, c.multiInject, l, i),
        p = new jx(ax.ClassProperty, d, u);
      (p.metadata = h), s.push(p);
    }
    var g = Object.getPrototypeOf(e.prototype).constructor;
    if (g !== Object) {
      var f = Wx(t, g, i);
      s = zx(zx([], s, !0), f, !0);
    }
    return s;
  }
  function Gx(t, e) {
    var i = Object.getPrototypeOf(e.prototype).constructor;
    if (i !== Object) {
      var n = Hx(t, Ox(i), i, !0),
        s = n.map(function (t) {
          return t.metadata.filter(function (t) {
            return t.key === Xb;
          });
        }),
        r = [].concat.apply([], s).length,
        a = n.length - r;
      return a > 0 ? a : Gx(t, i);
    }
    return 0;
  }
  function Ux(t) {
    var e = {};
    return (
      t.forEach(function (t) {
        e[t.key.toString()] = t.value;
      }),
      { inject: e[qb], multiInject: e[Zb], targetName: e[$b], unmanaged: e[Xb] }
    );
  }
  var Yx = (function () {
    function t(t, e, i, n, s) {
      (this.id = lx()),
        (this.serviceIdentifier = t),
        (this.parentContext = e),
        (this.parentRequest = i),
        (this.target = s),
        (this.childRequests = []),
        (this.bindings = Array.isArray(n) ? n : [n]),
        (this.requestScope = null === i ? new Map() : null);
    }
    return (
      (t.prototype.addChildRequest = function (e, i, n) {
        var s = new t(e, this.parentContext, this, i, n);
        return this.childRequests.push(s), s;
      }),
      t
    );
  })();
  function $x(t) {
    return t._bindingDictionary;
  }
  function Xx(t, e, i, n, s) {
    var r = qx(i.container, s.serviceIdentifier),
      a = [];
    return (
      r.length === Mx.NoBindingsAvailable &&
        i.container.options.autoBindInjectable &&
        'function' == typeof s.serviceIdentifier &&
        t.getConstructorMetadata(s.serviceIdentifier).compilerGeneratedMetadata &&
        (i.container.bind(s.serviceIdentifier).toSelf(), (r = qx(i.container, s.serviceIdentifier))),
      (a = e
        ? r
        : r.filter(function (t) {
            var e = new Yx(t.serviceIdentifier, i, n, t, s);
            return t.constraint(e);
          })),
      (function (t, e, i, n) {
        switch (e.length) {
          case Mx.NoBindingsAvailable:
            if (i.isOptional()) return e;
            var s = Cx(t),
              r = gx;
            throw (
              ((r += (function (t, e) {
                if (e.isTagged() || e.isNamed()) {
                  var i = '',
                    n = e.getNamedTag(),
                    s = e.getCustomTags();
                  return (
                    null !== n && (i += n.toString() + '\n'),
                    null !== s &&
                      s.forEach(function (t) {
                        i += t.toString() + '\n';
                      }),
                    ' ' + t + '\n ' + t + ' - ' + i
                  );
                }
                return ' ' + t;
              })(s, i)),
              (r += Ex(n, s, qx)),
              new Error(r))
            );
          case Mx.OnlyOneBindingAvailable:
            return e;
          case Mx.MultipleBindingsAvailable:
          default:
            if (i.isArray()) return e;
            (s = Cx(t)), (r = px + ' ' + s);
            throw ((r += Ex(n, s, qx)), new Error(r));
        }
      })(s.serviceIdentifier, a, s, i.container),
      a
    );
  }
  function Kx(t, e, i, n, s, r) {
    var a, o;
    if (null === s) {
      (a = Xx(t, e, n, null, r)), (o = new Yx(i, n, null, a, r));
      var l = new Dx(n, o);
      n.addPlan(l);
    } else (a = Xx(t, e, n, s, r)), (o = s.addChildRequest(r.serviceIdentifier, a, r));
    a.forEach(function (e) {
      var i = null;
      if (r.isArray()) i = o.addChildRequest(e.serviceIdentifier, e, r);
      else {
        if (e.cache) return;
        i = o;
      }
      if (e.type === rx.Instance && null !== e.implementationType) {
        var s = (function (t, e) {
          return Hx(t, Ox(e), e, !1);
        })(t, e.implementationType);
        if (!n.container.options.skipBaseClassChecks) {
          var a = Gx(t, e.implementationType);
          if (s.length < a) {
            var l = _x(Ox(e.implementationType));
            throw new Error(l);
          }
        }
        s.forEach(function (e) {
          Kx(t, !1, e.serviceIdentifier, n, i, e);
        });
      }
    });
  }
  function qx(t, e) {
    var i = [],
      n = $x(t);
    return n.hasKey(e) ? (i = n.get(e)) : null !== t.parent && (i = qx(t.parent, e)), i;
  }
  function Zx(t, e, i, n, s, r, a, o) {
    void 0 === o && (o = !1);
    var l = new Bx(e),
      h = (function (t, e, i, n, s, r) {
        var a = new Ix(t ? Zb : qb, i),
          o = new jx(e, n, i, a);
        if (void 0 !== s) {
          var l = new Ix(s, r);
          o.metadata.push(l);
        }
        return o;
      })(i, n, s, '', r, a);
    try {
      return Kx(t, o, s, l, null, h), l;
    } catch (t) {
      throw (Tx(t) && Rx(l.plan.rootRequest), t);
    }
  }
  function Jx(t) {
    return (('object' == typeof t && null !== t) || 'function' == typeof t) && 'function' == typeof t.then;
  }
  function Qx(t) {
    return !!Jx(t) || (Array.isArray(t) && t.some(Jx));
  }
  var tS,
    eS = function (t, e, i, n) {
      return new (i || (i = Promise))(function (s, r) {
        function a(t) {
          try {
            l(n.next(t));
          } catch (t) {
            r(t);
          }
        }
        function o(t) {
          try {
            l(n.throw(t));
          } catch (t) {
            r(t);
          }
        }
        function l(t) {
          var e;
          t.done
            ? s(t.value)
            : ((e = t.value),
              e instanceof i
                ? e
                : new i(function (t) {
                    t(e);
                  })).then(a, o);
        }
        l((n = n.apply(t, e || [])).next());
      });
    },
    iS = function (t, e) {
      var i,
        n,
        s,
        r,
        a = {
          label: 0,
          sent: function () {
            if (1 & s[0]) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        };
      return (
        (r = { next: o(0), throw: o(1), return: o(2) }),
        'function' == typeof Symbol &&
          (r[Symbol.iterator] = function () {
            return this;
          }),
        r
      );
      function o(r) {
        return function (o) {
          return (function (r) {
            if (i) throw new TypeError('Generator is already executing.');
            for (; a; )
              try {
                if (
                  ((i = 1),
                  n &&
                    (s = 2 & r[0] ? n.return : r[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) &&
                    !(s = s.call(n, r[1])).done)
                )
                  return s;
                switch (((n = 0), s && (r = [2 & r[0], s.value]), r[0])) {
                  case 0:
                  case 1:
                    s = r;
                    break;
                  case 4:
                    return a.label++, { value: r[1], done: !1 };
                  case 5:
                    a.label++, (n = r[1]), (r = [0]);
                    continue;
                  case 7:
                    (r = a.ops.pop()), a.trys.pop();
                    continue;
                  default:
                    if (!((s = a.trys), (s = s.length > 0 && s[s.length - 1]) || (6 !== r[0] && 2 !== r[0]))) {
                      a = 0;
                      continue;
                    }
                    if (3 === r[0] && (!s || (r[1] > s[0] && r[1] < s[3]))) {
                      a.label = r[1];
                      break;
                    }
                    if (6 === r[0] && a.label < s[1]) {
                      (a.label = s[1]), (s = r);
                      break;
                    }
                    if (s && a.label < s[2]) {
                      (a.label = s[2]), a.ops.push(r);
                      break;
                    }
                    s[2] && a.ops.pop(), a.trys.pop();
                    continue;
                }
                r = e.call(t, a);
              } catch (t) {
                (r = [6, t]), (n = 0);
              } finally {
                i = s = 0;
              }
            if (5 & r[0]) throw r[1];
            return { value: r[0] ? r[1] : void 0, done: !0 };
          })([r, o]);
        };
      }
    },
    nS = function (t, e, i) {
      t.has(e.id) || t.set(e.id, i);
    },
    sS = function (t, e) {
      (t.cache = e), (t.activated = !0), Jx(e) && rS(t, e);
    },
    rS = function (t, e) {
      return eS(void 0, void 0, void 0, function () {
        var i, n;
        return iS(this, function (s) {
          switch (s.label) {
            case 0:
              return s.trys.push([0, 2, , 3]), [4, e];
            case 1:
              return (i = s.sent()), (t.cache = i), [3, 3];
            case 2:
              throw ((n = s.sent()), (t.cache = null), (t.activated = !1), n);
            case 3:
              return [2];
          }
        });
      });
    };
  !(function (t) {
    (t.DynamicValue = 'toDynamicValue'), (t.Factory = 'toFactory'), (t.Provider = 'toProvider');
  })(tS || (tS = {}));
  var aS = function () {
      return (
        (aS =
          Object.assign ||
          function (t) {
            for (var e, i = 1, n = arguments.length; i < n; i++)
              for (var s in (e = arguments[i])) Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
            return t;
          }),
        aS.apply(this, arguments)
      );
    },
    oS = function (t, e, i, n) {
      return new (i || (i = Promise))(function (s, r) {
        function a(t) {
          try {
            l(n.next(t));
          } catch (t) {
            r(t);
          }
        }
        function o(t) {
          try {
            l(n.throw(t));
          } catch (t) {
            r(t);
          }
        }
        function l(t) {
          var e;
          t.done
            ? s(t.value)
            : ((e = t.value),
              e instanceof i
                ? e
                : new i(function (t) {
                    t(e);
                  })).then(a, o);
        }
        l((n = n.apply(t, e || [])).next());
      });
    },
    lS = function (t, e) {
      var i,
        n,
        s,
        r,
        a = {
          label: 0,
          sent: function () {
            if (1 & s[0]) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        };
      return (
        (r = { next: o(0), throw: o(1), return: o(2) }),
        'function' == typeof Symbol &&
          (r[Symbol.iterator] = function () {
            return this;
          }),
        r
      );
      function o(r) {
        return function (o) {
          return (function (r) {
            if (i) throw new TypeError('Generator is already executing.');
            for (; a; )
              try {
                if (
                  ((i = 1),
                  n &&
                    (s = 2 & r[0] ? n.return : r[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) &&
                    !(s = s.call(n, r[1])).done)
                )
                  return s;
                switch (((n = 0), s && (r = [2 & r[0], s.value]), r[0])) {
                  case 0:
                  case 1:
                    s = r;
                    break;
                  case 4:
                    return a.label++, { value: r[1], done: !1 };
                  case 5:
                    a.label++, (n = r[1]), (r = [0]);
                    continue;
                  case 7:
                    (r = a.ops.pop()), a.trys.pop();
                    continue;
                  default:
                    if (!((s = a.trys), (s = s.length > 0 && s[s.length - 1]) || (6 !== r[0] && 2 !== r[0]))) {
                      a = 0;
                      continue;
                    }
                    if (3 === r[0] && (!s || (r[1] > s[0] && r[1] < s[3]))) {
                      a.label = r[1];
                      break;
                    }
                    if (6 === r[0] && a.label < s[1]) {
                      (a.label = s[1]), (s = r);
                      break;
                    }
                    if (s && a.label < s[2]) {
                      (a.label = s[2]), a.ops.push(r);
                      break;
                    }
                    s[2] && a.ops.pop(), a.trys.pop();
                    continue;
                }
                r = e.call(t, a);
              } catch (t) {
                (r = [6, t]), (n = 0);
              } finally {
                i = s = 0;
              }
            if (5 & r[0]) throw r[1];
            return { value: r[0] ? r[1] : void 0, done: !0 };
          })([r, o]);
        };
      }
    },
    hS = function (t, e, i) {
      if (i || 2 === arguments.length)
        for (var n, s = 0, r = e.length; s < r; s++)
          (!n && s in e) || (n || (n = Array.prototype.slice.call(e, 0, s)), (n[s] = e[s]));
      return t.concat(n || Array.prototype.slice.call(e));
    };
  function cS(t, e, i) {
    var n;
    if (e.length > 0) {
      var s = (function (t, e) {
          return t.reduce(
            function (t, i) {
              var n = e(i);
              return (
                i.target.type === ax.ConstructorArgument
                  ? t.constructorInjections.push(n)
                  : (t.propertyRequests.push(i), t.propertyInjections.push(n)),
                t.isAsync || (t.isAsync = Qx(n)),
                t
              );
            },
            { constructorInjections: [], propertyInjections: [], propertyRequests: [], isAsync: !1 }
          );
        })(e, i),
        r = aS(aS({}, s), { constr: t });
      n = s.isAsync
        ? (function (t) {
            return oS(this, void 0, void 0, function () {
              var e, i;
              return lS(this, function (n) {
                switch (n.label) {
                  case 0:
                    return [4, uS(t.constructorInjections)];
                  case 1:
                    return (e = n.sent()), [4, uS(t.propertyInjections)];
                  case 2:
                    return (i = n.sent()), [2, dS(aS(aS({}, t), { constructorInjections: e, propertyInjections: i }))];
                }
              });
            });
          })(r)
        : dS(r);
    } else n = new t();
    return n;
  }
  function dS(t) {
    var e,
      i = new ((e = t.constr).bind.apply(e, hS([void 0], t.constructorInjections, !1)))();
    return (
      t.propertyRequests.forEach(function (e, n) {
        var s = e.target.identifier,
          r = t.propertyInjections[n];
        i[s] = r;
      }),
      i
    );
  }
  function uS(t) {
    return oS(this, void 0, void 0, function () {
      var e, i, n, s;
      return lS(this, function (r) {
        for (e = [], i = 0, n = t; i < n.length; i++) (s = n[i]), Array.isArray(s) ? e.push(Promise.all(s)) : e.push(s);
        return [2, Promise.all(e)];
      });
    });
  }
  function pS(t, e) {
    var i = (function (t, e) {
      var i, n;
      if (Reflect.hasMetadata(ex, t)) {
        var s = Reflect.getMetadata(ex, t);
        try {
          return null === (n = (i = e)[s.value]) || void 0 === n ? void 0 : n.call(i);
        } catch (e) {
          throw new Error(bx(t.name, e.message));
        }
      }
    })(t, e);
    return Jx(i)
      ? i.then(function () {
          return e;
        })
      : e;
  }
  function gS(t, e) {
    t.scope !== sx.Singleton &&
      (function (t, e) {
        var i = 'Class cannot be instantiated in ' + (t.scope === sx.Request ? 'request' : 'transient') + ' scope.';
        if ('function' == typeof t.onDeactivation) throw new Error(Sx(e.name, i));
        if (Reflect.hasMetadata(ix, e)) throw new Error(xx(e.name, i));
      })(t, e);
  }
  var fS = function (t, e, i, n) {
      return new (i || (i = Promise))(function (s, r) {
        function a(t) {
          try {
            l(n.next(t));
          } catch (t) {
            r(t);
          }
        }
        function o(t) {
          try {
            l(n.throw(t));
          } catch (t) {
            r(t);
          }
        }
        function l(t) {
          var e;
          t.done
            ? s(t.value)
            : ((e = t.value),
              e instanceof i
                ? e
                : new i(function (t) {
                    t(e);
                  })).then(a, o);
        }
        l((n = n.apply(t, e || [])).next());
      });
    },
    vS = function (t, e) {
      var i,
        n,
        s,
        r,
        a = {
          label: 0,
          sent: function () {
            if (1 & s[0]) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        };
      return (
        (r = { next: o(0), throw: o(1), return: o(2) }),
        'function' == typeof Symbol &&
          (r[Symbol.iterator] = function () {
            return this;
          }),
        r
      );
      function o(r) {
        return function (o) {
          return (function (r) {
            if (i) throw new TypeError('Generator is already executing.');
            for (; a; )
              try {
                if (
                  ((i = 1),
                  n &&
                    (s = 2 & r[0] ? n.return : r[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) &&
                    !(s = s.call(n, r[1])).done)
                )
                  return s;
                switch (((n = 0), s && (r = [2 & r[0], s.value]), r[0])) {
                  case 0:
                  case 1:
                    s = r;
                    break;
                  case 4:
                    return a.label++, { value: r[1], done: !1 };
                  case 5:
                    a.label++, (n = r[1]), (r = [0]);
                    continue;
                  case 7:
                    (r = a.ops.pop()), a.trys.pop();
                    continue;
                  default:
                    if (!((s = a.trys), (s = s.length > 0 && s[s.length - 1]) || (6 !== r[0] && 2 !== r[0]))) {
                      a = 0;
                      continue;
                    }
                    if (3 === r[0] && (!s || (r[1] > s[0] && r[1] < s[3]))) {
                      a.label = r[1];
                      break;
                    }
                    if (6 === r[0] && a.label < s[1]) {
                      (a.label = s[1]), (s = r);
                      break;
                    }
                    if (s && a.label < s[2]) {
                      (a.label = s[2]), a.ops.push(r);
                      break;
                    }
                    s[2] && a.ops.pop(), a.trys.pop();
                    continue;
                }
                r = e.call(t, a);
              } catch (t) {
                (r = [6, t]), (n = 0);
              } finally {
                i = s = 0;
              }
            if (5 & r[0]) throw r[1];
            return { value: r[0] ? r[1] : void 0, done: !0 };
          })([r, o]);
        };
      }
    },
    mS = function (t) {
      return function (e) {
        e.parentContext.setCurrentRequest(e);
        var i = e.bindings,
          n = e.childRequests,
          s = e.target && e.target.isArray(),
          r = !(
            e.parentRequest &&
            e.parentRequest.target &&
            e.target &&
            e.parentRequest.target.matchesArray(e.target.serviceIdentifier)
          );
        if (s && r)
          return n.map(function (e) {
            return mS(t)(e);
          });
        if (!e.target.isOptional() || 0 !== i.length) {
          var a = i[0];
          return xS(t, e, a);
        }
      };
    },
    yS = function (t, e) {
      var i = (function (t) {
        switch (t.type) {
          case rx.Factory:
            return { factory: t.factory, factoryType: tS.Factory };
          case rx.Provider:
            return { factory: t.provider, factoryType: tS.Provider };
          case rx.DynamicValue:
            return { factory: t.dynamicValue, factoryType: tS.DynamicValue };
          default:
            throw new Error('Unexpected factory type ' + t.type);
        }
      })(t);
      return (function (t, e) {
        try {
          return t();
        } catch (t) {
          throw (Tx(t) && (t = e()), t);
        }
      })(
        function () {
          return i.factory.bind(t)(e);
        },
        function () {
          return new Error(
            ((t = i.factoryType),
            (n = e.currentRequest.serviceIdentifier.toString()),
            "It looks like there is a circular dependency in one of the '" +
              t +
              "' bindings. Please investigate bindings withservice identifier '" +
              n +
              "'.")
          );
          var t, n;
        }
      );
    },
    _S = function (t, e, i) {
      var n,
        s = e.childRequests;
      switch (
        ((function (t) {
          var e = null;
          switch (t.type) {
            case rx.ConstantValue:
            case rx.Function:
              e = t.cache;
              break;
            case rx.Constructor:
            case rx.Instance:
              e = t.implementationType;
              break;
            case rx.DynamicValue:
              e = t.dynamicValue;
              break;
            case rx.Provider:
              e = t.provider;
              break;
            case rx.Factory:
              e = t.factory;
          }
          if (null === e) {
            var i = Cx(t.serviceIdentifier);
            throw new Error('Invalid binding type: ' + i);
          }
        })(i),
        i.type)
      ) {
        case rx.ConstantValue:
        case rx.Function:
          n = i.cache;
          break;
        case rx.Constructor:
          n = i.implementationType;
          break;
        case rx.Instance:
          n = (function (t, e, i, n) {
            gS(t, e);
            var s = cS(e, i, n);
            return Jx(s)
              ? s.then(function (t) {
                  return pS(e, t);
                })
              : pS(e, s);
          })(i, i.implementationType, s, mS(t));
          break;
        default:
          n = yS(i, e.parentContext);
      }
      return n;
    },
    bS = function (t, e, i) {
      var n = (function (t, e) {
        return e.scope === sx.Singleton && e.activated
          ? e.cache
          : e.scope === sx.Request && t.has(e.id)
          ? t.get(e.id)
          : null;
      })(t, e);
      return (
        null !== n ||
          (function (t, e, i) {
            e.scope === sx.Singleton && sS(e, i), e.scope === sx.Request && nS(t, e, i);
          })(t, e, (n = i())),
        n
      );
    },
    xS = function (t, e, i) {
      return bS(t, i, function () {
        var n = _S(t, e, i);
        return (n = Jx(n)
          ? n.then(function (t) {
              return SS(e, i, t);
            })
          : SS(e, i, n));
      });
    };
  function SS(t, e, i) {
    var n,
      s = wS(t.parentContext, e, i),
      r = TS(t.parentContext.container),
      a = r.next();
    do {
      n = a.value;
      var o = t.parentContext,
        l = t.serviceIdentifier,
        h = MS(n, l);
      (s = Jx(s) ? kS(h, o, s) : AS(h, o, s)), (a = r.next());
    } while (!0 !== a.done && !$x(n).hasKey(t.serviceIdentifier));
    return s;
  }
  var wS = function (t, e, i) {
      return 'function' == typeof e.onActivation ? e.onActivation(t, i) : i;
    },
    AS = function (t, e, i) {
      for (var n = t.next(); !n.done; ) {
        if (Jx((i = n.value(e, i)))) return kS(t, e, i);
        n = t.next();
      }
      return i;
    },
    kS = function (t, e, i) {
      return fS(void 0, void 0, void 0, function () {
        var n, s;
        return vS(this, function (r) {
          switch (r.label) {
            case 0:
              return [4, i];
            case 1:
              (n = r.sent()), (s = t.next()), (r.label = 2);
            case 2:
              return s.done ? [3, 4] : [4, s.value(e, n)];
            case 3:
              return (n = r.sent()), (s = t.next()), [3, 2];
            case 4:
              return [2, n];
          }
        });
      });
    },
    MS = function (t, e) {
      var i = t._activations;
      return i.hasKey(e) ? i.get(e).values() : [].values();
    },
    TS = function (t) {
      for (var e = [t], i = t.parent; null !== i; ) e.push(i), (i = i.parent);
      return {
        next: function () {
          var t = e.pop();
          return void 0 !== t ? { done: !1, value: t } : { done: !0, value: void 0 };
        }
      };
    };
  var CS = function (t, e) {
      var i = t.parentRequest;
      return null !== i && (!!e(i) || CS(i, e));
    },
    ES = function (t) {
      return function (e) {
        var i = function (i) {
          return null !== i && null !== i.target && i.target.matchesTag(t)(e);
        };
        return (i.metaData = new Ix(t, e)), i;
      };
    },
    PS = ES(Yb),
    RS = function (t) {
      return function (e) {
        var i = null;
        if (null !== e) {
          if (((i = e.bindings[0]), 'string' == typeof t)) return i.serviceIdentifier === t;
          var n = e.bindings[0].implementationType;
          return t === n;
        }
        return !1;
      };
    },
    OS = (function () {
      function t(t) {
        this._binding = t;
      }
      return (
        (t.prototype.when = function (t) {
          return (this._binding.constraint = t), new BS(this._binding);
        }),
        (t.prototype.whenTargetNamed = function (t) {
          return (this._binding.constraint = PS(t)), new BS(this._binding);
        }),
        (t.prototype.whenTargetIsDefault = function () {
          return (
            (this._binding.constraint = function (t) {
              return null !== t && null !== t.target && !t.target.isNamed() && !t.target.isTagged();
            }),
            new BS(this._binding)
          );
        }),
        (t.prototype.whenTargetTagged = function (t, e) {
          return (this._binding.constraint = ES(t)(e)), new BS(this._binding);
        }),
        (t.prototype.whenInjectedInto = function (t) {
          return (
            (this._binding.constraint = function (e) {
              return null !== e && RS(t)(e.parentRequest);
            }),
            new BS(this._binding)
          );
        }),
        (t.prototype.whenParentNamed = function (t) {
          return (
            (this._binding.constraint = function (e) {
              return null !== e && PS(t)(e.parentRequest);
            }),
            new BS(this._binding)
          );
        }),
        (t.prototype.whenParentTagged = function (t, e) {
          return (
            (this._binding.constraint = function (i) {
              return null !== i && ES(t)(e)(i.parentRequest);
            }),
            new BS(this._binding)
          );
        }),
        (t.prototype.whenAnyAncestorIs = function (t) {
          return (
            (this._binding.constraint = function (e) {
              return null !== e && CS(e, RS(t));
            }),
            new BS(this._binding)
          );
        }),
        (t.prototype.whenNoAncestorIs = function (t) {
          return (
            (this._binding.constraint = function (e) {
              return null !== e && !CS(e, RS(t));
            }),
            new BS(this._binding)
          );
        }),
        (t.prototype.whenAnyAncestorNamed = function (t) {
          return (
            (this._binding.constraint = function (e) {
              return null !== e && CS(e, PS(t));
            }),
            new BS(this._binding)
          );
        }),
        (t.prototype.whenNoAncestorNamed = function (t) {
          return (
            (this._binding.constraint = function (e) {
              return null !== e && !CS(e, PS(t));
            }),
            new BS(this._binding)
          );
        }),
        (t.prototype.whenAnyAncestorTagged = function (t, e) {
          return (
            (this._binding.constraint = function (i) {
              return null !== i && CS(i, ES(t)(e));
            }),
            new BS(this._binding)
          );
        }),
        (t.prototype.whenNoAncestorTagged = function (t, e) {
          return (
            (this._binding.constraint = function (i) {
              return null !== i && !CS(i, ES(t)(e));
            }),
            new BS(this._binding)
          );
        }),
        (t.prototype.whenAnyAncestorMatches = function (t) {
          return (
            (this._binding.constraint = function (e) {
              return null !== e && CS(e, t);
            }),
            new BS(this._binding)
          );
        }),
        (t.prototype.whenNoAncestorMatches = function (t) {
          return (
            (this._binding.constraint = function (e) {
              return null !== e && !CS(e, t);
            }),
            new BS(this._binding)
          );
        }),
        t
      );
    })(),
    BS = (function () {
      function t(t) {
        this._binding = t;
      }
      return (
        (t.prototype.onActivation = function (t) {
          return (this._binding.onActivation = t), new OS(this._binding);
        }),
        (t.prototype.onDeactivation = function (t) {
          return (this._binding.onDeactivation = t), new OS(this._binding);
        }),
        t
      );
    })(),
    IS = (function () {
      function t(t) {
        (this._binding = t),
          (this._bindingWhenSyntax = new OS(this._binding)),
          (this._bindingOnSyntax = new BS(this._binding));
      }
      return (
        (t.prototype.when = function (t) {
          return this._bindingWhenSyntax.when(t);
        }),
        (t.prototype.whenTargetNamed = function (t) {
          return this._bindingWhenSyntax.whenTargetNamed(t);
        }),
        (t.prototype.whenTargetIsDefault = function () {
          return this._bindingWhenSyntax.whenTargetIsDefault();
        }),
        (t.prototype.whenTargetTagged = function (t, e) {
          return this._bindingWhenSyntax.whenTargetTagged(t, e);
        }),
        (t.prototype.whenInjectedInto = function (t) {
          return this._bindingWhenSyntax.whenInjectedInto(t);
        }),
        (t.prototype.whenParentNamed = function (t) {
          return this._bindingWhenSyntax.whenParentNamed(t);
        }),
        (t.prototype.whenParentTagged = function (t, e) {
          return this._bindingWhenSyntax.whenParentTagged(t, e);
        }),
        (t.prototype.whenAnyAncestorIs = function (t) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(t);
        }),
        (t.prototype.whenNoAncestorIs = function (t) {
          return this._bindingWhenSyntax.whenNoAncestorIs(t);
        }),
        (t.prototype.whenAnyAncestorNamed = function (t) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(t);
        }),
        (t.prototype.whenAnyAncestorTagged = function (t, e) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(t, e);
        }),
        (t.prototype.whenNoAncestorNamed = function (t) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(t);
        }),
        (t.prototype.whenNoAncestorTagged = function (t, e) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(t, e);
        }),
        (t.prototype.whenAnyAncestorMatches = function (t) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(t);
        }),
        (t.prototype.whenNoAncestorMatches = function (t) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(t);
        }),
        (t.prototype.onActivation = function (t) {
          return this._bindingOnSyntax.onActivation(t);
        }),
        (t.prototype.onDeactivation = function (t) {
          return this._bindingOnSyntax.onDeactivation(t);
        }),
        t
      );
    })(),
    DS = (function () {
      function t(t) {
        this._binding = t;
      }
      return (
        (t.prototype.inRequestScope = function () {
          return (this._binding.scope = sx.Request), new IS(this._binding);
        }),
        (t.prototype.inSingletonScope = function () {
          return (this._binding.scope = sx.Singleton), new IS(this._binding);
        }),
        (t.prototype.inTransientScope = function () {
          return (this._binding.scope = sx.Transient), new IS(this._binding);
        }),
        t
      );
    })(),
    LS = (function () {
      function t(t) {
        (this._binding = t),
          (this._bindingWhenSyntax = new OS(this._binding)),
          (this._bindingOnSyntax = new BS(this._binding)),
          (this._bindingInSyntax = new DS(t));
      }
      return (
        (t.prototype.inRequestScope = function () {
          return this._bindingInSyntax.inRequestScope();
        }),
        (t.prototype.inSingletonScope = function () {
          return this._bindingInSyntax.inSingletonScope();
        }),
        (t.prototype.inTransientScope = function () {
          return this._bindingInSyntax.inTransientScope();
        }),
        (t.prototype.when = function (t) {
          return this._bindingWhenSyntax.when(t);
        }),
        (t.prototype.whenTargetNamed = function (t) {
          return this._bindingWhenSyntax.whenTargetNamed(t);
        }),
        (t.prototype.whenTargetIsDefault = function () {
          return this._bindingWhenSyntax.whenTargetIsDefault();
        }),
        (t.prototype.whenTargetTagged = function (t, e) {
          return this._bindingWhenSyntax.whenTargetTagged(t, e);
        }),
        (t.prototype.whenInjectedInto = function (t) {
          return this._bindingWhenSyntax.whenInjectedInto(t);
        }),
        (t.prototype.whenParentNamed = function (t) {
          return this._bindingWhenSyntax.whenParentNamed(t);
        }),
        (t.prototype.whenParentTagged = function (t, e) {
          return this._bindingWhenSyntax.whenParentTagged(t, e);
        }),
        (t.prototype.whenAnyAncestorIs = function (t) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(t);
        }),
        (t.prototype.whenNoAncestorIs = function (t) {
          return this._bindingWhenSyntax.whenNoAncestorIs(t);
        }),
        (t.prototype.whenAnyAncestorNamed = function (t) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(t);
        }),
        (t.prototype.whenAnyAncestorTagged = function (t, e) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(t, e);
        }),
        (t.prototype.whenNoAncestorNamed = function (t) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(t);
        }),
        (t.prototype.whenNoAncestorTagged = function (t, e) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(t, e);
        }),
        (t.prototype.whenAnyAncestorMatches = function (t) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(t);
        }),
        (t.prototype.whenNoAncestorMatches = function (t) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(t);
        }),
        (t.prototype.onActivation = function (t) {
          return this._bindingOnSyntax.onActivation(t);
        }),
        (t.prototype.onDeactivation = function (t) {
          return this._bindingOnSyntax.onDeactivation(t);
        }),
        t
      );
    })(),
    FS = (function () {
      function t(t) {
        this._binding = t;
      }
      return (
        (t.prototype.to = function (t) {
          return (this._binding.type = rx.Instance), (this._binding.implementationType = t), new LS(this._binding);
        }),
        (t.prototype.toSelf = function () {
          if ('function' != typeof this._binding.serviceIdentifier)
            throw new Error('The toSelf function can only be applied when a constructor is used as service identifier');
          var t = this._binding.serviceIdentifier;
          return this.to(t);
        }),
        (t.prototype.toConstantValue = function (t) {
          return (
            (this._binding.type = rx.ConstantValue),
            (this._binding.cache = t),
            (this._binding.dynamicValue = null),
            (this._binding.implementationType = null),
            (this._binding.scope = sx.Singleton),
            new IS(this._binding)
          );
        }),
        (t.prototype.toDynamicValue = function (t) {
          return (
            (this._binding.type = rx.DynamicValue),
            (this._binding.cache = null),
            (this._binding.dynamicValue = t),
            (this._binding.implementationType = null),
            new LS(this._binding)
          );
        }),
        (t.prototype.toConstructor = function (t) {
          return (
            (this._binding.type = rx.Constructor),
            (this._binding.implementationType = t),
            (this._binding.scope = sx.Singleton),
            new IS(this._binding)
          );
        }),
        (t.prototype.toFactory = function (t) {
          return (
            (this._binding.type = rx.Factory),
            (this._binding.factory = t),
            (this._binding.scope = sx.Singleton),
            new IS(this._binding)
          );
        }),
        (t.prototype.toFunction = function (t) {
          if ('function' != typeof t) throw new Error('Value provided to function binding must be a function!');
          var e = this.toConstantValue(t);
          return (this._binding.type = rx.Function), (this._binding.scope = sx.Singleton), e;
        }),
        (t.prototype.toAutoFactory = function (t) {
          return (
            (this._binding.type = rx.Factory),
            (this._binding.factory = function (e) {
              return function () {
                return e.container.get(t);
              };
            }),
            (this._binding.scope = sx.Singleton),
            new IS(this._binding)
          );
        }),
        (t.prototype.toAutoNamedFactory = function (t) {
          return (
            (this._binding.type = rx.Factory),
            (this._binding.factory = function (e) {
              return function (i) {
                return e.container.getNamed(t, i);
              };
            }),
            new IS(this._binding)
          );
        }),
        (t.prototype.toProvider = function (t) {
          return (
            (this._binding.type = rx.Provider),
            (this._binding.provider = t),
            (this._binding.scope = sx.Singleton),
            new IS(this._binding)
          );
        }),
        (t.prototype.toService = function (t) {
          this.toDynamicValue(function (e) {
            return e.container.get(t);
          });
        }),
        t
      );
    })(),
    jS = (function () {
      function t() {}
      return (
        (t.of = function (e, i, n, s, r) {
          var a = new t();
          return (
            (a.bindings = e),
            (a.middleware = i),
            (a.deactivations = s),
            (a.activations = n),
            (a.moduleActivationStore = r),
            a
          );
        }),
        t
      );
    })();
  var zS = (function () {
      function t() {
        this._map = new Map();
      }
      return (
        (t.prototype.getMap = function () {
          return this._map;
        }),
        (t.prototype.add = function (t, e) {
          if (null == t) throw new Error(dx);
          if (null == e) throw new Error(dx);
          var i = this._map.get(t);
          void 0 !== i ? i.push(e) : this._map.set(t, [e]);
        }),
        (t.prototype.get = function (t) {
          if (null == t) throw new Error(dx);
          var e = this._map.get(t);
          if (void 0 !== e) return e;
          throw new Error(ux);
        }),
        (t.prototype.remove = function (t) {
          if (null == t) throw new Error(dx);
          if (!this._map.delete(t)) throw new Error(ux);
        }),
        (t.prototype.removeIntersection = function (t) {
          var e = this;
          this.traverse(function (i, n) {
            var s = t.hasKey(i) ? t.get(i) : void 0;
            if (void 0 !== s) {
              var r = n.filter(function (t) {
                return !s.some(function (e) {
                  return t === e;
                });
              });
              e._setValue(i, r);
            }
          });
        }),
        (t.prototype.removeByCondition = function (t) {
          var e = this,
            i = [];
          return (
            this._map.forEach(function (n, s) {
              for (var r = [], a = 0, o = n; a < o.length; a++) {
                var l = o[a];
                t(l) ? i.push(l) : r.push(l);
              }
              e._setValue(s, r);
            }),
            i
          );
        }),
        (t.prototype.hasKey = function (t) {
          if (null == t) throw new Error(dx);
          return this._map.has(t);
        }),
        (t.prototype.clone = function () {
          var e = new t();
          return (
            this._map.forEach(function (t, i) {
              t.forEach(function (t) {
                return e.add(
                  i,
                  'object' == typeof (n = t) && null !== n && 'clone' in n && 'function' == typeof n.clone
                    ? t.clone()
                    : t
                );
                var n;
              });
            }),
            e
          );
        }),
        (t.prototype.traverse = function (t) {
          this._map.forEach(function (e, i) {
            t(i, e);
          });
        }),
        (t.prototype._setValue = function (t, e) {
          e.length > 0 ? this._map.set(t, e) : this._map.delete(t);
        }),
        t
      );
    })(),
    HS = (function () {
      function t() {
        this._map = new Map();
      }
      return (
        (t.prototype.remove = function (t) {
          if (this._map.has(t)) {
            var e = this._map.get(t);
            return this._map.delete(t), e;
          }
          return this._getEmptyHandlersStore();
        }),
        (t.prototype.addDeactivation = function (t, e, i) {
          this._getModuleActivationHandlers(t).onDeactivations.add(e, i);
        }),
        (t.prototype.addActivation = function (t, e, i) {
          this._getModuleActivationHandlers(t).onActivations.add(e, i);
        }),
        (t.prototype.clone = function () {
          var e = new t();
          return (
            this._map.forEach(function (t, i) {
              e._map.set(i, { onActivations: t.onActivations.clone(), onDeactivations: t.onDeactivations.clone() });
            }),
            e
          );
        }),
        (t.prototype._getModuleActivationHandlers = function (t) {
          var e = this._map.get(t);
          return void 0 === e && ((e = this._getEmptyHandlersStore()), this._map.set(t, e)), e;
        }),
        (t.prototype._getEmptyHandlersStore = function () {
          return { onActivations: new zS(), onDeactivations: new zS() };
        }),
        t
      );
    })(),
    NS = function () {
      return (
        (NS =
          Object.assign ||
          function (t) {
            for (var e, i = 1, n = arguments.length; i < n; i++)
              for (var s in (e = arguments[i])) Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
            return t;
          }),
        NS.apply(this, arguments)
      );
    },
    VS = function (t, e, i, n) {
      return new (i || (i = Promise))(function (s, r) {
        function a(t) {
          try {
            l(n.next(t));
          } catch (t) {
            r(t);
          }
        }
        function o(t) {
          try {
            l(n.throw(t));
          } catch (t) {
            r(t);
          }
        }
        function l(t) {
          var e;
          t.done
            ? s(t.value)
            : ((e = t.value),
              e instanceof i
                ? e
                : new i(function (t) {
                    t(e);
                  })).then(a, o);
        }
        l((n = n.apply(t, e || [])).next());
      });
    },
    WS = function (t, e) {
      var i,
        n,
        s,
        r,
        a = {
          label: 0,
          sent: function () {
            if (1 & s[0]) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        };
      return (
        (r = { next: o(0), throw: o(1), return: o(2) }),
        'function' == typeof Symbol &&
          (r[Symbol.iterator] = function () {
            return this;
          }),
        r
      );
      function o(r) {
        return function (o) {
          return (function (r) {
            if (i) throw new TypeError('Generator is already executing.');
            for (; a; )
              try {
                if (
                  ((i = 1),
                  n &&
                    (s = 2 & r[0] ? n.return : r[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) &&
                    !(s = s.call(n, r[1])).done)
                )
                  return s;
                switch (((n = 0), s && (r = [2 & r[0], s.value]), r[0])) {
                  case 0:
                  case 1:
                    s = r;
                    break;
                  case 4:
                    return a.label++, { value: r[1], done: !1 };
                  case 5:
                    a.label++, (n = r[1]), (r = [0]);
                    continue;
                  case 7:
                    (r = a.ops.pop()), a.trys.pop();
                    continue;
                  default:
                    if (!((s = a.trys), (s = s.length > 0 && s[s.length - 1]) || (6 !== r[0] && 2 !== r[0]))) {
                      a = 0;
                      continue;
                    }
                    if (3 === r[0] && (!s || (r[1] > s[0] && r[1] < s[3]))) {
                      a.label = r[1];
                      break;
                    }
                    if (6 === r[0] && a.label < s[1]) {
                      (a.label = s[1]), (s = r);
                      break;
                    }
                    if (s && a.label < s[2]) {
                      (a.label = s[2]), a.ops.push(r);
                      break;
                    }
                    s[2] && a.ops.pop(), a.trys.pop();
                    continue;
                }
                r = e.call(t, a);
              } catch (t) {
                (r = [6, t]), (n = 0);
              } finally {
                i = s = 0;
              }
            if (5 & r[0]) throw r[1];
            return { value: r[0] ? r[1] : void 0, done: !0 };
          })([r, o]);
        };
      }
    },
    GS = function (t, e, i) {
      if (i || 2 === arguments.length)
        for (var n, s = 0, r = e.length; s < r; s++)
          (!n && s in e) || (n || (n = Array.prototype.slice.call(e, 0, s)), (n[s] = e[s]));
      return t.concat(n || Array.prototype.slice.call(e));
    },
    US = (function () {
      function t(t) {
        var e = t || {};
        if ('object' != typeof e)
          throw new Error('Invalid Container constructor argument. Container options must be an object.');
        if (void 0 === e.defaultScope) e.defaultScope = sx.Transient;
        else if (e.defaultScope !== sx.Singleton && e.defaultScope !== sx.Transient && e.defaultScope !== sx.Request)
          throw new Error("Invalid Container option. Default scope must be a string ('singleton' or 'transient').");
        if (void 0 === e.autoBindInjectable) e.autoBindInjectable = !1;
        else if ('boolean' != typeof e.autoBindInjectable)
          throw new Error('Invalid Container option. Auto bind injectable must be a boolean');
        if (void 0 === e.skipBaseClassChecks) e.skipBaseClassChecks = !1;
        else if ('boolean' != typeof e.skipBaseClassChecks)
          throw new Error('Invalid Container option. Skip base check must be a boolean');
        (this.options = {
          autoBindInjectable: e.autoBindInjectable,
          defaultScope: e.defaultScope,
          skipBaseClassChecks: e.skipBaseClassChecks
        }),
          (this.id = lx()),
          (this._bindingDictionary = new zS()),
          (this._snapshots = []),
          (this._middleware = null),
          (this._activations = new zS()),
          (this._deactivations = new zS()),
          (this.parent = null),
          (this._metadataReader = new kx()),
          (this._moduleActivationStore = new HS());
      }
      return (
        (t.merge = function (e, i) {
          for (var n = [], s = 2; s < arguments.length; s++) n[s - 2] = arguments[s];
          var r = new t(),
            a = GS([e, i], n, !0).map(function (t) {
              return $x(t);
            }),
            o = $x(r);
          return (
            a.forEach(function (t) {
              !(function (t, e) {
                t.traverse(function (t, i) {
                  i.forEach(function (t) {
                    e.add(t.serviceIdentifier, t.clone());
                  });
                });
              })(t, o);
            }),
            r
          );
        }),
        (t.prototype.load = function () {
          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
          for (var i = this._getContainerModuleHelpersFactory(), n = 0, s = t; n < s.length; n++) {
            var r = s[n],
              a = i(r.id);
            r.registry(
              a.bindFunction,
              a.unbindFunction,
              a.isboundFunction,
              a.rebindFunction,
              a.unbindAsyncFunction,
              a.onActivationFunction,
              a.onDeactivationFunction
            );
          }
        }),
        (t.prototype.loadAsync = function () {
          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
          return VS(this, void 0, void 0, function () {
            var e, i, n, s, r;
            return WS(this, function (a) {
              switch (a.label) {
                case 0:
                  (e = this._getContainerModuleHelpersFactory()), (i = 0), (n = t), (a.label = 1);
                case 1:
                  return i < n.length
                    ? ((s = n[i]),
                      (r = e(s.id)),
                      [
                        4,
                        s.registry(
                          r.bindFunction,
                          r.unbindFunction,
                          r.isboundFunction,
                          r.rebindFunction,
                          r.unbindAsyncFunction,
                          r.onActivationFunction,
                          r.onDeactivationFunction
                        )
                      ])
                    : [3, 4];
                case 2:
                  a.sent(), (a.label = 3);
                case 3:
                  return i++, [3, 1];
                case 4:
                  return [2];
              }
            });
          });
        }),
        (t.prototype.unload = function () {
          for (var t = this, e = [], i = 0; i < arguments.length; i++) e[i] = arguments[i];
          e.forEach(function (e) {
            var i = t._removeModuleBindings(e.id);
            t._deactivateSingletons(i), t._removeModuleHandlers(e.id);
          });
        }),
        (t.prototype.unloadAsync = function () {
          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
          return VS(this, void 0, void 0, function () {
            var e, i, n, s;
            return WS(this, function (r) {
              switch (r.label) {
                case 0:
                  (e = 0), (i = t), (r.label = 1);
                case 1:
                  return e < i.length
                    ? ((n = i[e]), (s = this._removeModuleBindings(n.id)), [4, this._deactivateSingletonsAsync(s)])
                    : [3, 4];
                case 2:
                  r.sent(), this._removeModuleHandlers(n.id), (r.label = 3);
                case 3:
                  return e++, [3, 1];
                case 4:
                  return [2];
              }
            });
          });
        }),
        (t.prototype.bind = function (t) {
          var e = this.options.defaultScope || sx.Transient,
            i = new hx(t, e);
          return this._bindingDictionary.add(t, i), new FS(i);
        }),
        (t.prototype.rebind = function (t) {
          return this.unbind(t), this.bind(t);
        }),
        (t.prototype.rebindAsync = function (t) {
          return VS(this, void 0, void 0, function () {
            return WS(this, function (e) {
              switch (e.label) {
                case 0:
                  return [4, this.unbindAsync(t)];
                case 1:
                  return e.sent(), [2, this.bind(t)];
              }
            });
          });
        }),
        (t.prototype.unbind = function (t) {
          if (this._bindingDictionary.hasKey(t)) {
            var e = this._bindingDictionary.get(t);
            this._deactivateSingletons(e);
          }
          this._removeServiceFromDictionary(t);
        }),
        (t.prototype.unbindAsync = function (t) {
          return VS(this, void 0, void 0, function () {
            var e;
            return WS(this, function (i) {
              switch (i.label) {
                case 0:
                  return this._bindingDictionary.hasKey(t)
                    ? ((e = this._bindingDictionary.get(t)), [4, this._deactivateSingletonsAsync(e)])
                    : [3, 2];
                case 1:
                  i.sent(), (i.label = 2);
                case 2:
                  return this._removeServiceFromDictionary(t), [2];
              }
            });
          });
        }),
        (t.prototype.unbindAll = function () {
          var t = this;
          this._bindingDictionary.traverse(function (e, i) {
            t._deactivateSingletons(i);
          }),
            (this._bindingDictionary = new zS());
        }),
        (t.prototype.unbindAllAsync = function () {
          return VS(this, void 0, void 0, function () {
            var t,
              e = this;
            return WS(this, function (i) {
              switch (i.label) {
                case 0:
                  return (
                    (t = []),
                    this._bindingDictionary.traverse(function (i, n) {
                      t.push(e._deactivateSingletonsAsync(n));
                    }),
                    [4, Promise.all(t)]
                  );
                case 1:
                  return i.sent(), (this._bindingDictionary = new zS()), [2];
              }
            });
          });
        }),
        (t.prototype.onActivation = function (t, e) {
          this._activations.add(t, e);
        }),
        (t.prototype.onDeactivation = function (t, e) {
          this._deactivations.add(t, e);
        }),
        (t.prototype.isBound = function (t) {
          var e = this._bindingDictionary.hasKey(t);
          return !e && this.parent && (e = this.parent.isBound(t)), e;
        }),
        (t.prototype.isCurrentBound = function (t) {
          return this._bindingDictionary.hasKey(t);
        }),
        (t.prototype.isBoundNamed = function (t, e) {
          return this.isBoundTagged(t, Yb, e);
        }),
        (t.prototype.isBoundTagged = function (t, e, i) {
          var n = !1;
          if (this._bindingDictionary.hasKey(t)) {
            var s = this._bindingDictionary.get(t),
              r = (function (t, e, i, n) {
                var s = new jx(ax.Variable, '', e, new Ix(i, n)),
                  r = new Bx(t);
                return new Yx(e, r, null, [], s);
              })(this, t, e, i);
            n = s.some(function (t) {
              return t.constraint(r);
            });
          }
          return !n && this.parent && (n = this.parent.isBoundTagged(t, e, i)), n;
        }),
        (t.prototype.snapshot = function () {
          this._snapshots.push(
            jS.of(
              this._bindingDictionary.clone(),
              this._middleware,
              this._activations.clone(),
              this._deactivations.clone(),
              this._moduleActivationStore.clone()
            )
          );
        }),
        (t.prototype.restore = function () {
          var t = this._snapshots.pop();
          if (void 0 === t) throw new Error('No snapshot available to restore.');
          (this._bindingDictionary = t.bindings),
            (this._activations = t.activations),
            (this._deactivations = t.deactivations),
            (this._middleware = t.middleware),
            (this._moduleActivationStore = t.moduleActivationStore);
        }),
        (t.prototype.createChild = function (e) {
          var i = new t(e || this.options);
          return (i.parent = this), i;
        }),
        (t.prototype.applyMiddleware = function () {
          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
          var i = this._middleware ? this._middleware : this._planAndResolve();
          this._middleware = t.reduce(function (t, e) {
            return e(t);
          }, i);
        }),
        (t.prototype.applyCustomMetadataReader = function (t) {
          this._metadataReader = t;
        }),
        (t.prototype.get = function (t) {
          var e = this._getNotAllArgs(t, !1);
          return this._getButThrowIfAsync(e);
        }),
        (t.prototype.getAsync = function (t) {
          return VS(this, void 0, void 0, function () {
            var e;
            return WS(this, function (i) {
              return (e = this._getNotAllArgs(t, !1)), [2, this._get(e)];
            });
          });
        }),
        (t.prototype.getTagged = function (t, e, i) {
          var n = this._getNotAllArgs(t, !1, e, i);
          return this._getButThrowIfAsync(n);
        }),
        (t.prototype.getTaggedAsync = function (t, e, i) {
          return VS(this, void 0, void 0, function () {
            var n;
            return WS(this, function (s) {
              return (n = this._getNotAllArgs(t, !1, e, i)), [2, this._get(n)];
            });
          });
        }),
        (t.prototype.getNamed = function (t, e) {
          return this.getTagged(t, Yb, e);
        }),
        (t.prototype.getNamedAsync = function (t, e) {
          return this.getTaggedAsync(t, Yb, e);
        }),
        (t.prototype.getAll = function (t) {
          var e = this._getAllArgs(t);
          return this._getButThrowIfAsync(e);
        }),
        (t.prototype.getAllAsync = function (t) {
          var e = this._getAllArgs(t);
          return this._getAll(e);
        }),
        (t.prototype.getAllTagged = function (t, e, i) {
          var n = this._getNotAllArgs(t, !0, e, i);
          return this._getButThrowIfAsync(n);
        }),
        (t.prototype.getAllTaggedAsync = function (t, e, i) {
          var n = this._getNotAllArgs(t, !0, e, i);
          return this._getAll(n);
        }),
        (t.prototype.getAllNamed = function (t, e) {
          return this.getAllTagged(t, Yb, e);
        }),
        (t.prototype.getAllNamedAsync = function (t, e) {
          return this.getAllTaggedAsync(t, Yb, e);
        }),
        (t.prototype.resolve = function (t) {
          var e = this.isBound(t);
          e || this.bind(t).toSelf();
          var i = this.get(t);
          return e || this.unbind(t), i;
        }),
        (t.prototype._preDestroy = function (t, e) {
          if (Reflect.hasMetadata(ix, t)) return e[Reflect.getMetadata(ix, t).value]();
        }),
        (t.prototype._removeModuleHandlers = function (t) {
          var e = this._moduleActivationStore.remove(t);
          this._activations.removeIntersection(e.onActivations),
            this._deactivations.removeIntersection(e.onDeactivations);
        }),
        (t.prototype._removeModuleBindings = function (t) {
          return this._bindingDictionary.removeByCondition(function (e) {
            return e.moduleId === t;
          });
        }),
        (t.prototype._deactivate = function (t, e) {
          var i = this,
            n = Object.getPrototypeOf(e).constructor;
          try {
            if (this._deactivations.hasKey(t.serviceIdentifier)) {
              var s = this._deactivateContainer(e, this._deactivations.get(t.serviceIdentifier).values());
              if (Jx(s))
                return this._handleDeactivationError(
                  s.then(function () {
                    return i._propagateContainerDeactivationThenBindingAndPreDestroyAsync(t, e, n);
                  }),
                  n
                );
            }
            var r = this._propagateContainerDeactivationThenBindingAndPreDestroy(t, e, n);
            if (Jx(r)) return this._handleDeactivationError(r, n);
          } catch (t) {
            throw new Error(Sx(n.name, t.message));
          }
        }),
        (t.prototype._handleDeactivationError = function (t, e) {
          return VS(this, void 0, void 0, function () {
            var i;
            return WS(this, function (n) {
              switch (n.label) {
                case 0:
                  return n.trys.push([0, 2, , 3]), [4, t];
                case 1:
                  return n.sent(), [3, 3];
                case 2:
                  throw ((i = n.sent()), new Error(Sx(e.name, i.message)));
                case 3:
                  return [2];
              }
            });
          });
        }),
        (t.prototype._deactivateContainer = function (t, e) {
          for (var i = this, n = e.next(); n.value; ) {
            var s = n.value(t);
            if (Jx(s))
              return s.then(function () {
                return i._deactivateContainerAsync(t, e);
              });
            n = e.next();
          }
        }),
        (t.prototype._deactivateContainerAsync = function (t, e) {
          return VS(this, void 0, void 0, function () {
            var i;
            return WS(this, function (n) {
              switch (n.label) {
                case 0:
                  (i = e.next()), (n.label = 1);
                case 1:
                  return i.value ? [4, i.value(t)] : [3, 3];
                case 2:
                  return n.sent(), (i = e.next()), [3, 1];
                case 3:
                  return [2];
              }
            });
          });
        }),
        (t.prototype._getContainerModuleHelpersFactory = function () {
          var t = this,
            e = function (t, e) {
              t._binding.moduleId = e;
            },
            i = function (i) {
              return function (n) {
                var s = t.rebind(n);
                return e(s, i), s;
              };
            },
            n = function (e) {
              return function (i, n) {
                t._moduleActivationStore.addActivation(e, i, n), t.onActivation(i, n);
              };
            },
            s = function (e) {
              return function (i, n) {
                t._moduleActivationStore.addDeactivation(e, i, n), t.onDeactivation(i, n);
              };
            };
          return function (r) {
            return {
              bindFunction:
                ((a = r),
                function (i) {
                  var n = t.bind(i);
                  return e(n, a), n;
                }),
              isboundFunction: function (e) {
                return t.isBound(e);
              },
              onActivationFunction: n(r),
              onDeactivationFunction: s(r),
              rebindFunction: i(r),
              unbindFunction: function (e) {
                return t.unbind(e);
              },
              unbindAsyncFunction: function (e) {
                return t.unbindAsync(e);
              }
            };
            var a;
          };
        }),
        (t.prototype._getAll = function (t) {
          return Promise.all(this._get(t));
        }),
        (t.prototype._get = function (t) {
          var e = NS(NS({}, t), {
            contextInterceptor: function (t) {
              return t;
            },
            targetType: ax.Variable
          });
          if (this._middleware) {
            var i = this._middleware(e);
            if (null == i) throw new Error('Invalid return type in middleware. Middleware must return!');
            return i;
          }
          return this._planAndResolve()(e);
        }),
        (t.prototype._getButThrowIfAsync = function (t) {
          var e = this._get(t);
          if (Qx(e))
            throw new Error(
              "You are attempting to construct '" +
                t.serviceIdentifier +
                "' in a synchronous way\n but it has asynchronous dependencies."
            );
          return e;
        }),
        (t.prototype._getAllArgs = function (t) {
          return { avoidConstraints: !0, isMultiInject: !0, serviceIdentifier: t };
        }),
        (t.prototype._getNotAllArgs = function (t, e, i, n) {
          return { avoidConstraints: !1, isMultiInject: e, serviceIdentifier: t, key: i, value: n };
        }),
        (t.prototype._planAndResolve = function () {
          var t = this;
          return function (e) {
            var i = Zx(
              t._metadataReader,
              t,
              e.isMultiInject,
              e.targetType,
              e.serviceIdentifier,
              e.key,
              e.value,
              e.avoidConstraints
            );
            return (function (t) {
              return mS(t.plan.rootRequest.requestScope)(t.plan.rootRequest);
            })((i = e.contextInterceptor(i)));
          };
        }),
        (t.prototype._deactivateIfSingleton = function (t) {
          var e = this;
          if (t.activated)
            return Jx(t.cache)
              ? t.cache.then(function (i) {
                  return e._deactivate(t, i);
                })
              : this._deactivate(t, t.cache);
        }),
        (t.prototype._deactivateSingletons = function (t) {
          for (var e = 0, i = t; e < i.length; e++) {
            var n = i[e];
            if (Jx(this._deactivateIfSingleton(n)))
              throw new Error(
                'Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)'
              );
          }
        }),
        (t.prototype._deactivateSingletonsAsync = function (t) {
          return VS(this, void 0, void 0, function () {
            var e = this;
            return WS(this, function (i) {
              switch (i.label) {
                case 0:
                  return [
                    4,
                    Promise.all(
                      t.map(function (t) {
                        return e._deactivateIfSingleton(t);
                      })
                    )
                  ];
                case 1:
                  return i.sent(), [2];
              }
            });
          });
        }),
        (t.prototype._propagateContainerDeactivationThenBindingAndPreDestroy = function (t, e, i) {
          return this.parent
            ? this._deactivate.bind(this.parent)(t, e)
            : this._bindingDeactivationAndPreDestroy(t, e, i);
        }),
        (t.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync = function (t, e, i) {
          return VS(this, void 0, void 0, function () {
            return WS(this, function (n) {
              switch (n.label) {
                case 0:
                  return this.parent ? [4, this._deactivate.bind(this.parent)(t, e)] : [3, 2];
                case 1:
                  return n.sent(), [3, 4];
                case 2:
                  return [4, this._bindingDeactivationAndPreDestroyAsync(t, e, i)];
                case 3:
                  n.sent(), (n.label = 4);
                case 4:
                  return [2];
              }
            });
          });
        }),
        (t.prototype._removeServiceFromDictionary = function (t) {
          try {
            this._bindingDictionary.remove(t);
          } catch (e) {
            throw new Error('Could not unbind serviceIdentifier: ' + Cx(t));
          }
        }),
        (t.prototype._bindingDeactivationAndPreDestroy = function (t, e, i) {
          var n = this;
          if ('function' == typeof t.onDeactivation) {
            var s = t.onDeactivation(e);
            if (Jx(s))
              return s.then(function () {
                return n._preDestroy(i, e);
              });
          }
          return this._preDestroy(i, e);
        }),
        (t.prototype._bindingDeactivationAndPreDestroyAsync = function (t, e, i) {
          return VS(this, void 0, void 0, function () {
            return WS(this, function (n) {
              switch (n.label) {
                case 0:
                  return 'function' != typeof t.onDeactivation ? [3, 2] : [4, t.onDeactivation(e)];
                case 1:
                  n.sent(), (n.label = 2);
                case 2:
                  return [4, this._preDestroy(i, e)];
                case 3:
                  return n.sent(), [2];
              }
            });
          });
        }),
        t
      );
    })(),
    YS = function (t) {
      (this.id = lx()), (this.registry = t);
    };
  function $S(t, e, i, n) {
    !(function (t) {
      if (void 0 !== t) throw new Error(yx);
    })(e),
      KS(Jb, t, i.toString(), n);
  }
  function XS(t) {
    var e = [];
    if (Array.isArray(t)) {
      var i = (function (t) {
        for (var e = new Set(), i = 0, n = t; i < n.length; i++) {
          var s = n[i];
          if (e.has(s)) return s;
          e.add(s);
        }
      })(
        (e = t).map(function (t) {
          return t.key;
        })
      );
      if (void 0 !== i) throw new Error(cx + ' ' + i.toString());
    } else e = [t];
    return e;
  }
  function KS(t, e, i, n) {
    var s = XS(n),
      r = {};
    Reflect.hasOwnMetadata(t, e) && (r = Reflect.getMetadata(t, e));
    var a = r[i];
    if (void 0 === a) a = [];
    else
      for (
        var o = function (t) {
            if (
              s.some(function (e) {
                return e.key === t.key;
              })
            )
              throw new Error(cx + ' ' + t.key.toString());
          },
          l = 0,
          h = a;
        l < h.length;
        l++
      ) {
        o(h[l]);
      }
    a.push.apply(a, s), (r[i] = a), Reflect.defineMetadata(t, r, e);
  }
  function qS(t) {
    return function (e, i, n) {
      'number' == typeof n
        ? $S(e, i, n, t)
        : (function (t, e, i) {
            if (void 0 !== t.prototype) throw new Error(yx);
            KS(Qb, t.constructor, e, i);
          })(e, i, t);
    };
  }
  function ZS() {
    return function (t) {
      if (Reflect.hasOwnMetadata(tx, t)) throw new Error('Cannot apply @injectable decorator multiple times.');
      var e = Reflect.getMetadata('design:paramtypes', t) || [];
      return Reflect.defineMetadata(tx, e, t), t;
    };
  }
  function JS(t) {
    return qS(new Ix(Yb, t));
  }
  function QS(t) {
    return function (e) {
      return function (i, n, s) {
        if (void 0 === e) {
          var r = 'function' == typeof i ? i.name : i.constructor.name;
          throw new Error(
            '@inject called with undefined this could mean that the class ' +
              r +
              ' has a circular dependency problem. You can use a LazyServiceIdentifer to  overcome this limitation.'
          );
        }
        return qS(new Ix(t, e))(i, n, s);
      };
    };
  }
  var tw = QS(qb),
    ew = QS(Zb);
  var iw,
    nw,
    sw =
      ((iw = ex),
      (nw = 'Cannot apply @postConstruct decorator multiple times in the same class'),
      function () {
        return function (t, e) {
          var i = new Ix(iw, e);
          if (Reflect.hasOwnMetadata(iw, t.constructor)) throw new Error(nw);
          Reflect.defineMetadata(iw, i, t.constructor);
        };
      });
  const rw = Symbol('ContributionProvider');
  class aw {
    constructor(t, e) {
      (this.serviceIdentifier = t), (this.container = e);
    }
    getContributions() {
      return (
        this.caches ||
          ((this.caches = []),
          this.container &&
            this.container.isBound(this.serviceIdentifier) &&
            this.caches.push(...this.container.getAll(this.serviceIdentifier))),
        this.caches
      );
    }
  }
  function ow(t, e) {
    t(rw)
      .toDynamicValue(t => {
        let { container: i } = t;
        return new aw(e, i);
      })
      .inSingletonScope()
      .whenTargetNamed(e);
  }
  class lw {
    constructor(t, e) {
      (this._args = t), (this.name = e), (this.taps = []);
    }
    tap(t, e) {
      this._tap('sync', t, e);
    }
    unTap(t, e) {
      const i = 'string' == typeof t ? t.trim() : t.name;
      i && (this.taps = this.taps.filter(t => t.name !== i && (!e || t.fn === e)));
    }
    _parseOptions(t, e, i) {
      let n;
      if ('string' == typeof e) n = { name: e.trim() };
      else if ('object' != typeof e || null === e) throw new Error('Invalid tap options');
      if ('string' != typeof n.name || '' === n.name) throw new Error('Missing name for tap');
      return (n = Object.assign({ type: t, fn: i }, n)), n;
    }
    _tap(t, e, i) {
      this._insert(this._parseOptions(t, e, i));
    }
    _insert(t) {
      let e;
      'string' == typeof t.before ? (e = new Set([t.before])) : Array.isArray(t.before) && (e = new Set(t.before));
      let i = 0;
      'number' == typeof t.stage && (i = t.stage);
      let n = this.taps.length;
      for (; n > 0; ) {
        n--;
        const t = this.taps[n];
        this.taps[n + 1] = t;
        const s = t.stage || 0;
        if (e) {
          if (e.has(t.name)) {
            e.delete(t.name);
            continue;
          }
          if (e.size > 0) continue;
        }
        if (!(s > i)) {
          n++;
          break;
        }
      }
      this.taps[n] = t;
    }
  }
  class hw extends lw {
    call() {
      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
      this.taps.map(t => t.fn).forEach(t => t(...e));
    }
  }
  const cw = Symbol.for('EnvContribution'),
    dw = Symbol.for('VGlobal');
  var uw = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    pw = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    gw = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let fw = class {
    get env() {
      return this._env;
    }
    get devicePixelRatio() {
      return this._env || this.setEnv('browser'), this.envContribution.getDevicePixelRatio();
    }
    get supportEvent() {
      return this._env || this.setEnv('browser'), this.envContribution.supportEvent;
    }
    get supportsTouchEvents() {
      return this._env || this.setEnv('browser'), this.envContribution.supportsTouchEvents;
    }
    get supportsPointerEvents() {
      return this._env || this.setEnv('browser'), this.envContribution.supportsPointerEvents;
    }
    get supportsMouseEvents() {
      return this._env || this.setEnv('browser'), this.envContribution.supportsMouseEvents;
    }
    get applyStyles() {
      return this._env || this.setEnv('browser'), this.envContribution.applyStyles;
    }
    constructor(t) {
      (this.contributions = t),
        (this.hooks = { onSetEnv: new hw(['lastEnv', 'env', 'global']) }),
        (this.measureTextMethod = 'native');
    }
    bindContribution(t) {
      const e = [];
      if (
        (this.contributions.getContributions().forEach(i => {
          const n = i.configure(this, t);
          n && n.then && e.push(n);
        }),
        e.length)
      )
        return Promise.all(e);
    }
    getDynamicCanvasCount() {
      return this._env || this.setEnv('browser'), this.envContribution.getDynamicCanvasCount();
    }
    getStaticCanvasCount() {
      return this._env || this.setEnv('browser'), this.envContribution.getStaticCanvasCount();
    }
    setEnv(t, e) {
      if ((e && !0 === e.force) || this._env !== t) return this.deactiveCurrentEnv(), this.activeEnv(t, e);
    }
    deactiveCurrentEnv() {
      this.envContribution && this.envContribution.release();
    }
    activeEnv(t, e) {
      const i = this._env;
      this._env = t;
      const n = this.bindContribution(e);
      if (n && n.then) {
        return n.then(() => {
          (this.envParams = e), this.hooks.onSetEnv.call(i, t, this);
        });
      }
      (this.envParams = e), this.hooks.onSetEnv.call(i, t, this);
    }
    setActiveEnvContribution(t) {
      this.envContribution = t;
    }
    createCanvas(t) {
      return this._env || this.setEnv('browser'), this.envContribution.createCanvas(t);
    }
    createOffscreenCanvas(t) {
      return this._env || this.setEnv('browser'), this.envContribution.createOffscreenCanvas(t);
    }
    releaseCanvas(t) {
      return this._env || this.setEnv('browser'), this.envContribution.releaseCanvas(t);
    }
    addEventListener(t, e, i) {
      return this._env || this.setEnv('browser'), this.envContribution.addEventListener(t, e, i);
    }
    removeEventListener(t, e, i) {
      return this._env || this.setEnv('browser'), this.envContribution.removeEventListener(t, e, i);
    }
    dispatchEvent(t) {
      return this._env || this.setEnv('browser'), this.envContribution.dispatchEvent(t);
    }
    getRequestAnimationFrame() {
      return this._env || this.setEnv('browser'), this.envContribution.getRequestAnimationFrame();
    }
    getCancelAnimationFrame() {
      return this._env || this.setEnv('browser'), this.envContribution.getCancelAnimationFrame();
    }
    getElementById(t) {
      return (
        this._env || this.setEnv('browser'),
        this.envContribution.getElementById ? this.envContribution.getElementById(t) : null
      );
    }
    getRootElement() {
      return (
        this._env || this.setEnv('browser'),
        this.envContribution.getRootElement ? this.envContribution.getRootElement() : null
      );
    }
    getDocument() {
      return (
        this._env || this.setEnv('browser'),
        this.envContribution.getDocument ? this.envContribution.getDocument() : null
      );
    }
    mapToCanvasPoint(t, e) {
      return (
        this._env || this.setEnv('browser'),
        this.envContribution.mapToCanvasPoint ? this.envContribution.mapToCanvasPoint(t, e) : null
      );
    }
    loadImage(t) {
      return this._env || this.setEnv('browser'), this.envContribution.loadImage(t);
    }
    loadSvg(t) {
      return this._env || this.setEnv('browser'), this.envContribution.loadSvg(t);
    }
    loadJson(t) {
      return this._env || this.setEnv('browser'), this.envContribution.loadJson(t);
    }
    loadArrayBuffer(t) {
      return this._env || this.setEnv('browser'), this.envContribution.loadArrayBuffer(t);
    }
    loadBlob(t) {
      return this._env || this.setEnv('browser'), this.envContribution.loadBlob(t);
    }
    isChrome() {
      return this._env || this.setEnv('browser'), 'browser' === this._env && navigator.userAgent.indexOf('Chrome') > -1;
    }
    isSafari() {
      return (
        this._env || this.setEnv('browser'),
        'browser' === this._env && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)
      );
    }
    getNativeAABBBounds(t) {
      return this._env || this.setEnv('browser'), this.envContribution.getNativeAABBBounds(t);
    }
    removeDom(t) {
      return this._env || this.setEnv('browser'), this.envContribution.removeDom(t);
    }
    createDom(t) {
      return this._env || this.setEnv('browser'), this.envContribution.createDom(t);
    }
    getElementTop(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      return this._env || this.setEnv('browser'), this.envContribution.getElementTop(t, e);
    }
    getElementLeft(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      return this._env || this.setEnv('browser'), this.envContribution.getElementLeft(t, e);
    }
    getElementTopLeft(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      return this._env || this.setEnv('browser'), this.envContribution.getElementTopLeft(t, e);
    }
  };
  fw = uw([ZS(), gw(0, tw(rw)), gw(0, JS(cw)), pw('design:paramtypes', [Object])], fw);
  const vw = Ct - 1e-8;
  class mw {
    constructor(t) {
      this.init(t);
    }
    init(t) {
      this.bounds = t;
    }
    arc(t, e, i, n, s, r) {
      if (Math.abs(s - n) > vw) return this.bounds.add(t - i, e - i), void this.bounds.add(t + i, e + i);
      let a,
        o,
        l,
        h,
        c = 1 / 0,
        d = -1 / 0,
        u = 1 / 0,
        p = -1 / 0;
      function g(t) {
        (l = i * Math.cos(t)),
          (h = i * Math.sin(t)),
          l < c && (c = l),
          l > d && (d = l),
          h < u && (u = h),
          h > p && (p = h);
      }
      if ((g(n), g(s), s !== n))
        if (((n %= Ct) < 0 && (n += Ct), (s %= Ct) < 0 && (s += Ct), s < n && ((r = !r), (a = n), (n = s), (s = a)), r))
          for (s -= Ct, a = n - (n % Tt), o = 0; o < 4 && a > s; ++o, a -= Tt) g(a);
        else for (a = n - (n % Tt) + Tt, o = 0; o < 4 && a < s; ++o, a += Tt) g(a);
      this.bounds.add(t + c, e + u), this.bounds.add(t + d, e + p);
    }
    arcTo(t, e, i, n, s) {
      throw new Error('不支持arcTo');
    }
    bezierCurveTo(t, e, i, n, s, r) {
      this.bounds.add(t, e), this.bounds.add(i, n), this.bounds.add(s, r);
    }
    closePath() {}
    ellipse() {
      throw new Error('不支持ellipse');
    }
    lineTo(t, e) {
      this.bounds.add(t, e);
    }
    moveTo(t, e) {
      this.bounds.add(t, e);
    }
    quadraticCurveTo(t, e, i, n) {
      this.bounds.add(t, e), this.bounds.add(i, n);
    }
    rect(t, e, i, n) {
      this.bounds.add(t, e), this.bounds.add(t + i, e + n);
    }
    clear() {
      this.bounds.clear();
    }
    release() {}
  }
  class yw {
    constructor() {
      (this.curves = []), (this.bounds = new Kt());
    }
    getCurveLengths() {
      return this.curves.map(t => t.getLength());
    }
    getPointAt(t) {
      return { x: 0, y: 0 };
    }
    getLength() {
      return 0;
    }
    getBounds() {
      return this.bounds;
    }
  }
  const _w = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi,
    bw = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7, M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7 },
    xw = { A: 0, AT: 1, C: 2, Z: 3, E: 4, L: 5, M: 6, Q: 7, R: 8 };
  let Sw, ww, Aw, kw, Mw, Tw;
  var Cw, Ew, Pw, Rw, Ow, Bw, Iw, Dw, Lw;
  function Fw(t) {
    const e = t[0],
      i = t[1],
      n = t[2],
      s = t[3],
      r = t[4],
      a = t[5],
      o = t[6],
      l = t[7],
      h = l * r,
      c = -o * a,
      d = o * r,
      u = l * a,
      p = Math.cos(n),
      g = Math.sin(n),
      f = Math.cos(s),
      v = Math.sin(s),
      m = 0.5 * (s - n),
      y = Math.sin(0.5 * m),
      _ = ((8 / 3) * y * y) / Math.sin(m),
      b = e + p - _ * g,
      x = i + g + _ * p,
      S = e + f,
      w = i + v,
      A = S + _ * v,
      k = w - _ * f;
    return [h * b + c * x, d * b + u * x, h * A + c * k, d * A + u * k, h * S + c * w, d * S + u * w];
  }
  function jw(t, e, i, n) {
    const s = (function (t, e, i, n, s, r, a, o, l) {
      const h = qt(a),
        c = Math.sin(h),
        d = Math.cos(h),
        u = d * (o - t) * 0.5 + c * (l - e) * 0.5,
        p = d * (l - e) * 0.5 - c * (o - t) * 0.5;
      let g = (u * u) / ((i = Math.abs(i)) * i) + (p * p) / ((n = Math.abs(n)) * n);
      g > 1 && ((g = Math.sqrt(g)), (i *= g), (n *= g));
      const f = d / i,
        v = c / i,
        m = -c / n,
        y = d / n,
        _ = f * o + v * l,
        b = m * o + y * l,
        x = f * t + v * e,
        S = m * t + y * e;
      let w = 1 / ((x - _) * (x - _) + (S - b) * (S - b)) - 0.25;
      w < 0 && (w = 0);
      let A = Math.sqrt(w);
      r === s && (A = -A);
      const k = 0.5 * (_ + x) - A * (S - b),
        M = 0.5 * (b + S) + A * (x - _),
        T = Math.atan2(b - M, _ - k);
      let C = Math.atan2(S - M, x - k) - T;
      C < 0 && 1 === r ? (C += Ct) : C > 0 && 0 === r && (C -= Ct);
      const E = Math.ceil(Math.abs(C / (Tt + 0.001))),
        P = [];
      for (let t = 0; t < E; ++t) {
        const e = T + (t * C) / E,
          s = T + ((t + 1) * C) / E;
        P[t] = [k, M, e, s, i, n, c, d];
      }
      return P;
    })(n[5], n[6], n[0], n[1], n[3], n[4], n[2], e, i);
    for (let e = 0; e < s.length; ++e) {
      const i = Fw(s[e]);
      t.bezierCurveTo(i[0], i[1], i[2], i[3], i[4], i[5]);
    }
  }
  !(function (t) {
    (t[(t.NONE = 0)] = 'NONE'),
      (t[(t.UPDATE_BOUNDS = 1)] = 'UPDATE_BOUNDS'),
      (t[(t.UPDATE_SHAPE = 2)] = 'UPDATE_SHAPE'),
      (t[(t.CLEAR_SHAPE = 253)] = 'CLEAR_SHAPE'),
      (t[(t.UPDATE_SHAPE_AND_BOUNDS = 3)] = 'UPDATE_SHAPE_AND_BOUNDS'),
      (t[(t.INIT = 179)] = 'INIT'),
      (t[(t.CLEAR_BOUNDS = 254)] = 'CLEAR_BOUNDS'),
      (t[(t.UPDATE_GLOBAL_MATRIX = 32)] = 'UPDATE_GLOBAL_MATRIX'),
      (t[(t.CLEAR_GLOBAL_MATRIX = 223)] = 'CLEAR_GLOBAL_MATRIX'),
      (t[(t.UPDATE_LOCAL_MATRIX = 16)] = 'UPDATE_LOCAL_MATRIX'),
      (t[(t.CLEAR_LOCAL_MATRIX = 239)] = 'CLEAR_LOCAL_MATRIX'),
      (t[(t.UPDATE_GLOBAL_LOCAL_MATRIX = 48)] = 'UPDATE_GLOBAL_LOCAL_MATRIX'),
      (t[(t.UPDATE_LAYOUT = 128)] = 'UPDATE_LAYOUT'),
      (t[(t.CLEAR_LAYOUT = 127)] = 'CLEAR_LAYOUT');
  })(Cw || (Cw = {})),
    (function (t) {
      (t[(t.GLOBAL = 1)] = 'GLOBAL'),
        (t[(t.LOCAL = 16)] = 'LOCAL'),
        (t[(t.GLOBAL_ACCURATE = 3)] = 'GLOBAL_ACCURATE'),
        (t[(t.LOCAL_ACCURATE = 48)] = 'LOCAL_ACCURATE');
    })(Ew || (Ew = {})),
    (function (t) {
      (t[(t.INIT = 0)] = 'INIT'),
        (t[(t.DEFAULT = 1)] = 'DEFAULT'),
        (t[(t.STATE = 2)] = 'STATE'),
        (t[(t.ANIMATE_BIND = 10)] = 'ANIMATE_BIND'),
        (t[(t.ANIMATE_PLAY = 11)] = 'ANIMATE_PLAY'),
        (t[(t.ANIMATE_START = 12)] = 'ANIMATE_START'),
        (t[(t.ANIMATE_UPDATE = 13)] = 'ANIMATE_UPDATE'),
        (t[(t.ANIMATE_END = 14)] = 'ANIMATE_END'),
        (t[(t.TRANSLATE = 20)] = 'TRANSLATE'),
        (t[(t.TRANSLATE_TO = 21)] = 'TRANSLATE_TO'),
        (t[(t.SCALE = 22)] = 'SCALE'),
        (t[(t.SCALE_TO = 23)] = 'SCALE_TO'),
        (t[(t.ROTATE = 24)] = 'ROTATE'),
        (t[(t.ROTATE_TO = 25)] = 'ROTATE_TO');
    })(Pw || (Pw = {})),
    (function (t) {
      (t[(t.INITIAL = 0)] = 'INITIAL'),
        (t[(t.RUNNING = 1)] = 'RUNNING'),
        (t[(t.PAUSED = 2)] = 'PAUSED'),
        (t[(t.END = 3)] = 'END');
    })(Rw || (Rw = {})),
    (function (t) {
      (t[(t.NORMAL = 0)] = 'NORMAL'), (t[(t.SET_ATTR_IMMEDIATELY = 1)] = 'SET_ATTR_IMMEDIATELY');
    })(Ow || (Ow = {})),
    (function (t) {
      (t.wait = 'wait'), (t.from = 'from'), (t.to = 'to'), (t.customAnimate = 'customAnimate');
    })(Bw || (Bw = {})),
    (function (t) {
      (t[(t.ROW = 1)] = 'ROW'), (t[(t.COLUMN = 2)] = 'COLUMN');
    })(Iw || (Iw = {})),
    (function (t) {
      (t[(t.CubicBezierCurve = 0)] = 'CubicBezierCurve'),
        (t[(t.QuadraticBezierCurve = 1)] = 'QuadraticBezierCurve'),
        (t[(t.ArcCurve = 2)] = 'ArcCurve'),
        (t[(t.LineCurve = 3)] = 'LineCurve'),
        (t[(t.EllipseCurve = 4)] = 'EllipseCurve'),
        (t[(t.MoveCurve = 5)] = 'MoveCurve');
    })(Dw || (Dw = {})),
    (function (t) {
      (t[(t.beforeFillStroke = 0)] = 'beforeFillStroke'), (t[(t.afterFillStroke = 1)] = 'afterFillStroke');
    })(Lw || (Lw = {}));
  const zw = (t, e, i, n, s, r, a) => {
      const o = Math.abs(i - e),
        l = (4 * Math.tan(o / 4)) / 3,
        h = i < e ? -1 : 1,
        c = Math.cos(e),
        d = Math.sin(e),
        u = Math.cos(i),
        p = Math.sin(i),
        g = c * r + n,
        f = d * a + s,
        v = u * r + n,
        m = p * a + s,
        y = r * l * h,
        _ = a * l * h;
      t.push(g - y * d, f + _ * c, v + y * p, m - _ * u, v, m);
    },
    Hw = [
      (t, e, i, n, s, r, a) => e.arc(t[1] * s + i, t[2] * r + n, (t[3] * (s + r)) / 2, t[4], t[5], t[6], a),
      (t, e, i, n, s, r, a) => e.arcTo(t[1] * s + i, t[2] * r + n, t[3] * s + i, t[4] * r + n, (t[5] * (s + r)) / 2, a),
      (t, e, i, n, s, r, a) =>
        e.bezierCurveTo(t[1] * s + i, t[2] * r + n, t[3] * s + i, t[4] * r + n, t[5] * s + i, t[6] * r + n, a),
      (t, e, i, n) => e.closePath(),
      (t, e, i, n, s, r) => e.ellipse(t[1] * s + i, t[2] * r + n, t[3] * s, t[4] * r, t[5], t[6], t[7], t[8]),
      (t, e, i, n, s, r, a) => e.lineTo(t[1] * s + i, t[2] * r + n, a),
      (t, e, i, n, s, r, a) => e.moveTo(t[1] * s + i, t[2] * r + n, a),
      (t, e, i, n, s, r, a) => e.quadraticCurveTo(t[1] * s + i, t[2] * r + n, t[3] * s + i, t[4] * r + n, a),
      (t, e, i, n, s, r, a) => e.rect(t[1] * s + i, t[2] * r + n, t[3] * s, t[4] * r, a)
    ];
  function Nw(t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
      n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
      s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1,
      r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1,
      a = arguments.length > 6 ? arguments[6] : void 0;
    for (let o = 0; o < t.length; o++) {
      const l = t[o];
      Hw[l[0]](l, e, i, n, s, r, a);
    }
  }
  class Vw {
    getLength(t) {
      return null != t
        ? this.calcProjLength(t)
        : (Number.isFinite(this.length) || (this.length = this.calcLength()), this.length);
    }
  }
  function Ww(t, e, i, n, s) {
    return (function (t, e) {
      let i = 0;
      const n = t.length;
      for (let s = 0; s < n; s++) {
        const r = t[s],
          a = e[s],
          o = t[(s + 1) % n],
          l = e[(s + 1) % n];
        i += Yt.distanceNN(r, a, o, l);
      }
      return i / 2;
    })([t.x, e.x, i.x, n.x], [t.y, e.y, i.y, n.y]);
  }
  function Gw(t, e, i, n, s) {
    const r = 1 - s;
    return r * r * r * t + 3 * e * s * r * r + 3 * i * s * s * r + n * s * s * s;
  }
  function Uw(t, e, i, n, s) {
    const r = Gw(t.x, e.x, i.x, n.x, s),
      a = Gw(t.y, e.y, i.y, n.y, s);
    return new Ut(r, a);
  }
  function Yw(t, e) {
    const { p0: i, p1: n, p2: s, p3: r } = t,
      a = Uw(i, n, s, r, e),
      o = Yt.pointAtPP(i, n, e),
      l = Yt.pointAtPP(n, s, e),
      h = Yt.pointAtPP(s, r, e),
      c = Yt.pointAtPP(o, l, e),
      d = Yt.pointAtPP(l, h, e);
    return [new $w(i, o, c, a), new $w(a, d, h, r)];
  }
  class $w extends Vw {
    constructor(t, e, i, n) {
      super(), (this.type = Dw.CubicBezierCurve), (this.p0 = t), (this.p1 = e), (this.p2 = i), (this.p3 = n);
    }
    _validPoint() {
      return Number.isFinite(
        this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y
      );
    }
    getPointAt(t) {
      if (!1 !== this.defined) return Uw(this.p0, this.p1, this.p2, this.p3, t);
      throw new Error('defined为false的点不能getPointAt');
    }
    calcLength() {
      return this._validPoint() ? Ww(this.p0, this.p1, this.p2, this.p3) : 60;
    }
    calcProjLength(t) {
      return t === Iw.ROW ? Pt(this.p0.x - this.p3.x) : t === Iw.COLUMN ? Pt(this.p0.y - this.p3.y) : 0;
    }
    getAngleAt(t) {
      const e = Bt(t - 0.01, 0),
        i = It(t + 0.01, 1),
        n = this.getPointAt(e),
        s = this.getPointAt(i);
      return Rt(s.y - n.y, s.x - n.x);
    }
  }
  function Xw(t, e) {
    const { p0: i, p1: n } = t,
      s = Yt.pointAtPP(i, n, e);
    return [new Kw(i, s), new Kw(s, n)];
  }
  class Kw extends Vw {
    constructor(t, e) {
      super(), (this.type = Dw.LineCurve), (this.p0 = t), (this.p1 = e);
    }
    getPointAt(t) {
      if (!1 !== this.defined) return Yt.pointAtPP(this.p0, this.p1, t);
      throw new Error('defined为false的点不能getPointAt');
    }
    getAngleAt(t) {
      return null == this.angle && (this.angle = Rt(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), this.angle;
    }
    _validPoint() {
      return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
    }
    calcLength() {
      return this._validPoint() ? Yt.distancePP(this.p0, this.p1) : 60;
    }
    calcProjLength(t) {
      return t === Iw.ROW ? Pt(this.p0.x - this.p1.x) : t === Iw.COLUMN ? Pt(this.p0.y - this.p1.y) : 0;
    }
  }
  class qw {
    get endX() {
      return this._lastX;
    }
    get endY() {
      return this._lastY;
    }
    constructor(t, e) {
      this.init(t, e);
    }
    init(t, e) {
      (this._lastX = this._lastY = this._startX = this._startY = 0),
        (this.curveType = t),
        (this.direction = e),
        (this.curves = []);
    }
    bezierCurveTo(t, e, i, n, s, r, a, o) {
      const l = new $w(new Ut(this._lastX, this._lastY), new Ut(t, e), new Ut(i, n), new Ut(s, r));
      (l.originP1 = this._lastOriginP),
        (l.originP2 = o),
        (l.defined = a),
        this.curves.push(l),
        (this._lastX = s),
        (this._lastY = r),
        (this._lastOriginP = o);
    }
    closePath() {
      if (this.curves.length < 2) return;
      const t = this.curves[this.curves.length - 1];
      this.lineTo(this._startX, this._startY, t.defined, this._startOriginP);
    }
    ellipse() {
      throw new Error('SegContext不支持调用ellipse');
    }
    lineTo(t, e, i, n) {
      const s = this.addLinearCurve(t, e, i, this._lastOriginP, n);
      this.curves.push(s), (this._lastX = t), (this._lastY = e), (this._lastOriginP = n);
    }
    moveTo(t, e, i) {
      return (
        (this._lastX = this._startX = t),
        (this._lastY = this._startY = e),
        (this._lastOriginP = i),
        (this._startOriginP = i),
        this
      );
    }
    quadraticCurveTo(t, e, i, n) {
      throw new Error('SegContext不支持调用quadraticCurveTo');
    }
    clear() {
      (this.curves = []), (this.length = NaN);
    }
    tryUpdateLength(t) {
      return this.getLength(t);
    }
    addLinearCurve(t, e, i, n, s) {
      const r = new Kw(new Ut(this._lastX, this._lastY), new Ut(t, e));
      return (r.originP1 = n), (r.originP2 = s), (r.defined = i), r;
    }
    getPointAt(t) {
      throw new Error('暂未实现');
    }
    getCurveLengths() {
      return [];
    }
    getLength(t) {
      var e, i;
      if (t === Iw.COLUMN) {
        if (!this.curves.length) return 0;
        const t = this.curves[0],
          i = this.curves[this.curves.length - 1],
          n = null !== (e = i.p3) && void 0 !== e ? e : i.p1;
        return Pt(t.p0.y - n.y);
      }
      if (t === Iw.ROW) {
        if (!this.curves.length) return 0;
        const t = this.curves[0],
          e = this.curves[this.curves.length - 1],
          n = null !== (i = e.p3) && void 0 !== i ? i : e.p1;
        return Pt(t.p0.x - n.x);
      }
      return (
        Number.isFinite(this.length) || (this.length = this.curves.reduce((t, e) => t + e.getLength(), 0)), this.length
      );
    }
  }
  class Zw extends qw {
    bezierCurveTo(t, e, i, n, s, r, a, o) {
      return super.bezierCurveTo(e, t, n, i, r, s, a, o);
    }
    lineTo(t, e, i, n) {
      return super.lineTo(e, t, i, n);
    }
    moveTo(t, e, i) {
      return super.moveTo(e, t, i);
    }
    clear() {
      return super.clear();
    }
  }
  function Jw(t, e) {
    let i = !1;
    for (let n = 0, s = e.length; n <= s; n++)
      n >= s === i && ((i = !i) ? t.lineStart() : t.lineEnd()), i && t.point(e[n]);
  }
  class Qw {
    constructor(t, e) {
      (this.context = t), e && (this.startPoint = e);
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      (this._point = 0), this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
      (this._line || (0 !== this._line && 1 === this._point)) && this.context.closePath(),
        (this._line = 1 - this._line);
    }
    point(t) {
      const e = t.x,
        i = t.y;
      switch (this._point) {
        case 0:
          (this._point = 1),
            this._line
              ? this.context.lineTo(e, i, !1 !== this._lastDefined && !1 !== t.defined, t)
              : this.context.moveTo(e, i, t);
          break;
        case 1:
          this._point = 2;
        default:
          this.context.lineTo(e, i, !1 !== this._lastDefined && !1 !== t.defined, t);
      }
      this._lastDefined = t.defined;
    }
    tryUpdateLength() {
      return this.context.tryUpdateLength();
    }
  }
  function tA(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const { direction: i, startPoint: n } = e;
    if (t.length < 2 - Number(!!n)) return null;
    const s = new qw(
      'linear',
      null != i ? i : Pt(t[t.length - 1].x - t[0].x) > Pt(t[t.length - 1].y - t[0].y) ? Iw.ROW : Iw.COLUMN
    );
    return (
      (function (t, e) {
        Jw(t, e);
      })(new Qw(s, n), t),
      s
    );
  }
  function eA(t, e, i, n, s) {
    t.context.bezierCurveTo(
      (2 * t._x0 + t._x1) / 3,
      (2 * t._y0 + t._y1) / 3,
      (t._x0 + 2 * t._x1) / 3,
      (t._y0 + 2 * t._y1) / 3,
      (t._x0 + 4 * t._x1 + e) / 6,
      (t._y0 + 4 * t._y1 + i) / 6,
      n,
      t.lastPoint1
    );
  }
  class iA {
    constructor(t, e) {
      (this.context = t), (this.startPoint = e);
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      (this._x0 = this._x1 = this._y0 = this._y1 = NaN),
        (this._point = 0),
        this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
      2 === this._point &&
        eA(
          this,
          6 * this._x1 - (this._x0 + 4 * this._x1),
          6 * this._y1 - (this._y0 + 4 * this._y1),
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
          this.lastPoint1
        ),
        (this._line || (0 !== this._line && 1 === this._point)) && this.context.closePath(),
        (this._line = 1 - this._line);
    }
    point(t) {
      const e = t.x,
        i = t.y;
      switch (this._point) {
        case 0:
          (this._point = 1),
            this._line
              ? this.context.lineTo(e, i, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, t)
              : this.context.moveTo(e, i, t);
          break;
        case 1:
          this._point = 2;
          break;
        default:
          eA(this, e, i, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
      }
      (this._x0 = this._x1),
        (this._x1 = e),
        (this._y0 = this._y1),
        (this._y1 = i),
        (this._lastDefined1 = this._lastDefined2),
        (this._lastDefined2 = t.defined),
        (this.lastPoint0 = this.lastPoint1),
        (this.lastPoint1 = t);
    }
    tryUpdateLength() {
      return this.context.tryUpdateLength();
    }
  }
  function nA(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const { direction: i, startPoint: n } = e;
    if (t.length < 2 - Number(!!n)) return null;
    if (t.length < 3 - Number(!!n)) return tA(t, e);
    const s = new qw(
      'basis',
      null != i ? i : Pt(t[t.length - 1].x - t[0].x) > Pt(t[t.length - 1].y - t[0].y) ? Iw.ROW : Iw.COLUMN
    );
    return (
      (function (t, e) {
        Jw(t, e);
      })(new iA(s, n), t),
      s
    );
  }
  function sA(t) {
    return t < 0 ? -1 : 1;
  }
  function rA(t, e, i) {
    const n = t._x1 - t._x0,
      s = e - t._x1,
      r = (t._y1 - t._y0) / (n || Number(s < 0 && -0)),
      a = (i - t._y1) / (s || Number(n < 0 && -0)),
      o = (r * s + a * n) / (n + s);
    return (sA(r) + sA(a)) * Math.min(Math.abs(r), Math.abs(a), 0.5 * Math.abs(o)) || 0;
  }
  function aA(t, e) {
    const i = t._x1 - t._x0;
    return i ? ((3 * (t._y1 - t._y0)) / i - e) / 2 : e;
  }
  function oA(t, e, i, n, s) {
    const r = t._x0,
      a = t._y0,
      o = t._x1,
      l = t._y1,
      h = (o - r) / 3;
    t.context.bezierCurveTo(r + h, a + h * e, o - h, l - h * i, o, l, n, t.lastPoint1);
  }
  class lA {
    constructor(t, e) {
      (this.context = t), (this.startPoint = e);
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      (this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN),
        (this._point = 0),
        this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
      switch (this._point) {
        case 2:
          this.context.lineTo(this._x1, this._y1, !1 !== this._lastDefined2, this.lastPoint1);
          break;
        case 3:
          oA(this, this._t0, aA(this, this._t0), !1 !== this._lastDefined2, this.lastPoint1);
      }
      (this._line || (0 !== this._line && 1 === this._point)) && this.context.closePath(),
        (this._line = 1 - this._line);
    }
    point(t) {
      let e = NaN;
      const i = t.x,
        n = t.y;
      if (i !== this._x1 || n !== this._y1) {
        switch (this._point) {
          case 0:
            (this._point = 1),
              this._line
                ? this.context.lineTo(i, n, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, t)
                : this.context.moveTo(i, n, t);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            (this._point = 3),
              oA(this, aA(this, (e = rA(this, i, n))), e, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
            break;
          default:
            oA(this, this._t0, (e = rA(this, i, n)), !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
        }
        (this._x0 = this._x1),
          (this._x1 = i),
          (this._y0 = this._y1),
          (this._y1 = n),
          (this._t0 = e),
          (this._lastDefined1 = this._lastDefined2),
          (this._lastDefined2 = !1 !== t.defined),
          (this.lastPoint0 = this.lastPoint1),
          (this.lastPoint1 = t);
      }
    }
    tryUpdateLength() {
      return this.context.tryUpdateLength();
    }
  }
  class hA extends lA {
    constructor(t, e) {
      super(t, e);
    }
    point(t) {
      return super.point({ y: t.x, x: t.y, defined: t.defined });
    }
  }
  function cA(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const { direction: i, startPoint: n } = e;
    if (t.length < 2 - Number(!!n)) return null;
    if (t.length < 3 - Number(!!n)) return tA(t, e);
    const s = new qw(
      'monotoneX',
      null != i ? i : Pt(t[t.length - 1].x - t[0].x) > Pt(t[t.length - 1].y - t[0].y) ? Iw.ROW : Iw.COLUMN
    );
    return (
      (function (t, e) {
        Jw(t, e);
      })(new lA(s, n), t),
      s
    );
  }
  function dA(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const { direction: i, startPoint: n } = e;
    if (t.length < 2 - Number(!!n)) return null;
    if (t.length < 3 - Number(!!n)) return tA(t, e);
    const s = new Zw(
      'monotoneY',
      null != i ? i : Pt(t[t.length - 1].x - t[0].x) > Pt(t[t.length - 1].y - t[0].y) ? Iw.ROW : Iw.COLUMN
    );
    return (
      (function (t, e) {
        Jw(t, e);
      })(new hA(s, n), t),
      s
    );
  }
  let uA = class {
    constructor(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.5,
        i = arguments.length > 2 ? arguments[2] : void 0;
      (this.context = t), (this._t = e), (this.startPoint = i);
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      (this._x = this._y = NaN), (this._point = 0), this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
      0 < this._t &&
        this._t < 1 &&
        2 === this._point &&
        this.context.lineTo(this._x, this._y, !1 !== this._lastDefined, this.lastPoint),
        (this._line || (0 !== this._line && 1 === this._point)) && this.context.closePath(),
        this._line >= 0 && ((this._t = 1 - this._t), (this._line = 1 - this._line));
    }
    point(t) {
      const e = t.x,
        i = t.y;
      switch (this._point) {
        case 0:
          (this._point = 1),
            this._line
              ? this.context.lineTo(e, i, !1 !== this._lastDefined && !1 !== t.defined, t)
              : this.context.moveTo(e, i, t);
          break;
        case 1:
          this._point = 2;
        default:
          if (this._t <= 0)
            this.context.lineTo(this._x, i, !1 !== this._lastDefined && !1 !== t.defined, this.lastPoint),
              this.context.lineTo(e, i, !1 !== this._lastDefined && !1 !== t.defined, t);
          else {
            const n = this._x * (1 - this._t) + e * this._t;
            this.context.lineTo(n, this._y, !1 !== this._lastDefined && !1 !== t.defined, this.lastPoint),
              this.context.lineTo(n, i, !1 !== this._lastDefined && !1 !== t.defined, t);
          }
      }
      (this._lastDefined = t.defined), (this._x = e), (this._y = i), (this.lastPoint = t);
    }
    tryUpdateLength() {
      return this.context.tryUpdateLength();
    }
  };
  function pA(t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    const { direction: n, startPoint: s } = i;
    if (t.length < 2 - Number(!!s)) return null;
    const r = new qw(
      'step',
      null != n ? n : Pt(t[t.length - 1].x - t[0].x) > Pt(t[t.length - 1].y - t[0].y) ? Iw.ROW : Iw.COLUMN
    );
    return (
      (function (t, e) {
        Jw(t, e);
      })(new uA(r, e, s), t),
      r
    );
  }
  class gA {
    constructor(t, e) {
      (this.context = t), e && (this.startPoint = e);
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      (this._point = 0), this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
      this.context.closePath();
    }
    point(t) {
      const e = t.x,
        i = t.y;
      switch (this._point) {
        case 0:
          (this._point = 1),
            this._line
              ? this.context.lineTo(e, i, !1 !== this._lastDefined && !1 !== t.defined, t)
              : this.context.moveTo(e, i, t);
          break;
        case 1:
          this._point = 2;
        default:
          this.context.lineTo(e, i, !1 !== this._lastDefined && !1 !== t.defined, t);
      }
      this._lastDefined = t.defined;
    }
    tryUpdateLength() {
      return this.context.tryUpdateLength();
    }
  }
  function fA(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const { direction: i, startPoint: n } = e;
    if (t.length < 2 - Number(!!n)) return null;
    const s = new qw(
      'linear',
      null != i ? i : Pt(t[t.length - 1].x - t[0].x) > Pt(t[t.length - 1].y - t[0].y) ? Iw.ROW : Iw.COLUMN
    );
    return (
      (function (t, e) {
        Jw(t, e);
      })(new gA(s, n), t),
      s
    );
  }
  function vA(t, e, i) {
    switch (e) {
      case 'linear':
      default:
        return tA(t, i);
      case 'basis':
        return nA(t, i);
      case 'monotoneX':
        return cA(t, i);
      case 'monotoneY':
        return dA(t, i);
      case 'step':
        return pA(t, 0.5, i);
      case 'stepBefore':
        return pA(t, 0, i);
      case 'stepAfter':
        return pA(t, 1, i);
      case 'linearClosed':
        return fA(t, i);
    }
  }
  class mA extends yw {
    constructor(t) {
      super(), (this.commandList = []), t && (this._ctx = t), (this._boundsContext = new mw(this.bounds));
    }
    setCtx(t) {
      this._ctx = t;
    }
    moveTo(t, e) {
      return this.commandList.push([xw.M, t, e]), this._ctx && this._ctx.moveTo(t, e), this;
    }
    lineTo(t, e) {
      return this.commandList.push([xw.L, t, e]), this._ctx && this._ctx.lineTo(t, e), this;
    }
    quadraticCurveTo(t, e, i, n) {
      return this.commandList.push([xw.Q, t, e, i, n]), this._ctx && this._ctx.quadraticCurveTo(t, e, i, n), this;
    }
    bezierCurveTo(t, e, i, n, s, r) {
      return (
        this.commandList.push([xw.C, t, e, i, n, s, r]), this._ctx && this._ctx.bezierCurveTo(t, e, i, n, s, r), this
      );
    }
    arcTo(t, e, i, n, s) {
      return this.commandList.push([xw.AT, t, e, i, n, s]), this._ctx && this._ctx.arcTo(t, e, i, n, s), this;
    }
    ellipse(t, e, i, n, s, r, a, o) {
      return (
        this.commandList.push([xw.E, t, e, i, n, s, r, a, o]),
        this._ctx && this._ctx.ellipse(t, e, i, n, s, r, a, o),
        this
      );
    }
    rect(t, e, i, n) {
      return this.commandList.push([xw.R, t, e, i, n]), this._ctx && this._ctx.rect(t, e, i, n), this;
    }
    arc(t, e, i, n, s, r) {
      return this.commandList.push([xw.A, t, e, i, n, s, r]), this._ctx && this._ctx.arc(t, e, i, n, s, r), this;
    }
    closePath() {
      return this.commandList.push([xw.Z]), this._ctx && this._ctx.closePath(), this;
    }
    addCurve(t) {
      this.curves.push(t);
    }
    clear() {
      (this.transformCbList = null), (this.commandList.length = 0), (this.curves.length = 0);
    }
    toString() {
      if (!this.toStringCbList) {
        const t = [];
        (t[xw.M] = t => `M${t[1]} ${t[2]}`),
          (t[xw.L] = t => `L${t[1]} ${t[2]}`),
          (t[xw.Q] = t => `Q${t[1]} ${t[2]} ${t[3]} ${t[4]}`),
          (t[xw.C] = t => `C${t[1]} ${t[2]} ${t[3]} ${t[4]} ${t[5]} ${t[6]}`),
          (t[xw.A] = t => {
            const e = [];
            zw(e, t[4], t[5], t[1], t[2], t[3], t[3]);
            let i = '';
            for (let t = 0; t < e.length; t += 6)
              i += `C${e[t]} ${e[t + 1]} ${e[t + 2]} ${e[t + 3]} ${e[t + 4]} ${e[t + 5]}`;
            return i;
          }),
          (t[xw.Z] = t => 'Z'),
          (this.toStringCbList = t);
      }
      const t = this.toStringCbList;
      let e = '';
      return (
        this.commandList.forEach(i => {
          e += t[i[0]](i);
        }),
        e
      );
    }
    fromString(t, e, i, n, s) {
      this.clear();
      const r = (function (t) {
        if (!t) return [];
        const e = t.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
        if (null === e) return [];
        let i, n;
        const s = [];
        for (let t = 0, r = e.length; t < r; t++)
          if (((Sw = e[t]), (ww = Sw.slice(1)), (Aw = Sw[0]), (i = [Aw]), (n = ww.match(_w)), null !== n)) {
            for (let t = 0, e = n.length; t < e; t++)
              (kw = n[t]), (Mw = parseFloat(kw)), Number.isNaN(Mw) || i.push(Mw);
            if (((Tw = bw[Aw]), i.length - 1 > Tw)) {
              let t;
              for (let e = 1, n = i.length; e < n; e += Tw) {
                t = [Aw];
                for (let n = e, s = e + Tw; n < s; n++) t.push(i[n]);
                s.push(t);
              }
            } else s.push(i);
          } else s.push(i);
        return s;
      })(t);
      return this._runCommandStrList(r, e, i, n, s), this._updateBounds(), this;
    }
    fromLine(t) {
      const { points: e, curveType: i, clipRangeByDimension: n } = t.attribute;
      if (!e) return;
      const s = vA(e, i);
      'x' === n
        ? (this.direction = Iw.ROW)
        : 'y' === n
        ? (this.direction = Iw.COLUMN)
        : 'auto' === n && (this.direction = s.direction),
        (this.curves = s.curves);
    }
    fromCustomPath2D(t, e, i, n, s) {
      return this.clear(), this._runCommandList(t.commandList, e, i, n, s), this._updateBounds(), this;
    }
    transform(t, e, i, n) {
      const s = this.commandList;
      if (!this.transformCbList) {
        const t = [];
        (t[xw.M] = this.moveToTransform),
          (t[xw.L] = this.lineToTransform),
          (t[xw.Q] = this.quadraticCurveToTransform),
          (t[xw.C] = this.bezierCurveToTransform),
          (t[xw.AT] = this.arcToTransform),
          (t[xw.E] = this.ellipseTransform),
          (t[xw.R] = this.rectTransform),
          (t[xw.A] = this.arcTransform),
          (t[xw.Z] = this.closePathTransform),
          (this.transformCbList = t);
      }
      s.forEach(s => {
        this.transformCbList[s[0]](s, t, e, i, n);
      }),
        this._updateBounds();
    }
    moveToTransform(t, e, i, n, s) {
      (t[1] = t[1] * n + e), (t[2] = t[2] * s + i);
    }
    lineToTransform(t, e, i, n, s) {
      (t[1] = t[1] * n + e), (t[2] = t[2] * s + i);
    }
    quadraticCurveToTransform(t, e, i, n, s) {
      (t[1] = t[1] * n + e), (t[2] = t[2] * s + i), (t[3] = t[3] * n + e), (t[4] = t[4] * s + i);
    }
    bezierCurveToTransform(t, e, i, n, s) {
      (t[1] = t[1] * n + e),
        (t[2] = t[2] * s + i),
        (t[3] = t[3] * n + e),
        (t[4] = t[4] * s + i),
        (t[5] = t[5] * n + e),
        (t[6] = t[6] * s + i);
    }
    arcToTransform(t, e, i, n, s) {
      (t[1] = t[1] * n + e),
        (t[2] = t[2] * s + i),
        (t[3] = t[3] * n + e),
        (t[4] = t[4] * s + i),
        (t[5] = (t[5] * (n + s)) / 2);
    }
    ellipseTransform(t, e, i, n, s) {
      (t[1] = t[1] * n + e), (t[2] = t[2] * s + i), (t[3] = t[3] * n), (t[4] = t[4] * s);
    }
    rectTransform(t, e, i, n, s) {
      (t[1] = t[1] * n + e), (t[2] = t[2] * s + i), (t[3] = t[3] * n), (t[4] = t[4] * s);
    }
    arcTransform(t, e, i, n, s) {
      (t[1] = t[1] * n + e), (t[2] = t[2] * s + i), (t[3] = (t[3] * (n + s)) / 2);
    }
    closePathTransform() {}
    _runCommandStrList(t) {
      let e,
        i,
        n,
        s,
        r,
        a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
        o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
        l = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
        h = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1,
        c = null,
        d = 0,
        u = 0,
        p = 0,
        g = 0;
      for (let f = 0, v = t.length; f < v; ++f) {
        switch (((e = t[f]), (1 === l && 1 === h) || (e = _A(e, l, h)), e[0])) {
          case 'l':
            (d += e[1]), (u += e[2]), this.lineTo(d + a, u + o);
            break;
          case 'L':
            (d = e[1]), (u = e[2]), this.lineTo(d + a, u + o);
            break;
          case 'h':
            (d += e[1]), this.lineTo(d + a, u + o);
            break;
          case 'H':
            (d = e[1]), this.lineTo(d + a, u + o);
            break;
          case 'v':
            (u += e[1]), this.lineTo(d + a, u + o);
            break;
          case 'V':
            (u = e[1]), this.lineTo(d + a, u + o);
            break;
          case 'm':
            (d += e[1]), (u += e[2]), this.moveTo(d + a, u + o);
            break;
          case 'M':
            (d = e[1]), (u = e[2]), this.moveTo(d + a, u + o);
            break;
          case 'c':
            (i = d + e[5]),
              (n = u + e[6]),
              (p = d + e[3]),
              (g = u + e[4]),
              this.bezierCurveTo(d + e[1] + a, u + e[2] + o, p + a, g + o, i + a, n + o),
              (d = i),
              (u = n);
            break;
          case 'C':
            (d = e[5]),
              (u = e[6]),
              (p = e[3]),
              (g = e[4]),
              this.bezierCurveTo(e[1] + a, e[2] + o, p + a, g + o, d + a, u + o);
            break;
          case 's':
            (i = d + e[3]),
              (n = u + e[4]),
              (p = 2 * d - p),
              (g = 2 * u - g),
              this.bezierCurveTo(p + a, g + o, d + e[1] + a, u + e[2] + o, i + a, n + o),
              (p = d + e[1]),
              (g = u + e[2]),
              (d = i),
              (u = n);
            break;
          case 'S':
            (i = e[3]),
              (n = e[4]),
              (p = 2 * d - p),
              (g = 2 * u - g),
              this.bezierCurveTo(p + a, g + o, e[1] + a, e[2] + o, i + a, n + o),
              (d = i),
              (u = n),
              (p = e[1]),
              (g = e[2]);
            break;
          case 'q':
            (i = d + e[3]),
              (n = u + e[4]),
              (p = d + e[1]),
              (g = u + e[2]),
              this.quadraticCurveTo(p + a, g + o, i + a, n + o),
              (d = i),
              (u = n);
            break;
          case 'Q':
            (i = e[3]),
              (n = e[4]),
              this.quadraticCurveTo(e[1] + a, e[2] + o, i + a, n + o),
              (d = i),
              (u = n),
              (p = e[1]),
              (g = e[2]);
            break;
          case 't':
            (i = d + e[1]),
              (n = u + e[2]),
              null === c[0].match(/[QqTt]/)
                ? ((p = d), (g = u))
                : 't' === c[0]
                ? ((p = 2 * d - s), (g = 2 * u - r))
                : 'q' === c[0] && ((p = 2 * d - p), (g = 2 * u - g)),
              (s = p),
              (r = g),
              this.quadraticCurveTo(p + a, g + o, i + a, n + o),
              (d = i),
              (u = n),
              (p = d + e[1]),
              (g = u + e[2]);
            break;
          case 'T':
            (i = e[1]),
              (n = e[2]),
              (p = 2 * d - p),
              (g = 2 * u - g),
              this.quadraticCurveTo(p + a, g + o, i + a, n + o),
              (d = i),
              (u = n);
            break;
          case 'a':
            jw(this, d + a, u + o, [e[1], e[2], e[3], e[4], e[5], e[6] + d + a, e[7] + u + o]),
              (d += e[6]),
              (u += e[7]);
            break;
          case 'A':
            jw(this, d + a, u + o, [e[1], e[2], e[3], e[4], e[5], e[6] + a, e[7] + o]), (d = e[6]), (u = e[7]);
            break;
          case 'z':
          case 'Z':
            this.closePath();
        }
        c = e;
      }
    }
    _runCommandList(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
        s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1;
      if (0 !== e || 0 !== i || 1 !== n || 1 !== s)
        for (let r = 0, a = t.length; r < a; ++r) {
          const a = t[r].slice();
          switch (a[0]) {
            case xw.L:
              this.lineToTransform(a, e, i, n, s);
              break;
            case xw.M:
              this.moveToTransform(a, e, i, n, s);
              break;
            case xw.C:
              this.bezierCurveToTransform(a, e, i, n, s);
              break;
            case xw.Q:
              this.quadraticCurveToTransform(a, e, i, n, s);
              break;
            case xw.A:
              this.arcToTransform(a, e, i, n, s);
              break;
            case xw.E:
              this.ellipseTransform(a, e, i, n, s);
              break;
            case xw.R:
              this.rectTransform(a, e, i, n, s);
              break;
            case xw.AT:
              this.arcToTransform(a, e, i, n, s);
              break;
            case xw.Z:
              this.closePath();
          }
        }
      else this.commandList = t.map(t => t.slice());
    }
    _updateBounds() {
      this.bounds.clear(), Nw(this.commandList, this._boundsContext);
    }
    release() {
      (this.commandList = []), (this._boundsContext = null), (this._ctx = null);
    }
    getLength() {
      if (this.direction === Iw.COLUMN) {
        if (!this.curves.length) return 0;
        const t = this.curves[0],
          e = this.curves[this.curves.length - 1];
        return Pt(t.p0.y - e.p1.y);
      }
      if (this.direction === Iw.ROW) {
        if (!this.curves.length) return 0;
        const t = this.curves[0],
          e = this.curves[this.curves.length - 1];
        return Pt(t.p0.x - e.p1.x);
      }
      return this.curves.reduce((t, e) => t + e.getLength(), 0);
    }
    getAttrAt(t) {
      if (!this.curves) return { pos: { x: 0, y: 0 }, angle: 0 };
      let e,
        i = 0;
      for (let n = 0; n < this.curves.length; n++) {
        e = this.curves[n];
        const s = e.getLength(this.direction);
        if (i + s >= t) break;
        i += s;
      }
      const n = (t - i) / e.getLength(this.direction);
      return { pos: e.getPointAt(n), angle: e.getAngleAt(n) };
    }
  }
  const yA = ['l', 0, 0, 0, 0, 0, 0, 0];
  function _A(t, e, i) {
    const n = (yA[0] = t[0]);
    if ('a' === n || 'A' === n)
      (yA[1] = e * t[1]),
        (yA[2] = i * t[2]),
        (yA[3] = t[3]),
        (yA[4] = t[4]),
        (yA[5] = t[5]),
        (yA[6] = e * t[6]),
        (yA[7] = i * t[7]);
    else if ('h' === n || 'H' === n) yA[1] = e * t[1];
    else if ('v' === n || 'V' === n) yA[1] = i * t[1];
    else for (let n = 1, s = t.length; n < s; ++n) yA[n] = (n % 2 == 1 ? e : i) * t[n];
    return yA;
  }
  const bA = {
      x: 0,
      y: 0,
      z: 0,
      dx: 0,
      dy: 0,
      dz: 0,
      scrollX: 0,
      scrollY: 0,
      scaleX: 1,
      scaleY: 1,
      scaleZ: 1,
      angle: 0,
      alpha: 0,
      beta: 0,
      scaleCenter: [0, 0],
      anchor: [0, 0],
      anchor3d: [0, 0],
      postMatrix: new ie()
    },
    xA = { fillOpacity: 1, fill: !1, shadowBlur: 0, shadowColor: 'black', shadowOffsetX: 0, shadowOffsetY: 0 },
    SA = {
      strokeOpacity: 1,
      lineDash: [],
      lineDashOffset: 0,
      lineWidth: 1,
      lineCap: 'butt',
      lineJoin: 'miter',
      miterLimit: 10,
      strokeBoundsBuffer: 2,
      stroke: !1
    },
    wA = Object.assign(
      {
        outerBorder: Object.assign(Object.assign({}, SA), { distance: 0 }),
        innerBorder: Object.assign(Object.assign({}, SA), { distance: 0 })
      },
      SA
    ),
    AA = {
      text: '',
      maxLineWidth: 1 / 0,
      textAlign: 'left',
      textBaseline: 'alphabetic',
      fontSize: 16,
      fontFamily:
        'PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol',
      fontWeight: '',
      ellipsis: '…',
      fontVariant: '',
      fontStyle: '',
      lineHeight: void 0,
      underline: 0,
      lineThrough: 0,
      scaleIn3d: !1,
      direction: 'horizontal',
      wordBreak: 'break-all',
      ignoreBuf: !1
    },
    kA = Object.assign(
      Object.assign(
        Object.assign(
          {
            opacity: 1,
            background: null,
            texture: null,
            textureColor: 'black',
            textureSize: 10,
            texturePadding: 2,
            backgroundMode: 0,
            blur: 0,
            cursor: null,
            html: null
          },
          xA
        ),
        wA
      ),
      { alignSelf: 'auto' }
    ),
    MA = { connectedType: 'none', connectedStyle: {}, connectedX: NaN, connectedY: NaN },
    TA = Object.assign(
      Object.assign(
        {
          strokeSeg: null,
          pickable: !0,
          childrenPickable: !0,
          visible: !0,
          zIndex: 0,
          layout: null,
          boundsPadding: 0,
          pickMode: 'accurate',
          customPickShape: null,
          boundsMode: 'accurate',
          keepDirIn3d: !0,
          shadowRootIdx: 1
        },
        kA
      ),
      bA
    ),
    CA = Object.assign(Object.assign({}, TA), {
      startAngle: 0,
      endAngle: Et,
      innerRadius: 0,
      outerRadius: 1,
      cornerRadius: 0,
      padRadius: 0,
      padAngle: 0,
      cap: !1,
      forceShowCap: !1
    }),
    EA = Object.assign(Object.assign(Object.assign({}, TA), MA), {
      points: [],
      segments: [],
      curveType: 'linear',
      clipRange: 1,
      closePath: !1
    }),
    PA = Object.assign(Object.assign({}, TA), { radius: 1, startAngle: 0, endAngle: Et }),
    RA = Object.assign(Object.assign({}, TA), {
      width: 0,
      height: 0,
      cornerRadius: 0,
      path: [],
      clip: !1,
      visibleAll: !0,
      display: 'relative',
      flexDirection: 'row',
      flexWrap: 'wrap',
      justifyContent: 'flex-start',
      alignItems: 'flex-start',
      alignContent: 'flex-start'
    }),
    OA = Object.assign(Object.assign({}, TA), { path: '', width: 0, height: 0, cornerRadius: 0, clip: !1 }),
    BA = Object.assign(Object.assign(Object.assign({}, TA), MA), {
      points: [],
      segments: [],
      curveType: 'linear',
      clipRange: 1,
      clipRangeByDimension: 'default',
      closePath: !1
    }),
    IA = Object.assign(Object.assign({}, TA), {
      path: new mA(),
      customPath: () => {
        console.warn('空函数');
      }
    }),
    DA = Object.assign(Object.assign({}, TA), { points: [], cornerRadius: 0 }),
    LA = Object.assign(Object.assign({}, TA), { width: 0, height: 0, strokeBoundsBuffer: 0, cornerRadius: 0 }),
    FA = Object.assign(Object.assign({}, TA), { width: 0, height: 0, cornerRadius: 0, length: 0 }),
    jA = Object.assign(Object.assign({}, TA), { symbolType: 'circle', size: 10, keepDirIn3d: !0 }),
    zA = Object.assign(Object.assign(Object.assign({}, TA), AA), { strokeBoundsBuffer: 0, keepDirIn3d: !0 }),
    HA = Object.assign(Object.assign({}, TA), {
      width: 300,
      height: 300,
      ellipsis: !0,
      wordBreak: 'break-word',
      verticalDirection: 'top',
      textAlign: 'left',
      textBaseline: 'top',
      layoutDirection: 'horizontal',
      textConfig: [],
      maxHeight: void 0,
      maxWidth: void 0,
      singleLine: !1
    }),
    NA = Object.assign(
      Object.assign({ repeatX: 'no-repeat', repeatY: 'no-repeat', image: '', width: 0, height: 0 }, TA),
      { fill: !0, cornerRadius: 0 }
    ),
    VA = Object.assign(Object.assign({}, NA), {
      backgroundShowMode: 'never',
      backgroundWidth: 0,
      backgroundHeight: 0,
      textAlign: 'left',
      textBaseline: 'middle',
      direction: 'horizontal',
      margin: 0,
      id: '',
      width: 20,
      height: 20,
      backgroundFill: 'rgba(101, 117, 168, 0.1)',
      backgroundFillOpacity: 1,
      backgroundStroke: !1,
      backgroundStrokeOpacity: 1,
      backgroundRadius: 4,
      opacity: 1
    });
  const WA = new (class {})(),
    GA = {
      horizontal: { width: 'width', height: 'height', left: 'left', top: 'top', x: 'x', y: 'y', bottom: 'bottom' },
      vertical: { width: 'height', height: 'width', left: 'top', top: 'left', x: 'y', y: 'x', bottom: 'right' }
    },
    UA = !0,
    YA = !1,
    $A = /\w|\(|\)|-/,
    XA = /[.?!,;:/，。？！、；：]/,
    KA = /\S/;
  function qA(t, e, i, n, s) {
    if (!e || e <= 0) return 0;
    const r = WA.graphicUtil.textMeasure;
    let a = n,
      o = t.slice(0, a),
      l = Math.floor(r.measureText(o, i).width),
      h = t.slice(0, a + 1),
      c = Math.floor(r.measureText(h, i).width);
    for (; l > e || c <= e; ) {
      if ((l > e ? a-- : a++, a > t.length)) {
        a = t.length;
        break;
      }
      if (a < 0) {
        a = 0;
        break;
      }
      (o = t.slice(0, a)),
        (l = Math.floor(r.measureText(o, i).width)),
        (h = t.slice(0, a + 1)),
        (c = Math.floor(r.measureText(h, i).width));
    }
    return s && (a = ZA(t, a)), a;
  }
  function ZA(t, e) {
    let i = e;
    for (; ($A.test(t[i - 1]) && $A.test(t[i])) || XA.test(t[i]); ) if ((i--, i <= 0)) return e;
    return i;
  }
  function JA(t, e) {
    const i = WA.graphicUtil.textMeasure.measureText(t, e),
      n = { ascent: 0, height: 0, descent: 0, width: 0 };
    return (
      'number' != typeof i.actualBoundingBoxAscent || 'number' != typeof i.actualBoundingBoxDescent
        ? ((n.width = Math.floor(i.width)), (n.height = e.fontSize || 0), (n.ascent = n.height), (n.descent = 0))
        : ((n.width = Math.floor(i.width)),
          (n.height = Math.floor(i.actualBoundingBoxAscent + i.actualBoundingBoxDescent)),
          (n.ascent = Math.floor(i.actualBoundingBoxAscent)),
          (n.descent = n.height - n.ascent)),
      n
    );
  }
  var QA = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let tk = class {
    configure(t, e) {
      (this.canvas = t.canvas), (this.context = t.context), t.bindTextMeasure(this);
    }
    measureTextWidth(t, e) {
      return this.context
        ? (this.context.setTextStyleWithoutAlignBaseline(e), this.context.measureText(t).width)
        : this.estimate(t, e).width;
    }
    estimate(t, e) {
      let { fontSize: i = zA.fontSize } = e,
        n = 0,
        s = 0;
      for (let e = 0; e < t.length; e++) t.charCodeAt(e) < 128 ? n++ : s++;
      return { width: ~~(0.8 * n * i + s * i), height: i };
    }
    measureTextPixelHeight(t, e) {
      var i;
      if (!this.context) return null !== (i = e.fontSize) && void 0 !== i ? i : AA.fontSize;
      this.context.setTextStyleWithoutAlignBaseline(e);
      const n = this.context.measureText(t);
      return Math.abs(n.actualBoundingBoxAscent - n.actualBoundingBoxDescent);
    }
    measureTextBoundHieght(t, e) {
      var i;
      if (!this.context) return null !== (i = e.fontSize) && void 0 !== i ? i : AA.fontSize;
      this.context.setTextStyleWithoutAlignBaseline(e);
      const n = this.context.measureText(t);
      return Math.abs(n.fontBoundingBoxAscent - n.fontBoundingBoxDescent);
    }
    measureText(t, e) {
      return this.context
        ? (this.context.setTextStyleWithoutAlignBaseline(e), this.context.measureText(t))
        : this.estimate(t, e);
    }
    clipTextVertical(t, e, i, n) {
      if (0 === t.length) return { verticalList: t, width: 0 };
      const { fontSize: s = 12 } = e;
      t.forEach(t => {
        t.width = 0 === t.direction ? s : this.measureTextWidth(t.text, e);
      });
      const r = [];
      let a = 0,
        o = 0;
      for (; o < t.length && a + t[o].width < i; o++) (a += t[o].width), r.push(t[o]);
      if (t[o] && t[o].text.length > 1) {
        const s = this._clipText(t[o].text, e, i - a, 0, t[o].text.length - 1);
        if (n && s.str !== t[o].text) {
          let i = '',
            n = 0;
          for (let e = 0; e < o; e++) {
            const s = t[e];
            (i += s.text), (n += s.text.length);
          }
          i += t[o].text;
          let r = ZA(i, n + s.str.length);
          (r -= n),
            r !== s.str.length - 1 && ((s.str = s.str.substring(0, r)), (s.width = this.measureTextWidth(s.str, e)));
        }
        r.push(Object.assign(Object.assign({}, t[o]), { text: s.str, width: s.width })), (a += s.width);
      }
      return { verticalList: r, width: a };
    }
    clipText(t, e, i, n) {
      if (0 === t.length) return { str: '', width: 0 };
      let s = this.measureTextWidth(t, e);
      if (s <= i) return { str: t, width: s };
      if (((s = this.measureTextWidth(t[0], e)), s > i)) return { str: '', width: 0 };
      const r = this._clipText(t, e, i, 0, t.length - 1);
      if (n && r.str !== t) {
        const i = ZA(t, r.str.length);
        i !== r.str.length && ((r.str = t.substring(0, i)), (r.width = this.measureTextWidth(r.str, e)));
      }
      return r;
    }
    _clipText(t, e, i, n, s) {
      const r = Math.floor((n + s) / 2),
        a = t.substring(0, r + 1),
        o = this.measureTextWidth(a, e);
      let l;
      if (o > i) {
        if (a.length <= 1) return { str: '', width: 0 };
        const s = t.substring(0, r);
        return (l = this.measureTextWidth(s, e)), l <= i ? { str: s, width: l } : this._clipText(t, e, i, n, r);
      }
      if (o < i) {
        if (r >= t.length - 1) return { str: t, width: this.measureTextWidth(t, e) };
        const n = t.substring(0, r + 2);
        return (l = this.measureTextWidth(n, e)), l >= i ? { str: a, width: o } : this._clipText(t, e, i, r, s);
      }
      return { str: a, width: o };
    }
    clipTextWithSuffixVertical(t, e, i, n, s) {
      if ('' === n) return this.clipTextVertical(t, e, i, s);
      if (0 === t.length) return { verticalList: t, width: 0 };
      const r = this.clipTextVertical(t, e, i, s);
      if (
        r.verticalList.length === t.length &&
        r.verticalList[r.verticalList.length - 1].width === t[t.length - 1].width
      )
        return r;
      const a = this.measureTextWidth(n, e);
      if (a > i) return r;
      i -= a;
      const o = this.clipTextVertical(t, e, i, s);
      return (o.width += a), o.verticalList.push({ text: n, direction: 1, width: a }), o;
    }
    clipTextWithSuffix(t, e, i, n, s) {
      if ('' === n) return this.clipText(t, e, i, s);
      if (0 === t.length) return { str: '', width: 0 };
      const r = this.measureTextWidth(t, e);
      if (r <= i) return { str: t, width: r };
      const a = this.measureTextWidth(n, e);
      if (a > i) return { str: '', width: 0 };
      i -= a;
      const o = this._clipText(t, e, i, 0, t.length - 1);
      if (s && o.str !== t) {
        const i = ZA(t, o.str.length);
        i !== o.str.length && ((o.str = t.substring(0, i)), (o.width = this.measureTextWidth(o.str, e)));
      }
      return (o.str += n), (o.width += a), o;
    }
  };
  tk = QA([ZS()], tk);
  var ek = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  const ik = Symbol.for('TextMeasureContribution');
  let nk = class extends tk {};
  nk = ek([ZS()], nk);
  const sk = new US(),
    rk = Symbol.for('CanvasFactory'),
    ak = Symbol.for('Context2dFactory');
  function ok(t) {
    return sk.getNamed(rk, WA.global.env)(t);
  }
  const lk = 1e-4,
    hk = Math.sqrt(3),
    ck = 1 / 3;
  function dk(t) {
    return t > -kk && t < kk;
  }
  function uk(t) {
    return t > kk || t < -kk;
  }
  const pk = [0, 0],
    gk = [0, 0],
    fk = [0, 0];
  function vk(t, e) {
    return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]);
  }
  function mk(t, e, i, n) {
    const s = 1 - n;
    return s * (s * t + 2 * n * e) + n * n * i;
  }
  function yk(t, e, i, n, s) {
    const r = 1 - s;
    return r * r * (r * t + 3 * s * e) + s * s * (s * n + 3 * r * i);
  }
  function _k(t) {
    return (t %= Et) < 0 && (t += Et), t;
  }
  function bk(t, e, i, n, s, r) {
    if ((r > e && r > n) || (r < e && r < n)) return 0;
    if (n === e) return 0;
    const a = (r - e) / (n - e);
    let o = n < e ? 1 : -1;
    (1 !== a && 0 !== a) || (o = n < e ? 0.5 : -0.5);
    const l = a * (i - t) + t;
    return l === s ? 1 / 0 : l > s ? o : 0;
  }
  function xk(t, e, i, n, s, r, a, o, l) {
    if (0 === a) return !1;
    const h = a;
    return (
      !(
        (l > e + h && l > n + h && l > r + h) ||
        (l < e - h && l < n - h && l < r - h) ||
        (o > t + h && o > i + h && o > s + h) ||
        (o < t - h && o < i - h && o < s - h)
      ) &&
      (function (t, e, i, n, s, r, a, o, l) {
        let h = 0,
          c = 0.005,
          d = 1 / 0;
        (pk[0] = a), (pk[1] = o);
        for (let a = 0; a < 1; a += 0.05) {
          (gk[0] = mk(t, i, s, a)), (gk[1] = mk(e, n, r, a));
          const o = vk(pk, gk);
          o < d && ((h = a), (d = o));
        }
        d = 1 / 0;
        for (let a = 0; a < 32 && !(c < lk); a++) {
          const a = h - c,
            o = h + c;
          (gk[0] = mk(t, i, s, a)), (gk[1] = mk(e, n, r, a));
          const l = vk(gk, pk);
          if (a >= 0 && l < d) (h = a), (d = l);
          else {
            (fk[0] = mk(t, i, s, o)), (fk[1] = mk(e, n, r, o));
            const a = vk(fk, pk);
            o <= 1 && a < d ? ((h = o), (d = a)) : (c *= 0.5);
          }
        }
        return l && ((l[0] = mk(t, i, s, h)), (l[1] = mk(e, n, r, h))), Math.sqrt(d);
      })(t, e, i, n, s, r, o, l, null) <=
        h / 2
    );
  }
  function Sk(t, e, i, n, s, r, a, o, l, h, c) {
    if (0 === l) return !1;
    const d = l;
    return (
      !(
        (c > e + d && c > n + d && c > r + d && c > o + d) ||
        (c < e - d && c < n - d && c < r - d && c < o - d) ||
        (h > t + d && h > i + d && h > s + d && h > a + d) ||
        (h < t - d && h < i - d && h < s - d && h < a - d)
      ) &&
      (function (t, e, i, n, s, r, a, o, l, h, c) {
        let d,
          u,
          p,
          g,
          f = 0,
          v = 0.005,
          m = 1 / 0;
        (pk[0] = l), (pk[1] = h);
        for (let l = 0; l < 1; l += 0.05)
          (gk[0] = yk(t, i, s, a, l)), (gk[1] = yk(e, n, r, o, l)), (p = vk(pk, gk)), p < m && ((f = l), (m = p));
        m = 1 / 0;
        for (let l = 0; l < 32 && !(v < lk); l++)
          (d = f - v),
            (u = f + v),
            (gk[0] = yk(t, i, s, a, d)),
            (gk[1] = yk(e, n, r, o, d)),
            (p = vk(gk, pk)),
            d >= 0 && p < m
              ? ((f = d), (m = p))
              : ((fk[0] = yk(t, i, s, a, u)),
                (fk[1] = yk(e, n, r, o, u)),
                (g = vk(fk, pk)),
                u <= 1 && g < m ? ((f = u), (m = g)) : (v *= 0.5));
        return c && ((c[0] = yk(t, i, s, a, f)), (c[1] = yk(e, n, r, o, f))), Math.sqrt(m);
      })(t, e, i, n, s, r, a, o, h, c, null) <=
        d / 2
    );
  }
  function wk(t, e, i, n, s, r, a, o, l) {
    if (0 === a) return !1;
    const h = a;
    (o -= t), (l -= e);
    const c = Math.sqrt(o * o + l * l);
    if (c - h > i || c + h < i) return !1;
    if (Math.abs(n - s) % Et < 1e-4) return !0;
    if (r) {
      const t = n;
      (n = _k(s)), (s = _k(t));
    } else (n = _k(n)), (s = _k(s));
    n > s && (s += Et);
    let d = Math.atan2(l, o);
    return d < 0 && (d += Et), (d >= n && d <= s) || (d + Et >= n && d + Et <= s);
  }
  function Ak(t, e, i, n, s, r, a) {
    if (0 === s) return !1;
    const o = s,
      l = s / 2;
    let h = 0,
      c = t;
    if ((a > e + l && a > n + l) || (a < e - l && a < n - l) || (r > t + l && r > i + l) || (r < t - l && r < i - l))
      return !1;
    if (t === i) return Math.abs(r - t) <= o / 2;
    (h = (e - n) / (t - i)), (c = (t * n - i * e) / (t - i));
    const d = h * r - a + c;
    return (d * d) / (h * h + 1) <= ((o / 2) * o) / 2;
  }
  const kk = 1e-4;
  function Mk(t, e, i, n, s) {
    const r = 6 * i - 12 * e + 6 * t,
      a = 9 * e + 3 * n - 3 * t - 9 * i,
      o = 3 * e - 3 * t;
    let l = 0;
    if (dk(a)) {
      if (uk(r)) {
        const t = -o / r;
        t >= 0 && t <= 1 && (s[l++] = t);
      }
    } else {
      const t = r * r - 4 * a * o;
      if (dk(t)) s[0] = -r / (2 * a);
      else if (t > 0) {
        const e = Math.sqrt(t),
          i = (-r + e) / (2 * a),
          n = (-r - e) / (2 * a);
        i >= 0 && i <= 1 && (s[l++] = i), n >= 0 && n <= 1 && (s[l++] = n);
      }
    }
    return l;
  }
  const Tk = [-1, -1, -1],
    Ck = [-1, -1];
  function Ek() {
    const t = Ck[0];
    (Ck[0] = Ck[1]), (Ck[1] = t);
  }
  function Pk(t, e, i, n, s, r, a, o, l, h) {
    if ((h > e && h > n && h > r && h > o) || (h < e && h < n && h < r && h < o)) return 0;
    const c = (function (t, e, i, n, s, r) {
      const a = n + 3 * (e - i) - t,
        o = 3 * (i - 2 * e + t),
        l = 3 * (e - t),
        h = t - s,
        c = o * o - 3 * a * l,
        d = o * l - 9 * a * h,
        u = l * l - 3 * o * h;
      let p = 0;
      if (dk(c) && dk(d))
        if (dk(o)) r[0] = 0;
        else {
          const t = -l / o;
          t >= 0 && t <= 1 && (r[p++] = t);
        }
      else {
        const t = d * d - 4 * c * u;
        if (dk(t)) {
          const t = d / c,
            e = -o / a + t,
            i = -t / 2;
          e >= 0 && e <= 1 && (r[p++] = e), i >= 0 && i <= 1 && (r[p++] = i);
        } else if (t > 0) {
          const e = Math.sqrt(t);
          let i = c * o + 1.5 * a * (-d + e),
            n = c * o + 1.5 * a * (-d - e);
          (i = i < 0 ? -Math.pow(-i, ck) : Math.pow(i, ck)), (n = n < 0 ? -Math.pow(-n, ck) : Math.pow(n, ck));
          const s = (-o - (i + n)) / (3 * a);
          s >= 0 && s <= 1 && (r[p++] = s);
        } else {
          const t = (2 * c * o - 3 * a * d) / (2 * Math.sqrt(c * c * c)),
            e = Math.acos(t) / 3,
            i = Math.sqrt(c),
            n = Math.cos(e),
            s = (-o - 2 * i * n) / (3 * a),
            l = (-o + i * (n + hk * Math.sin(e))) / (3 * a),
            h = (-o + i * (n - hk * Math.sin(e))) / (3 * a);
          s >= 0 && s <= 1 && (r[p++] = s), l >= 0 && l <= 1 && (r[p++] = l), h >= 0 && h <= 1 && (r[p++] = h);
        }
      }
      return p;
    })(e, n, r, o, h, Tk);
    if (0 === c) return 0;
    let d = 0,
      u = -1,
      p = 0,
      g = 0;
    for (let h = 0; h < c; h++) {
      const c = Tk[h],
        f = 0 === c || 1 === c ? 0.5 : 1;
      yk(t, i, s, a, c) < l ||
        (u < 0 &&
          ((u = Mk(e, n, r, o, Ck)),
          Ck[1] < Ck[0] && u > 1 && Ek(),
          (p = yk(e, n, r, o, Ck[0])),
          u > 1 && (g = yk(e, n, r, o, Ck[1]))),
        2 === u
          ? c < Ck[0]
            ? (d += p < e ? f : -f)
            : c < Ck[1]
            ? (d += g < p ? f : -f)
            : (d += o < g ? f : -f)
          : c < Ck[0]
          ? (d += p < e ? f : -f)
          : (d += o < p ? f : -f));
    }
    return d;
  }
  function Rk(t, e, i, n, s, r, a, o) {
    if ((o > e && o > n && o > r) || (o < e && o < n && o < r)) return 0;
    const l = (function (t, e, i, n, s) {
      const r = t - 2 * e + i,
        a = 2 * (e - t),
        o = t - n;
      let l = 0;
      if (dk(r)) {
        if (uk(a)) {
          const t = -o / a;
          t >= 0 && t <= 1 && (s[l++] = t);
        }
      } else {
        const t = a * a - 4 * r * o;
        if (dk(t)) {
          const t = -a / (2 * r);
          t >= 0 && t <= 1 && (s[l++] = t);
        } else if (t > 0) {
          const e = Math.sqrt(t),
            i = (-a + e) / (2 * r),
            n = (-a - e) / (2 * r);
          i >= 0 && i <= 1 && (s[l++] = i), n >= 0 && n <= 1 && (s[l++] = n);
        }
      }
      return l;
    })(e, n, r, o, Tk);
    if (0 === l) return 0;
    const h = (function (t, e, i) {
      const n = t + i - 2 * e;
      return 0 === n ? 0.5 : (t - e) / n;
    })(e, n, r);
    if (h >= 0 && h <= 1) {
      let o = 0;
      const c = mk(e, n, r, h);
      for (let n = 0; n < l; n++) {
        const l = 0 === Tk[n] || 1 === Tk[n] ? 0.5 : 1;
        mk(t, i, s, Tk[n]) < a || (Tk[n] < h ? (o += c < e ? l : -l) : (o += r < c ? l : -l));
      }
      return o;
    }
    const c = 0 === Tk[0] || 1 === Tk[0] ? 0.5 : 1;
    return mk(t, i, s, Tk[0]) < a ? 0 : r < e ? c : -c;
  }
  function Ok(t, e, i, n, s, r, a, o) {
    if ((o -= e) > i || o < -i) return 0;
    const l = Math.sqrt(i * i - o * o);
    (Tk[0] = -l), (Tk[1] = l);
    const h = Math.abs(n - s);
    if (h < 1e-4) return 0;
    if (h >= Et - 1e-4) {
      (n = 0), (s = Et);
      const e = r ? 1 : -1;
      return a >= Tk[0] + t && a <= Tk[1] + t ? e : 0;
    }
    if (n > s) {
      const t = n;
      (n = s), (s = t);
    }
    n < 0 && ((n += Et), (s += Et));
    let c = 0;
    for (let e = 0; e < 2; e++) {
      const i = Tk[e];
      if (i + t > a) {
        let t = Math.atan2(o, i),
          e = r ? 1 : -1;
        t < 0 && (t = Et + t),
          ((t >= n && t <= s) || (t + Et >= n && t + Et <= s)) && (t > Mt / 2 && t < 1.5 * Mt && (e = -e), (c += e));
      }
    }
    return c;
  }
  function Bk(t) {
    return ((Math.round((t / Mt) * 1e8) / 1e8) % 2) * Mt;
  }
  function Ik(t, e) {
    let i = Bk(t[0]);
    i < 0 && (i += Et);
    const n = i - t[0];
    let s = t[1];
    (s += n),
      !e && s - i >= Et
        ? (s = i + Et)
        : e && i - s >= Et
        ? (s = i - Et)
        : !e && i > s
        ? (s = i + (Et - Bk(i - s)))
        : e && i < s && (s = i - (Et - Bk(s - i))),
      (t[0] = i),
      (t[1] = s);
  }
  const Dk = [0, 0];
  function Lk(t, e, i, n, s) {
    const r = t,
      a = t.length;
    let o,
      l,
      h = 0,
      c = 0,
      d = 0,
      u = 0,
      p = 0;
    for (let t = 0; t < a; t++) {
      const a = r[t],
        g = 0 === t;
      a[0] === xw.M && t > 1 && (i || (h += bk(c, d, u, p, n, s))), g && ((c = a[1]), (d = a[2]), (u = c), (p = d));
      const f = a[0],
        v = a[1],
        m = a[2],
        y = a[3],
        _ = a[4],
        b = a[5],
        x = a[6];
      let S = _,
        w = b;
      (Dk[0] = S), (Dk[1] = w), Ik(Dk, Boolean(a[6])), (S = Dk[0]), (w = Dk[1]);
      const A = S,
        k = w - S,
        M = !!(1 - (a[6] ? 0 : 1)),
        T = ((n - v) * y) / y + v;
      switch (f) {
        case xw.M:
          (u = v), (p = m), (c = u), (d = p);
          break;
        case xw.L:
          if (i) {
            if (Ak(c, d, v, m, e, n, s)) return !0;
          } else h += bk(c, d, v, m, n, s) || 0;
          (c = v), (d = m);
          break;
        case xw.C:
          if (i) {
            if (Sk(c, d, v, m, y, _, b, x, e, n, s)) return !0;
          } else h += Pk(c, d, v, m, y, _, b, x, n, s) || 0;
          (c = b), (d = x);
          break;
        case xw.Q:
          if (i) {
            if (xk(c, d, v, m, y, _, e, n, s)) return !0;
          } else h += Rk(c, d, v, m, y, _, n, s) || 0;
          (c = y), (d = _);
          break;
        case xw.A:
          if (
            ((o = Math.cos(A) * y + v),
            (l = Math.sin(A) * y + m),
            g ? ((u = o), (p = l)) : (h += bk(c, d, o, l, n, s)),
            i)
          ) {
            if (wk(v, m, y, A, A + k, M, e, T, s)) return !0;
          } else h += Ok(v, m, y, A, A + k, M, T, s);
          (c = Math.cos(A + k) * y + v), (d = Math.sin(A + k) * y + m);
          break;
        case xw.R:
          if (((u = c = v), (p = d = m), (o = u + y), (l = p + _), i)) {
            if (
              Ak(u, p, o, p, e, n, s) ||
              Ak(o, p, o, l, e, n, s) ||
              Ak(o, l, u, l, e, n, s) ||
              Ak(u, l, u, p, e, n, s)
            )
              return !0;
          } else (h += bk(o, p, o, l, n, s)), (h += bk(u, l, u, p, n, s));
          break;
        case xw.Z:
          if (i) {
            if (Ak(c, d, u, p, e, n, s)) return !0;
          } else h += bk(c, d, u, p, n, s);
          (c = u), (d = p);
      }
    }
    return (
      i ||
        (function (t, e) {
          return Math.abs(t - e) < kk;
        })(d, p) ||
        (h += bk(c, d, u, p, n, s) || 0),
      0 !== h
    );
  }
  var Fk = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    jk = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    zk = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let Hk = class {
    constructor(t, e) {
      (this.contributions = t),
        (this.global = e),
        (this.configured = !1),
        this.global.hooks.onSetEnv.tap('graphic-util', (t, e, i) => {
          (this.configured = !1), this.configure(i, e);
        });
    }
    get textMeasure() {
      return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;
    }
    configure(t, e) {
      if (this.configured) return;
      const i = ok({ nativeCanvas: t.createCanvas({ width: 100, height: 100 }) });
      (this.canvas = i),
        (this.context = i.getContext('2d')),
        this.contributions.getContributions().forEach(t => {
          t.configure(this, e);
        }),
        (this.configured = !0);
    }
    bindTextMeasure(t) {
      this._textMeasure = t;
    }
    measureText(t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'native';
      var n;
      this.configure(this.global, this.global.env);
      const s = this.global.measureTextMethod;
      this.global.measureTextMethod = i;
      const r = {
        width: this._textMeasure.measureTextWidth(t, e),
        height: null !== (n = e.fontSize) && void 0 !== n ? n : AA.fontSize
      };
      return (this.global.measureTextMethod = s), r;
    }
    createTextMeasureInstance(t, e, i) {
      return (
        this.configure(this.global, this.global.env),
        new $e(
          Object.assign(
            {
              defaultFontParams: { fontFamily: AA.fontFamily, fontSize: AA.fontSize },
              getCanvasForMeasure: i || (() => this.canvas),
              getTextBounds: void 0,
              specialCharSet: '-/: .,@%\'"~' + $e.ALPHABET_CHAR_SET + $e.ALPHABET_CHAR_SET.toUpperCase()
            },
            null != e ? e : {}
          ),
          t
        )
      );
    }
  };
  var Nk;
  (Hk = Fk([ZS(), zk(0, tw(rw)), zk(0, JS(ik)), zk(1, tw(dw)), jk('design:paramtypes', [Object, Object])], Hk)),
    (function (t) {
      (t[(t.transform = 0)] = 'transform'), (t[(t.matrix = 1)] = 'matrix');
    })(Nk || (Nk = {}));
  const Vk = new ie();
  let Wk = class {
    constructor() {
      this.matrix = new ie();
    }
    init(t) {
      return (this.mode = Nk.transform), (this.originTransform = t), this.matrix.reset(), this;
    }
    fromMatrix(t, e) {
      return (this.mode = Nk.matrix), (this.outSourceMatrix = t), (this.outTargetMatrix = e), this;
    }
    scaleMatrix(t, e, i) {
      const n = this.outSourceMatrix;
      if ((Vk.setValue(n.a, n.b, n.c, n.d, n.e, n.f), this.outTargetMatrix.reset(), i)) {
        const { x: n, y: s } = i;
        this.outTargetMatrix.translate(n, s), this.outTargetMatrix.scale(t, e), this.outTargetMatrix.translate(-n, -s);
      } else this.outTargetMatrix.scale(t, e);
      return this.outTargetMatrix.multiply(Vk.a, Vk.b, Vk.c, Vk.d, Vk.e, Vk.f), this;
    }
    rotateMatrix(t, e) {
      const i = this.outSourceMatrix;
      if ((Vk.setValue(i.a, i.b, i.c, i.d, i.e, i.f), this.outTargetMatrix.reset(), e)) {
        const { x: i, y: n } = e;
        this.outTargetMatrix.translate(i, n), this.outTargetMatrix.rotate(t), this.outTargetMatrix.translate(-i, -n);
      } else this.outTargetMatrix.rotate(t);
      return this.outTargetMatrix.multiply(Vk.a, Vk.b, Vk.c, Vk.d, Vk.e, Vk.f), this;
    }
    scale(t, e, i) {
      return this.mode === Nk.matrix ? this.scaleMatrix(t, e, i) : this;
    }
    rotate(t, e) {
      return this.mode === Nk.matrix ? this.rotateMatrix(t, e) : this;
    }
    translateMatrix(t, e) {
      const i = this.outSourceMatrix;
      return (
        Vk.setValue(i.a, i.b, i.c, i.d, i.e, i.f),
        this.outTargetMatrix.reset(),
        this.outTargetMatrix.translate(t, e),
        this.outTargetMatrix.multiply(Vk.a, Vk.b, Vk.c, Vk.d, Vk.e, Vk.f),
        this
      );
    }
    translate(t, e) {
      return this.mode === Nk.matrix ? this.translateMatrix(t, e) : this;
    }
    simplify(t) {
      return this.mode === Nk.matrix ? this.simplifyMatrix(t) : this;
    }
    simplifyMatrix(t) {
      return this;
    }
  };
  Wk = Fk([ZS(), jk('design:paramtypes', [])], Wk);
  const Gk = {
      arc: CA,
      area: EA,
      circle: PA,
      line: BA,
      path: IA,
      symbol: jA,
      text: zA,
      rect: LA,
      rect3d: FA,
      polygon: DA,
      richtext: HA,
      richtextIcon: VA,
      image: NA,
      group: RA,
      glyph: OA
    },
    Uk = Object.keys(Gk);
  function Yk() {
    return {
      arc: Object.assign({}, Gk.arc),
      area: Object.assign({}, Gk.area),
      circle: Object.assign({}, Gk.circle),
      line: Object.assign({}, Gk.line),
      path: Object.assign({}, Gk.path),
      symbol: Object.assign({}, Gk.symbol),
      text: Object.assign({}, Gk.text),
      rect: Object.assign({}, Gk.rect),
      rect3d: Object.assign({}, Gk.rect3d),
      polygon: Object.assign({}, Gk.polygon),
      richtext: Object.assign({}, Gk.richtext),
      richtextIcon: Object.assign({}, Gk.richtextIcon),
      image: Object.assign({}, Gk.image),
      group: Object.assign({}, Gk.group),
      glyph: Object.assign({}, Gk.glyph)
    };
  }
  function $k(t, e) {
    e &&
      (!(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
        ? Object.keys(e).forEach(i => {
            t[i] ? Object.assign(t[i], e[i]) : (t[i] = e[i]);
          })
        : Object.keys(e).forEach(i => {
            if (t[i]) {
              const n = t[i],
                s = e[i];
              Object.keys(e[i]).forEach(t => {
                void 0 === n[t] && (n[t] = s[t]);
              });
            } else t[i] = e[i];
          }));
  }
  const Xk = new Array(60).fill(0).map(() => Yk());
  class Kk {
    constructor() {
      (this._defaultTheme = Xk.pop() || Yk()), (this.combinedTheme = this._defaultTheme), (this.dirty = !1);
    }
    getTheme(t) {
      if (!t) return this.combinedTheme;
      if (!this.dirty) return this.combinedTheme;
      let e = {};
      const i = this.getParentWithTheme(t);
      return i && (e = i.theme), this.applyTheme(t, e), this.combinedTheme;
    }
    getParentWithTheme(t) {
      for (; t.parent; ) if ((t = t.parent).theme) return t;
      return null;
    }
    applyTheme(t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      if (this.dirty) {
        const n = this.getParentWithTheme(t);
        if (n) {
          const t = n.theme;
          (t.dirty || i) && t.applyTheme(n, e, !0),
            this.userTheme
              ? $k(this.userTheme, t.userTheme, !1)
              : (this.userTheme = (function (t) {
                  let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : void 0;
                  const s = [],
                    r = [];
                  return (
                    void 0 === e && (e = !0),
                    void 0 === i && (i = 1 / 0),
                    (function t(i, a) {
                      if (null === i) return null;
                      if (0 === a) return i;
                      let o;
                      if ('object' != typeof i) return i;
                      if (
                        (f(i)
                          ? (o = [])
                          : x(i)
                          ? ((o = new RegExp(
                              i.source,
                              (function (t) {
                                let e = '';
                                return t.global && (e += 'g'), t.ignoreCase && (e += 'i'), t.multiline && (e += 'm'), e;
                              })(i)
                            )),
                            i.lastIndex && (o.lastIndex = i.lastIndex))
                          : (o = m(i)
                              ? new Date(i.getTime())
                              : void 0 === n
                              ? Object.create(Object.getPrototypeOf(i))
                              : Object.create(n)),
                        e)
                      ) {
                        const t = s.indexOf(i);
                        if (-1 !== t) return r[t];
                        s.push(i), r.push(o);
                      }
                      for (const e in i) o[e] = t(i[e], a - 1);
                      return o;
                    })(t, i)
                  );
                })(t.userTheme)),
            $k(e, t.userTheme);
        }
        this.userTheme
          ? this.doCombine(e)
          : (n
              ? (this.combinedTheme = n.theme.combinedTheme)
              : ((this.combinedTheme = this._defaultTheme), console.warn('未知错误，走到不应该走的区域里')),
            (this.dirty = !1));
      }
      return this.combinedTheme;
    }
    doCombine(t) {
      const e = this.userTheme,
        i = this._defaultTheme,
        n = this.combinedTheme,
        s = t.common || {},
        r = Object.assign(s, this.commonTheme);
      Uk.forEach(s => {
        var a, o;
        e[s] || r || t[s]
          ? (n[s] = Object.assign(
              {},
              i[s],
              null != r ? r : {},
              null !== (a = t[s]) && void 0 !== a ? a : {},
              null !== (o = e[s]) && void 0 !== o ? o : {}
            ))
          : (n[s] = i[s]);
      }),
        (this.dirty = !1);
    }
    resetTheme(t, e) {
      (this.userTheme = t), (this.dirty = !0), this.dirtyChildren(e);
    }
    setTheme(t, e) {
      let i = this.userTheme;
      i
        ? Object.keys(t).forEach(e => {
            i[e] ? Object.assign(i[e], t[e]) : (i[e] = Object.assign({}, t[e]));
          })
        : (i = t),
        t.common && (this.commonTheme ? Object.assign(this.commonTheme, t.common) : (this.commonTheme = t.common)),
        (this.userTheme = i),
        (this.dirty = !0),
        this.dirtyChildren(e);
    }
    dirtyChildren(t) {
      t.forEachChildren(t => {
        t.isContainer && (t.theme && (t.theme.dirty = !0), this.dirtyChildren(t));
      });
    }
  }
  const qk = new Kk();
  function Zk(t, e) {
    return t.glyphHost
      ? Zk(t.glyphHost)
      : e
      ? (t.isContainer, e)
      : (function (t) {
          let e;
          if (((e = t.isContainer ? t : t.parent), e)) {
            for (; e && !e.theme; ) e = e.parent;
            return e ? (e.theme || e.createTheme(), e.theme.getTheme(e)) : qk.getTheme();
          }
          return null;
        })(t) || qk.getTheme();
  }
  class Jk {
    static GenAutoIncrementId() {
      return Jk.auto_increment_id++;
    }
  }
  Jk.auto_increment_id = 0;
  var Qk = function (t, e, i, n) {
    return new (i || (i = Promise))(function (s, r) {
      function a(t) {
        try {
          l(n.next(t));
        } catch (t) {
          r(t);
        }
      }
      function o(t) {
        try {
          l(n.throw(t));
        } catch (t) {
          r(t);
        }
      }
      function l(t) {
        var e;
        t.done
          ? s(t.value)
          : ((e = t.value),
            e instanceof i
              ? e
              : new i(function (t) {
                  t(e);
                })).then(a, o);
      }
      l((n = n.apply(t, e || [])).next());
    });
  };
  class tM extends s {
    get previousSibling() {
      return this._prev;
    }
    get nextSibling() {
      return this._next;
    }
    get children() {
      return this.getChildren();
    }
    get firstChild() {
      return this._firstChild;
    }
    get lastChild() {
      return this._lastChild;
    }
    get count() {
      return this._count;
    }
    get childrenCount() {
      return this._idMap ? this._idMap.size : 0;
    }
    constructor() {
      super(),
        (this._uid = Jk.GenAutoIncrementId()),
        (this._firstChild = null),
        (this._lastChild = null),
        (this.parent = null),
        (this._count = 1);
    }
    forEachChildren(t) {
      if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) {
        let e = this._lastChild,
          i = 0;
        for (; e; ) {
          if (t(e, i++)) return;
          e = e._prev;
        }
      } else {
        let e = this._firstChild,
          i = 0;
        for (; e; ) {
          if (t(e, i++)) return;
          e = e._next;
        }
      }
    }
    forEachChildrenAsync(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      return Qk(this, void 0, void 0, function* () {
        if (e) {
          let e = this._lastChild,
            i = 0;
          for (; e; ) {
            let n = t(e, i++);
            if ((n.then && (n = yield n), n)) return;
            e = e._prev;
          }
        } else {
          let e = this._firstChild,
            i = 0;
          for (; e; ) {
            let n = t(e, i++);
            if ((n.then && (n = yield n), n)) return;
            e = e._next;
          }
        }
      });
    }
    forEach(t) {
      return this.forEachChildren(t);
    }
    appendChild(t) {
      if (this._uid === t._uid) return null;
      if (t.isAncestorsOf(this)) throw new Error('【Node::appendChild】不能将父辈元素append为子元素');
      return (
        t.parent && t.parent.removeChild(t),
        (t.parent = this),
        this._lastChild
          ? ((this._lastChild._next = t), (t._prev = this._lastChild), (this._lastChild = t))
          : ((this._firstChild = this._lastChild = t), (t._prev = t._next = null)),
        this._idMap || (this._idMap = new Map()),
        this._idMap.set(t._uid, t),
        this.setCount(t.count),
        (this._structEdit = !0),
        t
      );
    }
    appendChildArrHighPerformance(t) {
      return console.error('暂不支持该函数'), t;
    }
    insertBefore(t, e) {
      if (!e) return this.appendChild(t);
      if (this._uid === t._uid) return null;
      if (t.isAncestorsOf(this)) throw new Error('【Node::insertBefore】不能将父辈元素insert为子元素');
      return e.parent !== this
        ? null
        : (t.parent && t.parent.removeChild(t),
          (t.parent = this),
          (t._prev = e._prev),
          e._prev ? (e._prev._next = t) : (this._firstChild = t),
          (e._prev = t),
          (t._next = e),
          this._idMap || (this._idMap = new Map()),
          this._idMap.set(t._uid, t),
          (this._structEdit = !0),
          this.setCount(t.count),
          t);
    }
    insertAfter(t, e) {
      if (!e) return this.appendChild(t);
      if (this._uid === t._uid) return null;
      if (t.isAncestorsOf(this)) throw new Error('【Node::insertAfter】不能将父辈元素insert为子元素');
      return e.parent !== this
        ? null
        : (t.parent && t.parent.removeChild(t),
          (t.parent = this),
          e._next ? ((e._next._prev = t), (t._next = e._next)) : (this._lastChild = t),
          (e._next = t),
          (t._prev = e),
          this._idMap || (this._idMap = new Map()),
          this._idMap.set(t._uid, t),
          (this._structEdit = !0),
          this.setCount(t.count),
          t);
    }
    insertInto(t, e) {
      if (
        (!this._ignoreWarn && this._nodeList && console.warn('insertIntoKeepIdx和insertInto混用可能会存在错误'),
        e >= this.childrenCount)
      )
        return this.appendChild(t);
      if (this._uid === t._uid) return null;
      if (t.isAncestorsOf(this)) throw new Error('【Node::insertBefore】不能将父辈元素insert为子元素');
      if ((t.parent && t.parent.removeChild(t), (t.parent = this), 0 === e))
        (t._next = this._firstChild),
          this._firstChild && (this._firstChild._prev = t),
          (t._prev = null),
          (this._firstChild = t);
      else {
        let i = this._firstChild;
        for (let t = 0; t < e; t++) {
          if (!i) return null;
          t > 0 && (i = i._next);
        }
        if (!i) return null;
        (t._next = i._next), (t._prev = i), (i._next = t), t._next && (t._next._prev = t);
      }
      return (
        this._idMap || (this._idMap = new Map()),
        this._idMap.set(t._uid, t),
        (this._structEdit = !0),
        this.setCount(t.count),
        t
      );
    }
    insertIntoKeepIdx(t, e) {
      if ((this._nodeList || (this._nodeList = this.children), this._nodeList[e])) {
        const i = this._nodeList[e];
        return this._nodeList.splice(e, 0, t), this.insertBefore(t, i);
      }
      let i;
      this._nodeList[e] = t;
      for (let t = e - 1; t >= 0 && ((i = this._nodeList[t]), !i); t--);
      if (i) return i._next ? this.insertBefore(t, i._next) : this.appendChild(t);
      this._ignoreWarn = !0;
      const n = this.insertInto(t, 0);
      return (this._ignoreWarn = !1), n;
    }
    removeChild(t) {
      if (!this._idMap) return null;
      if (!this._idMap.has(t._uid)) return null;
      if ((this._idMap.delete(t._uid), this._nodeList)) {
        const e = this._nodeList.findIndex(e => e === t);
        e > 0 && this._nodeList.splice(e, 1);
      }
      return (
        t._prev ? (t._prev._next = t._next) : (this._firstChild = t._next),
        t._next ? (t._next._prev = t._prev) : (this._lastChild = t._prev),
        (t.parent = null),
        (t._prev = null),
        (t._next = null),
        (this._structEdit = !0),
        this.setCount(-t.count),
        t
      );
    }
    delete() {
      this.parent && this.parent.removeChild(this);
    }
    removeAllChild() {
      if (!this._idMap) return;
      let t = this._firstChild;
      for (; t; ) (t.parent = null), (t._prev = null), (t._next = null), (t = t._next);
      (this._firstChild = null),
        (this._lastChild = null),
        this._idMap.clear(),
        (this._structEdit = !0),
        this.setCount(1 - this._count);
    }
    replaceChild(t, e) {
      throw new Error('暂不支持');
    }
    find(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
        i = null;
      return (
        this.forEachChildren((e, n) => !(e === this || !t(e, n) || ((i = e), 0))),
        e &&
          this.forEachChildren(e => {
            if (e.isContainer) {
              const n = e.find(t, !0);
              if (n) return (i = n), !0;
            }
            return !1;
          }),
        i
      );
    }
    findAll(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
        i = [];
      return (
        this.forEachChildren((e, n) => {
          e !== this && t(e, n) && i.push(e);
        }),
        e &&
          this.forEachChildren(e => {
            if (e.isContainer) {
              const n = e.findAll(t, !0);
              n.length && (i = i.concat(n));
            }
          }),
        i
      );
    }
    getElementById(t) {
      return this.find(e => e.id === t, !0);
    }
    findChildById(t) {
      return this.getElementById(t);
    }
    findChildByUid(t) {
      return (this._idMap && this._idMap.get(t)) || null;
    }
    getElementsByName(t) {
      return this.findAll(e => e.name === t, !0);
    }
    findChildrenByName(t) {
      return this.getElementsByName(t);
    }
    getElementsByType(t) {
      return this.findAll(e => e.type === t, !0);
    }
    getChildByName(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      return this.find(e => e.name === t, e);
    }
    getChildAt(t) {
      let e = this._firstChild;
      if (!e) return null;
      for (let i = 0; i < t; i++) {
        if (!e._next) return null;
        e = e._next;
      }
      return e;
    }
    at(t) {
      return this.getChildAt(t);
    }
    containNode(t) {
      if (!this._idMap) return !1;
      if (this._idMap.has(t._uid)) return !0;
      let e = this._firstChild;
      for (; e; ) {
        if (e.containNode(t)) return !0;
        e = e._next;
      }
      return !1;
    }
    getRootNode() {
      let t = this.parent;
      for (; null == t ? void 0 : t.parent; ) t = t.parent;
      return t || this;
    }
    hasChildNodes() {
      return null !== this._firstChild;
    }
    addChild(t) {
      return this.appendChild(t);
    }
    add(t) {
      return this.appendChild(t);
    }
    getChildren() {
      const t = [];
      let e = this._firstChild;
      for (; e; ) t.push(e), (e = e._next);
      return t;
    }
    isChildOf(t) {
      return !!this.parent && this.parent._uid === t._uid;
    }
    isParentOf(t) {
      return t.isChildOf(this);
    }
    isDescendantsOf(t) {
      let e = this.parent;
      if (!e) return !1;
      do {
        if (e._uid === t._uid) return !0;
        e = e.parent;
      } while (null !== e);
      return !1;
    }
    isAncestorsOf(t) {
      return t.isDescendantsOf(this);
    }
    getAncestor(t) {
      throw new Error('暂不支持');
    }
    setAllDescendantsProps(t, e) {
      let i = this._firstChild;
      for (; i; ) (i[t] = e), i.setAllDescendantsProps(t, e), (i = i._next);
    }
    setCount(t) {
      this._count += t;
      let e = this.parent;
      if (e)
        do {
          (e._count += t), (e = e.parent);
        } while (null !== e);
    }
    clone() {
      throw new Error('暂不支持');
    }
    cloneTo(t) {
      throw new Error('暂不支持');
    }
    getParent() {
      return this.parent;
    }
    del(t) {
      return this.removeChild(t);
    }
    addEventListener(t, e, i) {
      const n = (a(i, !0) && i) || (c(i) && i.capture),
        s = c(i) && i.once,
        r = o(e) ? void 0 : e;
      return (
        (t = n ? `${t}capture` : t), (e = o(e) ? e : e.handleEvent), s ? super.once(t, e, r) : super.on(t, e, r), this
      );
    }
    on(t, e, i) {
      return this.addEventListener(t, e, i);
    }
    removeEventListener(t, e, i) {
      const n = (a(i, !0) && i) || (c(i) && i.capture),
        s = o(e) ? void 0 : e;
      (t = n ? `${t}capture` : t), (e = o(e) ? e : e.handleEvent);
      const r = c(i) && i.once;
      return super.off(t, e, s, r), this;
    }
    off(t, e, i) {
      return this.removeEventListener(t, e, i);
    }
    once(t, e, i) {
      return c(i) ? ((i.once = !0), this.addEventListener(t, e, i)) : this.addEventListener(t, e, { once: !0 });
    }
    removeAllEventListeners() {
      return super.removeAllListeners(), this;
    }
    removeAllListeners() {
      return this.removeAllEventListeners();
    }
    dispatchEvent(t) {
      for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) i[n - 1] = arguments[n];
      return super.emit(t.type, t, ...i), !t.defaultPrevented;
    }
    emit(t, e) {
      return this.dispatchEvent(t, e);
    }
    release() {
      this.removeAllListeners();
    }
  }
  class eM {
    get layerX() {
      return this.layer.x;
    }
    get layerY() {
      return this.layer.y;
    }
    get pageX() {
      return this.page.x;
    }
    get pageY() {
      return this.page.y;
    }
    get x() {
      return this.canvas.x;
    }
    get y() {
      return this.canvas.y;
    }
    get canvasX() {
      return this.canvas.x;
    }
    get canvasY() {
      return this.canvas.y;
    }
    get viewX() {
      return this.viewport.x;
    }
    get viewY() {
      return this.viewport.y;
    }
    constructor(t) {
      (this.bubbles = !0),
        (this.cancelBubble = !0),
        (this.cancelable = !1),
        (this.composed = !1),
        (this.defaultPrevented = !1),
        (this.eventPhase = eM.prototype.NONE),
        (this.propagationStopped = !1),
        (this.propagationImmediatelyStopped = !1),
        (this.layer = new Ut()),
        (this.page = new Ut()),
        (this.canvas = new Ut()),
        (this.viewport = new Ut()),
        (this.NONE = 0),
        (this.CAPTURING_PHASE = 1),
        (this.AT_TARGET = 2),
        (this.BUBBLING_PHASE = 3),
        (this.manager = t);
    }
    composedPath() {
      return (
        !this.manager ||
          (this.path && this.path[this.path.length - 1] === this.target) ||
          (this.path = this.target ? this.manager.propagationPath(this.target) : []),
        this.path
      );
    }
    preventDefault() {
      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(),
        (this.defaultPrevented = !0);
    }
    stopImmediatePropagation() {
      this.propagationImmediatelyStopped = !0;
    }
    stopPropagation() {
      this.propagationStopped = !0;
    }
    initEvent() {}
    initUIEvent() {}
    clone() {
      throw new Error('Method not implemented.');
    }
  }
  class iM extends eM {
    constructor() {
      super(...arguments),
        (this.client = new Ut()),
        (this.movement = new Ut()),
        (this.offset = new Ut()),
        (this.global = new Ut()),
        (this.screen = new Ut());
    }
    get clientX() {
      return this.client.x;
    }
    get clientY() {
      return this.client.y;
    }
    get movementX() {
      return this.movement.x;
    }
    get movementY() {
      return this.movement.y;
    }
    get offsetX() {
      return this.offset.x;
    }
    get offsetY() {
      return this.offset.y;
    }
    get globalX() {
      return this.global.x;
    }
    get globalY() {
      return this.global.y;
    }
    get screenX() {
      return this.screen.x;
    }
    get screenY() {
      return this.screen.y;
    }
    getModifierState(t) {
      return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(t);
    }
    initMouseEvent(t, e, i, n, s, r, a, o, l, h, c, d, u, p, g) {
      throw new Error('Method not implemented.');
    }
  }
  class nM extends iM {
    constructor() {
      super(...arguments), (this.width = 0), (this.height = 0), (this.isPrimary = !1);
    }
    getCoalescedEvents() {
      return 'pointermove' === this.type || 'mousemove' === this.type || 'touchmove' === this.type ? [this] : [];
    }
    getPredictedEvents() {
      throw new Error('getPredictedEvents is not supported!');
    }
    clone() {
      var t, e, i;
      const n = new nM(this.manager);
      return (
        (n.eventPhase = n.NONE),
        (n.currentTarget = null),
        (n.path = []),
        (n.target = null),
        (n.nativeEvent = this.nativeEvent),
        (n.originalEvent = this.originalEvent),
        null === (t = this.manager) || void 0 === t || t.copyPointerData(this, n),
        null === (e = this.manager) || void 0 === e || e.copyMouseData(this, n),
        null === (i = this.manager) || void 0 === i || i.copyData(this, n),
        (n.target = this.target),
        (n.path = this.composedPath().slice()),
        (n.type = this.type),
        n
      );
    }
  }
  class sM extends iM {
    constructor() {
      super(...arguments), (this.DOM_DELTA_PIXEL = 0), (this.DOM_DELTA_LINE = 1), (this.DOM_DELTA_PAGE = 2);
    }
    clone() {
      var t, e, i;
      const n = new sM(this.manager);
      return (
        (n.eventPhase = n.NONE),
        (n.currentTarget = null),
        (n.path = []),
        (n.target = null),
        (n.nativeEvent = this.nativeEvent),
        (n.originalEvent = this.originalEvent),
        null === (t = this.manager) || void 0 === t || t.copyWheelData(this, n),
        null === (e = this.manager) || void 0 === e || e.copyMouseData(this, n),
        null === (i = this.manager) || void 0 === i || i.copyData(this, n),
        (n.target = this.target),
        (n.path = this.composedPath().slice()),
        (n.type = this.type),
        n
      );
    }
  }
  (sM.DOM_DELTA_PIXEL = 0), (sM.DOM_DELTA_LINE = 1), (sM.DOM_DELTA_PAGE = 2);
  class rM extends eM {
    constructor(t, e) {
      super(), (this.type = t), (this.detail = e);
    }
  }
  const aM = 'object' == typeof performance && performance.now ? performance : Date;
  function oM(t) {
    return 'mouse' === t || 'pen' === t;
  }
  class lM {
    constructor(t) {
      (this.dispatch = new s()),
        (this.mappingState = { trackingData: {} }),
        (this.eventPool = new Map()),
        (this.onPointerDown = (t, e) => {
          if (!(t instanceof nM))
            return void console.warn('EventManager cannot map a non-pointer event as a pointer event');
          const i = this.createPointerEvent(t, t.type, e);
          if ((this.dispatchEvent(i, 'pointerdown'), 'touch' === i.pointerType)) this.dispatchEvent(i, 'touchstart');
          else if (oM(i.pointerType)) {
            const t = 2 === i.button;
            this.dispatchEvent(i, t ? 'rightdown' : 'mousedown');
          }
          (this.trackingData(t.pointerId).pressTargetsByButton[t.button] = i.composedPath()), this.freeEvent(i);
        }),
        (this.onPointerMove = (t, e) => {
          var i, n;
          if (!(t instanceof nM))
            return void console.warn('EventManager cannot map a non-pointer event as a pointer event');
          const s = this.createPointerEvent(t, t.type, e),
            r = oM(s.pointerType),
            a = this.trackingData(t.pointerId),
            o = this.findMountedTarget(a.overTargets);
          if (a.overTargets && o && o !== this.rootTarget && o !== s.target) {
            const e = 'mousemove' === t.type ? 'mouseout' : 'pointerout',
              i = this.createPointerEvent(t, e, o || void 0);
            if (
              (this.dispatchEvent(i, 'pointerout'),
              r && this.dispatchEvent(i, 'mouseout'),
              !s.composedPath().includes(o))
            ) {
              const e = this.createPointerEvent(t, 'pointerleave', o || void 0);
              for (e.eventPhase = e.AT_TARGET; e.target && !s.composedPath().includes(e.target); )
                (e.currentTarget = e.target),
                  this.notifyTarget(e),
                  r && this.notifyTarget(e, 'mouseleave'),
                  (e.target = e.target.parent);
              this.freeEvent(e);
            }
            this.freeEvent(i);
          }
          if (o !== s.target) {
            const e = 'mousemove' === t.type ? 'mouseover' : 'pointerover',
              i = this.clonePointerEvent(s, e);
            this.dispatchEvent(i, 'pointerover'), r && this.dispatchEvent(i, 'mouseover');
            let n = null == o ? void 0 : o.parent;
            for (; n && n !== this.rootTarget.parent && n !== s.target; ) n = n.parent;
            if (!n || n === this.rootTarget.parent) {
              const t = this.clonePointerEvent(s, 'pointerenter');
              for (t.eventPhase = t.AT_TARGET; t.target && t.target !== o && t.target !== this.rootTarget.parent; )
                (t.currentTarget = t.target),
                  this.notifyTarget(t),
                  r && this.notifyTarget(t, 'mouseenter'),
                  (t.target = t.target.parent);
              this.freeEvent(t);
            }
            this.freeEvent(i);
          }
          this.dispatchEvent(s, 'pointermove'),
            'touch' === s.pointerType && this.dispatchEvent(s, 'touchmove'),
            r &&
              (this.dispatchEvent(s, 'mousemove'),
              (this.cursor =
                (null === (n = null === (i = s.target) || void 0 === i ? void 0 : i.attribute) || void 0 === n
                  ? void 0
                  : n.cursor) || this.rootTarget.getCursor())),
            (a.overTargets = s.composedPath()),
            this.freeEvent(s);
        }),
        (this.onPointerOver = (t, e) => {
          var i, n;
          if (!(t instanceof nM))
            return void console.warn('EventManager cannot map a non-pointer event as a pointer event');
          const s = this.trackingData(t.pointerId),
            r = this.createPointerEvent(t, t.type, e),
            a = oM(r.pointerType);
          this.dispatchEvent(r, 'pointerover'),
            a && this.dispatchEvent(r, 'mouseover'),
            'mouse' === r.pointerType &&
              (this.cursor =
                (null === (n = null === (i = r.target) || void 0 === i ? void 0 : i.attribute) || void 0 === n
                  ? void 0
                  : n.cursor) || this.rootTarget.getCursor());
          const o = this.clonePointerEvent(r, 'pointerenter');
          for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent; )
            (o.currentTarget = o.target),
              this.notifyTarget(o),
              a && this.notifyTarget(o, 'mouseenter'),
              (o.target = o.target.parent);
          (s.overTargets = r.composedPath()), this.freeEvent(r), this.freeEvent(o);
        }),
        (this.onPointerOut = (t, e) => {
          if (!(t instanceof nM))
            return void console.warn('EventManager cannot map a non-pointer event as a pointer event');
          const i = this.trackingData(t.pointerId);
          if (i.overTargets) {
            const e = oM(t.pointerType),
              n = this.findMountedTarget(i.overTargets),
              s = this.createPointerEvent(t, 'pointerout', n || void 0);
            this.dispatchEvent(s), e && this.dispatchEvent(s, 'mouseout');
            const r = this.createPointerEvent(t, 'pointerleave', n || void 0);
            for (r.eventPhase = r.AT_TARGET; r.target && r.target !== this.rootTarget.parent; )
              (r.currentTarget = r.target),
                this.notifyTarget(r),
                e && this.notifyTarget(r, 'mouseleave'),
                (r.target = r.target.parent);
            (i.overTargets = []), this.freeEvent(s), this.freeEvent(r);
          }
          this.cursor = '';
        }),
        (this.onPointerUp = (t, e) => {
          if (!(t instanceof nM))
            return void console.warn('EventManager cannot map a non-pointer event as a pointer event');
          const i = aM.now(),
            n = this.createPointerEvent(t, t.type, e);
          if ((this.dispatchEvent(n, 'pointerup'), 'touch' === n.pointerType)) this.dispatchEvent(n, 'touchend');
          else if (oM(n.pointerType)) {
            const t = 2 === n.button;
            this.dispatchEvent(n, t ? 'rightup' : 'mouseup');
          }
          const s = this.trackingData(t.pointerId),
            r = this.findMountedTarget(s.pressTargetsByButton[t.button]);
          let a = r;
          if (r && !n.composedPath().includes(r)) {
            let e = r;
            for (; e && !n.composedPath().includes(e); ) {
              if (((n.currentTarget = e), this.notifyTarget(n, 'pointerupoutside'), 'touch' === n.pointerType))
                this.notifyTarget(n, 'touchendoutside');
              else if (oM(n.pointerType)) {
                const t = 2 === n.button;
                this.notifyTarget(n, t ? 'rightupoutside' : 'mouseupoutside');
              }
              e = e.parent;
            }
            delete s.pressTargetsByButton[t.button], (a = e);
          }
          if (a) {
            const e = this.clonePointerEvent(n, 'click');
            (e.target = a),
              (e.path = []),
              s.clicksByButton[t.button] ||
                (s.clicksByButton[t.button] = { clickCount: 0, target: e.target, timeStamp: i });
            const r = s.clicksByButton[t.button];
            r.target === e.target && i - r.timeStamp < 200 ? ++r.clickCount : (r.clickCount = 1),
              (r.target = e.target),
              (r.timeStamp = i),
              (e.detail = r.clickCount),
              oM(e.pointerType)
                ? (this.dispatchEvent(e, 'click'), 2 === r.clickCount && this.dispatchEvent(e, 'dblclick'))
                : 'touch' === e.pointerType && this.dispatchEvent(e, 'tap'),
              this.dispatchEvent(e, 'pointertap'),
              this.freeEvent(e);
          }
          this.freeEvent(n);
        }),
        (this.onPointerUpOutside = (t, e) => {
          if (!(t instanceof nM))
            return void console.warn('EventManager cannot map a non-pointer event as a pointer event');
          const i = this.trackingData(t.pointerId),
            n = this.findMountedTarget(i.pressTargetsByButton[t.button]),
            s = this.createPointerEvent(t, t.type, e);
          if (n) {
            let e = n;
            for (; e; )
              (s.currentTarget = e),
                this.notifyTarget(s, 'pointerupoutside'),
                'touch' === s.pointerType
                  ? this.notifyTarget(s, 'touchendoutside')
                  : oM(s.pointerType) && this.notifyTarget(s, 2 === s.button ? 'rightupoutside' : 'mouseupoutside'),
                (e = e.parent);
            delete i.pressTargetsByButton[t.button];
          }
          this.freeEvent(s);
        }),
        (this.onWheel = (t, e) => {
          if (!(t instanceof sM))
            return void console.warn('EventManager cannot map a non-wheel event as a wheel event');
          const i = this.createWheelEvent(t, e);
          this.dispatchEvent(i), this.freeEvent(i);
        }),
        (this.rootTarget = t),
        (this.mappingTable = {}),
        this.addEventMapping('pointerdown', this.onPointerDown),
        this.addEventMapping('pointermove', this.onPointerMove),
        this.addEventMapping('pointerout', this.onPointerOut),
        this.addEventMapping('pointerleave', this.onPointerOut),
        this.addEventMapping('pointerover', this.onPointerOver),
        this.addEventMapping('pointerup', this.onPointerUp),
        this.addEventMapping('pointerupoutside', this.onPointerUpOutside),
        this.addEventMapping('wheel', this.onWheel);
    }
    addEventMapping(t, e) {
      this.mappingTable[t] || (this.mappingTable[t] = []),
        this.mappingTable[t].push({ fn: e, priority: 0 }),
        this.mappingTable[t].sort((t, e) => t.priority - e.priority);
    }
    dispatchEvent(t, e) {
      (t.propagationStopped = !1),
        (t.propagationImmediatelyStopped = !1),
        this.propagate(t, e),
        this.dispatch.emit(e || t.type, t);
    }
    mapEvent(t) {
      var e, i, n, s, r;
      if (!this.rootTarget) return;
      const a = this.mappingTable[t.type];
      let o;
      const l = `${t.canvasX}-${t.canvasY}`;
      if (
        ((null === (e = this._prePointTargetCache) || void 0 === e ? void 0 : e[l]) &&
        (null === (n = null === (i = this._prePointTargetCache) || void 0 === i ? void 0 : i[l]) || void 0 === n
          ? void 0
          : n.stage.renderCount) ===
          (null === (s = this._prePointTargetCache) || void 0 === s ? void 0 : s.stageRenderCount)
          ? (o = this._prePointTargetCache[l])
          : ((o = this.pickTarget(t.canvasX, t.canvasY, t)),
            t.pickParams ||
              (this._prePointTargetCache = {
                [l]: o,
                stageRenderCount: null !== (r = null == o ? void 0 : o.stage.renderCount) && void 0 !== r ? r : -1
              })),
        a)
      )
        for (let e = 0, i = a.length; e < i; e++) a[e].fn(t, o);
      else console.warn(`[EventManager]: Event mapping not defined for ${t.type}`);
    }
    propagate(t, e) {
      if (!t.target) return;
      const i = t.composedPath();
      t.eventPhase = t.CAPTURING_PHASE;
      for (let n = 0, s = i.length - 1; n < s; n++)
        if (
          ((t.currentTarget = i[n]), this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped)
        )
          return;
      if (
        ((t.eventPhase = t.AT_TARGET),
        (t.currentTarget = t.target),
        this.notifyTarget(t, e),
        !t.propagationStopped && !t.propagationImmediatelyStopped)
      ) {
        t.eventPhase = t.BUBBLING_PHASE;
        for (let n = i.length - 2; n >= 0; n--)
          if (
            ((t.currentTarget = i[n]), this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped)
          )
            return;
      }
    }
    propagationPath(t) {
      const e = [t];
      for (let i = 0; i < 2048 && t !== this.rootTarget && t.parent; i++) {
        if (!t.parent) throw new Error('Cannot find propagation path to disconnected target');
        e.push(t.parent), (t = t.parent);
      }
      return e.reverse(), e;
    }
    notifyTarget(t, e) {
      e = null != e ? e : t.type;
      const i = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${e}capture` : e;
      this.notifyListeners(t, i), t.eventPhase === t.AT_TARGET && this.notifyListeners(t, e);
    }
    findMountedTarget(t) {
      if (!t) return null;
      let e = t[0];
      for (let i = 1; i < t.length && t[i].parent === e; i++) e = t[i];
      return e;
    }
    createPointerEvent(t, e, i) {
      const n = this.allocateEvent(nM);
      return (
        this.copyPointerData(t, n),
        this.copyMouseData(t, n),
        this.copyData(t, n),
        (n.nativeEvent = t.nativeEvent),
        (n.originalEvent = t),
        (n.target = i || this.pickTarget(n.global.x, n.global.y, n)),
        'string' == typeof e && (n.type = e),
        n
      );
    }
    createWheelEvent(t, e) {
      const i = this.allocateEvent(sM);
      return (
        this.copyWheelData(t, i),
        this.copyMouseData(t, i),
        this.copyData(t, i),
        (i.nativeEvent = t.nativeEvent),
        (i.originalEvent = t),
        (i.target = e || this.pickTarget(i.global.x, i.global.y, i)),
        i
      );
    }
    clonePointerEvent(t, e) {
      const i = this.allocateEvent(nM);
      return (
        (i.nativeEvent = t.nativeEvent),
        (i.originalEvent = t.originalEvent),
        this.copyPointerData(t, i),
        this.copyMouseData(t, i),
        this.copyData(t, i),
        (i.target = t.target),
        (i.path = t.composedPath().slice()),
        (i.type = null != e ? e : i.type),
        i
      );
    }
    copyWheelData(t, e) {
      (e.deltaMode = t.deltaMode), (e.deltaX = t.deltaX), (e.deltaY = t.deltaY), (e.deltaZ = t.deltaZ);
    }
    copyPointerData(t, e) {
      t instanceof nM &&
        e instanceof nM &&
        ((e.pointerId = t.pointerId),
        (e.width = t.width),
        (e.height = t.height),
        (e.isPrimary = t.isPrimary),
        (e.pointerType = t.pointerType),
        (e.pressure = t.pressure),
        (e.tangentialPressure = t.tangentialPressure),
        (e.tiltX = t.tiltX),
        (e.tiltY = t.tiltY),
        (e.twist = t.twist));
    }
    copyMouseData(t, e) {
      t instanceof iM &&
        e instanceof iM &&
        ((e.altKey = t.altKey),
        (e.button = t.button),
        (e.buttons = t.buttons),
        e.client.copyFrom(t.client),
        (e.ctrlKey = t.ctrlKey),
        (e.shiftKey = t.shiftKey),
        (e.metaKey = t.metaKey),
        e.movement.copyFrom(t.movement),
        e.canvas.copyFrom(t.canvas),
        e.screen.copyFrom(t.screen),
        e.global.copyFrom(t.global),
        e.offset.copyFrom(t.offset),
        e.viewport.copyFrom(t.viewport));
    }
    copyData(t, e) {
      (e.isTrusted = t.isTrusted),
        (e.srcElement = t.srcElement),
        (e.timeStamp = aM.now()),
        (e.type = t.type),
        (e.detail = t.detail),
        (e.view = t.view),
        (e.which = t.which),
        e.layer.copyFrom(t.layer),
        e.page.copyFrom(t.page),
        (e.pickParams = t.pickParams);
    }
    trackingData(t) {
      return (
        this.mappingState.trackingData[t] ||
          (this.mappingState.trackingData[t] = { pressTargetsByButton: {}, clicksByButton: {}, overTarget: null }),
        this.mappingState.trackingData[t]
      );
    }
    allocateEvent(t) {
      var e;
      this.eventPool.has(t) || this.eventPool.set(t, []);
      const i = (null === (e = this.eventPool.get(t)) || void 0 === e ? void 0 : e.pop()) || new t(this);
      return (i.eventPhase = i.NONE), (i.currentTarget = null), (i.path = []), (i.target = null), i;
    }
    freeEvent(t) {
      var e;
      if (t.manager !== this) throw new Error('It is illegal to free an event not managed by this EventManager!');
      const i = t.constructor;
      this.eventPool.has(i) || this.eventPool.set(i, []),
        null === (e = this.eventPool.get(i)) || void 0 === e || e.push(t);
    }
    notifyListeners(t, e) {
      const i = t.currentTarget._events[e];
      if (i)
        if ('fn' in i) i.once && t.currentTarget.removeEventListener(e, i.fn, { once: !0 }), i.fn.call(i.context, t);
        else
          for (let n = 0, s = i.length; n < s && !t.propagationImmediatelyStopped; n++)
            i[n].once && t.currentTarget.removeEventListener(e, i[n].fn, { once: !0 }), i[n].fn.call(i[n].context, t);
      this.emitDelegation(t, e);
    }
    emitDelegation(t, e) {
      const i = t.currentTarget._events['*'];
      if (i)
        if ('fn' in i) i.fn.call(i.context, t, e);
        else
          for (let n = 0, s = i.length; n < s && !t.propagationImmediatelyStopped; n++)
            i[n].fn.call(i[n].context, t, e);
    }
    pickTarget(t, e, i) {
      let n;
      const s = this.rootTarget.pick(t, e);
      return (
        (n =
          s && s.graphic
            ? s.graphic
            : s && s.group
            ? s.group
            : t >= 0 && t <= C(this.rootTarget, 'width') && e >= 0 && e <= C(this.rootTarget, 'height')
            ? this.rootTarget
            : null),
        i && (i.pickParams = s.params),
        n
      );
    }
  }
  const hM = {
      pickable: !0,
      visible: !0,
      dispatchEvent(t) {
        var e;
        if (!(t instanceof eM))
          throw new Error('DisplayObject cannot propagate events outside of the Federated Events API');
        return (
          (t.defaultPrevented = !1),
          (t.path = []),
          (t.target = this),
          null === (e = null == t ? void 0 : t.manager) || void 0 === e || e.dispatchEvent(t),
          !t.defaultPrevented
        );
      },
      emit(t, e) {
        return this.dispatchEvent(new rM(t, e));
      }
    },
    cM = {
      touchstart: 'pointerdown',
      touchend: 'pointerup',
      touchendoutside: 'pointerupoutside',
      touchmove: 'pointermove',
      touchcancel: 'pointercancel'
    };
  class dM {
    constructor(t) {
      (this.resolution = 1),
        (this.onPointerDown = t => {
          if (this.supportsTouchEvents && 'touch' === t.pointerType) return;
          const e = this.normalizeToPointerData(t);
          this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !('cancelable' in t)) && t.preventDefault();
          for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t],
              n = this.bootstrapEvent(this.rootPointerEvent, i);
            this.manager.mapEvent(n);
          }
          this.setCursor(this.manager.cursor);
        }),
        (this.onPointerMove = t => {
          if (this.supportsTouchEvents && 'touch' === t.pointerType) return;
          if (this.isEventOutsideOfTargetElement(t)) return;
          const e = this.normalizeToPointerData(t);
          for (let t = 0, i = e.length; t < i; t++) {
            const i = this.bootstrapEvent(this.rootPointerEvent, e[t]);
            this.manager.mapEvent(i);
          }
          this.setCursor(this.manager.cursor);
        }),
        (this.onPointerUp = t => {
          if (this.supportsTouchEvents && 'touch' === t.pointerType) return;
          const e = this.isEventOutsideOfTargetElement(t) ? 'outside' : '',
            i = this.normalizeToPointerData(t);
          for (let t = 0, n = i.length; t < n; t++) {
            const n = this.bootstrapEvent(this.rootPointerEvent, i[t]);
            (n.type += e), this.manager.mapEvent(n);
          }
          this.setCursor(this.manager.cursor);
        }),
        (this.onPointerOverOut = t => {
          if (this.supportsTouchEvents && 'touch' === t.pointerType) return;
          const e = this.normalizeToPointerData(t);
          for (let t = 0, i = e.length; t < i; t++) {
            const i = this.bootstrapEvent(this.rootPointerEvent, e[t]);
            this.manager.mapEvent(i);
          }
          this.setCursor(this.manager.cursor);
        }),
        (this.onWheel = t => {
          const e = this.normalizeWheelEvent(t);
          this.manager.mapEvent(e);
        });
      const { targetElement: e, resolution: i, rootNode: n, global: s, viewport: r, autoPreventDefault: a = !1 } = t;
      (this.manager = new lM(n)),
        (this.globalObj = s),
        (this.supportsPointerEvents = s.supportsPointerEvents),
        (this.supportsTouchEvents = s.supportsTouchEvents),
        (this.supportsMouseEvents = s.supportsMouseEvents),
        (this.applyStyles = s.applyStyles),
        (this.autoPreventDefault = a),
        (this.eventsAdded = !1),
        (this.viewport = r),
        (this.rootPointerEvent = new nM()),
        (this.rootWheelEvent = new sM()),
        (this.cursorStyles = { default: 'inherit', pointer: 'pointer' }),
        (this.resolution = i),
        this.setTargetElement(e);
    }
    release() {
      this.setTargetElement(null);
    }
    setCursor() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'default';
      const { applyStyles: e, domElement: i } = this;
      if (this.currentCursor === t) return;
      this.currentCursor = t;
      const n = this.cursorStyles[t];
      n
        ? 'string' == typeof n && e
          ? (i.style.cursor = n)
          : 'function' == typeof n
          ? n(t)
          : 'object' == typeof n && e && Object.assign(i.style, n)
        : e && g(t) && !P(this.cursorStyles, t) && (i.style.cursor = t);
    }
    setTargetElement(t) {
      this.removeEvents(), (this.domElement = t), this.addEvents();
    }
    addEvents() {
      if (this.eventsAdded || !this.domElement) return;
      const { globalObj: t, domElement: e } = this;
      this.supportsPointerEvents
        ? (t.getDocument()
            ? (t.getDocument().addEventListener('pointermove', this.onPointerMove, !0),
              t.getDocument().addEventListener('pointerup', this.onPointerUp, !0))
            : (e.addEventListener('pointermove', this.onPointerMove, !0),
              e.addEventListener('pointerup', this.onPointerUp, !0)),
          e.addEventListener('pointerdown', this.onPointerDown, !0),
          e.addEventListener('pointerleave', this.onPointerOverOut, !0),
          e.addEventListener('pointerover', this.onPointerOverOut, !0))
        : (t.getDocument()
            ? (t.getDocument().addEventListener('mousemove', this.onPointerMove, !0),
              t.getDocument().addEventListener('mouseup', this.onPointerUp, !0))
            : (e.addEventListener('mousemove', this.onPointerMove, !0),
              e.addEventListener('mouseup', this.onPointerUp, !0)),
          e.addEventListener('mousedown', this.onPointerDown, !0),
          e.addEventListener('mouseout', this.onPointerOverOut, !0),
          e.addEventListener('mouseover', this.onPointerOverOut, !0)),
        this.supportsTouchEvents &&
          (e.addEventListener('touchstart', this.onPointerDown, !0),
          e.addEventListener('touchend', this.onPointerUp, !0),
          e.addEventListener('touchmove', this.onPointerMove, !0)),
        e.addEventListener('wheel', this.onWheel, { capture: !0 }),
        (this.eventsAdded = !0);
    }
    removeEvents() {
      if (!this.eventsAdded || !this.domElement) return;
      const { globalObj: t, domElement: e } = this;
      this.supportsPointerEvents
        ? (t.getDocument()
            ? (t.getDocument().removeEventListener('pointermove', this.onPointerMove, !0),
              t.getDocument().removeEventListener('pointerup', this.onPointerUp, !0))
            : (e.removeEventListener('pointermove', this.onPointerMove, !0),
              e.removeEventListener('pointerup', this.onPointerUp, !0)),
          e.removeEventListener('pointerdown', this.onPointerDown, !0),
          e.removeEventListener('pointerleave', this.onPointerOverOut, !0),
          e.removeEventListener('pointerover', this.onPointerOverOut, !0))
        : (t.getDocument()
            ? (t.getDocument().removeEventListener('mousemove', this.onPointerMove, !0),
              t.getDocument().removeEventListener('mouseup', this.onPointerUp, !0))
            : (e.removeEventListener('mousemove', this.onPointerMove, !0),
              e.removeEventListener('mouseup', this.onPointerUp, !0)),
          e.removeEventListener('mousedown', this.onPointerDown, !0),
          e.removeEventListener('mouseout', this.onPointerOverOut, !0),
          e.removeEventListener('mouseover', this.onPointerOverOut, !0)),
        this.supportsTouchEvents &&
          (e.removeEventListener('touchstart', this.onPointerDown, !0),
          e.removeEventListener('touchend', this.onPointerUp, !0),
          e.removeEventListener('touchmove', this.onPointerMove, !0)),
        e.removeEventListener('wheel', this.onWheel, !0),
        (this.domElement = null),
        (this.eventsAdded = !1);
    }
    mapToViewportPoint(t) {
      const e = this.viewport,
        { x: i, y: n } = t;
      return { x: i - e.x, y: n - e.y };
    }
    mapToCanvasPoint(t) {
      var e;
      const i = null === (e = this.globalObj) || void 0 === e ? void 0 : e.mapToCanvasPoint(t, this.domElement);
      if (i) return i;
      const { clientX: n, clientY: s } = t,
        r = this.domElement.getBoundingClientRect();
      return { x: n - r.left, y: s - r.top };
    }
    normalizeToPointerData(t) {
      const e = [];
      if (this.supportsTouchEvents && t.changedTouches && t.changedTouches.length)
        for (let i = 0, n = t.changedTouches.length; i < n; i++) {
          const n = t.changedTouches[i];
          p(n.button) && (n.button = 0),
            p(n.buttons) && (n.buttons = 1),
            p(n.isPrimary) && (n.isPrimary = 1 === t.touches.length && 'touchstart' === t.type),
            p(n.width) && (n.width = n.radiusX || 1),
            p(n.height) && (n.height = n.radiusY || 1),
            p(n.tiltX) && (n.tiltX = 0),
            p(n.tiltY) && (n.tiltY = 0),
            p(n.pointerType) && (n.pointerType = 'touch'),
            p(n.pointerId) && (n.pointerId = n.identifier || 0),
            p(n.pressure) && (n.pressure = n.force || 0.5),
            p(n.twist) && (n.twist = 0),
            p(n.tangentialPressure) && (n.tangentialPressure = 0),
            p(n.layerX) && (n.layerX = n.offsetX = n.clientX),
            p(n.layerY) && (n.layerY = n.offsetY = n.clientY),
            (n.isNormalized = !0),
            (n.type = t.type),
            e.push(n);
        }
      else if (
        !this.globalObj.supportsMouseEvents ||
        (t instanceof MouseEvent && !(this.supportsPointerEvents && t instanceof PointerEvent))
      ) {
        const i = t;
        p(i.isPrimary) && (i.isPrimary = !0),
          p(i.width) && (i.width = 1),
          p(i.height) && (i.height = 1),
          p(i.tiltX) && (i.tiltX = 0),
          p(i.tiltY) && (i.tiltY = 0),
          p(i.pointerType) && (i.pointerType = 'mouse'),
          p(i.pointerId) && (i.pointerId = 1),
          p(i.pressure) && (i.pressure = 0.5),
          p(i.twist) && (i.twist = 0),
          p(i.tangentialPressure) && (i.tangentialPressure = 0),
          (i.isNormalized = !0),
          e.push(i);
      } else e.push(t);
      return e;
    }
    normalizeWheelEvent(t) {
      const e = this.rootWheelEvent;
      this.transferMouseData(e, t),
        (e.deltaMode = t.deltaMode),
        (e.deltaX = t.deltaX),
        (e.deltaY = t.deltaY),
        (e.deltaZ = t.deltaZ);
      const { x: i, y: n } = this.mapToCanvasPoint(t);
      (e.canvas.x = i), (e.canvas.y = n), e.global.copyFrom(e.canvas), e.offset.copyFrom(e.canvas);
      const { x: s, y: r } = this.mapToViewportPoint(e);
      return (e.viewport.x = s), (e.viewport.y = r), (e.nativeEvent = t), (e.type = t.type), e;
    }
    bootstrapEvent(t, e) {
      (t.originalEvent = null),
        (t.nativeEvent = e),
        (t.pointerId = e.pointerId),
        (t.width = e.width),
        (t.height = e.height),
        (t.isPrimary = e.isPrimary),
        (t.pointerType = e.pointerType),
        (t.pressure = e.pressure),
        (t.tangentialPressure = e.tangentialPressure),
        (t.tiltX = e.tiltX),
        (t.tiltY = e.tiltY),
        (t.twist = e.twist),
        this.transferMouseData(t, e);
      const { x: i, y: n } = this.mapToCanvasPoint(e);
      (t.canvas.x = i), (t.canvas.y = n), t.global.copyFrom(t.canvas), t.offset.copyFrom(t.canvas);
      const { x: s, y: r } = this.mapToViewportPoint(t);
      return (
        (t.viewport.x = s),
        (t.viewport.y = r),
        (t.isTrusted = e.isTrusted),
        'pointerleave' === t.type && (t.type = 'pointerout'),
        t.type.startsWith('mouse') && (t.type = t.type.replace('mouse', 'pointer')),
        t.type.startsWith('touch') && (t.type = cM[t.type] || t.type),
        t
      );
    }
    transferMouseData(t, e) {
      (t.isTrusted = e.isTrusted),
        (t.srcElement = e.srcElement),
        (t.timeStamp = aM.now()),
        (t.type = e.type),
        (t.altKey = e.altKey),
        (t.button = e.button),
        (t.buttons = e.buttons),
        (t.client.x = e.clientX),
        (t.client.y = e.clientY),
        (t.ctrlKey = e.ctrlKey),
        (t.shiftKey = e.shiftKey),
        (t.metaKey = e.metaKey),
        (t.movement.x = e.movementX),
        (t.movement.y = e.movementY),
        (t.page.x = e.pageX),
        (t.page.y = e.pageY),
        (t.relatedTarget = null);
    }
    isEventOutsideOfTargetElement(t) {
      let e = t.target;
      return (
        t.composedPath && t.composedPath().length > 0 && (e = t.composedPath()[0]),
        e !== (this.domElement.getNativeHandler ? this.domElement.getNativeHandler().nativeCanvas : this.domElement)
      );
    }
  }
  class uM {
    constructor(t) {
      (this.onPointerDown = t => {
        const e = t.target,
          i = this.rootNode,
          n = e === i;
        if (e && !n) {
          let s,
            r = !1;
          function a(t) {
            if (
              (r || ((t.type = 'dragstart'), null == e || e.dispatchEvent(t), (r = !0)),
              (t.type = 'drag'),
              null == e || e.dispatchEvent(t),
              !n)
            ) {
              e.pickable = !1;
              const n = (null == i ? void 0 : i.pick(t.global.x, t.global.y)).graphic;
              (e.pickable = !0),
                s !== n &&
                  (s && ((t.type = 'dragleave'), (t.target = s), s.dispatchEvent(t)),
                  n && ((t.type = 'dragenter'), (t.target = n), n.dispatchEvent(t)),
                  (s = n),
                  s && ((t.type = 'dragover'), (t.target = s), s.dispatchEvent(t)));
            }
          }
          null == i || i.addEventListener('pointermove', a);
          const o = function () {
            r &&
              (s && ((t.type = 'drop'), (t.target = s), s.dispatchEvent(t)),
              (t.type = 'dragend'),
              e.dispatchEvent(t),
              (r = !1)),
              null == i || i.removeEventListener('pointermove', a);
          };
          e.addEventListener('pointerup', o, { once: !0 }), e.addEventListener('pointerupoutside', o, { once: !0 });
        }
      }),
        (this.rootNode = t),
        this.initEvents();
    }
    initEvents() {
      var t;
      null === (t = this.rootNode) || void 0 === t || t.addEventListener('pointerdown', this.onPointerDown);
    }
    removeEvents() {
      var t;
      null === (t = this.rootNode) || void 0 === t || t.removeEventListener('pointerdown', this.onPointerDown);
    }
    release() {
      this.removeEvents(), (this.rootNode = null);
    }
  }
  const pM = (t, e) => {
      const i = e.x - t.x,
        n = e.y - t.y;
      return Math.abs(i) > Math.abs(n) ? (i > 0 ? 'right' : 'left') : n > 0 ? 'down' : 'up';
    },
    gM = (t, e) => {
      const i = Math.abs(e.x - t.x),
        n = Math.abs(e.y - t.y);
      return Math.sqrt(i * i + n * n);
    };
  class fM extends s {
    constructor(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      var i, n, s, r, a, o, l, h;
      super(),
        (this.cachedEvents = []),
        (this.startPoints = []),
        (this.processEvent = {}),
        (this.throttleTimer = 0),
        (this.emitThrottles = []),
        (this.onStart = t => {
          this.reset(), (this.startTime = aM.now());
          const { cachedEvents: e, startPoints: i } = this;
          t && e.push(t.clone()), (i.length = e.length);
          for (let t = 0; t < e.length; t++) {
            const { x: n, y: s } = e[t],
              r = { x: n, y: s };
            i[t] = r;
          }
          if (1 !== i.length)
            (this.startDistance = gM(i[0], i[1])),
              (this.center = (t => {
                const e = t.length;
                if (1 === e) return { x: Math.round(t[0].x), y: Math.round(t[0].y) };
                let i = 0,
                  n = 0,
                  s = 0;
                for (; s < e; ) (i += t[s].x), (n += t[s].y), s++;
                return { x: Math.round(i / e), y: Math.round(n / e) };
              })([i[0], i[1]]));
          else {
            const t = e[0];
            this.pressTimeout = setTimeout(() => {
              (t.direction = 'none'),
                (t.deltaX = 0),
                (t.deltaY = 0),
                (t.points = i),
                this.triggerStartEvent('press', t),
                this.triggerEvent('press', t),
                (this.eventType = 'press'),
                (this.direction = 'none');
            }, this.config.press.time);
          }
        }),
        (this.onMove = t => {
          this.clearPressTimeout();
          const { startPoints: e, cachedEvents: i } = this;
          if (!e.length) return;
          const n = t.clone(),
            { x: s, y: r, pointerId: a } = n;
          for (let t = 0, e = i.length; t < e; t++)
            if (a === i[t].pointerId) {
              i[t] = n;
              break;
            }
          const o = { x: s, y: r },
            l = i.map(t => ({ x: t.x, y: t.y })),
            h = aM.now();
          if (
            ((this.prevMoveTime = this.lastMoveTime),
            (this.prevMovePoint = this.lastMovePoint),
            (this.lastMoveTime = h),
            (this.lastMovePoint = o),
            1 === e.length)
          ) {
            const t = e[0],
              i = s - t.x,
              a = r - t.y,
              h = this.direction || pM(t, o);
            this.direction = h;
            const c = this.getEventType(o);
            return (
              (n.direction = h),
              (n.deltaX = i),
              (n.deltaY = a),
              (n.points = l),
              this.triggerStartEvent(c, n),
              void this.triggerEvent(c, n)
            );
          }
          const { startDistance: c } = this,
            d = gM(l[0], l[1]);
          (n.scale = d / c),
            (n.center = this.center),
            (n.points = l),
            this.triggerStartEvent('pinch', n),
            this.triggerEvent('pinch', n);
        }),
        (this.onEnd = t => {
          const e = t.clone(),
            { cachedEvents: i, startPoints: n } = this,
            s = i.map(t => ({ x: t.x, y: t.y }));
          if (((e.points = s), this.triggerEndEvent(e), 1 === i.length)) {
            const t = aM.now(),
              i = this.lastMoveTime;
            if (t - i < 100) {
              const t = i - (this.prevMoveTime || this.startTime);
              if (t > 0) {
                const i = this.prevMovePoint || n[0],
                  s = this.lastMovePoint || n[0],
                  r = gM(i, s),
                  a = r / t;
                a > this.config.swipe.velocity &&
                  r > this.config.swipe.threshold &&
                  ((e.velocity = a), (e.direction = pM(i, s)), this.triggerEvent('swipe', e));
              }
            }
          }
          for (let t = 0, s = i.length; t < s; t++)
            if (i[t].pointerId === e.pointerId) {
              i.splice(t, 1), n.splice(t, 1);
              break;
            }
          this.reset(), i.length > 0 && this.onStart();
        }),
        (this.element = t),
        (this.config = {
          press: {
            time:
              null !== (n = null === (i = null == e ? void 0 : e.press) || void 0 === i ? void 0 : i.time) &&
              void 0 !== n
                ? n
                : 251,
            threshold:
              null !== (r = null === (s = null == e ? void 0 : e.press) || void 0 === s ? void 0 : s.threshold) &&
              void 0 !== r
                ? r
                : 9
          },
          swipe: {
            threshold:
              null !== (o = null === (a = null == e ? void 0 : e.swipe) || void 0 === a ? void 0 : a.threshold) &&
              void 0 !== o
                ? o
                : 10,
            velocity:
              null !== (h = null === (l = null == e ? void 0 : e.swipe) || void 0 === l ? void 0 : l.velocity) &&
              void 0 !== h
                ? h
                : 0.3
          }
        }),
        this.initEvents();
    }
    initEvents() {
      const { element: t } = this;
      t &&
        (t.addEventListener('pointerdown', this.onStart),
        t.addEventListener('pointermove', this.onMove),
        t.addEventListener('pointerup', this.onEnd),
        t.addEventListener('pointerupoutside', this.onEnd));
    }
    removeEvents() {
      const { element: t } = this;
      t &&
        (t.removeEventListener('pointerdown', this.onStart),
        t.removeEventListener('pointermove', this.onMove),
        t.removeEventListener('pointerup', this.onEnd),
        t.removeEventListener('pointerupoutside', this.onEnd));
    }
    release() {
      this.removeEvents(), (this.element = null);
    }
    getEventType(t) {
      const { eventType: e, startTime: i, startPoints: n } = this;
      if (e) return e;
      let s;
      return (
        (s = aM.now() - i > this.config.press.time && gM(n[0], t) < this.config.press.threshold ? 'press' : 'pan'),
        (this.eventType = s),
        s
      );
    }
    enable(t) {
      this.processEvent[t] = !0;
    }
    isProcess(t) {
      return this.processEvent[t];
    }
    pushEvent(t, e) {
      const { emitThrottles: i } = this,
        n = { type: t, ev: e };
      for (let e = 0, s = i.length; e < s; e++) if (i[e].type === t) return void i.splice(e, 1, n);
      i.push(n);
    }
    clearPressTimeout() {
      this.pressTimeout && (clearTimeout(this.pressTimeout), (this.pressTimeout = null));
    }
    reset() {
      this.clearPressTimeout(),
        (this.startTime = 0),
        (this.startDistance = 0),
        (this.direction = null),
        (this.eventType = null),
        (this.prevMoveTime = 0),
        (this.prevMovePoint = null),
        (this.lastMoveTime = 0),
        (this.lastMovePoint = null);
    }
    triggerEvent(t, e) {
      this.pushEvent(t, e);
      const { throttleTimer: i, emitThrottles: n } = this;
      i ||
        (this.throttleTimer = WA.global.getRequestAnimationFrame()(() => {
          for (let t = 0, e = n.length; t < e; t++) {
            const { type: e, ev: i } = n[t];
            this.emitEvent(e, i);
          }
          (this.throttleTimer = 0), (this.emitThrottles.length = 0);
        }));
    }
    triggerStartEvent(t, e) {
      this.isProcess(t) || (this.enable(t), this.triggerEvent(`${t}start`, e));
    }
    triggerEndEvent(t) {
      const e = this.processEvent;
      Object.keys(e).forEach(i => {
        this.triggerEvent(`${i}end`, t), 'press' === i && this.triggerEvent(`${i}up`, t), delete e[i];
      });
    }
    emitEvent(t, e) {
      const i = this.element._events['*'];
      if (i)
        if ('fn' in i) i.fn.call(i.context, e, t);
        else
          for (let n = 0, s = i.length; n < s && !e.propagationImmediatelyStopped; n++)
            i[n].fn.call(i[n].context, e, t);
      this.emit(t, e);
    }
  }
  class vM {
    constructor() {
      this.time = 0;
    }
    static Avaliable() {
      return !0;
    }
    avaliable() {
      return vM.Avaliable();
    }
    tick(t, e) {
      (this.time = Math.max(0, t + this.time)), e(this, { once: !0 });
    }
    tickTo(t, e) {
      (this.time = Math.max(0, t)), e(this, { once: !0 });
    }
    release() {
      this.timerId > 0 && (this.timerId = -1);
    }
    getTime() {
      return this.time;
    }
  }
  class mM {
    static Avaliable() {
      return !0;
    }
    avaliable() {
      return mM.Avaliable();
    }
    tick(t, e) {
      this.timerId = setTimeout(() => {
        e(this);
      }, t);
    }
    release() {
      this.timerId > 0 && (clearTimeout(this.timerId), (this.timerId = -1));
    }
    getTime() {
      return Date.now();
    }
  }
  class yM {
    static Avaliable() {
      return !!WA.global.getRequestAnimationFrame();
    }
    avaliable() {
      return yM.Avaliable();
    }
    tick(t, e) {
      WA.global.getRequestAnimationFrame()(() => {
        this.released || e(this);
      });
    }
    release() {
      this.released = !0;
    }
    getTime() {
      return Date.now();
    }
  }
  var _M;
  !(function (t) {
    (t[(t.INITIAL = 0)] = 'INITIAL'), (t[(t.RUNNING = 1)] = 'RUNNING'), (t[(t.PAUSE = 2)] = 'PAUSE');
  })(_M || (_M = {}));
  class bM {
    constructor() {}
    static linear(t) {
      return t;
    }
    static none() {
      return this.linear;
    }
    static get(t) {
      return (
        t < -1 ? (t = -1) : t > 1 && (t = 1),
        function (e) {
          return 0 === t ? e : t < 0 ? e * (e * -t + 1 + t) : e * ((2 - e) * t + (1 - t));
        }
      );
    }
    static getPowIn(t) {
      return function (e) {
        return Math.pow(e, t);
      };
    }
    static getPowOut(t) {
      return function (e) {
        return 1 - Math.pow(1 - e, t);
      };
    }
    static getPowInOut(t) {
      return function (e) {
        return (e *= 2) < 1 ? 0.5 * Math.pow(e, t) : 1 - 0.5 * Math.abs(Math.pow(2 - e, t));
      };
    }
    static getBackIn(t) {
      return function (e) {
        return e * e * ((t + 1) * e - t);
      };
    }
    static getBackOut(t) {
      return function (e) {
        return --e * e * ((t + 1) * e + t) + 1;
      };
    }
    static getBackInOut(t) {
      return (
        (t *= 1.525),
        function (e) {
          return (e *= 2) < 1 ? e * e * ((t + 1) * e - t) * 0.5 : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2);
        }
      );
    }
    static sineIn(t) {
      return 1 - Math.cos((t * Math.PI) / 2);
    }
    static sineOut(t) {
      return Math.sin((t * Math.PI) / 2);
    }
    static sineInOut(t) {
      return -(Math.cos(Math.PI * t) - 1) / 2;
    }
    static expoIn(t) {
      return 0 === t ? 0 : Math.pow(2, 10 * t - 10);
    }
    static expoOut(t) {
      return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
    }
    static expoInOut(t) {
      return 0 === t ? 0 : 1 === t ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
    }
    static circIn(t) {
      return -(Math.sqrt(1 - t * t) - 1);
    }
    static circOut(t) {
      return Math.sqrt(1 - --t * t);
    }
    static circInOut(t) {
      return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    }
    static bounceOut(t) {
      return t < 1 / 2.75
        ? 7.5625 * t * t
        : t < 2 / 2.75
        ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
        : t < 2.5 / 2.75
        ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
        : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    }
    static bounceIn(t) {
      return 1 - bM.bounceOut(1 - t);
    }
    static bounceInOut(t) {
      return t < 0.5 ? 0.5 * bM.bounceIn(2 * t) : 0.5 * bM.bounceOut(2 * t - 1) + 0.5;
    }
    static getElasticIn(t, e) {
      return function (i) {
        if (0 === i || 1 === i) return i;
        const n = (e / Et) * Math.asin(1 / t);
        return -t * Math.pow(2, 10 * (i -= 1)) * Math.sin(((i - n) * Et) / e);
      };
    }
    static getElasticOut(t, e) {
      return function (i) {
        if (0 === i || 1 === i) return i;
        const n = (e / Et) * Math.asin(1 / t);
        return t * Math.pow(2, -10 * i) * Math.sin(((i - n) * Et) / e) + 1;
      };
    }
    static getElasticInOut(t, e) {
      return function (i) {
        const n = (e / Et) * Math.asin(1 / t);
        return (i *= 2) < 1
          ? t * Math.pow(2, 10 * (i -= 1)) * Math.sin(((i - n) * Et) / e) * -0.5
          : t * Math.pow(2, -10 * (i -= 1)) * Math.sin(((i - n) * Et) / e) * 0.5 + 1;
      };
    }
  }
  (bM.quadIn = bM.getPowIn(2)),
    (bM.quadOut = bM.getPowOut(2)),
    (bM.quadInOut = bM.getPowInOut(2)),
    (bM.cubicIn = bM.getPowIn(3)),
    (bM.cubicOut = bM.getPowOut(3)),
    (bM.cubicInOut = bM.getPowInOut(3)),
    (bM.quartIn = bM.getPowIn(4)),
    (bM.quartOut = bM.getPowOut(4)),
    (bM.quartInOut = bM.getPowInOut(4)),
    (bM.quintIn = bM.getPowIn(5)),
    (bM.quintOut = bM.getPowOut(5)),
    (bM.quintInOut = bM.getPowInOut(5)),
    (bM.backIn = bM.getBackIn(1.7)),
    (bM.backOut = bM.getBackOut(1.7)),
    (bM.backInOut = bM.getBackInOut(1.7)),
    (bM.elasticIn = bM.getElasticIn(1, 0.3)),
    (bM.elasticOut = bM.getElasticOut(1, 0.3)),
    (bM.elasticInOut = bM.getElasticInOut(1, 0.3 * 1.5));
  class xM {
    constructor() {
      (this.id = Jk.GenAutoIncrementId()),
        (this.animateHead = null),
        (this.animateTail = null),
        (this.animateCount = 0),
        (this.paused = !1);
    }
    addAnimate(t) {
      this.animateTail
        ? ((this.animateTail.nextAnimate = t),
          (t.prevAnimate = this.animateTail),
          (this.animateTail = t),
          (t.nextAnimate = null))
        : ((this.animateHead = t), (this.animateTail = t)),
        this.animateCount++;
    }
    pause() {
      this.paused = !0;
    }
    resume() {
      this.paused = !1;
    }
    tick(t) {
      if (this.paused) return;
      let e = this.animateHead;
      for (this.animateCount = 0; e; )
        e.status === Rw.END
          ? this.removeAnimate(e)
          : e.status === Rw.RUNNING || e.status === Rw.INITIAL
          ? (this.animateCount++, e.advance(t))
          : e.status === Rw.PAUSED && this.animateCount++,
          (e = e.nextAnimate);
    }
    clear() {
      let t = this.animateHead;
      for (; t; ) t.release(), (t = t.nextAnimate);
      (this.animateHead = null), (this.animateTail = null), (this.animateCount = 0);
    }
    removeAnimate(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      t._onRemove && t._onRemove.forEach(t => t()),
        t === this.animateHead
          ? ((this.animateHead = t.nextAnimate),
            t === this.animateTail ? (this.animateTail = null) : (this.animateHead.prevAnimate = null))
          : t === this.animateTail
          ? ((this.animateTail = t.prevAnimate), (this.animateTail.nextAnimate = null))
          : ((t.prevAnimate.nextAnimate = t.nextAnimate), (t.nextAnimate.prevAnimate = t.prevAnimate)),
        e && t.release();
    }
  }
  const SM = new xM();
  class wM {
    constructor(t, e, i, n, s) {
      (this.from = t), (this.to = e), (this.duration = i), (this.easing = n), (this.params = s), (this.updateCount = 0);
    }
    bind(t, e) {
      (this.target = t), (this.subAnimate = e), this.onBind();
    }
    onBind() {}
    onFirstRun() {}
    onStart() {}
    onEnd() {}
    getEndProps() {}
    getFromProps() {
      return this.from;
    }
    getMergedEndProps() {
      var t;
      const e = this.getEndProps();
      return e
        ? this._endProps === e
          ? this._mergedEndProps
          : ((this._endProps = e),
            void (this._mergedEndProps = Object.assign(
              {},
              null !== (t = this.step.prev.getLastProps()) && void 0 !== t ? t : {},
              e
            )))
        : this.step.prev
        ? this.step.prev.getLastProps()
        : e;
    }
    update(t, e, i) {
      0 === this.updateCount && this.onFirstRun(),
        (this.updateCount += 1),
        Object.assign(i, this.step.getLastProps()),
        this.onUpdate(t, e, i),
        t && this.onEnd();
    }
  }
  class AM extends wM {
    constructor(t) {
      super(null, null, 0, 'linear'), (this.cb = t);
    }
    onUpdate(t, e, i) {}
    onStart() {
      this.cb();
    }
  }
  let kM = class t {
    constructor() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jk.GenAutoIncrementId(),
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : SM;
      (this.id = t),
        (this.timeline = e),
        (this.status = Rw.INITIAL),
        (this.tailAnimate = new MM(this)),
        (this.subAnimates = [this.tailAnimate]),
        (this.timeScale = 1),
        (this.rawPosition = -1),
        (this._startTime = 0),
        (this._duringTime = 0),
        this.timeline.addAnimate(this);
    }
    setTimeline(t) {
      t !== this.timeline && (this.timeline.removeAnimate(this, !1), t.addAnimate(this));
    }
    getStartTime() {
      return this._startTime;
    }
    getDuration() {
      return this.subAnimates.reduce((t, e) => t + e.totalDuration, 0);
    }
    after(t) {
      const e = t.getDuration();
      return (this._startTime = e), this;
    }
    afterAll(t) {
      let e = -1 / 0;
      return (
        t.forEach(t => {
          e = Bt(t.getDuration(), e);
        }),
        (this._startTime = e),
        this
      );
    }
    parallel(t) {
      return (this._startTime = t.getStartTime()), this;
    }
    static AddInterpolate(e, i) {
      t.interpolateMap.set(e, i);
    }
    play(t) {
      if ((this.tailAnimate.play(t), this.target)) {
        const t = this.target.stage;
        t && t.renderNextFrame();
      }
      return (
        1 === this.subAnimates.length &&
          this.tailAnimate.duration === t.duration &&
          this.trySetAttribute(t.getFromProps(), t.mode),
        this
      );
    }
    trySetAttribute(e) {
      let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.mode;
      e &&
        i & Ow.SET_ATTR_IMMEDIATELY &&
        this.target.setAttributes &&
        this.target.setAttributes(e, !1, { type: Pw.ANIMATE_PLAY });
    }
    runCb(t) {
      const e = new AM(() => {
        t(this, e.step.prev);
      });
      return this.tailAnimate.play(e), this;
    }
    customInterpolate(e, i, n, s, r, a) {
      const o = t.interpolateMap.get(e) || t.interpolateMap.get('');
      return !!o && o(e, i, n, s, r, a);
    }
    pause() {
      this.status === Rw.RUNNING && (this.status = Rw.PAUSED);
    }
    resume() {
      this.status === Rw.PAUSED && (this.status = Rw.RUNNING);
    }
    to(t, e, i, n) {
      if ((this.tailAnimate.to(t, e, i, n), this.target)) {
        const t = this.target.stage;
        t && t.renderNextFrame();
      }
      return this;
    }
    from(t, e, i, n) {
      if ((this.tailAnimate.from(t, e, i, n), this.target)) {
        const t = this.target.stage;
        t && t.renderNextFrame();
      }
      return this;
    }
    wait(t) {
      if ((this.tailAnimate.wait(t), this.target)) {
        const t = this.target.stage;
        t && t.renderNextFrame();
      }
      return this;
    }
    startAt(t) {
      if ((this.tailAnimate.startAt(t), this.target)) {
        const t = this.target.stage;
        t && t.renderNextFrame();
      }
      return this;
    }
    loop(t) {
      if (((this.tailAnimate.loop = t), this.target)) {
        const t = this.target.stage;
        t && t.renderNextFrame();
      }
      return this;
    }
    reversed(t) {
      if (((this.tailAnimate.reversed = t), this.target)) {
        const t = this.target.stage;
        t && t.renderNextFrame();
      }
      return this;
    }
    bounce(t) {
      if (((this.tailAnimate.bounce = t), this.target)) {
        const t = this.target.stage;
        t && t.renderNextFrame();
      }
      return this;
    }
    subAnimate() {
      const t = new MM(this, this.tailAnimate);
      return (this.tailAnimate = t), this.subAnimates.push(t), t.bind(this.target), this;
    }
    getStartProps() {
      return this.subAnimates[0].getStartProps();
    }
    getEndProps() {
      return this.tailAnimate.getEndProps();
    }
    depreventAttr(t) {
      this._preventAttrs && this._preventAttrs.delete(t);
    }
    preventAttr(t) {
      this._preventAttrs || (this._preventAttrs = new Set()), this._preventAttrs.add(t);
    }
    preventAttrs(t) {
      t.forEach(t => this.preventAttr(t));
    }
    validAttr(t) {
      return !this._preventAttrs || !this._preventAttrs.has(t);
    }
    bind(t) {
      return (
        (this.target = t),
        this.target.onAnimateBind && this.target.onAnimateBind(this),
        this.subAnimates.forEach(e => {
          e.bind(t);
        }),
        this
      );
    }
    advance(t) {
      if (this._duringTime < this._startTime) {
        if (this._duringTime + t * this.timeScale < this._startTime)
          return void (this._duringTime += t * this.timeScale);
        (t = this._duringTime + t * this.timeScale - this._startTime), (this._duringTime = this._startTime);
      }
      this.status === Rw.INITIAL && ((this.status = Rw.RUNNING), this._onStart && this._onStart.forEach(t => t())),
        this.setPosition(this.rawPosition + t * this.timeScale) &&
          this.status === Rw.RUNNING &&
          ((this.status = Rw.END), this._onEnd && this._onEnd.forEach(t => t()));
    }
    setPosition(t) {
      let e,
        i = 0;
      const n = this.rawPosition,
        s = this.subAnimates.reduce((t, e) => t + e.totalDuration, 0);
      t < 0 && (t = 0);
      const r = t >= s;
      if ((r && (t = s), t === n)) return r;
      for (let n = 0; n < this.subAnimates.length && ((e = this.subAnimates[n]), !(i + e.totalDuration >= t)); n++)
        (i += e.totalDuration), (e = void 0);
      return (this.rawPosition = t), e.setPosition(t - i), r;
    }
    onStart(t) {
      this._onStart || (this._onStart = []), this._onStart.push(t);
    }
    onEnd(t) {
      this._onEnd || (this._onEnd = []), this._onEnd.push(t);
    }
    onRemove(t) {
      this._onRemove || (this._onRemove = []), this._onRemove.push(t);
    }
    onFrame(t) {
      this._onFrame || (this._onFrame = []), this._onFrame.push(t);
    }
    release() {
      this.status = Rw.END;
    }
    stop(t) {
      t || this.target.onStop(),
        'start' === t
          ? this.target.onStop(this.getStartProps())
          : 'end' === t
          ? this.target.onStop(this.getEndProps())
          : this.target.onStop(t),
        this.release();
    }
  };
  (kM.mode = Ow.NORMAL), (kM.interpolateMap = new Map());
  class MM {
    get totalDuration() {
      return this.calcAttr(), this._totalDuration + this._startAt;
    }
    constructor(t, e) {
      (this.rawPosition = -1),
        (this.position = 0),
        (this.loop = 0),
        (this.duration = 0),
        (this.animate = t),
        (this.stepHead = new TM(0, 0, e ? Object.assign({}, e.stepTail.props) : {})),
        (this.stepTail = this.stepHead),
        (this.dirty = !0),
        (this._startAt = 0);
    }
    calcAttr() {
      this.dirty && (this._totalDuration = this.duration * (this.loop + 1));
    }
    bind(t) {
      return (this.target = t), this;
    }
    play(t) {
      let e = t.duration;
      (null == e || e < 0) && (e = 0);
      const i = t.easing,
        n = 'string' == typeof i ? bM[i] : i,
        s = this._addStep(e, null, n);
      return (
        (s.type = Bw.customAnimate), this._appendProps(t.getEndProps(), s, !1), this._appendCustomAnimate(t, s), this
      );
    }
    to(t, e, i, n) {
      (null == e || e < 0) && (e = 0);
      const s = 'string' == typeof i ? bM[i] : i,
        r = this._addStep(e, null, s);
      return (
        (r.type = Bw.to),
        this._appendProps(t, r, !!n && n.tempProps),
        r.propKeys || (r.propKeys = Object.keys(r.props)),
        (n && n.noPreventAttrs) ||
          this.target.animates.forEach(t => {
            t.id !== this.animate.id && t.preventAttrs(r.propKeys);
          }),
        this
      );
    }
    from(t, e, i, n) {
      this.to(t, 0, i, n);
      const s = {};
      this.stepTail.propKeys || (this.stepTail.propKeys = Object.keys(this.stepTail.props)),
        this.stepTail.propKeys.forEach(t => {
          s[t] = this.getLastPropByName(t, this.stepTail);
        }),
        this.to(s, e, i, n),
        (this.stepTail.type = Bw.from);
    }
    startAt(t) {
      return t < 0 && (t = 0), (this._startAt = t), this;
    }
    getStartProps() {
      var t;
      return null === (t = this.stepHead) || void 0 === t ? void 0 : t.props;
    }
    getEndProps() {
      return this.stepTail.props;
    }
    getLastStep() {
      return this._lastStep;
    }
    wait(t) {
      if (t > 0) {
        const e = this._addStep(+t, null);
        (e.type = Bw.wait),
          e.prev.customAnimate ? (e.props = e.prev.customAnimate.getEndProps()) : (e.props = e.prev.props),
          this.target.onAddStep && this.target.onAddStep(e);
      }
      return this;
    }
    _addStep(t, e, i) {
      const n = new TM(this.duration, t, e, i);
      return (this.duration += t), this.stepTail.append(n), (this.stepTail = n), n;
    }
    _appendProps(t, e, i) {
      e.props = i ? t : Object.assign({}, t);
      let n = e.prev;
      const s = e.props;
      for (
        e.propKeys || (e.propKeys = Object.keys(e.props)),
          e.propKeys.forEach(t => {
            void 0 === e.props[t] && (e.props[t] = this.target.getDefaultAttribute(t));
          });
        n.prev;

      )
        n.props &&
          (n.propKeys || (n.propKeys = Object.keys(n.props)),
          n.propKeys.forEach(t => {
            void 0 === s[t] && (s[t] = n.props[t]);
          })),
          (n = n.prev);
      const r = this.stepHead.props;
      e.propKeys || (e.propKeys = Object.keys(s)),
        e.propKeys.forEach(t => {
          if (void 0 === r[t]) {
            const e = this.animate.getStartProps();
            r[t] = e[t] = this.target.getComputedAttribute(t);
          }
        }),
        this.target.onAddStep && this.target.onAddStep(e);
    }
    _appendCustomAnimate(t, e) {
      (e.customAnimate = t), (t.step = e), t.bind(this.target, this);
    }
    setPosition(t) {
      var e;
      const i = this.duration,
        n = this.loop,
        s = this.rawPosition;
      let r,
        a,
        o = !1;
      const l = null !== (e = this._startAt) && void 0 !== e ? e : 0;
      if ((t < 0 && (t = 0), t < l)) return (this.rawPosition = t), !1;
      if (((t -= l), i <= 0)) return (o = !0), o;
      if (
        ((r = Math.floor(t / i)),
        (a = t - r * i),
        (o = t >= n * i + i),
        o && ((a = i), (r = n), (t = a * r + i)),
        t === s)
      )
        return o;
      const h = !this.reversed != !(this.bounce && r % 2);
      return (
        h && (a = i - a),
        (this._deltaPosition = a - this.position),
        (this.position = a),
        (this.rawPosition = t + l),
        this.updatePosition(o, h),
        o
      );
    }
    updatePosition(t, e) {
      if (!this.stepHead) return;
      let i = this.stepHead.next;
      const n = this.position,
        s = this.duration;
      if (this.target && i) {
        let r = i.next;
        for (; r && r.position <= n; ) (i = r), (r = i.next);
        let a = t ? (0 === s ? 1 : n / s) : (n - i.position) / i.duration;
        i.easing && (a = i.easing(a)),
          this.tryCallCustomAnimateLifeCycle(i, this._lastStep || (e ? this.stepTail : this.stepHead), e),
          this.updateTarget(i, a, t),
          (this._lastStep = i),
          this.animate._onFrame && this.animate._onFrame.forEach(t => t(i, a));
      }
    }
    tryCallCustomAnimateLifeCycle(t, e, i) {
      if (t !== e)
        if (i) {
          let i = e.prev;
          for (; i && i !== t; )
            i.customAnimate &&
              (i.customAnimate.onStart && i.customAnimate.onStart(), i.customAnimate.onEnd && i.customAnimate.onEnd()),
              (i = t.prev);
          e && e.customAnimate && e.customAnimate.onEnd && e.customAnimate.onEnd(),
            t && t.customAnimate && t.customAnimate.onStart && t.customAnimate.onStart();
        } else {
          let i = e.next;
          for (; i && i !== t; )
            i.customAnimate &&
              (i.customAnimate.onStart && i.customAnimate.onStart(), i.customAnimate.onEnd && i.customAnimate.onEnd()),
              (i = i.next);
          e && e.customAnimate && e.customAnimate.onEnd && e.customAnimate.onEnd(),
            t && t.customAnimate && t.customAnimate.onStart && t.customAnimate.onStart();
        }
    }
    getLastPropByName(t, e) {
      let i = e.prev;
      for (; i; ) {
        if (i.props && void 0 !== i.props[t]) return i.props[t];
        if (i.customAnimate) {
          const e = i.customAnimate.getEndProps()[t];
          if (void 0 !== e) return e;
        }
        i = i.prev;
      }
      return console.warn('未知错误，step中找不到属性'), e.props[t];
    }
    updateTarget(t, e, i) {
      (null == t.props && null == t.customAnimate) || this.target.onStep(this, this.animate, t, e, i);
    }
  }
  class TM {
    constructor(t, e, i, n) {
      (this.duration = e), (this.position = t), (this.props = i), (this.easing = n);
    }
    append(t) {
      (t.prev = this), (t.next = this.next), (this.next = t);
    }
    getLastProps() {
      let t = this.prev;
      for (; t; ) {
        if (t.props) return t.props;
        if (t.customAnimate) return t.customAnimate.getMergedEndProps();
        t = t.prev;
      }
      return null;
    }
  }
  const CM = 200,
    EM = 'cubicOut',
    PM = 1e3,
    RM = 'quadInOut';
  var OM;
  !(function (t) {
    (t[(t.Top = 1)] = 'Top'),
      (t[(t.Right = 2)] = 'Right'),
      (t[(t.Bottom = 4)] = 'Bottom'),
      (t[(t.Left = 8)] = 'Left'),
      (t[(t.ALL = 15)] = 'ALL');
  })(OM || (OM = {}));
  const BM = [!1, !1, !1, !1],
    IM = [0, 0, 0, 0],
    DM = t =>
      t
        ? f(t)
          ? 0 === t.length
            ? 0
            : 1 === t.length
            ? t[0]
            : 2 === t.length
            ? ((IM[0] = t[0]), (IM[2] = t[0]), (IM[1] = t[1]), (IM[3] = t[1]), IM)
            : t
          : t
        : 0,
    LM = [
      { x: 0, y: 0 },
      { x: 0, y: 0 },
      { x: 0, y: 0 },
      { x: 0, y: 0 }
    ],
    FM = [1, 2, 3, 0, 1, 2, 3, 0];
  function jM(t, e, i, n) {
    for (; t >= Et; ) t -= Et;
    for (; t < 0; ) t += Et;
    for (; t > e; ) e += Et;
    (LM[0].x = i), (LM[1].y = i), (LM[2].x = -i), (LM[3].y = -i);
    const s = Math.ceil(t / Tt) % 4,
      r = Math.ceil(e / Tt) % 4;
    if ((n.add(Ot(t) * i, Dt(t) * i), n.add(Ot(e) * i, Dt(e) * i), s !== r || e - t > Mt)) {
      let t = !1;
      for (let e = 0; e < FM.length; e++)
        if (t || s !== FM[e]) {
          if (t && r === FM[e]) break;
          if (t) {
            const t = LM[FM[e]];
            n.add(t.x, t.y);
          }
        } else {
          t = !0;
          const e = LM[s];
          n.add(e.x, e.y);
        }
    }
  }
  function zM(t, e, i) {
    const { x: n, y: s } = Ht(t.x, t.y, e.x, e.y, i),
      { x: r, y: a } = Ht(t.x1, t.y1, e.x1, e.y1, i),
      o = new Ut(n, s, r, a);
    return (o.defined = e.defined), o;
  }
  function HM(t, e, i) {
    if (!t || !e) return [];
    Array.isArray(t) || (t = [t]), Array.isArray(e) || (e = [e]);
    let n = [];
    if (t.length > e.length) {
      n = e.map(t => {
        const e = new Ut(t.x, t.y, t.x1, t.y1);
        return (e.defined = t.defined), e;
      });
      for (let s = 0; s < e.length; s++) n[s] = zM(t[s], e[s], i);
    } else {
      n = e.map(t => {
        const e = new Ut(t.x, t.y, t.x1, t.y1);
        return (e.defined = t.defined), e;
      });
      for (let s = 0; s < t.length; s++) n[s] = zM(t[s], e[s], i);
    }
    return n;
  }
  const NM = ['x', 'y', 'dx', 'dy', 'scaleX', 'scaleY', 'angle', 'anchor', 'postMatrix', 'scrollX', 'scrollY'];
  function VM(t, e) {
    if (f(t)) {
      let i;
      for (let n = 0; n < t.length && void 0 === i; n++) i = t[n][e];
      return i;
    }
    return t[e];
  }
  class WM {
    constructor() {
      (this.durations = []), (this.timeout = WM.TimeOut), (this.lastDate = 0), (this.durationsListThreshold = 30);
    }
    call(t) {
      return (
        (this.lastDate = Date.now()),
        setTimeout(
          () => {
            this.appendDuration(Date.now() - this.lastDate), t(0);
          },
          this.timeout,
          !0
        )
      );
    }
    clear(t) {
      clearTimeout(t);
    }
    appendDuration(t) {
      this.durations.push(t),
        this.durations.length > this.durationsListThreshold && this.durations.shift(),
        (this.timeout = Math.min(
          Math.max(this.durations.reduce((t, e) => t + e, 0) / this.durations.length, 1e3 / 60),
          1e3 / 30
        ));
    }
  }
  WM.TimeOut = 1e3 / 60;
  const GM = new WM();
  class UM extends wM {
    constructor(t, e, i, n, s) {
      super(t, e, i, n, s);
    }
    getEndProps() {
      return !1 === this.valid ? {} : { text: this.to };
    }
    onBind() {
      var t, e, i, n, s, r;
      (this.fromNumber = y(null === (t = this.from) || void 0 === t ? void 0 : t.text)
        ? null === (e = this.from) || void 0 === e
          ? void 0
          : e.text
        : Number.parseFloat(null === (i = this.from) || void 0 === i ? void 0 : i.text)),
        (this.toNumber = y(null === (n = this.to) || void 0 === n ? void 0 : n.text)
          ? null === (s = this.to) || void 0 === s
            ? void 0
            : s.text
          : Number.parseFloat(null === (r = this.to) || void 0 === r ? void 0 : r.text)),
        Number.isFinite(this.toNumber) || (this.fromNumber = 0),
        Number.isFinite(this.toNumber) || (this.valid = !1);
    }
    onEnd() {}
    onUpdate(t, e, i) {
      var n, s;
      !1 !== this.valid &&
        (i.text = t
          ? this.toNumber.toFixed()
          : (this.fromNumber + (this.toNumber - this.fromNumber) * e).toFixed(
              null !== (s = null === (n = this.params) || void 0 === n ? void 0 : n.fixed) && void 0 !== s ? s : 0
            ));
    }
  }
  var YM;
  !(function (t) {
    (t[(t.LEFT_TO_RIGHT = 0)] = 'LEFT_TO_RIGHT'),
      (t[(t.RIGHT_TO_LEFT = 1)] = 'RIGHT_TO_LEFT'),
      (t[(t.TOP_TO_BOTTOM = 2)] = 'TOP_TO_BOTTOM'),
      (t[(t.BOTTOM_TO_TOP = 3)] = 'BOTTOM_TO_TOP'),
      (t[(t.STROKE = 4)] = 'STROKE');
  })(YM || (YM = {}));
  class $M extends wM {
    constructor(t, e, i, n, s) {
      super(t, e, i, n, s),
        (this.newPointAnimateType = 'appear' === (null == s ? void 0 : s.newPointAnimateType) ? 'appear' : 'grow');
    }
    onBind() {
      var t, e;
      const i = null === (t = this.from) || void 0 === t ? void 0 : t.points,
        n = null === (e = this.to) || void 0 === e ? void 0 : e.points;
      (this.fromPoints = i ? (Array.isArray(i) ? i : [i]) : []),
        (this.toPoints = n ? (Array.isArray(n) ? n : [n]) : []);
      const s = new Map();
      this.fromPoints.forEach(t => {
        t.context && s.set(t.context, t);
      });
      let r,
        a,
        o = 1 / 0,
        l = -1 / 0;
      for (let t = 0; t < this.toPoints.length; t += 1)
        if (s.has(this.toPoints[t].context)) {
          (o = t), (r = s.get(this.toPoints[t].context));
          break;
        }
      for (let t = this.toPoints.length - 1; t >= 0; t -= 1)
        if (s.has(this.toPoints[t].context)) {
          (l = t), (a = s.get(this.toPoints[t].context));
          break;
        }
      let h = this.toPoints[0];
      (this.interpolatePoints = this.toPoints.map((t, e) => {
        const i = s.get(t.context);
        return i
          ? ((h = i), [i, t])
          : 'appear' === this.newPointAnimateType
          ? [t, t]
          : e < o && r
          ? [r, t]
          : e > l && a
          ? [a, t]
          : [h, t];
      })),
        (this.points = this.interpolatePoints.map(t => {
          const e = t[0],
            i = t[1],
            n = new Ut(e.x, e.y, e.x1, e.y1);
          return (n.defined = i.defined), (n.context = i.context), n;
        }));
    }
    onUpdate(t, e, i) {
      (this.points = this.points.map((t, i) => {
        const n = zM(this.interpolatePoints[i][0], this.interpolatePoints[i][1], e);
        return (n.context = t.context), n;
      })),
        (i.points = this.points);
    }
  }
  class XM extends wM {
    constructor(t, e, i, n, s) {
      super(null, null, i, n, s),
        (this.clipFromAttribute = t),
        (this.clipToAttribute = e),
        (this._group = null == s ? void 0 : s.group),
        (this._clipGraphic = null == s ? void 0 : s.clipGraphic);
    }
    onBind() {
      this._group &&
        this._clipGraphic &&
        ((this._lastClip = this._group.attribute.clip),
        (this._lastPath = this._group.attribute.path),
        this._group.setAttributes({ clip: !0, path: [this._clipGraphic] }, !1, { type: Pw.ANIMATE_BIND }));
    }
    onEnd() {
      this._group &&
        this._group.setAttributes({ clip: this._lastClip, path: this._lastPath }, !1, { type: Pw.ANIMATE_END });
    }
    onUpdate(t, e, i) {
      if (!this._clipGraphic) return;
      const n = {};
      Object.keys(this.clipFromAttribute).forEach(t => {
        n[t] = this.clipFromAttribute[t] + (this.clipToAttribute[t] - this.clipFromAttribute[t]) * e;
      }),
        this._clipGraphic.setAttributes(n, !1, { type: Pw.ANIMATE_UPDATE, animationState: { ratio: e, end: t } });
    }
  }
  class KM extends XM {
    constructor(t, e, i, n, s) {
      var r, a, o, l, h, c, d, u, p, g, f, v;
      const m =
          null !== (a = null === (r = null == s ? void 0 : s.group) || void 0 === r ? void 0 : r.attribute) &&
          void 0 !== a
            ? a
            : {},
        y = null !== (o = m.width) && void 0 !== o ? o : 0,
        _ = null !== (l = m.height) && void 0 !== l ? l : 0,
        b = null !== (h = null == s ? void 0 : s.animationType) && void 0 !== h ? h : 'in',
        x = null !== (c = null == s ? void 0 : s.startAngle) && void 0 !== c ? c : 0,
        S = null !== (d = null == s ? void 0 : s.orient) && void 0 !== d ? d : 'clockwise';
      let w = 0,
        A = 0;
      'anticlockwise' === S
        ? ((A = 'in' === b ? x + 2 * Math.PI : x), (A = x + 2 * Math.PI))
        : ((w = x), (A = 'out' === b ? x + 2 * Math.PI : x));
      const k = WA.graphicService.creator.arc({
        x:
          null !== (p = null === (u = null == s ? void 0 : s.center) || void 0 === u ? void 0 : u.x) && void 0 !== p
            ? p
            : y / 2,
        y:
          null !== (f = null === (g = null == s ? void 0 : s.center) || void 0 === g ? void 0 : g.y) && void 0 !== f
            ? f
            : _ / 2,
        outerRadius: null !== (v = null == s ? void 0 : s.radius) && void 0 !== v ? v : (y + _) / 2,
        innerRadius: 0,
        startAngle: w,
        endAngle: A,
        fill: !0
      });
      let M, T;
      'anticlockwise' === S
        ? ((M = { startAngle: x + 2 * Math.PI }), (T = { startAngle: x }))
        : ((M = { endAngle: x }), (T = { endAngle: x + 2 * Math.PI })),
        super('in' === b ? M : T, 'in' === b ? T : M, i, n, { group: null == s ? void 0 : s.group, clipGraphic: k });
    }
  }
  class qM extends XM {
    constructor(t, e, i, n, s) {
      var r, a, o, l, h, c, d, u, p;
      const g =
          null !== (a = null === (r = null == s ? void 0 : s.group) || void 0 === r ? void 0 : r.attribute) &&
          void 0 !== a
            ? a
            : {},
        f =
          null !== (l = null !== (o = null == s ? void 0 : s.width) && void 0 !== o ? o : g.width) && void 0 !== l
            ? l
            : 0,
        v =
          null !== (c = null !== (h = null == s ? void 0 : s.height) && void 0 !== h ? h : g.height) && void 0 !== c
            ? c
            : 0,
        m = null !== (d = null == s ? void 0 : s.animationType) && void 0 !== d ? d : 'in',
        y = null !== (u = null == s ? void 0 : s.direction) && void 0 !== u ? u : 'x',
        _ = null !== (p = null == s ? void 0 : s.orient) && void 0 !== p ? p : 'positive',
        b = WA.graphicService.creator.rect({
          x: 0,
          y: 0,
          width: 'in' === m && 'x' === y ? 0 : f,
          height: 'in' === m && 'y' === y ? 0 : v,
          fill: !0
        });
      let x = {},
        S = {};
      'y' === y
        ? 'negative' === _
          ? ((x = { y: v, height: 0 }), (S = { y: 0, height: v }))
          : ((x = { height: 0 }), (S = { height: v }))
        : 'negative' === _
        ? ((x = { x: f, width: 0 }), (S = { x: 0, width: f }))
        : ((x = { width: 0 }), (S = { width: f })),
        super('in' === m ? x : S, 'in' === m ? S : x, i, n, { group: null == s ? void 0 : s.group, clipGraphic: b });
    }
  }
  class ZM extends wM {
    onStart() {
      const { center: t, r: e } = 'function' == typeof this.params ? this.params() : this.params,
        i = this.target.getComputedAttribute('x'),
        n = this.target.getComputedAttribute('y'),
        s = this.target.getComputedAttribute('z'),
        r = Math.acos((n - t.y) / e);
      let a = Math.acos((i - t.x) / e / Math.sin(r));
      s - t.z < 0 && (a = Et - a), (this.theta = a), (this.phi = r);
    }
    onBind() {}
    onEnd() {}
    onUpdate(t, e, i) {
      if (null == this.phi || null == this.theta) return;
      const { center: n, r: s } = 'function' == typeof this.params ? this.params() : this.params,
        r = 2 * Math.PI * e,
        a = this.theta + r,
        o = this.phi,
        l = s * Math.sin(o) * Math.cos(a) + n.x,
        h = s * Math.cos(o) + n.y,
        c = s * Math.sin(o) * Math.sin(a) + n.z;
      for (i.x = l, i.y = h, i.z = c, i.alpha = a + Mt / 2; i.alpha > Et; ) i.alpha -= Et;
      (i.alpha = Et - i.alpha), (i.zIndex = -1e4 * i.z);
    }
  }
  class JM extends wM {
    getEndProps() {
      return {};
    }
    onBind() {
      this.target.setTheme({ common: { opacity: 1 } });
    }
    onEnd() {
      this.target.setTheme({ common: { opacity: 0 } });
    }
    onUpdate(t, e, i) {
      this.target.setTheme({ common: { opacity: 1 - e } });
    }
  }
  class QM extends wM {
    constructor(t, e) {
      super(null, null, t, 'linear'), (this.customAnimates = e);
    }
    initAnimates() {
      this.customAnimates.forEach(t => {
        (t.step = this.step), (t.subAnimate = this.subAnimate), (t.target = this.target);
      });
    }
    getEndProps() {
      const t = {};
      return (
        this.customAnimates.forEach(e => {
          Object.assign(t, e.getEndProps());
        }),
        t
      );
    }
    onBind() {
      this.initAnimates(),
        this.customAnimates.forEach(t => {
          t.onBind();
        });
    }
    onEnd() {
      this.customAnimates.forEach(t => {
        t.onEnd();
      });
    }
    onUpdate(t, e, i) {
      this.updating ||
        ((this.updating = !0),
        this.customAnimates.forEach(n => {
          const s = n.easing,
            r = 'string' == typeof s ? bM[s] : s;
          (e = r(e)), n.onUpdate(t, e, i);
        }),
        (this.updating = !1));
    }
  }
  function tT(t, e, i, n, s, r) {
    const a = (e - t) * s + t,
      o = (i - e) * s + e,
      l = (n - i) * s + i,
      h = (o - a) * s + a,
      c = (l - o) * s + o,
      d = (c - h) * s + h;
    (r[0] = t), (r[1] = a), (r[2] = h), (r[3] = d), (r[4] = d), (r[5] = c), (r[6] = l), (r[7] = n);
  }
  function eT(t, e) {
    const i = t.length,
      n = e.length;
    if (i === n) return [t, e];
    const s = [],
      r = [],
      a = i < n ? t : e,
      o = Math.min(i, n),
      l = Math.abs(n - i) / 6,
      h = (o - 2) / 6,
      c = Math.ceil(l / h),
      d = [a[0], a[1]];
    let u = l;
    for (let t = 2; t < o; t += 6) {
      let e = a[t - 2],
        i = a[t - 1],
        n = a[t],
        o = a[t + 1],
        l = a[t + 2],
        h = a[t + 3];
      const p = a[t + 4],
        g = a[t + 5];
      if (u <= 0) {
        d.push(n, o, l, h, p, g);
        continue;
      }
      const f = Math.min(u, c) + 1;
      for (let t = 1; t <= f; t++) {
        const a = t / f;
        tT(e, n, l, p, a, s),
          tT(i, o, h, g, a, r),
          (e = s[3]),
          (i = r[3]),
          d.push(s[1], r[1], s[2], r[2], e, i),
          (n = s[5]),
          (o = r[5]),
          (l = s[6]),
          (h = r[6]);
      }
      u -= f - 1;
    }
    return a === t ? [d, e] : [t, d];
  }
  function iT(t, e) {
    const i = t || e,
      n = i.length,
      s = i[n - 2],
      r = i[n - 1],
      a = [];
    for (let t = 0; t < e.length; t += 2) (a[t] = s), (a[t + 1] = r);
    return a;
  }
  function nT(t) {
    const e = [],
      i = t.length;
    for (let n = 0; n < i; n += 2) (e[n] = t[i - n - 2]), (e[n + 1] = t[i - n - 1]);
    return e;
  }
  function sT(t) {
    let e = 0,
      i = 0,
      n = 0;
    const s = t.length;
    for (let r = 0, a = s - 2; r < s; a = r, r += 2) {
      const s = t[a],
        o = t[a + 1],
        l = t[r],
        h = t[r + 1],
        c = s * h - l * o;
      (e += c), (i += (s + l) * c), (n += (o + h) * c);
    }
    return 0 === e ? [t[0] || 0, t[1] || 0, 0] : [i / e / 3, n / e / 3, e];
  }
  function rT(t, e, i, n) {
    const s = (t.length - 2) / 6;
    let r = 1 / 0,
      a = 0;
    const o = t.length,
      l = o - 2;
    for (let h = 0; h < s; h++) {
      const s = 6 * h;
      let c = 0;
      for (let r = 0; r < o; r += 2) {
        const a = 0 === r ? s : ((s + r - 2) % l) + 2,
          o = t[a] - i[0],
          h = t[a + 1] - i[1],
          d = e[r] - n[0] - o,
          u = e[r + 1] - n[1] - h;
        c += d * d + u * u;
      }
      c < r && ((r = c), (a = h));
    }
    return a;
  }
  const aT = (t, e, i, n, s) => {
    (ot(e, n) && ot(i, s)) || t.push(e, i, n, s, n, s);
  };
  function oT(t) {
    const e = t.commandList,
      i = [];
    let n,
      s = 0,
      r = 0,
      a = 0,
      o = 0;
    const l = (t, e) => {
      n && n.length > 2 && i.push(n), (n = [t, e]);
    };
    let h, c, d, u;
    for (let t = 0, i = e.length; t < i; t++) {
      const i = e[t],
        p = 0 === t;
      switch ((p && ((a = s = i[1]), (o = r = i[2]), [xw.L, xw.C, xw.Q].includes(i[0]) && (n = [a, o])), i[0])) {
        case xw.M:
          (s = a = i[1]), (r = o = i[2]), l(a, o);
          break;
        case xw.L:
          (h = i[1]), (c = i[2]), aT(n, s, r, h, c), (s = h), (r = c);
          break;
        case xw.C:
          n.push(i[1], i[2], i[3], i[4], (s = i[5]), (r = i[6]));
          break;
        case xw.Q:
          (h = i[1]),
            (c = i[2]),
            (d = i[3]),
            (u = i[4]),
            n.push(s + (2 / 3) * (h - s), r + (2 / 3) * (c - r), d + (2 / 3) * (h - d), u + (2 / 3) * (c - u), d, u),
            (s = d),
            (r = u);
          break;
        case xw.A: {
          const t = i[1],
            e = i[2],
            d = i[3],
            u = d,
            g = i[4],
            f = i[5],
            v = !!i[6];
          (h = Math.cos(g) * d + t),
            (c = Math.sin(g) * d + e),
            p ? ((a = h), (o = c), l(a, o)) : aT(n, s, r, h, c),
            (s = Math.cos(f) * d + t),
            (r = Math.sin(f) * d + e);
          const m = ((v ? -1 : 1) * Math.PI) / 2;
          for (let i = g; v ? i > f : i < f; i += m) {
            const s = v ? Math.max(i + m, f) : Math.min(i + m, f);
            zw(n, i, s, t, e, d, u);
          }
          break;
        }
        case xw.E: {
          const t = i[1],
            e = i[2],
            d = i[3],
            u = i[4],
            g = i[5],
            f = i[6],
            v = i[7] + f,
            m = !!i[8],
            y = !ot(g, 0),
            _ = Math.cos(g),
            b = Math.sin(g);
          let x = Math.cos(f) * d,
            S = Math.sin(f) * u;
          y ? ((h = x * _ - S * b + t), (c = x * b + S * _ + e)) : ((h = x + t), (c = S + e)),
            p ? ((a = h), (o = c), l(a, o)) : aT(n, s, r, h, c),
            (x = Math.cos(v) * d),
            (S = Math.sin(v) * u),
            y ? ((s = x * _ - S * b + t), (r = x * b + S * _ + e)) : ((s = x + t), (r = S + e));
          const w = ((m ? -1 : 1) * Math.PI) / 2;
          for (let i = f; m ? i > v : i < v; i += w) {
            const s = m ? Math.max(i + w, v) : Math.min(i + w, v);
            if ((zw(n, i, s, t, e, d, u), y)) {
              const i = n.length;
              for (let s = i - 6; s <= i - 1; s += 2)
                (x = n[s]),
                  (S = n[s + 1]),
                  (n[s] = (x - t) * _ - (S - e) * b + t),
                  (n[s + 1] = (x - t) * b + (S - e) * _ + e);
            }
          }
          break;
        }
        case xw.R:
          (a = s = i[1]),
            (o = r = i[2]),
            (h = a + i[3]),
            (c = o + i[4]),
            l(h, o),
            aT(n, h, o, h, c),
            aT(n, h, c, a, c),
            aT(n, a, c, a, o),
            aT(n, a, o, h, o);
          break;
        case xw.AT: {
          const t = i[1],
            e = i[2],
            l = i[3],
            h = i[4],
            c = i[5],
            d = Yt.distancePP({ x: s, y: r }, { x: t, y: e }),
            u = Yt.distancePP({ x: l, y: h }, { x: t, y: e }),
            p = ((s - t) * (l - t) + (r - e) * (h - e)) / (d * u),
            g = c / Math.sin(p / 2),
            f = (s + l - 2 * t) / 2,
            v = (r + h - 2 * e) / 2,
            m = Yt.distancePP({ x: f, y: v }, { x: 0, y: 0 }),
            y = t + (g * f) / m,
            _ = l + (g * v) / m,
            b = Math.sqrt(g * g - c * c);
          (a = t + (b * (s - t)) / d),
            (o = e + (b * (r - e)) / d),
            aT(n, s, r, a, o),
            (s = t + (b * (l - t)) / u),
            (r = e + (b * (h - e)) / u);
          const x = ee({ x: y, y: _ }, { x: a, y: o }),
            S = ee({ x: y, y: _ }, { x: s, y: r });
          zw(n, x, S, y, _, c, c);
          break;
        }
        case xw.Z:
          n && aT(n, s, r, a, o), (s = a), (r = o);
      }
    }
    return n && n.length > 2 && i.push(n), i;
  }
  function lT(t, e) {
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      for (let t = 0; t < n.length; t += 2) {
        const i = n[t],
          s = n[t + 1],
          r = { x: i, y: s };
        e.transformPoint({ x: i, y: s }, r), (n[t] = r.x), (n[t + 1] = r.y);
      }
    }
  }
  function hT(t) {
    const e = new mA();
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      if (n.length > 2) {
        e.moveTo(n[0], n[1]);
        for (let t = 2; t < n.length; t += 6) e.bezierCurveTo(n[t], n[t + 1], n[t + 2], n[t + 3], n[t + 4], n[t + 5]);
      }
    }
    return e;
  }
  function cT(t, e, i) {
    const n = t / e;
    let s, r;
    t >= e
      ? ((r = Math.ceil(Math.sqrt(i * n))), (s = Math.floor(i / r)), 0 === s && ((s = 1), (r = i)))
      : ((s = Math.ceil(Math.sqrt(i / n))), (r = Math.floor(i / s)), 0 === r && ((r = 1), (s = i)));
    const a = [];
    for (let t = 0; t < s; t++) a.push(r);
    const o = i - s * r;
    if (o > 0) for (let t = 0; t < o; t += r) t + r < o ? a.push(r) : a.push(o - t);
    return a;
  }
  const dT = (t, e) => {
    const i = t.filter(t => !1 !== t.defined && y(t.x) && y(t.y));
    if (0 === i.length) return [];
    if (1 === i.length) return new Array(e).fill(0).map(t => i[0]);
    const n = [];
    if (e <= i.length) {
      const t = i.length / e;
      let s = 0,
        r = 0;
      for (; s < e; ) n.push(i[Math.floor(r)]), (r += t), s++;
      return n;
    }
    const s = e - i.length,
      r = 1 / (s / (i.length - 1) + 1);
    let a = 0;
    for (let e = 0, i = t.length; e < i; e++)
      if ((n.push(t[e]), e < i - 1)) {
        let i = r;
        const o = t[e].x,
          l = t[e].y,
          h = t[e + 1].x,
          c = t[e + 1].y;
        for (; i < 1 && a < s; ) n.push({ x: o + (h - o) * i, y: l + (c - l) * i }), (i += r), (a += 1);
      }
    return n;
  };
  const uT = t => t.map(t => ({ x: t.x, y: t.y })),
    pT = (t, e, i) => {
      const n = t.length,
        s = [];
      for (let o = 0; o < n; o++) {
        const l = t[o],
          h = o === n - 1 ? t[0] : t[o + 1],
          c = Te([e.x, e.y], [i.x, i.y], [l.x, l.y], [h.x, h.y]);
        c &&
          'boolean' != typeof c &&
          s.push({
            dot: ((r = [c[0] - e.x, c[1] - e.x]), (a = [i.x - e.x, i.y - e.x]), r[0] * a[1] - r[1] * a[0]),
            point: { x: c[0], y: c[1] },
            edgeIndex: o
          });
      }
      var r, a;
      if (s.length < 2) return [uT(t), uT(t)];
      s.sort((t, e) => t.dot - e.dot);
      let o = s[0],
        l = s[s.length - 1];
      o.edgeIndex > l.edgeIndex && ([o, l] = [l, o]);
      const h = o.point,
        c = l.point,
        d = [{ x: h.x, y: h.y }];
      for (let e = o.edgeIndex + 1; e <= l.edgeIndex; e++) d.push({ x: t[e].x, y: t[e].y });
      d.push({ x: c.x, y: c.y });
      const u = [{ x: c.x, y: c.y }];
      for (let e = l.edgeIndex + 1, i = o.edgeIndex + n; e <= i; e++) {
        const i = t[e % n];
        u.push({ x: i.x, y: i.y });
      }
      return u.push({ x: h.x, y: h.y }), [d, u];
    },
    gT = (t, e, i) => {
      if (1 === e) i.push({ points: t });
      else {
        const n = Math.floor(e / 2),
          s = (t => {
            const e = new Xt();
            t.forEach(t => {
              e.add(t.x, t.y);
            });
            const i = e.width(),
              n = e.height();
            if (i >= n) {
              const n = e.x1 + i / 2;
              return pT(t, { x: n, y: e.y1 }, { x: n, y: e.y2 });
            }
            const s = e.y1 + n / 2;
            return pT(t, { x: e.x1, y: s }, { x: e.x2, y: s });
          })(t);
        gT(s[0], n, i), gT(s[1], e - n, i);
      }
    };
  var fT = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  const vT = {};
  for (const t in fT) P(fT, t) && (vT[fT[t]] = t);
  const mT = { to: {}, get: {} };
  function yT(t, e, i) {
    return Math.min(Math.max(e, t), i);
  }
  function _T(t) {
    const e = t.toString(16).toUpperCase();
    return e.length < 2 ? '0' + e : e;
  }
  (mT.get = function (t) {
    let e,
      i,
      n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [0, 0, 0, 1];
    switch (t.substring(0, 3).toLowerCase()) {
      case 'hsl':
        (e = mT.get.hsl(t, n)), (i = 'hsl');
        break;
      case 'hwb':
        (e = mT.get.hwb(t, n)), (i = 'hwb');
        break;
      default:
        (e = mT.get.rgb(t, n)), (i = 'rgb');
    }
    return e ? { model: i, value: e } : null;
  }),
    (mT.get.rgb = function (t) {
      if (!t) return null;
      const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [0, 0, 0, 1];
      let i, n, s;
      if ((i = t.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i))) {
        for (s = i[2], i = i[1], n = 0; n < 3; n++) {
          const t = 2 * n;
          e[n] = parseInt(i.slice(t, t + 2), 16);
        }
        s && (e[3] = Math.round((parseInt(s, 16) / 255) * 100) / 100);
      } else if ((i = t.match(/^#([a-f0-9]{3,4})$/i))) {
        for (i = i[1], s = i[3], n = 0; n < 3; n++) e[n] = parseInt(i[n] + i[n], 16);
        s && (e[3] = Math.round((parseInt(s + s, 16) / 255) * 100) / 100);
      } else if (
        (i = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/))
      ) {
        for (n = 0; n < 3; n++) e[n] = parseInt(i[n + 1], 10);
        i[4] && (e[3] = parseFloat(i[4]));
      } else {
        if (
          !(i = t.match(
            /^rgba?\(\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/
          ))
        ) {
          if ((i = t.match(/(\D+)/))) {
            if ('transparent' === i[1]) return [0, 0, 0, 0];
            const t = fT[i[1]];
            return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), e ? ((e[3] = 1), e) : null;
          }
          return null;
        }
        for (n = 0; n < 3; n++) e[n] = Math.round(2.55 * parseFloat(i[n + 1]));
        i[4] && (e[3] = parseFloat(i[4]));
      }
      for (n = 0; n < 3; n++) e[n] = yT(e[n], 0, 255);
      return (e[3] = yT(e[3], 0, 1)), e;
    }),
    (mT.get.hsl = function (t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [0, 0, 0, 1];
      if (!t) return null;
      const i = t.match(
        /^hsla?\(\s*([+-]?(?:\d*\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/
      );
      if (i) {
        const t = parseFloat(i[4]);
        return (
          (e[0] = (parseFloat(i[1]) + 360) % 360),
          (e[1] = yT(parseFloat(i[2]), 0, 100)),
          (e[2] = yT(parseFloat(i[3]), 0, 100)),
          (e[3] = yT(isNaN(t) ? 1 : t, 0, 1)),
          e
        );
      }
      return null;
    }),
    (mT.get.hwb = function (t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [0, 0, 0, 1];
      if (!t) return null;
      const i = t.match(
        /^hwb\(\s*([+-]?\d*[.]?\d+)(?:deg)?\s*,\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/
      );
      if (i) {
        const t = parseFloat(i[4]);
        return (
          (e[0] = ((parseFloat(i[1]) % 360) + 360) % 360),
          (e[1] = yT(parseFloat(i[2]), 0, 100)),
          (e[2] = yT(parseFloat(i[3]), 0, 100)),
          (e[3] = yT(isNaN(t) ? 1 : t, 0, 1)),
          e
        );
      }
      return null;
    }),
    (mT.to.hex = function () {
      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
      const n = e;
      return '#' + _T(n[0]) + _T(n[1]) + _T(n[2]) + (n[3] < 1 ? _T(Math.round(255 * n[3])) : '');
    }),
    (mT.to.rgb = function () {
      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
      const n = e;
      return n.length < 4 || 1 === n[3]
        ? 'rgb(' + Math.round(n[0]) + ', ' + Math.round(n[1]) + ', ' + Math.round(n[2]) + ')'
        : 'rgba(' + Math.round(n[0]) + ', ' + Math.round(n[1]) + ', ' + Math.round(n[2]) + ', ' + n[3] + ')';
    }),
    (mT.to.rgb.percent = function () {
      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
      const n = e,
        s = Math.round((n[0] / 255) * 100),
        r = Math.round((n[1] / 255) * 100),
        a = Math.round((n[2] / 255) * 100);
      return n.length < 4 || 1 === n[3]
        ? 'rgb(' + s + '%, ' + r + '%, ' + a + '%)'
        : 'rgba(' + s + '%, ' + r + '%, ' + a + '%, ' + n[3] + ')';
    }),
    (mT.to.hsl = function () {
      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
      const n = e;
      return n.length < 4 || 1 === n[3]
        ? 'hsl(' + n[0] + ', ' + n[1] + '%, ' + n[2] + '%)'
        : 'hsla(' + n[0] + ', ' + n[1] + '%, ' + n[2] + '%, ' + n[3] + ')';
    }),
    (mT.to.hwb = function () {
      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
      const n = e;
      let s = '';
      return (
        n.length >= 4 && 1 !== n[3] && (s = ', ' + n[3]), 'hwb(' + n[0] + ', ' + n[1] + '%, ' + n[2] + '%' + s + ')'
      );
    }),
    (mT.to.keyword = function (t) {
      return vT[t.slice(0, 3)];
    });
  const bT = mT;
  var xT;
  !(function (t) {
    (t[(t.Color255 = 0)] = 'Color255'), (t[(t.Color1 = 1)] = 'Color1');
  })(xT || (xT = {}));
  class ST {
    static Get(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : xT.Color1,
        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [0, 0, 0, 1];
      if (e === xT.Color1) {
        let e = ST.store1[t];
        if (e) return (i[0] = e[0]), (i[1] = e[1]), (i[2] = e[2]), (i[3] = e[3]), i;
        if (((e = mT.get(t)), e && e.value)) {
          const n = e.value,
            s = [n[0] / 255, n[1] / 255, n[2] / 255, n[3]];
          (ST.store1[t] = s), (ST.store255[t] = n), (i[0] = s[0]), (i[1] = s[1]), (i[2] = s[2]), (i[3] = s[3]);
        }
        return i;
      }
      let n = ST.store255[t];
      if (n) return (i[0] = n[0]), (i[1] = n[1]), (i[2] = n[2]), (i[3] = n[3]), i;
      if (((n = mT.get(t)), n && n.value)) {
        const e = n.value;
        (ST.store1[t] = [e[0] / 255, e[1] / 255, e[2] / 255, e[3]]),
          (ST.store255[t] = e),
          (i[0] = e[0]),
          (i[1] = e[1]),
          (i[2] = e[2]),
          (i[3] = e[3]);
      }
      return i;
    }
    static Set(t, e, i) {
      if (e === xT.Color1) {
        if (ST.store1[t]) return;
        (ST.store1[t] = i),
          (ST.store255[t] = [
            Math.floor(255 * i[0]),
            Math.floor(255 * i[1]),
            Math.floor(255 * i[2]),
            Math.floor(255 * i[3])
          ]);
      } else {
        if (ST.store255[t]) return;
        (ST.store255[t] = i), (ST.store1[t] = [i[0] / 255, i[1] / 255, i[2] / 255, i[3]]);
      }
    }
  }
  function wT(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return Array.isArray(t)
      ? e
        ? `rgb(${Math.round(t[0])},${Math.round(t[1])},${Math.round(t[2])},${t[3].toFixed(2)})`
        : `rgb(${Math.round(t[0])},${Math.round(t[1])},${Math.round(t[2])})`
      : t;
  }
  function AT(t, e, i, n, s) {
    if (!t || !e) return (t && wT(t)) || (e && wT(e)) || !1;
    let r,
      a,
      o = !1,
      l = !1;
    if (
      (Array.isArray(t) ? (r = t) : 'string' == typeof t ? (r = ST.Get(t, xT.Color255)) : (o = !0),
      Array.isArray(e) ? (a = e) : 'string' == typeof e ? (a = ST.Get(e, xT.Color255)) : (l = !0),
      o !== l)
    ) {
      const r = o ? t : e,
        a = o ? e : t,
        l = Object.assign(Object.assign({}, r), {
          stops: r.stops.map(t => Object.assign(Object.assign({}, t), { color: wT(a) }))
        });
      return o ? AT(r, l, i, n, s) : AT(l, r, i, n, s);
    }
    if (o) {
      if (t.gradient === e.gradient) {
        const n = t,
          s = e,
          r = n.stops,
          a = s.stops;
        if (r.length !== a.length) return !1;
        if ('linear' === n.gradient)
          return (function (t, e, i) {
            const n = t.stops,
              s = e.stops;
            return {
              gradient: 'linear',
              x0: t.x0 + (e.x0 - t.x0) * i,
              x1: t.x1 + (e.x1 - t.x1) * i,
              y0: t.y0 + (e.y0 - t.y0) * i,
              y1: t.y1 + (e.y1 - t.y1) * i,
              stops: new Array(n.length).fill(0).map((t, e) => ({
                color: TT(n[e].color, s[e].color, i),
                offset: n[e].offset + (s[e].offset - n[e].offset) * i
              }))
            };
          })(n, s, i);
        if ('radial' === n.gradient)
          return (function (t, e, i) {
            const n = t.stops,
              s = e.stops;
            return {
              gradient: 'radial',
              x0: t.x0 + (e.x0 - t.x0) * i,
              x1: t.x1 + (e.x1 - t.x1) * i,
              y0: t.y0 + (e.y0 - t.y0) * i,
              y1: t.y1 + (e.y1 - t.y1) * i,
              r0: t.r0 + (e.r0 - t.r0) * i,
              r1: t.r1 + (e.r1 - t.r1) * i,
              stops: new Array(n.length).fill(0).map((t, e) => ({
                color: TT(n[e].color, s[e].color, i),
                offset: n[e].offset + (s[e].offset - n[e].offset) * i
              }))
            };
          })(n, s, i);
        if ('conical' === n.gradient)
          return (function (t, e, i) {
            const n = t.stops,
              s = e.stops;
            return {
              gradient: 'conical',
              startAngle: t.startAngle + (e.startAngle - t.startAngle) * i,
              endAngle: t.endAngle + (e.endAngle - t.endAngle) * i,
              x: t.x + (e.x - t.x) * i,
              y: t.y + (e.y - t.y) * i,
              stops: new Array(n.length).fill(0).map((t, e) => ({
                color: TT(n[e].color, s[e].color, i),
                offset: n[e].offset + (s[e].offset - n[e].offset) * i
              }))
            };
          })(n, s, i);
      }
      return !1;
    }
    return (
      s && s(r, a),
      wT(
        (function (t, e, i) {
          return [
            t[0] + (e[0] - t[0]) * i,
            t[1] + (e[1] - t[1]) * i,
            t[2] + (e[2] - t[2]) * i,
            t[3] + (e[3] - t[3]) * i
          ];
        })(r, a, i),
        n
      )
    );
  }
  (ST.store255 = {}), (ST.store1 = {});
  const kT = [0, 0, 0, 0],
    MT = [0, 0, 0, 0];
  function TT(t, e, i) {
    return (
      ST.Get(t, xT.Color255, kT),
      ST.Get(e, xT.Color255, MT),
      `rgba(${Math.round(kT[0] + (MT[0] - kT[0]) * i)},${Math.round(kT[1] + (MT[1] - kT[1]) * i)},${Math.round(
        kT[2] + (MT[2] - kT[2]) * i
      )},${kT[3] + (MT[3] - kT[3]) * i})`
    );
  }
  const CT = (t, e, i) => {
      t.forEach(t => {
        if (Number.isFinite(t.to)) e[t.key] = t.from + (t.to - t.from) * i;
        else if ('fill' === t.key || 'stroke' === t.key) {
          const n = AT(t.from, t.to, i, !1);
          n && (e[t.key] = n);
        }
      });
    },
    ET = (t, e, i) => {
      const n = [],
        s = [];
      e.clear();
      for (let r = 0; r < t.length; r++) {
        const a = t[r],
          o = a.from,
          l = a.to,
          h = a.rotation * i,
          c = a.fromCp,
          d = a.toCp,
          u = Math.sin(h),
          p = Math.cos(h);
        (s[0] = c[0] + (d[0] - c[0]) * i), (s[1] = c[1] + (d[1] - c[1]) * i);
        for (let t = 0; t < o.length; t += 2) {
          const e = o[t],
            r = o[t + 1],
            a = e * (1 - i) + l[t] * i,
            h = r * (1 - i) + l[t + 1] * i;
          (n[t] = a * p - h * u + s[0]), (n[t + 1] = a * u + h * p + s[1]);
        }
        let g = n[0],
          f = n[1];
        e.moveTo(g, f);
        for (let t = 2; t < o.length; t += 6) {
          const i = n[t],
            s = n[t + 1],
            r = n[t + 2],
            a = n[t + 3],
            o = n[t + 4],
            l = n[t + 5];
          g === i && f === s && r === o && a === l ? e.lineTo(o, l) : e.bezierCurveTo(i, s, r, a, o, l),
            (g = o),
            (f = l);
        }
      }
    },
    PT = (t, e, i) => {
      const n = t ? oT(t) : [],
        s = oT(e);
      i && n && (i.fromTransform && lT(n, i.fromTransform.clone().getInverse()), lT(n, i.toTransfrom));
      const [r, a] = (function (t, e) {
        let i, n;
        const s = [],
          r = [];
        for (let a = 0; a < Math.max(t.length, e.length); a++) {
          const o = t[a],
            l = e[a];
          let h, c;
          o ? (l ? (([h, c] = eT(o, l)), (i = h), (n = c)) : ((c = iT(n, o)), (h = o))) : ((h = iT(i, l)), (c = l)),
            s.push(h),
            r.push(c);
        }
        return [s, r];
      })(n, s);
      return t
        ? (function (t, e, i, n) {
            const s = [];
            let r;
            for (let a = 0; a < t.length; a++) {
              let o = t[a];
              const l = e[a],
                h = sT(o),
                c = sT(l);
              null == r && (r = h[2] < 0 != c[2] < 0);
              const d = [],
                u = [];
              let p = 0,
                g = 1 / 0;
              const f = [],
                v = o.length;
              r && (o = nT(o));
              const m = 6 * rT(o, l, h, c),
                y = v - 2;
              for (let t = 0; t < y; t += 2) {
                const e = ((m + t) % y) + 2;
                (d[t + 2] = o[e] - h[0]), (d[t + 3] = o[e + 1] - h[1]);
              }
              if (((d[0] = o[m] - h[0]), (d[1] = o[m + 1] - h[1]), i > 0)) {
                const t = n / i;
                for (let e = -n / 2; e <= n / 2; e += t) {
                  const t = Math.sin(e),
                    i = Math.cos(e);
                  let n = 0;
                  for (let e = 0; e < o.length; e += 2) {
                    const s = d[e],
                      r = d[e + 1],
                      a = l[e] - c[0],
                      o = l[e + 1] - c[1],
                      h = a * i - o * t,
                      u = a * t + o * i;
                    (f[e] = h), (f[e + 1] = u);
                    const p = h - s,
                      g = u - r;
                    n += p * p + g * g;
                  }
                  if (n < g) {
                    (g = n), (p = e);
                    for (let t = 0; t < f.length; t++) u[t] = f[t];
                  }
                }
              } else for (let t = 0; t < v; t += 2) (u[t] = l[t] - c[0]), (u[t + 1] = l[t + 1] - c[1]);
              s.push({ from: d, to: u, fromCp: h, toCp: c, rotation: -p });
            }
            return s;
          })(r, a, 10, Math.PI)
        : a.map((t, e) => ({ from: r[e], to: t, fromCp: [0, 0], toCp: [0, 0], rotation: 0 }));
    },
    RT = [
      'fill',
      'fillOpacity',
      'shadowBlur',
      'shadowColor',
      'shadowOffsetX',
      'shadowOffsetY',
      'stroke',
      'strokeOpacity',
      'lineDashOffset'
    ],
    OT = (t, e) => {
      if (!t || !e) return null;
      const i = [];
      let n = !1;
      return (
        Object.keys(t).forEach(s => {
          if (!RT.includes(s)) return;
          const r = e[s];
          l(r) ||
            l(t[s]) ||
            r === t[s] ||
            ('fill' === s || 'stroke' === s
              ? i.push({
                  from: 'string' == typeof t[s] ? ST.Get(t[s], xT.Color255) : t[s],
                  to: 'string' == typeof r ? ST.Get(r, xT.Color255) : r,
                  key: s
                })
              : i.push({ from: t[s], to: r, key: s }),
            (n = !0));
        }),
        n ? i : null
      );
    };
  class BT extends wM {
    constructor(t, e, i) {
      super(0, 1, e, i),
        (this.morphingData = t.morphingData),
        (this.otherAttrs = t.otherAttrs),
        (this.saveOnEnd = t.saveOnEnd);
    }
    getEndProps() {
      return {};
    }
    onBind() {
      this.target.createPathProxy(), this.onUpdate(!1, 0, this.target.attribute);
    }
    onEnd() {}
    onUpdate(t, e, i) {
      const n = this.target,
        s = 'function' == typeof n.pathProxy ? n.pathProxy(n.attribute) : n.pathProxy;
      ET(this.morphingData, s, e),
        this.otherAttrs && this.otherAttrs.length && CT(this.otherAttrs, i, e),
        t && !this.saveOnEnd && (this.target.pathProxy = null);
    }
  }
  const IT = (t, e, i, n) => {
    var s, r, a;
    if (t && (!t.valid || !t.toCustomPath)) return console.error(t, ' is not validate'), null;
    if (!e.valid || !e.toCustomPath) return console.error(e, ' is not validate'), null;
    let o = null == t ? void 0 : t.globalTransMatrix;
    n && o && (o = n.clone().multiply(o.a, o.b, o.c, o.d, o.e, o.f));
    const l = PT(
        null === (s = null == t ? void 0 : t.toCustomPath) || void 0 === s ? void 0 : s.call(t),
        e.toCustomPath(),
        { fromTransform: o, toTransfrom: e.globalTransMatrix }
      ),
      h = OT(null == t ? void 0 : t.attribute, e.attribute),
      c = e.animate(i);
    return (
      (null == i ? void 0 : i.delay) && c.wait(i.delay),
      c.play(
        new BT(
          { morphingData: l, otherAttrs: h },
          null !== (r = null == i ? void 0 : i.duration) && void 0 !== r ? r : PM,
          null !== (a = null == i ? void 0 : i.easing) && void 0 !== a ? a : RM
        )
      ),
      c
    );
  };
  class DT extends wM {
    constructor(t, e, i) {
      super(0, 1, e, i), (this.morphingData = t.morphingData), (this.otherAttrs = t.otherAttrs);
    }
    getEndProps() {
      return {};
    }
    onBind() {
      this.addPathProxy();
    }
    addPathProxy() {
      this.target.shadowRoot.forEachChildren(t => {
        t.createPathProxy();
      }),
        this.onUpdate(!1, 0, this.target.attribute);
    }
    clearPathProxy() {
      this.target.shadowRoot.forEachChildren(t => {
        t.pathProxy = null;
      });
    }
    onEnd() {}
    onUpdate(t, e, i) {
      this.target.shadowRoot.forEachChildren((t, i) => {
        var n;
        ET(this.morphingData[i], 'function' == typeof t.pathProxy ? t.pathProxy(t.attribute) : t.pathProxy, e),
          (null === (n = this.otherAttrs) || void 0 === n ? void 0 : n[i]) &&
            this.otherAttrs[i].length &&
            CT(this.otherAttrs[i], t.attribute, e);
      }),
        t && (this.clearPathProxy(), (this.morphingData = null));
    }
  }
  const LT = t => {
      const e = {};
      return (
        Object.keys(t).forEach(i => {
          (t => NM.includes(t))(i) || (e[i] = t[i]);
        }),
        e
      );
    },
    FT = (t, e, i) => {
      const n = LT(t.attribute),
        s = t.attachShadow();
      if (e.length)
        s.setTheme({ [e[0].type]: n }),
          e.forEach(t => {
            s.appendChild(t);
          });
      else {
        const r = t.AABBBounds,
          a = r.width(),
          o = r.height();
        s.setTheme({ rect: n }),
          new Array(i).fill(0).forEach(t => {
            const i = WA.graphicService.creator.rect({ x: 0, y: 0, width: a, height: o });
            s.appendChild(i), e.push(i);
          });
      }
    },
    jT = (t, e, i) => {
      const n = [],
        s = i ? null : LT(t.attribute),
        r = t.toCustomPath();
      for (let t = 0; t < e; t++) {
        const t = { path: new mA().fromCustomPath2D(r) };
        n.push(WA.graphicService.creator.path(i ? t : Object.assign({}, s, t)));
      }
      return i && FT(t, n, e), n;
    },
    zT = (t, e, i) => {
      const n = [],
        s = i ? null : LT(t.attribute);
      if ('rect' === t.type)
        ((t, e) => {
          const i = t.getComputedAttribute('width'),
            n = t.getComputedAttribute('height'),
            s = cT(i, n, e),
            r = [],
            a = n / s.length;
          for (let t = 0, e = s.length; t < e; t++) {
            const e = s[t],
              n = i / e;
            for (let i = 0; i < e; i++) r.push({ x: 0 + i * n, y: 0 + t * a, width: n, height: a });
          }
          return r;
        })(t, e).forEach(t => {
          n.push(WA.graphicService.creator.rect(i ? t : Object.assign({}, s, t)));
        });
      else if ('arc' === t.type)
        ((t, e) => {
          const i = t.getParsedAngle(),
            n = i.startAngle,
            s = i.endAngle,
            r = t.getComputedAttribute('innerRadius'),
            a = t.getComputedAttribute('outerRadius'),
            o = Math.abs(n - s),
            l = Math.abs(a - r),
            h = cT((o * (r + a)) / 2, l, e),
            c = [],
            d = l / h.length,
            u = a >= r ? 1 : -1,
            p = s >= n ? 1 : -1;
          for (let t = 0, e = h.length; t < e; t++) {
            const e = h[t],
              i = o / e;
            for (let s = 0; s < e; s++)
              c.push({
                innerRadius: a - d * t * u,
                outerRadius: a - d * (t + 1) * u,
                startAngle: n + i * s * p,
                endAngle: n + i * (s + 1) * p
              });
          }
          return c;
        })(t, e).forEach(t => {
          n.push(WA.graphicService.creator.arc(i ? t : Object.assign({}, s, t)));
        });
      else if ('circle' === t.type)
        ((t, e) => {
          const i = t.getComputedAttribute('startAngle'),
            n = t.getComputedAttribute('endAngle'),
            s = t.getComputedAttribute('radius'),
            r = Math.abs(i - n),
            a = cT(r * s, s, e),
            o = [],
            l = r / a[0],
            h = s / a.length,
            c = n >= i ? 1 : -1;
          for (let t = 0, e = a.length; t < e; t++)
            for (let e = 0, n = a[t]; e < n; e++)
              o.push({
                innerRadius: h * t,
                outerRadius: h * (t + 1),
                startAngle: i + l * e * c,
                endAngle: i + l * (e + 1) * c
              });
          return o;
        })(t, e).forEach(t => {
          n.push(WA.graphicService.creator.arc(i ? t : Object.assign({}, s, t)));
        });
      else if ('line' === t.type) {
        const r = ((t, e) => {
            const i = t.attribute,
              n = i.points;
            if (n) return dT(n, e);
            if (i.segments) {
              const t = i.segments.reduce((t, e) => {
                var i;
                return t.concat(null !== (i = e.points) && void 0 !== i ? i : []);
              }, []);
              return dT(t, e);
            }
            return [];
          })(t, e),
          a = { size: 10, symbolType: 'circle' };
        r.forEach(t => {
          n.push(WA.graphicService.creator.symbol(i ? Object.assign({}, t, a) : Object.assign({}, s, t, a)));
        });
      } else
        'polygon' === t.type
          ? ((t, e) => {
              const i = t.attribute.points;
              if (!i || !i.length) return [];
              if (1 === e) return [{ points: uT(i) }];
              const n = [];
              return gT(i, e, n), n;
            })(t, e).forEach(t => {
              n.push(WA.graphicService.creator.polygon(i ? t : Object.assign({}, s, t)));
            })
          : 'area' === t.type
          ? ((t, e) => {
              var i, n;
              const s = t.attribute;
              let r = s.points;
              const a = s.segments;
              r ||
                (r = a.reduce((t, e) => {
                  var i;
                  return t.concat(null !== (i = e.points) && void 0 !== i ? i : []);
                }, []));
              const o = r.filter(t => !1 !== t.defined && y(t.x) && y(t.y));
              if (!o.length) return [];
              const l = [];
              o.forEach(t => {
                l.push({ x: t.x, y: t.y });
              });
              for (let t = o.length - 1; t >= 0; t--) {
                const e = o[t];
                l.push({
                  x: null !== (i = e.x1) && void 0 !== i ? i : e.x,
                  y: null !== (n = e.y1) && void 0 !== n ? n : e.y
                });
              }
              const h = [];
              return gT(r, e, h), h;
            })(t, e).forEach(t => {
              n.push(WA.graphicService.creator.polygon(i ? t : Object.assign({}, s, t)));
            })
          : 'path' === t.type &&
            ((t, e) => {
              const i = oT(t.getParsedPathShape());
              if (!i.length || e < 0) return [];
              const n = i.length;
              if (i.length >= e) {
                const t = [],
                  s = Math.floor(i.length / e);
                for (let r = 0; r < e; r++) {
                  const a = i.slice(r * s, r === e - 1 ? n : (r + 1) * s);
                  t.push({ path: hT(a) });
                }
                return t;
              }
              const s = [],
                r = Math.floor(e / n);
              let a = e;
              for (let t = 0; t < n; t++) {
                const e = [];
                for (let n = 2, s = i[t].length; n < s; n += 2) e.push({ x: i[0][n], y: i[0][n + 1] });
                gT(e, t === n - 1 ? a : r, s), (a -= r);
              }
              return s;
            })(t, e).forEach(t => {
              'path' in t
                ? n.push(WA.graphicService.creator.path(i ? t : Object.assign({}, s, t)))
                : n.push(WA.graphicService.creator.polygon(i ? t : Object.assign({}, s, t)));
            });
      return i && FT(t, n, e), n;
    };
  class HT {
    static GetImage(t, e) {
      var i;
      let n = HT.cache.get(t);
      n
        ? 'fail' === n.loadState
          ? WA.global.getRequestAnimationFrame()(() => {
              e.imageLoadFail(t);
            })
          : 'init' === n.loadState || 'loading' === n.loadState
          ? null === (i = n.waitingMark) || void 0 === i || i.push(e)
          : e &&
            WA.global.getRequestAnimationFrame()(() => {
              e.imageLoadSuccess(t, n.data);
            })
        : ((n = { type: 'image', loadState: 'init' }),
          HT.cache.set(t, n),
          (n.dataPromise = WA.global.loadImage(t)),
          n.dataPromise
            ? ((n.waitingMark = [e]),
              n.dataPromise.then(e => {
                var i;
                (n.loadState = (null == e ? void 0 : e.data) ? 'success' : 'fail'),
                  (n.data = null == e ? void 0 : e.data),
                  null === (i = n.waitingMark) ||
                    void 0 === i ||
                    i.map((i, s) => {
                      (null == e ? void 0 : e.data)
                        ? ((n.loadState = 'success'), (n.data = e.data), i.imageLoadSuccess(t, e.data))
                        : ((n.loadState = 'fail'), i.imageLoadFail(t));
                    });
              }))
            : ((n.loadState = 'fail'), e.imageLoadFail(t)));
    }
    static GetSvg(t, e) {
      var i;
      let n = HT.cache.get(t);
      n
        ? 'fail' === n.loadState
          ? WA.global.getRequestAnimationFrame()(() => {
              e.imageLoadFail(t);
            })
          : 'init' === n.loadState || 'loading' === n.loadState
          ? null === (i = n.waitingMark) || void 0 === i || i.push(e)
          : e &&
            WA.global.getRequestAnimationFrame()(() => {
              e.imageLoadSuccess(t, n.data);
            })
        : ((n = { type: 'image', loadState: 'init' }),
          HT.cache.set(t, n),
          (n.dataPromise = WA.global.loadSvg(t)),
          n.dataPromise
            ? ((n.waitingMark = [e]),
              n.dataPromise.then(e => {
                var i;
                (n.loadState = (null == e ? void 0 : e.data) ? 'success' : 'fail'),
                  (n.data = null == e ? void 0 : e.data),
                  null === (i = n.waitingMark) ||
                    void 0 === i ||
                    i.map((i, s) => {
                      (null == e ? void 0 : e.data)
                        ? ((n.loadState = 'success'), (n.data = e.data), i.imageLoadSuccess(t, e.data))
                        : ((n.loadState = 'fail'), i.imageLoadFail(t));
                    });
              }))
            : ((n.loadState = 'fail'), e.imageLoadFail(t)));
    }
    static GetFile(t, e) {
      let i = HT.cache.get(t);
      return i
        ? 'init' === i.loadState || 'fail' === i.loadState
          ? Promise.reject()
          : 'loading' === i.loadState
          ? i.dataPromise.then(t => t.data)
          : Promise.resolve(i.data)
        : ((i = { type: e, loadState: 'init' }),
          HT.cache.set(t, i),
          'arrayBuffer' === e
            ? (i.dataPromise = WA.global.loadArrayBuffer(t))
            : 'blob' === e
            ? (i.dataPromise = WA.global.loadBlob(t))
            : 'json' === e && (i.dataPromise = WA.global.loadJson(t)),
          i.dataPromise.then(t => t.data));
    }
  }
  HT.cache = new Map();
  const NT = new ie(),
    VT = ['lineWidth', 'lineCap', 'lineJoin', 'miterLimit', 'scaleX', 'scaleY', 'angle', 'anchor'],
    WT = ['x', 'y'],
    GT = ['scaleX', 'scaleY'],
    UT = ['angle'],
    YT = new Ut();
  class $T extends tM {
    static mixin(t) {
      const e = Object.keys(t);
      for (let i = 0; i < e.length; ++i) {
        const n = e[i];
        Object.defineProperty($T.prototype, n, Object.getOwnPropertyDescriptor(t, n));
      }
    }
    get AABBBounds() {
      return this.tryUpdateAABBBounds('imprecise' === this.attribute.boundsMode);
    }
    get OBBBounds() {
      return this.tryUpdateOBBBounds();
    }
    get globalAABBBounds() {
      return this.tryUpdateGlobalAABBBounds();
    }
    get transMatrix() {
      return this.tryUpdateLocalTransMatrix(!0);
    }
    get globalTransMatrix() {
      return this.tryUpdateGlobalTransMatrix(!0);
    }
    constructor() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      super(),
        (this._AABBBounds = new Kt()),
        (this._updateTag = Cw.INIT),
        (this.attribute = t),
        (this.valid = this.isValid()),
        t.background && this.loadImage(t.background, !0);
    }
    setMode(t) {
      '3d' === t ? this.set3dMode() : this.set2dMode();
    }
    set3dMode() {
      this.in3dMode = !0;
    }
    set2dMode() {
      this.in3dMode = !1;
    }
    getOffsetXY(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      const { dx: i = t.dx, dy: n = t.dy } = this.attribute;
      if (e && this.parent) {
        const t = Zk(this.parent).group,
          { scrollX: e = t.scrollX, scrollY: s = t.scrollY } = this.parent.attribute;
        (YT.x = i + e), (YT.y = n + s);
      } else (YT.x = i), (YT.y = n);
      return YT;
    }
    onAnimateBind(t) {
      this._emitCustomEvent('animate-bind', t);
    }
    tryUpdateAABBBounds(t) {
      if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
      if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
      WA.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
      const e = this.doUpdateAABBBounds(t);
      return (
        this.addUpdateLayoutTag(),
        WA.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, !0),
        e
      );
    }
    combindShadowAABBBounds(t) {
      if (this.shadowRoot) {
        const e = this.shadowRoot.AABBBounds.clone();
        t.union(e);
      }
    }
    tryUpdateGlobalAABBBounds() {
      return (
        this._globalAABBBounds
          ? this._globalAABBBounds.setValue(
              this._AABBBounds.x1,
              this._AABBBounds.y1,
              this._AABBBounds.x2,
              this._AABBBounds.y2
            )
          : (this._globalAABBBounds = this.AABBBounds.clone()),
        this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix),
        this._globalAABBBounds
      );
    }
    tryUpdateGlobalTransMatrix() {
      if (this._globalTransMatrix) {
        if (this.parent) {
          const t = this.parent.globalTransMatrix;
          this._globalTransMatrix.setValue(t.a, t.b, t.c, t.d, t.e, t.f);
        }
      } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
      return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;
    }
    shouldUpdateGlobalMatrix() {
      return !0;
    }
    tryUpdateLocalTransMatrix() {
      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      return (
        this._transMatrix || (this._transMatrix = new ie()),
        this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), t && this.clearUpdateLocalPositionTag()),
        this._transMatrix
      );
    }
    shouldUpdateAABBBounds() {
      return this.shadowRoot
        ? !!(this._updateTag & Cw.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds()
        : !!(this._updateTag & Cw.UPDATE_BOUNDS);
    }
    shouldSelfChangeUpdateAABBBounds() {
      return this.shadowRoot
        ? !!(this._updateTag & Cw.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds()
        : !!(this._updateTag & Cw.UPDATE_BOUNDS);
    }
    shouldUpdateLocalMatrix() {
      return !!(this._updateTag & Cw.UPDATE_LOCAL_MATRIX);
    }
    isValid() {
      var t, e;
      const i = this.attribute;
      return Number.isFinite(
        (null !== (t = i.x) && void 0 !== t ? t : 0) + (null !== (e = i.y) && void 0 !== e ? e : 0)
      );
    }
    _validNumber(t) {
      return null == t || Number.isFinite(t);
    }
    shouldUpdateShape() {
      return !!(this._updateTag & Cw.UPDATE_SHAPE);
    }
    clearUpdateShapeTag() {
      this._updateTag &= Cw.CLEAR_SHAPE;
    }
    containsPoint(t, e, i, n) {
      if (!n) return !1;
      if (i === Ew.GLOBAL) {
        const i = new Ut(t, e);
        this.parent && this.parent.globalTransMatrix.transformPoint(i, i), (t = i.x), (e = i.y);
      }
      return n.containsPoint(this, { x: t, y: e });
    }
    setAttributes(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
        i = arguments.length > 2 ? arguments[2] : void 0;
      (t = (this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(t, this.attribute, null, i)) || t)
        .background && this.loadImage(t.background, !0),
        this._setAttributes(t, e, i);
    }
    _setAttributes(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
        i = arguments.length > 2 ? arguments[2] : void 0;
      const n = Object.keys(t);
      for (let e = 0; e < n.length; e++) {
        const i = n[e];
        this.attribute[i] = t[i];
      }
      (this.valid = this.isValid()),
        this.updateShapeAndBoundsTagSetted() || (!e && !this.needUpdateTags(n))
          ? this.addUpdateBoundTag()
          : this.addUpdateShapeAndBoundsTag(),
        this.addUpdatePositionTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate(i);
    }
    setAttribute(t, e, i, n) {
      var s;
      const r = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({ [t]: e }, this.attribute, t, n);
      r
        ? this._setAttributes(r, i, n)
        : l(null === (s = this.normalAttrs) || void 0 === s ? void 0 : s[t])
        ? ((this.attribute[t] = e),
          (this.valid = this.isValid()),
          this.updateShapeAndBoundsTagSetted() || (!i && !this.needUpdateTag(t))
            ? this.addUpdateBoundTag()
            : this.addUpdateShapeAndBoundsTag(),
          this.addUpdatePositionTag(),
          this.addUpdateLayoutTag(),
          this.onAttributeUpdate(n))
        : (this.normalAttrs[t] = e),
        'background' === t && this.loadImage(e, !0);
    }
    needUpdateTags(t) {
      for (let e = 0; e < VT.length; e++) {
        const i = VT[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < VT.length; e++) if (t === VT[e]) return !0;
      return !1;
    }
    initAttributes(t) {
      const e = { type: Pw.INIT };
      (t = (this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(t, this.attribute, null, e)) || t),
        (this.attribute = t),
        t.background && this.loadImage(t.background, !0),
        (this._updateTag = Cw.INIT),
        this.onAttributeUpdate(e);
    }
    translate(t, e) {
      var i, n;
      if (0 === t && 0 === e) return this;
      const s = { type: Pw.TRANSLATE },
        r = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({ x: t, y: e }, this.attribute, WT, s);
      r && ((t = r.x), (e = r.y), delete r.x, delete r.y, this._setAttributes(r));
      const a = this.attribute,
        o = a.postMatrix;
      return (
        o
          ? WA.transformUtil.fromMatrix(o, o).translate(t, e)
          : ((a.x = (null !== (i = a.x) && void 0 !== i ? i : bA.x) + t),
            (a.y = (null !== (n = a.y) && void 0 !== n ? n : bA.y) + e)),
        this.addUpdatePositionTag(),
        this.addUpdateBoundTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate(s),
        this
      );
    }
    translateTo(t, e) {
      const i = this.attribute;
      if (i.x === t && i.y === e) return this;
      const n = { type: Pw.TRANSLATE_TO },
        s = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({ x: t, y: e }, this.attribute, WT, n);
      return s
        ? (this._setAttributes(s, !1, n), this)
        : ((i.x = t),
          (i.y = e),
          this.addUpdatePositionTag(),
          this.addUpdateBoundTag(),
          this.addUpdateLayoutTag(),
          this.onAttributeUpdate(n),
          this);
    }
    scale(t, e, i) {
      var n, s;
      if (1 === t && 1 === e) return this;
      const r = { type: Pw.SCALE },
        a =
          this.onBeforeAttributeUpdate &&
          this.onBeforeAttributeUpdate({ scaleX: t, scaleY: e, scaleCenter: i }, this.attribute, GT, r);
      a && ((t = a.scaleX), (e = a.scaleY), delete a.scaleX, delete a.scaleY, this._setAttributes(a));
      const o = this.attribute;
      if (i) {
        let { postMatrix: n } = this.attribute;
        n || ((n = new ie()), (o.postMatrix = n)), WA.transformUtil.fromMatrix(n, n).scale(t, e, i);
      } else (o.scaleX = (null !== (n = o.scaleX) && void 0 !== n ? n : bA.scaleX) * t), (o.scaleY = (null !== (s = o.scaleY) && void 0 !== s ? s : bA.scaleY) * e);
      return (
        this.addUpdatePositionTag(),
        this.addUpdateBoundTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate(r),
        this
      );
    }
    scaleTo(t, e) {
      const i = this.attribute;
      if (i.scaleX === t && i.scaleY === e) return this;
      const n = { type: Pw.SCALE_TO },
        s =
          this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({ scaleX: t, scaleY: e }, this.attribute, GT, n);
      return s
        ? (this._setAttributes(s, !1, n), this)
        : ((i.scaleX = t),
          (i.scaleY = e),
          this.addUpdatePositionTag(),
          this.addUpdateBoundTag(),
          this.addUpdateLayoutTag(),
          this.onAttributeUpdate(n),
          this);
    }
    rotate(t, e) {
      var i;
      if (0 === t) return this;
      const n = { type: Pw.ROTATE },
        s =
          this.onBeforeAttributeUpdate &&
          this.onBeforeAttributeUpdate({ angle: t, rotateCenter: e }, this.attribute, UT, n);
      s && (delete s.angle, this._setAttributes(s, !1, n));
      const r = this.attribute;
      if (e) {
        let { postMatrix: i } = this.attribute;
        i || ((i = new ie()), (r.postMatrix = i)), WA.transformUtil.fromMatrix(i, i).rotate(t, e);
      } else r.angle = (null !== (i = r.angle) && void 0 !== i ? i : bA.angle) + t;
      return (
        this.addUpdatePositionTag(),
        this.addUpdateBoundTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate(n),
        this
      );
    }
    rotateTo(t) {
      const e = this.attribute;
      if (e.angle === t) return this;
      const i = { type: Pw.ROTATE_TO },
        n = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(t, this.attribute, UT, i);
      return n
        ? (this._setAttributes(n, !1, i), this)
        : ((e.angle = t),
          this.addUpdatePositionTag(),
          this.addUpdateBoundTag(),
          this.addUpdateLayoutTag(),
          this.onAttributeUpdate(i),
          this);
    }
    skewTo(t, e) {
      return this;
    }
    animate(t) {
      this.animates || (this.animates = new Map());
      const e = new kM(null == t ? void 0 : t.id).bind(this);
      if (t) {
        const { onStart: i, onFrame: n, onEnd: s, onRemove: r } = t;
        null != i && e.onStart(i),
          null != n && e.onFrame(n),
          null != s && e.onEnd(s),
          null != r && e.onRemove(r),
          (e.interpolateFunc = t.interpolate);
      }
      return (
        this.animates.set(e.id, e),
        e.onRemove(() => {
          this.animates.delete(e.id);
        }),
        e
      );
    }
    onAttributeUpdate(t) {
      WA.graphicService.onAttributeUpdate(this), this._emitCustomEvent('afterAttributeUpdate', t);
    }
    update(t) {
      t
        ? (t.bounds && this.tryUpdateAABBBounds('imprecise' === this.attribute.boundsMode),
          t.trans && this.tryUpdateLocalTransMatrix())
        : (this.tryUpdateAABBBounds('imprecise' === this.attribute.boundsMode), this.tryUpdateLocalTransMatrix());
    }
    hasState(t) {
      return !(!this.currentStates || !this.currentStates.length) && (!!l(t) || this.currentStates.includes(t));
    }
    getState(t) {
      var e;
      return null === (e = this.states) || void 0 === e ? void 0 : e[t];
    }
    applyStateAttrs(t, e, i, n) {
      var s, r, a, o;
      if (i) {
        const i = Object.keys(t),
          l = n ? i.reduce((e, i) => ((e[i] = void 0 === t[i] ? this.getDefaultAttribute(i) : t[i]), e), {}) : t,
          h = this.animate();
        (h.stateNames = e),
          h.to(
            l,
            null !== (r = null === (s = this.stateAnimateConfig) || void 0 === s ? void 0 : s.duration) && void 0 !== r
              ? r
              : CM,
            null !== (o = null === (a = this.stateAnimateConfig) || void 0 === a ? void 0 : a.easing) && void 0 !== o
              ? o
              : EM
          );
      } else this.setAttributes(t, !1, { type: Pw.STATE });
    }
    updateNormalAttrs(t) {
      const e = {};
      this.normalAttrs
        ? (Object.keys(t).forEach(t => {
            t in this.normalAttrs
              ? ((e[t] = this.normalAttrs[t]), delete this.normalAttrs[t])
              : (e[t] = this.getNormalAttribute(t));
          }),
          Object.keys(this.normalAttrs).forEach(e => {
            t[e] = this.normalAttrs[e];
          }))
        : Object.keys(t).forEach(t => {
            e[t] = this.getNormalAttribute(t);
          }),
        (this.normalAttrs = e);
    }
    getNormalAttribute(t) {
      let e = this.attribute[t];
      return (
        this.animates &&
          this.animates.forEach(i => {
            if (i.stateNames) {
              const n = i.getEndProps();
              P(n, t) && (e = n[t]);
            }
          }),
        e
      );
    }
    clearStates(t) {
      this.hasState() && this.normalAttrs && this.applyStateAttrs(this.normalAttrs, this.currentStates, t, !0),
        (this.normalAttrs = null),
        (this.currentStates = []);
    }
    removeState(t, e) {
      if ((this.currentStates ? this.currentStates.indexOf(t) : -1) >= 0) {
        const i = this.currentStates.filter(e => e !== t);
        this.useStates(i, e);
      }
    }
    toggleState(t, e) {
      if (this.hasState(t)) this.removeState(t, e);
      else if ((this.currentStates ? this.currentStates.indexOf(t) : -1) < 0) {
        const i = this.currentStates ? this.currentStates.slice() : [];
        i.push(t), this.useStates(i, e);
      }
    }
    addState(t, e, i) {
      var n;
      if (this.currentStates && this.currentStates.includes(t) && (e || 1 === this.currentStates.length)) return;
      const s =
        e && (null === (n = this.currentStates) || void 0 === n ? void 0 : n.length)
          ? this.currentStates.concat([t])
          : [t];
      this.useStates(s, i);
    }
    useStates(t, e) {
      var i;
      if (!t.length) return void this.clearStates(e);
      if (
        (null === (i = this.currentStates) || void 0 === i ? void 0 : i.length) === t.length &&
        !t.some((t, e) => this.currentStates[e] !== t)
      )
        return;
      const n = {};
      t.forEach(e => {
        var i;
        const s = this.stateProxy ? this.stateProxy(e, t) : null === (i = this.states) || void 0 === i ? void 0 : i[e];
        s && Object.assign(n, s);
      }),
        this.updateNormalAttrs(n),
        (this.currentStates = t),
        this.applyStateAttrs(n, t, e);
    }
    addUpdateBoundTag() {
      (this._updateTag |= Cw.UPDATE_BOUNDS),
        this.parent && this.parent.addChildUpdateBoundTag(),
        this.glyphHost && this.glyphHost.addUpdateBoundTag();
    }
    addUpdateShapeTag() {
      this._updateTag |= Cw.UPDATE_SHAPE;
    }
    addUpdateShapeAndBoundsTag() {
      (this._updateTag |= Cw.UPDATE_SHAPE_AND_BOUNDS),
        this.parent && this.parent.addChildUpdateBoundTag(),
        this.glyphHost && this.glyphHost.addUpdateBoundTag();
    }
    updateShapeAndBoundsTagSetted() {
      return (this._updateTag & Cw.UPDATE_SHAPE_AND_BOUNDS) === Cw.UPDATE_SHAPE_AND_BOUNDS;
    }
    clearUpdateBoundTag() {
      this._updateTag &= Cw.CLEAR_BOUNDS;
    }
    addUpdatePositionTag() {
      this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(),
        (this._updateTag |= Cw.UPDATE_GLOBAL_LOCAL_MATRIX);
    }
    addUpdateGlobalPositionTag() {
      this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), (this._updateTag |= Cw.UPDATE_GLOBAL_MATRIX);
    }
    clearUpdateLocalPositionTag() {
      this._updateTag &= Cw.CLEAR_LOCAL_MATRIX;
    }
    clearUpdateGlobalPositionTag() {
      this._updateTag &= Cw.CLEAR_GLOBAL_MATRIX;
    }
    addUpdateLayoutTag() {
      this._updateTag |= Cw.UPDATE_LAYOUT;
    }
    clearUpdateLayoutTag() {
      this._updateTag &= Cw.CLEAR_LAYOUT;
    }
    needUpdateLayout() {
      return !!(this._updateTag & Cw.UPDATE_LAYOUT);
    }
    doUpdateLocalMatrix() {
      const {
          x: t = bA.x,
          y: e = bA.y,
          scaleX: i = bA.scaleX,
          scaleY: n = bA.scaleY,
          angle: s = bA.angle,
          scaleCenter: r,
          anchor: a,
          postMatrix: o
        } = this.attribute,
        l = [0, 0];
      if (a) {
        if ('string' == typeof a[0]) {
          const t = parseFloat(a[0]) / 100,
            e = this.AABBBounds;
          l[0] = e.x1 + (e.x2 - e.x1) * t;
        } else l[0] = a[0];
        if ('string' == typeof a[1]) {
          const t = parseFloat(a[1]) / 100,
            e = this.AABBBounds;
          l[1] = e.x1 + (e.x2 - e.x1) * t;
        } else l[1] = a[1];
      }
      if (!r || (1 === i && 1 === n))
        !(function (t, e, i, n, s, r, a, o) {
          const l = e.a,
            h = e.b,
            c = e.c,
            d = e.d,
            u = e.e,
            p = e.f,
            g = Ot(a),
            f = Dt(a);
          let v, m;
          o ? ((v = o[0]), (m = o[1])) : ((v = i), (m = n));
          const y = v - i,
            _ = m - n,
            b = l * g + c * f,
            x = h * g + d * f,
            S = c * g - l * f,
            w = d * g - h * f;
          (t.a = s * b),
            (t.b = s * x),
            (t.c = r * S),
            (t.d = r * w),
            (t.e = u + l * v + c * m - b * y - S * _),
            (t.f = p + h * v + d * m - x * y - w * _);
        })(this._transMatrix, this._transMatrix.reset(), t, e, i, n, s, a && l);
      else {
        const a = this._transMatrix;
        a.reset(),
          a.translate(l[0], l[1]),
          a.rotate(s),
          a.translate(-l[0], -l[1]),
          a.translate(t, e),
          WA.transformUtil.fromMatrix(a, a).scale(i, n, { x: r[0], y: r[1] });
      }
      const h = this.getOffsetXY(bA);
      if (((this._transMatrix.e += h.x), (this._transMatrix.f += h.y), o)) {
        const t = NT.setValue(o.a, o.b, o.c, o.d, o.e, o.f),
          e = this._transMatrix;
        t.multiply(e.a, e.b, e.c, e.d, e.e, e.f), e.setValue(t.a, t.b, t.c, t.d, t.e, t.f);
      }
    }
    doUpdateGlobalMatrix() {
      if (this.parent) {
        this._globalTransMatrix.multiply(
          this.transMatrix.a,
          this.transMatrix.b,
          this.transMatrix.c,
          this.transMatrix.d,
          this.transMatrix.e,
          this.transMatrix.f
        );
        const { scrollX: t = 0, scrollY: e = 0 } = this.parent.attribute;
        this._globalTransMatrix.translate(t, e);
      }
    }
    setStage(t, e) {
      if (this.stage !== t) {
        if (
          ((this.stage = t), (this.layer = e), this.setStageToShadowRoot(t, e), this.animates && this.animates.size)
        ) {
          const e = t.getTimeline();
          this.animates.forEach(t => {
            t.setTimeline(e);
          });
        }
        this._onSetStage && this._onSetStage(this, t, e), WA.graphicService.onSetStage(this, t);
      }
    }
    setStageToShadowRoot(t, e) {
      this.shadowRoot && this.shadowRoot.setStage(t, e);
    }
    onAddStep(t) {}
    onStop(t) {
      t && this.setAttributes(t, !1, { type: Pw.ANIMATE_END });
    }
    onStep(t, e, i, n, s) {
      const r = {};
      if (i.customAnimate) i.customAnimate.update(s, n, r);
      else {
        const a = i.props,
          o = i.parsedProps,
          l = i.propKeys;
        this.stepInterpolate(t, e, r, i, n, s, a, void 0, o, l);
      }
      this.setAttributes(r, !1, {
        type: Pw.ANIMATE_UPDATE,
        animationState: { ratio: n, end: s, step: i, isFirstFrameOfStep: t.getLastStep() !== i }
      }),
        this.stage && this.stage.renderNextFrame();
    }
    stepInterpolate(t, e, i, n, s, r, a, o, l, h) {
      h || ((h = Object.keys(a)), (n.propKeys = h)),
        r
          ? n.propKeys.forEach(t => {
              e.validAttr(t) && (i[t] = a[t]);
            })
          : h.forEach(r => {
              var h;
              if (!e.validAttr(r)) return;
              const c = a[r],
                d = null !== (h = o && o[r]) && void 0 !== h ? h : t.getLastPropByName(r, n);
              let u;
              (u = e.interpolateFunc && e.interpolateFunc(r, s, d, c, i)),
                u ||
                  ((u = e.customInterpolate(r, s, d, c, this, i)),
                  u || this.defaultInterpolate(c, d, r, i, l, s) || this._interpolate(r, s, d, c, i));
            }),
        (n.parsedProps = l);
    }
    defaultInterpolate(t, e, i, n, s, r) {
      if (Number.isFinite(t)) return (n[i] = e + (t - e) * r), !0;
      if ('fill' === i) {
        s || (s = {});
        const a = s.fillColorArray,
          o = AT(e, null != a ? a : t, r, !1, (t, e) => {
            s.fillColorArray = e;
          });
        return o && (n[i] = o), !0;
      }
      if ('stroke' === i) {
        s || (s = {});
        const a = s.strokeColorArray,
          o = AT(e, null != a ? a : t, r, !1, (t, e) => {
            s.strokeColorArray = e;
          });
        return o && (n[i] = o), !0;
      }
      if ('shadowColor' === i) {
        s || (s = {});
        const a = s.shadowColorArray,
          o = AT(e, null != a ? a : t, r, !0, (t, e) => {
            s.shadowColorArray = e;
          });
        return o && (n[i] = o), !0;
      }
      return !1;
    }
    _interpolate(t, e, i, n, s) {}
    getDefaultAttribute(t) {
      return Zk(this)[this.type][t];
    }
    getComputedAttribute(t) {
      var e;
      return null !== (e = this.attribute[t]) && void 0 !== e ? e : this.getDefaultAttribute(t);
    }
    onSetStage(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      (this._onSetStage = t), e && this.stage && t(this, this.stage);
    }
    attachShadow(t) {
      return (
        t && (t.shadowHost = this),
        (this.shadowRoot = null != t ? t : WA.graphicService.creator.shadowRoot(this)),
        this.addUpdateBoundTag(),
        this.shadowRoot.setStage(this.stage, this.layer),
        this.shadowRoot
      );
    }
    detachShadow() {
      this.shadowRoot && (this.addUpdateBoundTag(), (this.shadowRoot = null));
    }
    toJson() {
      return {
        attribute: this.attribute,
        _uid: this._uid,
        type: this.type,
        name: this.name,
        children: this.children.map(t => t.toJson())
      };
    }
    createPathProxy(t) {
      return g(t, !0) ? (this.pathProxy = new mA().fromString(t)) : (this.pathProxy = new mA()), this.pathProxy;
    }
    loadImage(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      if (
        !t ||
        (e &&
          (function (t) {
            return !(!t.fill && !t.stroke);
          })(t))
      )
        return;
      const i = t;
      this.resources || (this.resources = new Map());
      const n = { data: 'init', state: null };
      this.resources.set(i, n),
        'string' == typeof t
          ? ((n.state = 'loading'),
            b(t) || S(t)
              ? (HT.GetImage(t, this), (this.backgroundImg = this.backgroundImg || e))
              : t.startsWith('<svg') && (HT.GetSvg(t, this), (this.backgroundImg = this.backgroundImg || e)))
          : ((n.state = 'success'), (n.data = t), (this.backgroundImg = this.backgroundImg || e));
    }
    imageLoadSuccess(t, e, i) {
      if (!this.resources) return;
      const n = this.resources.get(t);
      n &&
        ((n.state = 'success'),
        (n.data = e),
        i && i(),
        this.addUpdateBoundTag(),
        this.stage && this.stage.renderNextFrame());
    }
    imageLoadFail(t, e) {
      if (!this.resources) return;
      const i = this.resources.get(t);
      i && ((i.state = 'fail'), e && e());
    }
    _stopAnimates(t) {
      t &&
        t.forEach(t => {
          t.stop();
        });
    }
    stopAnimates() {
      let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      this._stopAnimates(this.animates),
        this.shadowRoot && this.shadowRoot.stopAnimates(!0),
        this.isContainer &&
          t &&
          this.forEachChildren(e => {
            e.stopAnimates(t);
          });
    }
    release() {
      this.releaseStatus = 'released';
    }
    _emitCustomEvent(t, e) {
      var i, n;
      if (this._events && t in this._events) {
        const s = new rM(t, e);
        (s.bubbles = !1),
          (s.manager =
            null === (n = null === (i = this.stage) || void 0 === i ? void 0 : i.eventSystem) || void 0 === n
              ? void 0
              : n.manager),
          this.dispatchEvent(s);
      }
    }
  }
  $T.mixin(hM);
  var XT = {},
    KT = {};
  !(function (t) {
    const e =
        ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD',
      i = '[' + e + '][' + (e + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040') + ']*',
      n = new RegExp('^' + i + '$');
    (t.isExist = function (t) {
      return void 0 !== t;
    }),
      (t.isEmptyObject = function (t) {
        return 0 === Object.keys(t).length;
      }),
      (t.merge = function (t, e, i) {
        if (e) {
          const n = Object.keys(e),
            s = n.length;
          for (let r = 0; r < s; r++) t[n[r]] = 'strict' === i ? [e[n[r]]] : e[n[r]];
        }
      }),
      (t.getValue = function (e) {
        return t.isExist(e) ? e : '';
      }),
      (t.isName = function (t) {
        const e = n.exec(t);
        return !(null == e);
      }),
      (t.getAllMatches = function (t, e) {
        const i = [];
        let n = e.exec(t);
        for (; n; ) {
          const s = [];
          s.startIndex = e.lastIndex - n[0].length;
          const r = n.length;
          for (let t = 0; t < r; t++) s.push(n[t]);
          i.push(s), (n = e.exec(t));
        }
        return i;
      }),
      (t.nameRegexp = i);
  })(KT);
  const qT = KT,
    ZT = { allowBooleanAttributes: !1, unpairedTags: [] };
  function JT(t) {
    return ' ' === t || '\t' === t || '\n' === t || '\r' === t;
  }
  function QT(t, e) {
    const i = e;
    for (; e < t.length; e++)
      if ('?' != t[e] && ' ' != t[e]);
      else {
        const n = t.substr(i, e - i);
        if (e > 5 && 'xml' === n)
          return oC('InvalidXml', 'XML declaration allowed only at the start of the document.', hC(t, e));
        if ('?' == t[e] && '>' == t[e + 1]) {
          e++;
          break;
        }
      }
    return e;
  }
  function tC(t, e) {
    if (t.length > e + 5 && '-' === t[e + 1] && '-' === t[e + 2]) {
      for (e += 3; e < t.length; e++)
        if ('-' === t[e] && '-' === t[e + 1] && '>' === t[e + 2]) {
          e += 2;
          break;
        }
    } else if (
      t.length > e + 8 &&
      'D' === t[e + 1] &&
      'O' === t[e + 2] &&
      'C' === t[e + 3] &&
      'T' === t[e + 4] &&
      'Y' === t[e + 5] &&
      'P' === t[e + 6] &&
      'E' === t[e + 7]
    ) {
      let i = 1;
      for (e += 8; e < t.length; e++)
        if ('<' === t[e]) i++;
        else if ('>' === t[e] && (i--, 0 === i)) break;
    } else if (
      t.length > e + 9 &&
      '[' === t[e + 1] &&
      'C' === t[e + 2] &&
      'D' === t[e + 3] &&
      'A' === t[e + 4] &&
      'T' === t[e + 5] &&
      'A' === t[e + 6] &&
      '[' === t[e + 7]
    )
      for (e += 8; e < t.length; e++)
        if (']' === t[e] && ']' === t[e + 1] && '>' === t[e + 2]) {
          e += 2;
          break;
        }
    return e;
  }
  XT.validate = function (t, e) {
    e = Object.assign({}, ZT, e);
    const i = [];
    let n = !1,
      s = !1;
    '\ufeff' === t[0] && (t = t.substr(1));
    for (let a = 0; a < t.length; a++)
      if ('<' === t[a] && '?' === t[a + 1]) {
        if (((a += 2), (a = QT(t, a)), a.err)) return a;
      } else {
        if ('<' !== t[a]) {
          if (JT(t[a])) continue;
          return oC('InvalidChar', "char '" + t[a] + "' is not expected.", hC(t, a));
        }
        {
          let o = a;
          if ((a++, '!' === t[a])) {
            a = tC(t, a);
            continue;
          }
          {
            let l = !1;
            '/' === t[a] && ((l = !0), a++);
            let h = '';
            for (; a < t.length && '>' !== t[a] && ' ' !== t[a] && '\t' !== t[a] && '\n' !== t[a] && '\r' !== t[a]; a++)
              h += t[a];
            if (
              ((h = h.trim()),
              '/' === h[h.length - 1] && ((h = h.substring(0, h.length - 1)), a--),
              (r = h),
              !qT.isName(r))
            ) {
              let e;
              return (
                (e = 0 === h.trim().length ? "Invalid space after '<'." : "Tag '" + h + "' is an invalid name."),
                oC('InvalidTag', e, hC(t, a))
              );
            }
            const c = nC(t, a);
            if (!1 === c) return oC('InvalidAttr', "Attributes for '" + h + "' have open quote.", hC(t, a));
            let d = c.value;
            if (((a = c.index), '/' === d[d.length - 1])) {
              const i = a - d.length;
              d = d.substring(0, d.length - 1);
              const s = rC(d, e);
              if (!0 !== s) return oC(s.err.code, s.err.msg, hC(t, i + s.err.line));
              n = !0;
            } else if (l) {
              if (!c.tagClosed)
                return oC('InvalidTag', "Closing tag '" + h + "' doesn't have proper closing.", hC(t, a));
              if (d.trim().length > 0)
                return oC('InvalidTag', "Closing tag '" + h + "' can't have attributes or invalid starting.", hC(t, o));
              {
                const e = i.pop();
                if (h !== e.tagName) {
                  let i = hC(t, e.tagStartPos);
                  return oC(
                    'InvalidTag',
                    "Expected closing tag '" +
                      e.tagName +
                      "' (opened in line " +
                      i.line +
                      ', col ' +
                      i.col +
                      ") instead of closing tag '" +
                      h +
                      "'.",
                    hC(t, o)
                  );
                }
                0 == i.length && (s = !0);
              }
            } else {
              const r = rC(d, e);
              if (!0 !== r) return oC(r.err.code, r.err.msg, hC(t, a - d.length + r.err.line));
              if (!0 === s) return oC('InvalidXml', 'Multiple possible root nodes found.', hC(t, a));
              -1 !== e.unpairedTags.indexOf(h) || i.push({ tagName: h, tagStartPos: o }), (n = !0);
            }
            for (a++; a < t.length; a++)
              if ('<' === t[a]) {
                if ('!' === t[a + 1]) {
                  a++, (a = tC(t, a));
                  continue;
                }
                if ('?' !== t[a + 1]) break;
                if (((a = QT(t, ++a)), a.err)) return a;
              } else if ('&' === t[a]) {
                const e = aC(t, a);
                if (-1 == e) return oC('InvalidChar', "char '&' is not expected.", hC(t, a));
                a = e;
              } else if (!0 === s && !JT(t[a])) return oC('InvalidXml', 'Extra text at the end', hC(t, a));
            '<' === t[a] && a--;
          }
        }
      }
    var r;
    return n
      ? 1 == i.length
        ? oC('InvalidTag', "Unclosed tag '" + i[0].tagName + "'.", hC(t, i[0].tagStartPos))
        : !(i.length > 0) ||
          oC(
            'InvalidXml',
            "Invalid '" +
              JSON.stringify(
                i.map(t => t.tagName),
                null,
                4
              ).replace(/\r?\n/g, '') +
              "' found.",
            { line: 1, col: 1 }
          )
      : oC('InvalidXml', 'Start tag expected.', 1);
  };
  const eC = '"',
    iC = "'";
  function nC(t, e) {
    let i = '',
      n = '',
      s = !1;
    for (; e < t.length; e++) {
      if (t[e] === eC || t[e] === iC) '' === n ? (n = t[e]) : n !== t[e] || (n = '');
      else if ('>' === t[e] && '' === n) {
        s = !0;
        break;
      }
      i += t[e];
    }
    return '' === n && { value: i, index: e, tagClosed: s };
  }
  const sC = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');
  function rC(t, e) {
    const i = qT.getAllMatches(t, sC),
      n = {};
    for (let t = 0; t < i.length; t++) {
      if (0 === i[t][1].length)
        return oC('InvalidAttr', "Attribute '" + i[t][2] + "' has no space in starting.", cC(i[t]));
      if (void 0 !== i[t][3] && void 0 === i[t][4])
        return oC('InvalidAttr', "Attribute '" + i[t][2] + "' is without value.", cC(i[t]));
      if (void 0 === i[t][3] && !e.allowBooleanAttributes)
        return oC('InvalidAttr', "boolean attribute '" + i[t][2] + "' is not allowed.", cC(i[t]));
      const s = i[t][2];
      if (!lC(s)) return oC('InvalidAttr', "Attribute '" + s + "' is an invalid name.", cC(i[t]));
      if (n.hasOwnProperty(s)) return oC('InvalidAttr', "Attribute '" + s + "' is repeated.", cC(i[t]));
      n[s] = 1;
    }
    return !0;
  }
  function aC(t, e) {
    if (';' === t[++e]) return -1;
    if ('#' === t[e])
      return (function (t, e) {
        let i = /\d/;
        for ('x' === t[e] && (e++, (i = /[\da-fA-F]/)); e < t.length; e++) {
          if (';' === t[e]) return e;
          if (!t[e].match(i)) break;
        }
        return -1;
      })(t, ++e);
    let i = 0;
    for (; e < t.length; e++, i++)
      if (!(t[e].match(/\w/) && i < 20)) {
        if (';' === t[e]) break;
        return -1;
      }
    return e;
  }
  function oC(t, e, i) {
    return { err: { code: t, msg: e, line: i.line || i, col: i.col } };
  }
  function lC(t) {
    return qT.isName(t);
  }
  function hC(t, e) {
    const i = t.substring(0, e).split(/\r?\n/);
    return { line: i.length, col: i[i.length - 1].length + 1 };
  }
  function cC(t) {
    return t.startIndex + t[1].length;
  }
  var dC = {};
  const uC = {
    preserveOrder: !1,
    attributeNamePrefix: '@_',
    attributesGroupName: !1,
    textNodeName: '#text',
    ignoreAttributes: !0,
    removeNSPrefix: !1,
    allowBooleanAttributes: !1,
    parseTagValue: !0,
    parseAttributeValue: !1,
    trimValues: !0,
    cdataPropName: !1,
    numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 },
    tagValueProcessor: function (t, e) {
      return e;
    },
    attributeValueProcessor: function (t, e) {
      return e;
    },
    stopNodes: [],
    alwaysCreateTextNode: !1,
    isArray: () => !1,
    commentPropName: !1,
    unpairedTags: [],
    processEntities: !0,
    htmlEntities: !1,
    ignoreDeclaration: !1,
    ignorePiTags: !1,
    transformTagName: !1,
    transformAttributeName: !1,
    updateTag: function (t, e, i) {
      return t;
    }
  };
  (dC.buildOptions = function (t) {
    return Object.assign({}, uC, t);
  }),
    (dC.defaultOptions = uC);
  var pC = class {
    constructor(t) {
      (this.tagname = t), (this.child = []), (this[':@'] = {});
    }
    add(t, e) {
      '__proto__' === t && (t = '#__proto__'), this.child.push({ [t]: e });
    }
    addChild(t) {
      '__proto__' === t.tagname && (t.tagname = '#__proto__'),
        t[':@'] && Object.keys(t[':@']).length > 0
          ? this.child.push({ [t.tagname]: t.child, ':@': t[':@'] })
          : this.child.push({ [t.tagname]: t.child });
    }
  };
  const gC = KT;
  function fC(t, e) {
    let i = '';
    for (; e < t.length && "'" !== t[e] && '"' !== t[e]; e++) i += t[e];
    if (((i = i.trim()), -1 !== i.indexOf(' '))) throw new Error('External entites are not supported');
    const n = t[e++];
    let s = '';
    for (; e < t.length && t[e] !== n; e++) s += t[e];
    return [i, s, e];
  }
  function vC(t, e) {
    return '!' === t[e + 1] && '-' === t[e + 2] && '-' === t[e + 3];
  }
  function mC(t, e) {
    return (
      '!' === t[e + 1] &&
      'E' === t[e + 2] &&
      'N' === t[e + 3] &&
      'T' === t[e + 4] &&
      'I' === t[e + 5] &&
      'T' === t[e + 6] &&
      'Y' === t[e + 7]
    );
  }
  function yC(t, e) {
    return (
      '!' === t[e + 1] &&
      'E' === t[e + 2] &&
      'L' === t[e + 3] &&
      'E' === t[e + 4] &&
      'M' === t[e + 5] &&
      'E' === t[e + 6] &&
      'N' === t[e + 7] &&
      'T' === t[e + 8]
    );
  }
  function _C(t, e) {
    return (
      '!' === t[e + 1] &&
      'A' === t[e + 2] &&
      'T' === t[e + 3] &&
      'T' === t[e + 4] &&
      'L' === t[e + 5] &&
      'I' === t[e + 6] &&
      'S' === t[e + 7] &&
      'T' === t[e + 8]
    );
  }
  function bC(t, e) {
    return (
      '!' === t[e + 1] &&
      'N' === t[e + 2] &&
      'O' === t[e + 3] &&
      'T' === t[e + 4] &&
      'A' === t[e + 5] &&
      'T' === t[e + 6] &&
      'I' === t[e + 7] &&
      'O' === t[e + 8] &&
      'N' === t[e + 9]
    );
  }
  function xC(t) {
    if (gC.isName(t)) return t;
    throw new Error(`Invalid entity name ${t}`);
  }
  var SC = function (t, e) {
    const i = {};
    if (
      'O' !== t[e + 3] ||
      'C' !== t[e + 4] ||
      'T' !== t[e + 5] ||
      'Y' !== t[e + 6] ||
      'P' !== t[e + 7] ||
      'E' !== t[e + 8]
    )
      throw new Error('Invalid Tag instead of DOCTYPE');
    {
      e += 9;
      let n = 1,
        s = !1,
        r = !1,
        a = '';
      for (; e < t.length; e++)
        if ('<' !== t[e] || r)
          if ('>' === t[e]) {
            if ((r ? '-' === t[e - 1] && '-' === t[e - 2] && ((r = !1), n--) : n--, 0 === n)) break;
          } else '[' === t[e] ? (s = !0) : (a += t[e]);
        else {
          if (s && mC(t, e))
            (e += 7),
              ([entityName, val, e] = fC(t, e + 1)),
              -1 === val.indexOf('&') && (i[xC(entityName)] = { regx: RegExp(`&${entityName};`, 'g'), val: val });
          else if (s && yC(t, e)) e += 8;
          else if (s && _C(t, e)) e += 8;
          else if (s && bC(t, e)) e += 9;
          else {
            if (!vC) throw new Error('Invalid DOCTYPE');
            r = !0;
          }
          n++, (a = '');
        }
      if (0 !== n) throw new Error('Unclosed DOCTYPE');
    }
    return { entities: i, i: e };
  };
  const wC = /^[-+]?0x[a-fA-F0-9]+$/,
    AC = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
  !Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt),
    !Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
  const kC = { hex: !0, leadingZeros: !0, decimalPoint: '.', eNotation: !0 };
  var MC = function (t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (((e = Object.assign({}, kC, e)), !t || 'string' != typeof t)) return t;
    let i = t.trim();
    if (void 0 !== e.skipLike && e.skipLike.test(i)) return t;
    if (e.hex && wC.test(i)) return Number.parseInt(i, 16);
    {
      const n = AC.exec(i);
      if (n) {
        const s = n[1],
          r = n[2];
        let a = (function (t) {
          if (t && -1 !== t.indexOf('.'))
            return (
              '.' === (t = t.replace(/0+$/, ''))
                ? (t = '0')
                : '.' === t[0]
                ? (t = '0' + t)
                : '.' === t[t.length - 1] && (t = t.substr(0, t.length - 1)),
              t
            );
          return t;
        })(n[3]);
        const o = n[4] || n[6];
        if (!e.leadingZeros && r.length > 0 && s && '.' !== i[2]) return t;
        if (!e.leadingZeros && r.length > 0 && !s && '.' !== i[1]) return t;
        {
          const n = Number(i),
            l = '' + n;
          return -1 !== l.search(/[eE]/) || o
            ? e.eNotation
              ? n
              : t
            : -1 !== i.indexOf('.')
            ? ('0' === l && '' === a) || l === a || (s && l === '-' + a)
              ? n
              : t
            : r
            ? a === l || s + a === l
              ? n
              : t
            : i === l || i === s + l
            ? n
            : t;
        }
      }
      return t;
    }
  };
  const TC = KT,
    CC = pC,
    EC = SC,
    PC = MC;
  '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'.replace(
    /NAME/g,
    TC.nameRegexp
  );
  function RC(t) {
    const e = Object.keys(t);
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      this.lastEntities[n] = { regex: new RegExp('&' + n + ';', 'g'), val: t[n] };
    }
  }
  function OC(t, e, i, n, s, r, a) {
    if (void 0 !== t && (this.options.trimValues && !n && (t = t.trim()), t.length > 0)) {
      a || (t = this.replaceEntitiesValue(t));
      const n = this.options.tagValueProcessor(e, t, i, s, r);
      if (null == n) return t;
      if (typeof n != typeof t || n !== t) return n;
      if (this.options.trimValues) return GC(t, this.options.parseTagValue, this.options.numberParseOptions);
      return t.trim() === t ? GC(t, this.options.parseTagValue, this.options.numberParseOptions) : t;
    }
  }
  function BC(t) {
    if (this.options.removeNSPrefix) {
      const e = t.split(':'),
        i = '/' === t.charAt(0) ? '/' : '';
      if ('xmlns' === e[0]) return '';
      2 === e.length && (t = i + e[1]);
    }
    return t;
  }
  const IC = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');
  function DC(t, e, i) {
    if (!this.options.ignoreAttributes && 'string' == typeof t) {
      const i = TC.getAllMatches(t, IC),
        n = i.length,
        s = {};
      for (let t = 0; t < n; t++) {
        const n = this.resolveNameSpace(i[t][1]);
        let r = i[t][4],
          a = this.options.attributeNamePrefix + n;
        if (n.length)
          if (
            (this.options.transformAttributeName && (a = this.options.transformAttributeName(a)),
            '__proto__' === a && (a = '#__proto__'),
            void 0 !== r)
          ) {
            this.options.trimValues && (r = r.trim()), (r = this.replaceEntitiesValue(r));
            const t = this.options.attributeValueProcessor(n, r, e);
            s[a] =
              null == t
                ? r
                : typeof t != typeof r || t !== r
                ? t
                : GC(r, this.options.parseAttributeValue, this.options.numberParseOptions);
          } else this.options.allowBooleanAttributes && (s[a] = !0);
      }
      if (!Object.keys(s).length) return;
      if (this.options.attributesGroupName) {
        const t = {};
        return (t[this.options.attributesGroupName] = s), t;
      }
      return s;
    }
  }
  const LC = function (t) {
    t = t.replace(/\r\n?/g, '\n');
    const e = new CC('!xml');
    let i = e,
      n = '',
      s = '';
    for (let r = 0; r < t.length; r++) {
      if ('<' === t[r])
        if ('/' === t[r + 1]) {
          const e = NC(t, '>', r, 'Closing Tag is not closed.');
          let a = t.substring(r + 2, e).trim();
          if (this.options.removeNSPrefix) {
            const t = a.indexOf(':');
            -1 !== t && (a = a.substr(t + 1));
          }
          this.options.transformTagName && (a = this.options.transformTagName(a)),
            i && (n = this.saveTextToParentTag(n, i, s));
          const o = s.substring(s.lastIndexOf('.') + 1);
          if (a && -1 !== this.options.unpairedTags.indexOf(a))
            throw new Error(`Unpaired tag can not be used as closing tag: </${a}>`);
          let l = 0;
          o && -1 !== this.options.unpairedTags.indexOf(o)
            ? ((l = s.lastIndexOf('.', s.lastIndexOf('.') - 1)), this.tagsNodeStack.pop())
            : (l = s.lastIndexOf('.')),
            (s = s.substring(0, l)),
            (i = this.tagsNodeStack.pop()),
            (n = ''),
            (r = e);
        } else if ('?' === t[r + 1]) {
          let e = VC(t, r, !1, '?>');
          if (!e) throw new Error('Pi Tag is not closed.');
          if (
            ((n = this.saveTextToParentTag(n, i, s)),
            (this.options.ignoreDeclaration && '?xml' === e.tagName) || this.options.ignorePiTags)
          );
          else {
            const t = new CC(e.tagName);
            t.add(this.options.textNodeName, ''),
              e.tagName !== e.tagExp && e.attrExpPresent && (t[':@'] = this.buildAttributesMap(e.tagExp, s, e.tagName)),
              this.addChild(i, t, s);
          }
          r = e.closeIndex + 1;
        } else if ('!--' === t.substr(r + 1, 3)) {
          const e = NC(t, '--\x3e', r + 4, 'Comment is not closed.');
          if (this.options.commentPropName) {
            const a = t.substring(r + 4, e - 2);
            (n = this.saveTextToParentTag(n, i, s)),
              i.add(this.options.commentPropName, [{ [this.options.textNodeName]: a }]);
          }
          r = e;
        } else if ('!D' === t.substr(r + 1, 2)) {
          const e = EC(t, r);
          (this.docTypeEntities = e.entities), (r = e.i);
        } else if ('![' === t.substr(r + 1, 2)) {
          const e = NC(t, ']]>', r, 'CDATA is not closed.') - 2,
            a = t.substring(r + 9, e);
          if (((n = this.saveTextToParentTag(n, i, s)), this.options.cdataPropName))
            i.add(this.options.cdataPropName, [{ [this.options.textNodeName]: a }]);
          else {
            let t = this.parseTextData(a, i.tagname, s, !0, !1, !0);
            null == t && (t = ''), i.add(this.options.textNodeName, t);
          }
          r = e + 2;
        } else {
          let a = VC(t, r, this.options.removeNSPrefix),
            o = a.tagName,
            l = a.tagExp,
            h = a.attrExpPresent,
            c = a.closeIndex;
          this.options.transformTagName && (o = this.options.transformTagName(o)),
            i && n && '!xml' !== i.tagname && (n = this.saveTextToParentTag(n, i, s, !1));
          const d = i;
          if (
            (d &&
              -1 !== this.options.unpairedTags.indexOf(d.tagname) &&
              ((i = this.tagsNodeStack.pop()), (s = s.substring(0, s.lastIndexOf('.')))),
            o !== e.tagname && (s += s ? '.' + o : o),
            this.isItStopNode(this.options.stopNodes, s, o))
          ) {
            let e = '';
            if (l.length > 0 && l.lastIndexOf('/') === l.length - 1) r = a.closeIndex;
            else if (-1 !== this.options.unpairedTags.indexOf(o)) r = a.closeIndex;
            else {
              const i = this.readStopNodeData(t, o, c + 1);
              if (!i) throw new Error(`Unexpected end of ${o}`);
              (r = i.i), (e = i.tagContent);
            }
            const n = new CC(o);
            o !== l && h && (n[':@'] = this.buildAttributesMap(l, s, o)),
              e && (e = this.parseTextData(e, o, s, !0, h, !0, !0)),
              (s = s.substr(0, s.lastIndexOf('.'))),
              n.add(this.options.textNodeName, e),
              this.addChild(i, n, s);
          } else {
            if (l.length > 0 && l.lastIndexOf('/') === l.length - 1) {
              '/' === o[o.length - 1]
                ? ((o = o.substr(0, o.length - 1)), (s = s.substr(0, s.length - 1)), (l = o))
                : (l = l.substr(0, l.length - 1)),
                this.options.transformTagName && (o = this.options.transformTagName(o));
              const t = new CC(o);
              o !== l && h && (t[':@'] = this.buildAttributesMap(l, s, o)),
                this.addChild(i, t, s),
                (s = s.substr(0, s.lastIndexOf('.')));
            } else {
              const t = new CC(o);
              this.tagsNodeStack.push(i),
                o !== l && h && (t[':@'] = this.buildAttributesMap(l, s, o)),
                this.addChild(i, t, s),
                (i = t);
            }
            (n = ''), (r = c);
          }
        }
      else n += t[r];
    }
    return e.child;
  };
  function FC(t, e, i) {
    const n = this.options.updateTag(e.tagname, i, e[':@']);
    !1 === n || ('string' == typeof n ? ((e.tagname = n), t.addChild(e)) : t.addChild(e));
  }
  const jC = function (t) {
    if (this.options.processEntities) {
      for (let e in this.docTypeEntities) {
        const i = this.docTypeEntities[e];
        t = t.replace(i.regx, i.val);
      }
      for (let e in this.lastEntities) {
        const i = this.lastEntities[e];
        t = t.replace(i.regex, i.val);
      }
      if (this.options.htmlEntities)
        for (let e in this.htmlEntities) {
          const i = this.htmlEntities[e];
          t = t.replace(i.regex, i.val);
        }
      t = t.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return t;
  };
  function zC(t, e, i, n) {
    return (
      t &&
        (void 0 === n && (n = 0 === Object.keys(e.child).length),
        void 0 !== (t = this.parseTextData(t, e.tagname, i, !1, !!e[':@'] && 0 !== Object.keys(e[':@']).length, n)) &&
          '' !== t &&
          e.add(this.options.textNodeName, t),
        (t = '')),
      t
    );
  }
  function HC(t, e, i) {
    const n = '*.' + i;
    for (const i in t) {
      const s = t[i];
      if (n === s || e === s) return !0;
    }
    return !1;
  }
  function NC(t, e, i, n) {
    const s = t.indexOf(e, i);
    if (-1 === s) throw new Error(n);
    return s + e.length - 1;
  }
  function VC(t, e, i) {
    const n = (function (t, e) {
      let i,
        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : '>',
        s = '';
      for (let r = e; r < t.length; r++) {
        let e = t[r];
        if (i) e === i && (i = '');
        else if ('"' === e || "'" === e) i = e;
        else if (e === n[0]) {
          if (!n[1]) return { data: s, index: r };
          if (t[r + 1] === n[1]) return { data: s, index: r };
        } else '\t' === e && (e = ' ');
        s += e;
      }
    })(t, e + 1, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : '>');
    if (!n) return;
    let s = n.data;
    const r = n.index,
      a = s.search(/\s/);
    let o = s,
      l = !0;
    if ((-1 !== a && ((o = s.substr(0, a).replace(/\s\s*$/, '')), (s = s.substr(a + 1))), i)) {
      const t = o.indexOf(':');
      -1 !== t && ((o = o.substr(t + 1)), (l = o !== n.data.substr(t + 1)));
    }
    return { tagName: o, tagExp: s, closeIndex: r, attrExpPresent: l };
  }
  function WC(t, e, i) {
    const n = i;
    let s = 1;
    for (; i < t.length; i++)
      if ('<' === t[i])
        if ('/' === t[i + 1]) {
          const r = NC(t, '>', i, `${e} is not closed`);
          if (t.substring(i + 2, r).trim() === e && (s--, 0 === s)) return { tagContent: t.substring(n, i), i: r };
          i = r;
        } else if ('?' === t[i + 1]) {
          i = NC(t, '?>', i + 1, 'StopNode is not closed.');
        } else if ('!--' === t.substr(i + 1, 3)) {
          i = NC(t, '--\x3e', i + 3, 'StopNode is not closed.');
        } else if ('![' === t.substr(i + 1, 2)) {
          i = NC(t, ']]>', i, 'StopNode is not closed.') - 2;
        } else {
          const n = VC(t, i, '>');
          if (n) {
            (n && n.tagName) === e && '/' !== n.tagExp[n.tagExp.length - 1] && s++, (i = n.closeIndex);
          }
        }
  }
  function GC(t, e, i) {
    if (e && 'string' == typeof t) {
      const e = t.trim();
      return 'true' === e || ('false' !== e && PC(t, i));
    }
    return TC.isExist(t) ? t : '';
  }
  var UC = class {
      constructor(t) {
        (this.options = t),
          (this.currentNode = null),
          (this.tagsNodeStack = []),
          (this.docTypeEntities = {}),
          (this.lastEntities = {
            apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
            gt: { regex: /&(gt|#62|#x3E);/g, val: '>' },
            lt: { regex: /&(lt|#60|#x3C);/g, val: '<' },
            quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
          }),
          (this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: '&' }),
          (this.htmlEntities = {
            space: { regex: /&(nbsp|#160);/g, val: ' ' },
            cent: { regex: /&(cent|#162);/g, val: '¢' },
            pound: { regex: /&(pound|#163);/g, val: '£' },
            yen: { regex: /&(yen|#165);/g, val: '¥' },
            euro: { regex: /&(euro|#8364);/g, val: '€' },
            copyright: { regex: /&(copy|#169);/g, val: '©' },
            reg: { regex: /&(reg|#174);/g, val: '®' },
            inr: { regex: /&(inr|#8377);/g, val: '₹' }
          }),
          (this.addExternalEntities = RC),
          (this.parseXml = LC),
          (this.parseTextData = OC),
          (this.resolveNameSpace = BC),
          (this.buildAttributesMap = DC),
          (this.isItStopNode = HC),
          (this.replaceEntitiesValue = jC),
          (this.readStopNodeData = WC),
          (this.saveTextToParentTag = zC),
          (this.addChild = FC);
      }
    },
    YC = {};
  function $C(t, e, i) {
    let n;
    const s = {};
    for (let r = 0; r < t.length; r++) {
      const a = t[r],
        o = XC(a);
      let l = '';
      if (((l = void 0 === i ? o : i + '.' + o), o === e.textNodeName)) void 0 === n ? (n = a[o]) : (n += '' + a[o]);
      else {
        if (void 0 === o) continue;
        if (a[o]) {
          let t = $C(a[o], e, l);
          const i = qC(t, e);
          a[':@']
            ? KC(t, a[':@'], l, e)
            : 1 !== Object.keys(t).length || void 0 === t[e.textNodeName] || e.alwaysCreateTextNode
            ? 0 === Object.keys(t).length && (e.alwaysCreateTextNode ? (t[e.textNodeName] = '') : (t = ''))
            : (t = t[e.textNodeName]),
            void 0 !== s[o] && s.hasOwnProperty(o)
              ? (Array.isArray(s[o]) || (s[o] = [s[o]]), s[o].push(t))
              : e.isArray(o, l, i)
              ? (s[o] = [t])
              : (s[o] = t);
        }
      }
    }
    return 'string' == typeof n ? n.length > 0 && (s[e.textNodeName] = n) : void 0 !== n && (s[e.textNodeName] = n), s;
  }
  function XC(t) {
    const e = Object.keys(t);
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      if (':@' !== i) return i;
    }
  }
  function KC(t, e, i, n) {
    if (e) {
      const s = Object.keys(e),
        r = s.length;
      for (let a = 0; a < r; a++) {
        const r = s[a];
        n.isArray(r, i + '.' + r, !0, !0) ? (t[r] = [e[r]]) : (t[r] = e[r]);
      }
    }
  }
  function qC(t, e) {
    const { textNodeName: i } = e,
      n = Object.keys(t).length;
    return 0 === n || !(1 !== n || (!t[i] && 'boolean' != typeof t[i] && 0 !== t[i]));
  }
  YC.prettify = function (t, e) {
    return $C(t, e);
  };
  const { buildOptions: ZC } = dC,
    JC = UC,
    { prettify: QC } = YC,
    tE = XT;
  var eE = class {
    constructor(t) {
      (this.externalEntities = {}), (this.options = ZC(t));
    }
    parse(t, e) {
      if ('string' == typeof t);
      else {
        if (!t.toString) throw new Error('XML data is accepted in String or Bytes[] form.');
        t = t.toString();
      }
      if (e) {
        !0 === e && (e = {});
        const i = tE.validate(t, e);
        if (!0 !== i) throw Error(`${i.err.msg}:${i.err.line}:${i.err.col}`);
      }
      const i = new JC(this.options);
      i.addExternalEntities(this.externalEntities);
      const n = i.parseXml(t);
      return this.options.preserveOrder || void 0 === n ? n : QC(n, this.options);
    }
    addEntity(t, e) {
      if (-1 !== e.indexOf('&')) throw new Error("Entity value can't have '&'");
      if (-1 !== t.indexOf('&') || -1 !== t.indexOf(';'))
        throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      if ('&' === e) throw new Error("An entity with value '&' is not permitted");
      this.externalEntities[t] = e;
    }
  };
  function iE(t, e, i, n) {
    let s = '',
      r = !1;
    for (let a = 0; a < t.length; a++) {
      const o = t[a],
        l = nE(o);
      let h = '';
      if (((h = 0 === i.length ? l : `${i}.${l}`), l === e.textNodeName)) {
        let t = o[l];
        rE(h, e) || ((t = e.tagValueProcessor(l, t)), (t = aE(t, e))), r && (s += n), (s += t), (r = !1);
        continue;
      }
      if (l === e.cdataPropName) {
        r && (s += n), (s += `<![CDATA[${o[l][0][e.textNodeName]}]]>`), (r = !1);
        continue;
      }
      if (l === e.commentPropName) {
        (s += n + `\x3c!--${o[l][0][e.textNodeName]}--\x3e`), (r = !0);
        continue;
      }
      if ('?' === l[0]) {
        const t = sE(o[':@'], e),
          i = '?xml' === l ? '' : n;
        let a = o[l][0][e.textNodeName];
        (a = 0 !== a.length ? ' ' + a : ''), (s += i + `<${l}${a}${t}?>`), (r = !0);
        continue;
      }
      let c = n;
      '' !== c && (c += e.indentBy);
      const d = n + `<${l}${sE(o[':@'], e)}`,
        u = iE(o[l], e, h, c);
      -1 !== e.unpairedTags.indexOf(l)
        ? e.suppressUnpairedNode
          ? (s += d + '>')
          : (s += d + '/>')
        : (u && 0 !== u.length) || !e.suppressEmptyNode
        ? u && u.endsWith('>')
          ? (s += d + `>${u}${n}</${l}>`)
          : ((s += d + '>'),
            u && '' !== n && (u.includes('/>') || u.includes('</')) ? (s += n + e.indentBy + u + n) : (s += u),
            (s += `</${l}>`))
        : (s += d + '/>'),
        (r = !0);
    }
    return s;
  }
  function nE(t) {
    const e = Object.keys(t);
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      if (':@' !== i) return i;
    }
  }
  function sE(t, e) {
    let i = '';
    if (t && !e.ignoreAttributes)
      for (let n in t) {
        let s = e.attributeValueProcessor(n, t[n]);
        (s = aE(s, e)),
          !0 === s && e.suppressBooleanAttributes
            ? (i += ` ${n.substr(e.attributeNamePrefix.length)}`)
            : (i += ` ${n.substr(e.attributeNamePrefix.length)}="${s}"`);
      }
    return i;
  }
  function rE(t, e) {
    let i = (t = t.substr(0, t.length - e.textNodeName.length - 1)).substr(t.lastIndexOf('.') + 1);
    for (let n in e.stopNodes) if (e.stopNodes[n] === t || e.stopNodes[n] === '*.' + i) return !0;
    return !1;
  }
  function aE(t, e) {
    if (t && t.length > 0 && e.processEntities)
      for (let i = 0; i < e.entities.length; i++) {
        const n = e.entities[i];
        t = t.replace(n.regex, n.val);
      }
    return t;
  }
  const oE = function (t, e) {
      let i = '';
      return e.format && e.indentBy.length > 0 && (i = '\n'), iE(t, e, '', i);
    },
    lE = {
      attributeNamePrefix: '@_',
      attributesGroupName: !1,
      textNodeName: '#text',
      ignoreAttributes: !0,
      cdataPropName: !1,
      format: !1,
      indentBy: '  ',
      suppressEmptyNode: !1,
      suppressUnpairedNode: !0,
      suppressBooleanAttributes: !0,
      tagValueProcessor: function (t, e) {
        return e;
      },
      attributeValueProcessor: function (t, e) {
        return e;
      },
      preserveOrder: !1,
      commentPropName: !1,
      unpairedTags: [],
      entities: [
        { regex: new RegExp('&', 'g'), val: '&amp;' },
        { regex: new RegExp('>', 'g'), val: '&gt;' },
        { regex: new RegExp('<', 'g'), val: '&lt;' },
        { regex: new RegExp("'", 'g'), val: '&apos;' },
        { regex: new RegExp('"', 'g'), val: '&quot;' }
      ],
      processEntities: !0,
      stopNodes: [],
      oneListGroup: !1
    };
  function hE(t) {
    (this.options = Object.assign({}, lE, t)),
      this.options.ignoreAttributes || this.options.attributesGroupName
        ? (this.isAttribute = function () {
            return !1;
          })
        : ((this.attrPrefixLen = this.options.attributeNamePrefix.length), (this.isAttribute = uE)),
      (this.processTextOrObjNode = cE),
      this.options.format
        ? ((this.indentate = dE), (this.tagEndChar = '>\n'), (this.newLine = '\n'))
        : ((this.indentate = function () {
            return '';
          }),
          (this.tagEndChar = '>'),
          (this.newLine = ''));
  }
  function cE(t, e, i) {
    const n = this.j2x(t, i + 1);
    return void 0 !== t[this.options.textNodeName] && 1 === Object.keys(t).length
      ? this.buildTextValNode(t[this.options.textNodeName], e, n.attrStr, i)
      : this.buildObjectNode(n.val, e, n.attrStr, i);
  }
  function dE(t) {
    return this.options.indentBy.repeat(t);
  }
  function uE(t) {
    return (
      !(!t.startsWith(this.options.attributeNamePrefix) || t === this.options.textNodeName) &&
      t.substr(this.attrPrefixLen)
    );
  }
  (hE.prototype.build = function (t) {
    return this.options.preserveOrder
      ? oE(t, this.options)
      : (Array.isArray(t) &&
          this.options.arrayNodeName &&
          this.options.arrayNodeName.length > 1 &&
          (t = { [this.options.arrayNodeName]: t }),
        this.j2x(t, 0).val);
  }),
    (hE.prototype.j2x = function (t, e) {
      let i = '',
        n = '';
      for (let s in t)
        if (void 0 === t[s]) this.isAttribute(s) && (n += '');
        else if (null === t[s])
          this.isAttribute(s)
            ? (n += '')
            : '?' === s[0]
            ? (n += this.indentate(e) + '<' + s + '?' + this.tagEndChar)
            : (n += this.indentate(e) + '<' + s + '/' + this.tagEndChar);
        else if (t[s] instanceof Date) n += this.buildTextValNode(t[s], s, '', e);
        else if ('object' != typeof t[s]) {
          const r = this.isAttribute(s);
          if (r) i += this.buildAttrPairStr(r, '' + t[s]);
          else if (s === this.options.textNodeName) {
            let e = this.options.tagValueProcessor(s, '' + t[s]);
            n += this.replaceEntitiesValue(e);
          } else n += this.buildTextValNode(t[s], s, '', e);
        } else if (Array.isArray(t[s])) {
          const i = t[s].length;
          let r = '';
          for (let a = 0; a < i; a++) {
            const i = t[s][a];
            void 0 === i ||
              (null === i
                ? '?' === s[0]
                  ? (n += this.indentate(e) + '<' + s + '?' + this.tagEndChar)
                  : (n += this.indentate(e) + '<' + s + '/' + this.tagEndChar)
                : 'object' == typeof i
                ? this.options.oneListGroup
                  ? (r += this.j2x(i, e + 1).val)
                  : (r += this.processTextOrObjNode(i, s, e))
                : (r += this.buildTextValNode(i, s, '', e)));
          }
          this.options.oneListGroup && (r = this.buildObjectNode(r, s, '', e)), (n += r);
        } else if (this.options.attributesGroupName && s === this.options.attributesGroupName) {
          const e = Object.keys(t[s]),
            n = e.length;
          for (let r = 0; r < n; r++) i += this.buildAttrPairStr(e[r], '' + t[s][e[r]]);
        } else n += this.processTextOrObjNode(t[s], s, e);
      return { attrStr: i, val: n };
    }),
    (hE.prototype.buildAttrPairStr = function (t, e) {
      return (
        (e = this.options.attributeValueProcessor(t, '' + e)),
        (e = this.replaceEntitiesValue(e)),
        this.options.suppressBooleanAttributes && 'true' === e ? ' ' + t : ' ' + t + '="' + e + '"'
      );
    }),
    (hE.prototype.buildObjectNode = function (t, e, i, n) {
      if ('' === t)
        return '?' === e[0]
          ? this.indentate(n) + '<' + e + i + '?' + this.tagEndChar
          : this.indentate(n) + '<' + e + i + this.closeTag(e) + this.tagEndChar;
      {
        let s = '</' + e + this.tagEndChar,
          r = '';
        return (
          '?' === e[0] && ((r = '?'), (s = '')),
          (!i && '' !== i) || -1 !== t.indexOf('<')
            ? !1 !== this.options.commentPropName && e === this.options.commentPropName && 0 === r.length
              ? this.indentate(n) + `\x3c!--${t}--\x3e` + this.newLine
              : this.indentate(n) + '<' + e + i + r + this.tagEndChar + t + this.indentate(n) + s
            : this.indentate(n) + '<' + e + i + r + '>' + t + s
        );
      }
    }),
    (hE.prototype.closeTag = function (t) {
      let e = '';
      return (
        -1 !== this.options.unpairedTags.indexOf(t)
          ? this.options.suppressUnpairedNode || (e = '/')
          : (e = this.options.suppressEmptyNode ? '/' : `></${t}`),
        e
      );
    }),
    (hE.prototype.buildTextValNode = function (t, e, i, n) {
      if (!1 !== this.options.cdataPropName && e === this.options.cdataPropName)
        return this.indentate(n) + `<![CDATA[${t}]]>` + this.newLine;
      if (!1 !== this.options.commentPropName && e === this.options.commentPropName)
        return this.indentate(n) + `\x3c!--${t}--\x3e` + this.newLine;
      if ('?' === e[0]) return this.indentate(n) + '<' + e + i + '?' + this.tagEndChar;
      {
        let s = this.options.tagValueProcessor(e, t);
        return (
          (s = this.replaceEntitiesValue(s)),
          '' === s
            ? this.indentate(n) + '<' + e + i + this.closeTag(e) + this.tagEndChar
            : this.indentate(n) + '<' + e + i + '>' + s + '</' + e + this.tagEndChar
        );
      }
    }),
    (hE.prototype.replaceEntitiesValue = function (t) {
      if (t && t.length > 0 && this.options.processEntities)
        for (let e = 0; e < this.options.entities.length; e++) {
          const i = this.options.entities[e];
          t = t.replace(i.regex, i.val);
        }
      return t;
    });
  var pE = { XMLParser: eE, XMLValidator: XT, XMLBuilder: hE },
    gE = function (t, e, i, n) {
      return new (i || (i = Promise))(function (s, r) {
        function a(t) {
          try {
            l(n.next(t));
          } catch (t) {
            r(t);
          }
        }
        function o(t) {
          try {
            l(n.throw(t));
          } catch (t) {
            r(t);
          }
        }
        function l(t) {
          var e;
          t.done
            ? s(t.value)
            : ((e = t.value),
              e instanceof i
                ? e
                : new i(function (t) {
                    t(e);
                  })).then(a, o);
        }
        l((n = n.apply(t, e || [])).next());
      });
    };
  function fE(t, e, i) {
    let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    return (
      t.expand(
        e +
          (n / 2 +
            (i
              ? (function (t, e) {
                  return t ? e : 0;
                })(i, e)
              : 0))
      ),
      t
    );
  }
  let vE = 0;
  function mE() {
    return vE++;
  }
  var yE;
  function _E(t) {
    const e = [];
    let i = 0,
      n = '';
    for (let s = 0; s < t.length; s++)
      SE(t[s])
        ? i
          ? (n += t[s])
          : ((i = 1), (n = t[s]))
        : (i && (e.push({ text: n, direction: yE.VERTICAL }), (n = ''), (i = 0)),
          e.push({ text: t[s], direction: yE.HORIZONTAL }));
    return n && e.push({ text: n, direction: yE.VERTICAL }), e;
  }
  !(function (t) {
    (t[(t.HORIZONTAL = 0)] = 'HORIZONTAL'), (t[(t.VERTICAL = 1)] = 'VERTICAL');
  })(yE || (yE = {}));
  const bE = new Map();
  ['…', '（', '）', '—', '【', '】', '「', '」', '《', '》'].forEach(t => bE.set(t, !0));
  const xE = new Map();
  function SE(t) {
    if (bE.has(t)) return !0;
    if (xE.has(t)) return !1;
    let e = !1;
    return t.codePointAt(0) < 256 && (e = !0), e;
  }
  [''].forEach(t => xE.set(t, !0));
  const wE = mE(),
    AE = mE(),
    kE = mE(),
    ME = mE(),
    TE = mE(),
    CE = mE(),
    EE = mE(),
    PE = mE(),
    RE = mE(),
    OE = mE(),
    BE = mE(),
    IE = mE(),
    DE = mE(),
    LE = mE(),
    FE = mE(),
    jE = mE(),
    zE = Symbol.for('GraphicService'),
    HE = Symbol.for('GraphicCreator'),
    NE = {
      '@_stroke-linecap': 'lineCap',
      '@_stroke-linejoin': 'lineJoin',
      '@_stroke-dasharray': 'lineDash',
      '@_stroke-dashoffset': 'lineDashOffset',
      '@_stroke-width': 'lineWidth',
      '@_fill-opacity': 'fillOpacity',
      '@_stroke-opacity': 'strokeOpacity',
      '@_stroke': 'stroke',
      '@_fill': 'fill'
    },
    VE = Object.keys(NE);
  var WE;
  !(function (t) {
    (t[(t.LESS_GROUP = 0)] = 'LESS_GROUP'), (t[(t.MORE_GROUP = 1)] = 'MORE_GROUP');
  })(WE || (WE = {}));
  let GE = class t extends $T {
    constructor(t) {
      super(t),
        (this.type = 'group'),
        (this.parent = null),
        (this.isContainer = !0),
        (this.numberType = CE),
        (this._childUpdateTag = Cw.UPDATE_BOUNDS);
    }
    setMode(t) {
      '3d' === t ? this.set3dMode() : this.set2dMode();
    }
    set3dMode() {
      this.in3dMode = !0;
    }
    set2dMode() {
      this.in3dMode = !1;
    }
    setTheme(t) {
      return this.theme || (this.theme = new Kk()), this.theme.setTheme(t, this);
    }
    createTheme() {
      this.theme || (this.theme = new Kk());
    }
    hideAll() {
      this.setAttribute('visible', !1),
        this.forEachChildren(t => {
          t.isContainer && t.hideAll ? t.hideAll() : t.setAttribute('visible', !1);
        });
    }
    showAll() {
      this.setAttribute('visible', !0),
        this.forEachChildren(t => {
          t.isContainer && t.showAll ? t.showAll() : t.setAttribute('visible', !0);
        });
    }
    containsPoint(t, e, i) {
      if (i === Ew.GLOBAL) {
        const i = new Ut(t, e);
        return this.parent && this.parent.globalTransMatrix.transformPoint(i, i), this.AABBBounds.contains(i.x, i.y);
      }
      return this.AABBBounds.contains(t, e);
    }
    shouldUpdateAABBBounds() {
      return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & Cw.UPDATE_BOUNDS);
    }
    tryUpdateAABBBounds() {
      if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
      WA.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
      const t = this.shouldSelfChangeUpdateAABBBounds(),
        e = this.doUpdateAABBBounds();
      return (
        this.addUpdateLayoutTag(),
        WA.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, t),
        e
      );
    }
    doUpdateAABBBounds() {
      const t = this.attribute,
        e = Zk(this).group;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const i = WA.graphicService.updateGroupAABBBounds(t, Zk(this).group, this._AABBBounds, this),
        { boundsPadding: n = e.boundsPadding } = t,
        s = DM(n);
      return (
        s && i.expand(s),
        this.parent && this.parent.addChildUpdateBoundTag(),
        this.clearUpdateBoundTag(),
        this._emitCustomEvent('AAABBBoundsChange'),
        i
      );
    }
    clearUpdateBoundTag() {
      (this._updateTag &= Cw.CLEAR_BOUNDS), (this._childUpdateTag &= Cw.CLEAR_BOUNDS);
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    addUpdateBoundTag() {
      (this._updateTag |= Cw.UPDATE_BOUNDS), this.parent && this.parent.addChildUpdateBoundTag();
    }
    addChildUpdateBoundTag() {
      this._childUpdateTag & Cw.UPDATE_BOUNDS ||
        ((this._childUpdateTag |= Cw.UPDATE_BOUNDS), this.parent && this.parent.addChildUpdateBoundTag());
    }
    getTheme() {
      return this.theme.getTheme(this);
    }
    incrementalAppendChild(t) {
      const e = super.appendChild(t);
      return (
        this.stage && e && ((e.stage = this.stage), (e.layer = this.layer)),
        this.addUpdateBoundTag(),
        WA.graphicService.onAddIncremental(t, this, this.stage),
        e
      );
    }
    incrementalClearChild() {
      super.removeAllChild(), this.addUpdateBoundTag(), WA.graphicService.onClearIncremental(this, this.stage);
    }
    appendChild(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      const i = super.appendChild(t);
      return e && this.stage && i && i.setStage(this.stage, this.layer), this.addUpdateBoundTag(), i;
    }
    insertBefore(t, e) {
      const i = super.insertBefore(t, e);
      return this.stage && i && i.setStage(this.stage, this.layer), this.addUpdateBoundTag(), i;
    }
    insertAfter(t, e) {
      const i = super.insertAfter(t, e);
      return this.stage && i && i.setStage(this.stage, this.layer), this.addUpdateBoundTag(), i;
    }
    insertInto(t, e) {
      const i = super.insertInto(t, e);
      return this.stage && i && i.setStage(this.stage, this.layer), this.addUpdateBoundTag(), i;
    }
    removeChild(t) {
      const e = super.removeChild(t);
      return (t.stage = null), WA.graphicService.onRemove(t), this.addUpdateBoundTag(), e;
    }
    removeAllChild() {
      this.forEachChildren(t => {
        WA.graphicService.onRemove(t);
      }),
        super.removeAllChild(),
        this.addUpdateBoundTag();
    }
    setStage(t, e) {
      this.stage !== t &&
        ((this.stage = t),
        (this.layer = e),
        this.setStageToShadowRoot(t, e),
        this._onSetStage && this._onSetStage(this, t, e),
        WA.graphicService.onSetStage(this, t),
        this.forEachChildren(e => {
          e.setStage(t, this.layer);
        }));
    }
    addUpdatePositionTag() {
      super.addUpdatePositionTag(),
        this.forEachChildren(t => {
          t.isContainer && t.addUpdateGlobalPositionTag();
        });
    }
    addUpdateGlobalPositionTag() {
      super.addUpdateGlobalPositionTag(),
        this.forEachChildren(t => {
          t.isContainer && t.addUpdateGlobalPositionTag();
        });
    }
    tryUpdateGlobalTransMatrix() {
      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      if (this.shouldUpdateGlobalMatrix()) {
        if (this._globalTransMatrix) {
          if (this.parent) {
            const t = this.parent.globalTransMatrix;
            this._globalTransMatrix.setValue(t.a, t.b, t.c, t.d, t.e, t.f);
          }
        } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
        this.doUpdateGlobalMatrix(), t && this.clearUpdateGlobalPositionTag();
      }
      return this._globalTransMatrix;
    }
    shouldUpdateGlobalMatrix() {
      return !!(this._updateTag & Cw.UPDATE_GLOBAL_MATRIX);
    }
    _getChildByName(t, e) {
      return this.find(e => e.name === t, e);
    }
    createOrUpdateChild(t, e, i) {
      let n = this._getChildByName(t);
      return n ? n.setAttributes(e) : ((n = WA.graphicService.creator[i](e)), (n.name = t), this.add(n)), n;
    }
    clone() {
      return new t(Object.assign({}, this.attribute));
    }
  };
  const UE = Symbol.for('LayerHandlerContribution');
  class YE extends GE {
    get offscreen() {
      return this.layerHandler.offscreen;
    }
    get width() {
      return this.stage ? this.stage.width : 0;
    }
    get height() {
      return this.stage ? this.stage.height : 0;
    }
    get viewWidth() {
      return this.stage ? this.stage.viewWidth : 0;
    }
    get viewHeight() {
      return this.stage ? this.stage.viewHeight : 0;
    }
    get dirtyBound() {
      throw new Error('暂不支持');
    }
    get dpr() {
      return this._dpr;
    }
    constructor(t, e, i, n) {
      var s;
      super({}),
        (this.stage = t),
        (this.global = e),
        (this.window = i),
        (this.main = n.main),
        (this.layerHandler = sk.get(UE)),
        this.layerHandler.init(this, i, {
          main: n.main,
          canvasId: n.canvasId,
          width: this.viewWidth,
          height: this.viewHeight,
          zIndex: null !== (s = n.zIndex) && void 0 !== s ? s : 0
        }),
        (this.layer = this),
        (this.subLayers = new Map()),
        (this.theme = new Kk()),
        (this.background = 'rgba(0, 0, 0, 0)'),
        (this.virtual = !!n.virtual),
        (this.afterDrawCbs = []);
    }
    combineSubLayer() {
      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      const e = Array.from(this.subLayers.values()).sort((t, e) => t.zIndex - e.zIndex);
      this.layerHandler.merge(
        e.map(e => (e.layer.subLayers.size && e.layer.combineSubLayer(t), e.layer.getNativeHandler()))
      ),
        t &&
          e.forEach(t => {
            t.group && (t.group.incremental = 0);
          }),
        e.forEach(t => {
          WA.layerService.releaseLayer(this.stage, t.layer);
        }),
        this.subLayers.clear();
    }
    getNativeHandler() {
      return this.layerHandler;
    }
    setStage(t, e) {
      super.setStage(t, this);
    }
    pick(t, e) {
      throw new Error('暂不支持');
    }
    render(t, e) {
      var i;
      const n = this.stage;
      this.layerHandler.render(
        [this],
        {
          renderService: t.renderService,
          x: n.x,
          y: n.y,
          width: this.viewWidth,
          height: this.viewHeight,
          stage: this.stage,
          layer: this,
          background: null !== (i = t.background) && void 0 !== i ? i : this.background,
          updateBounds: t.updateBounds
        },
        e
      ),
        this.afterDrawCbs.forEach(t => t(this));
    }
    resize(t, e) {
      this.layerHandler.resize(t, e);
    }
    resizeView(t, e) {
      this.layerHandler.resizeView(t, e);
    }
    setDpr(t) {
      this.layerHandler.setDpr(t);
    }
    afterDraw(t) {
      this.afterDrawCbs.push(t);
    }
    startAnimate(t) {
      throw new Error('暂不支持');
    }
    setToFrame(t) {
      throw new Error('暂不支持');
    }
    prepare(t, e) {}
    combineTo(t, e) {
      var i, n, s;
      this.offscreen &&
        (this.layerHandler.drawTo(
          t,
          [this],
          Object.assign(
            {
              background: null !== (i = e.background) && void 0 !== i ? i : this.background,
              renderService: e.renderService,
              x: null !== (n = e.x) && void 0 !== n ? n : this.stage.x,
              y: null !== (s = e.y) && void 0 !== s ? s : this.stage.y,
              width: this.viewWidth,
              height: this.viewHeight,
              stage: this.stage,
              layer: this
            },
            e
          )
        ),
        this.afterDrawCbs.forEach(t => t(this)));
    }
    release() {
      super.release(),
        this.layerHandler.release(),
        this.subLayers &&
          this.subLayers.forEach(t => {
            WA.layerService.releaseLayer(this.stage, t.layer);
          });
    }
    drawTo(t, e) {
      var i, n, s;
      this.layerHandler.drawTo(
        t,
        [this],
        Object.assign(
          {
            background: null !== (i = e.background) && void 0 !== i ? i : this.background,
            renderService: e.renderService,
            x: null !== (n = e.x) && void 0 !== n ? n : this.stage.x,
            y: null !== (s = e.y) && void 0 !== s ? s : this.stage.y,
            width: this.viewWidth,
            height: this.viewHeight,
            stage: this.stage,
            layer: this
          },
          e
        )
      ),
        this.afterDrawCbs.forEach(t => t(this));
    }
  }
  var $E = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    XE = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    KE = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let qE = class {
    constructor(t) {
      (this.global = t), (this.layerMap = new Map());
    }
    tryInit() {
      this.inited ||
        ((this.staticLayerCountInEnv = this.global.getStaticCanvasCount()),
        (this.dynamicLayerCountInEnv = this.global.getDynamicCanvasCount()),
        (this.inited = !0));
    }
    getStageLayer(t) {
      return this.layerMap.get(t);
    }
    createLayer(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { main: !1 };
      this.tryInit();
      const i = new YE(
          t,
          this.global,
          t.window,
          Object.assign(Object.assign({}, e), { virtual: 0 === this.staticLayerCountInEnv })
        ),
        n = this.layerMap.get(t) || [];
      return n.push(i), this.layerMap.set(t, n), this.staticLayerCountInEnv--, i;
    }
    releaseLayer(t, e) {
      e.release();
      const i = this.layerMap.get(t) || [];
      this.layerMap.set(
        t,
        i.filter(t => t !== e)
      );
    }
    layerCount(t) {
      return (this.layerMap.get(t) || []).length;
    }
    restLayerCount(t) {
      return 'browser' === this.global.env ? 10 : 0;
    }
  };
  qE = $E([ZS(), KE(0, tw(dw)), XE('design:paramtypes', [Object])], qE);
  var ZE = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    JE = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    QE = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  const tP = Symbol.for('VWindow'),
    eP = Symbol.for('WindowHandlerContribution');
  let iP = class {
    get width() {
      if (this._handler) {
        const t = this._handler.getWH();
        return (this._width = t.width);
      }
      return this._width;
    }
    get height() {
      if (this._handler) {
        const t = this._handler.getWH();
        return (this._height = t.height);
      }
      return this._height;
    }
    get dpr() {
      return this._handler.getDpr();
    }
    constructor(t) {
      (this.global = t),
        (this.hooks = { onChange: new hw(['x', 'y', 'width', 'height']) }),
        (this._uid = Jk.GenAutoIncrementId());
    }
    postInit() {
      this.global.hooks.onSetEnv.tap('window', () => {
        this.active();
      }),
        this.active();
    }
    active() {
      const t = this.global;
      t.env && !this.actived && (sk.getNamed(eP, t.env).configure(this, t), (this.actived = !0), this._handler);
    }
    get style() {
      return this._handler.getStyle();
    }
    set style(t) {
      this._handler.setStyle(t);
    }
    create(t) {
      this._handler.createWindow(t);
      const e = this._handler.getWH();
      (this._width = e.width),
        (this._height = e.height),
        (this.title = this._handler.getTitle()),
        (this.resizable = !0);
    }
    setWindowHandler(t) {
      this._handler = t;
    }
    setDpr(t) {
      return this._handler.setDpr(t);
    }
    resize(t, e) {
      return this._handler.resizeWindow(t, e);
    }
    configure() {
      throw new Error('暂不支持');
    }
    release() {
      return this._handler.releaseWindow();
    }
    getContext() {
      return this._handler.getContext();
    }
    getNativeHandler() {
      return this._handler.getNativeHandler();
    }
    getImageBuffer(t) {
      return this._handler.getImageBuffer ? this._handler.getImageBuffer(t) : null;
    }
    addEventListener(t, e, i) {
      return this._handler.addEventListener(t, e, i);
    }
    removeEventListener(t, e, i) {
      return this._handler.removeEventListener(t, e, i);
    }
    dispatchEvent(t) {
      return this._handler.dispatchEvent(t);
    }
    getBoundingClientRect() {
      return this._handler.getBoundingClientRect();
    }
    getContainer() {
      return this._handler.container;
    }
    clearViewBox(t, e) {
      this._handler.clearViewBox(t, e);
    }
    isVisible(t) {
      return this._handler.isVisible(t);
    }
    onVisibleChange(t) {
      return this._handler.onVisibleChange(t);
    }
    getTopLeft(t) {
      return this._handler.getTopLeft(t);
    }
  };
  ZE(
    [sw(), JE('design:type', Function), JE('design:paramtypes', []), JE('design:returntype', void 0)],
    iP.prototype,
    'postInit',
    null
  ),
    (iP = ZE([ZS(), QE(0, tw(dw)), JE('design:paramtypes', [Object])], iP));
  const nP = Symbol.for('TransformUtil'),
    sP = Symbol.for('GraphicUtil'),
    rP = Symbol.for('LayerService');
  var aP = new YS(t => {
    t(fw).toSelf().inSingletonScope(),
      t(dw).toService(fw),
      t(iP).to(iP),
      t(tP).toService(iP),
      t(Hk).toSelf().inSingletonScope(),
      t(sP).toService(Hk),
      t(Wk).toSelf().inSingletonScope(),
      t(nP).toService(Wk),
      t(qE).toSelf().inSingletonScope(),
      t(rP).toService(qE);
  });
  function oP(t, e) {
    return !(!t && !e);
  }
  function lP(t, e) {
    let i;
    return (i = f(t) ? t.some(t => t || void 0 === t) : !!t), i && e > 0;
  }
  function hP(t, e, i) {
    return i && t * e > 0;
  }
  function cP(t, e, i, n, s) {
    return s && t * e > 0 && i > 0 && n > 0;
  }
  function dP(t, e) {
    return t * e > 0;
  }
  function uP(t, e, i, n) {
    return t * e > 0 && i > 0 && n > 0;
  }
  function pP(t, e, i, n, s, r, a, o) {
    if (!t.pathProxy) return !1;
    const l = Zk(t, null == r ? void 0 : r.theme)[t.type],
      {
        fill: h = l.fill,
        stroke: c = l.stroke,
        opacity: d = l.opacity,
        fillOpacity: u = l.fillOpacity,
        lineWidth: p = l.lineWidth,
        strokeOpacity: g = l.strokeOpacity,
        visible: f = l.visible
      } = t.attribute,
      v = hP(d, u, h),
      m = dP(d, g),
      y = oP(h),
      _ = lP(c, p);
    if (!f) return !0;
    if (!y && !_) return !0;
    if (!(v || m || a || o)) return !0;
    e.beginPath();
    return (
      Nw(('function' == typeof t.pathProxy ? t.pathProxy(t.attribute) : t.pathProxy).commandList, e, i, n),
      e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
      _ && (o ? o(e, t.attribute, l) : m && (e.setStrokeStyle(t, t.attribute, i, n, l), e.stroke())),
      y && (a ? a(e, t.attribute, l) : v && (e.setCommonStyle(t, t.attribute, i, n, l), e.fill())),
      !0
    );
  }
  function gP(t, e, i, n, s, r, a, o) {
    const l = i - t,
      h = n - e,
      c = a - s,
      d = o - r;
    let u = d * l - c * h;
    return u * u < kt ? [] : ((u = (c * (e - r) - d * (t - s)) / u), [t + u * l, e + u * h]);
  }
  function fP(t, e, i, n, s, r, a) {
    const o = t - i,
      l = e - n,
      h = (a ? r : -r) / Math.sqrt(o * o + l * l),
      c = h * l,
      d = -h * o,
      u = t + c,
      p = e + d,
      g = i + c,
      f = n + d,
      v = (u + g) / 2,
      m = (p + f) / 2,
      y = g - u,
      _ = f - p,
      b = y * y + _ * _,
      x = s - r,
      S = u * f - g * p,
      w = (_ < 0 ? -1 : 1) * Math.sqrt(Math.max(0, x * x * b - S * S));
    let A = (S * _ - y * w) / b,
      k = (-S * y - _ * w) / b;
    const M = (S * _ + y * w) / b,
      T = (-S * y + _ * w) / b,
      C = A - v,
      E = k - m,
      P = M - v,
      R = T - m;
    return (
      C * C + E * E > P * P + R * R && ((A = M), (k = T)),
      { cx: A, cy: k, x01: -c, y01: -d, x11: A * (s / x - 1), y11: k * (s / x - 1) }
    );
  }
  function vP(t, e, i, n, s, r, a) {
    const { startAngle: o, endAngle: l } = t.getParsedAngle(),
      h = Pt(l - o),
      c = l > o;
    let d = !1;
    if (s < r) {
      const t = s;
      (s = r), (r = t);
    }
    if (s <= kt) e.moveTo(i, n);
    else if (h >= Et - kt)
      e.moveTo(i + s * Ot(o), n + s * Dt(o)),
        e.arc(i, n, s, o, l, !c),
        r > kt && (e.moveTo(i + r * Ot(l), n + r * Dt(l)), e.arc(i, n, r, l, o, c));
    else {
      const u = t.getParsedCornerRadius(),
        {
          outerDeltaAngle: p,
          innerDeltaAngle: g,
          outerStartAngle: f,
          outerEndAngle: v,
          innerEndAngle: m,
          innerStartAngle: y
        } = t.getParsePadAngle(o, l),
        _ = u,
        b = u,
        x = u,
        S = u,
        w = Math.max(b, _),
        A = Math.max(x, S);
      let k = w,
        M = A;
      const T = s * Ot(f),
        C = s * Dt(f),
        E = r * Ot(m),
        P = r * Dt(m);
      let R, O, B, I;
      if ((A > kt || w > kt) && ((R = s * Ot(v)), (O = s * Dt(v)), (B = r * Ot(y)), (I = r * Dt(y)), h < Mt)) {
        const t = gP(T, C, B, I, R, O, E, P);
        if (t) {
          const e = T - t[0],
            i = C - t[1],
            n = R - t[0],
            a = O - t[1],
            o = 1 / Dt(jt((e * n + i * a) / (Lt(e * e + i * i) * Lt(n * n + a * a))) / 2),
            l = Lt(t[0] * t[0] + t[1] * t[1]);
          (M = It(A, (r - l) / (o - 1))), (k = It(w, (s - l) / (o + 1)));
        }
      }
      if (p < 0.001) a && (a[3] || a[1]) && e.moveTo(i + T, n + C), (d = !0);
      else if (k > kt) {
        const t = It(_, k),
          r = It(b, k),
          o = fP(B, I, T, C, s, t, Number(c)),
          l = fP(R, O, E, P, s, r, Number(c));
        k < w && t === r
          ? !a || a[0]
            ? (e.moveTo(i + o.cx + o.x01, n + o.cy + o.y01),
              e.arc(i + o.cx, n + o.cy, k, Rt(o.y01, o.x01), Rt(l.y01, l.x01), !c))
            : e.moveTo(i + o.cx + k * Ot(Rt(l.y01, l.x01)), n + o.cy + k * Dt(Rt(l.y01, l.x01)))
          : !a || a[0]
          ? (e.moveTo(i + o.cx + o.x01, n + o.cy + o.y01),
            t > 0 && e.arc(i + o.cx, n + o.cy, t, Rt(o.y01, o.x01), Rt(o.y11, o.x11), !c),
            e.arc(i, n, s, Rt(o.cy + o.y11, o.cx + o.x11), Rt(l.cy + l.y11, l.cx + l.x11), !c),
            r > 0 && e.arc(i + l.cx, n + l.cy, r, Rt(l.y11, l.x11), Rt(l.y01, l.x01), !c))
          : r > 0
          ? e.moveTo(i + l.cx + r * Ot(Rt(l.y01, l.x01)), n + l.cy + r * Dt(Rt(l.y01, l.x01)))
          : e.moveTo(i + R, n + s * Dt(v));
      } else (a && !a[0]) || (e.moveTo(i + T, n + C), e.arc(i, n, s, f, v, !c));
      if (!(r > kt) || g < 0.001) !a || a[1] ? e.lineTo(i + E, n + P) : e.moveTo(i + E, n + P), (d = !0);
      else if (M > kt) {
        const t = It(S, M),
          s = It(x, M),
          o = fP(E, P, R, O, r, -s, Number(c)),
          l = fP(T, C, B, I, r, -t, Number(c));
        if (
          (!a || a[1] ? e.lineTo(i + o.cx + o.x01, n + o.cy + o.y01) : e.moveTo(i + o.cx + o.x01, n + o.cy + o.y01),
          M < A && t === s)
        ) {
          const t = Rt(l.y01, l.x01);
          !a || a[2]
            ? e.arc(i + o.cx, n + o.cy, M, Rt(o.y01, o.x01), t, !c)
            : e.moveTo(i + o.cx + Ot(t), n + o.cy + Dt(t));
        } else
          !a || a[2]
            ? (s > 0 && e.arc(i + o.cx, n + o.cy, s, Rt(o.y01, o.x01), Rt(o.y11, o.x11), !c),
              e.arc(i, n, r, Rt(o.cy + o.y11, o.cx + o.x11), Rt(l.cy + l.y11, l.cx + l.x11), c),
              t > 0 && e.arc(i + l.cx, n + l.cy, t, Rt(l.y11, l.x11), Rt(l.y01, l.x01), !c))
            : t > 0
            ? e.moveTo(i + l.cx + t * Ot(Rt(l.y01, l.x01)), n + l.cy + t * Dt(Rt(l.y01, l.x01)))
            : e.moveTo(i + B, n + I);
      } else
        !a || a[1] ? e.lineTo(i + E, n + P) : e.moveTo(i + E, n + P),
          !a || a[2] ? e.arc(i, n, r, m, y, c) : e.moveTo(i + r * Ot(y), n + r * Dt(y));
    }
    return a ? a[3] && e.lineTo(i + s * Ot(l), n + s * Ot(l)) : e.closePath(), d;
  }
  class mP {
    static GetCanvas() {
      try {
        return mP.canvas || (mP.canvas = WA.global.createCanvas({})), mP.canvas;
      } catch (t) {
        return null;
      }
    }
    static GetCtx() {
      if (!mP.ctx) {
        const t = mP.GetCanvas();
        mP.ctx = t.getContext('2d');
      }
      return mP.ctx;
    }
  }
  class yP {
    constructor() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100;
      const i = mP.GetCanvas(),
        n = mP.GetCtx();
      if (((i.width = e), (i.height = 1), !n)) return;
      if ((n.translate(0, 0), !n)) throw new Error('获取ctx发生错误');
      const s = n.createLinearGradient(0, 0, e, 0);
      t.forEach(t => {
        s.addColorStop(t[0], t[1]);
      }),
        (n.fillStyle = s),
        n.fillRect(0, 0, e, 1),
        (this.rgbaSet = n.getImageData(0, 0, e, 1).data);
    }
    getColor(t) {
      const e = this.rgbaSet.slice(4 * t, 4 * t + 4);
      return `rgba(${e[0]}, ${e[1]}, ${e[2]}, ${e[3] / 255})`;
    }
    static GetOrCreate() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100,
        i = '';
      t.forEach(t => (i += t.join())), (i += e);
      let n = yP.dataMap.get(i);
      return n || ((n = new yP(t, e)), yP.dataMap.set(i, n)), n;
    }
    static SetColorInterpolateInstance(t, e) {
      yP.dataMap.set(t, e);
    }
    static GetColorInterpolateInstance(t) {
      return yP.dataMap.get(t);
    }
  }
  yP.dataMap = new Map();
  class _P {
    static GetSize(t) {
      for (let e = 0; e < _P.ImageSize.length; e++) if (_P.ImageSize[e] >= t) return _P.ImageSize[e];
      return t;
    }
    static Get(t, e, i, n, s, r, a) {
      const o = _P.GenKey(t, e, i, n, s),
        l = _P.cache[o];
      if (!l || 0 === l.length) return null;
      for (let t = 0; t < l.length; t++) if (l[t].width >= r && l[t].height >= a) return l[t].pattern;
      return null;
    }
    static Set(t, e, i, n, s, r, a, o) {
      const l = _P.GenKey(t, e, i, n, s);
      _P.cache[l]
        ? _P.cache[l].push({ width: a, height: o, pattern: r })
        : (_P.cache[l] = [{ width: a, height: o, pattern: r }]);
    }
    static GenKey(t, e, i, n, s) {
      return `${e},${i},${n},${s},${t.join()}`;
    }
  }
  (_P.cache = {}), (_P.ImageSize = [20, 40, 80, 160, 320, 640, 1280, 2560]);
  const bP = Symbol.for('ArcRenderContribution'),
    xP = Symbol.for('AreaRenderContribution'),
    SP = Symbol.for('CircleRenderContribution'),
    wP = Symbol.for('GroupRenderContribution'),
    AP = Symbol.for('ImageRenderContribution'),
    kP = Symbol.for('PathRenderContribution'),
    MP = Symbol.for('PolygonRenderContribution'),
    TP = Symbol.for('RectRenderContribution'),
    CP = Symbol.for('SymbolRenderContribution'),
    EP = Symbol.for('TextRenderContribution'),
    PP = Symbol.for('InteractiveSubRenderContribution');
  var RP = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    OP = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    BP = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let IP = class {
    constructor(t) {
      (this.arcRenderContribitions = t), (this.numberType = wE);
    }
    drawArcTailCapPath(t, e, i, n, s, r, a, o) {
      const l = o - a,
        h = t.getParsedAngle(),
        c = h.startAngle;
      let d = h.endAngle;
      d = o;
      const u = Pt(d - c),
        p = d > c;
      let g = !1;
      if (s < r) {
        const t = s;
        (s = r), (r = t);
      }
      const f = t.getParsedCornerRadius(),
        {
          outerDeltaAngle: v,
          innerDeltaAngle: m,
          outerStartAngle: y,
          outerEndAngle: _,
          innerEndAngle: b,
          innerStartAngle: x
        } = t.getParsePadAngle(c, d),
        S = f,
        w = f,
        A = f,
        k = f,
        M = Math.max(w, S),
        T = Math.max(A, k);
      let C = M,
        E = T;
      const P = s * Ot(y),
        R = s * Dt(y),
        O = r * Ot(b),
        B = r * Dt(b);
      let I, D, L, F;
      if ((T > kt || M > kt) && ((I = s * Ot(_)), (D = s * Dt(_)), (L = r * Ot(x)), (F = r * Dt(x)), u < Mt)) {
        const t = gP(P, R, L, F, I, D, O, B);
        if (t) {
          const e = P - t[0],
            i = R - t[1],
            n = I - t[0],
            a = D - t[1],
            o = 1 / Dt(jt((e * n + i * a) / (Lt(e * e + i * i) * Lt(n * n + a * a))) / 2),
            l = Lt(t[0] * t[0] + t[1] * t[1]);
          (E = It(T, (r - l) / (o - 1))), (C = It(M, (s - l) / (o + 1)));
        }
      }
      if (C > kt) {
        const t = It(S, C),
          r = It(w, C),
          a = fP(L, F, P, R, s, t, Number(p)),
          o = fP(I, D, O, B, s, r, Number(p));
        if (C < M && t === r)
          e.moveTo(i + a.cx + a.x01, n + a.cy + a.y01),
            e.arc(i + a.cx, n + a.cy, C, Rt(a.y01, a.x01), Rt(o.y01, o.x01), !p);
        else {
          const t = d - l - 0.03,
            a = Rt(o.y11, o.x11);
          e.arc(i, n, s, t, a, !p), r > 0 && e.arc(i + o.cx, n + o.cy, r, Rt(o.y11, o.x11), Rt(o.y01, o.x01), !p);
        }
      } else e.moveTo(i + P, n + R);
      if (!(r > kt) || m < 0.001) e.lineTo(i + O, n + B), (g = !0);
      else if (E > kt) {
        const t = It(k, E),
          s = It(A, E),
          a = fP(O, B, I, D, r, -s, Number(p)),
          o = fP(P, R, L, F, r, -t, Number(p));
        if ((e.lineTo(i + a.cx + a.x01, n + a.cy + a.y01), E < T && t === s)) {
          const t = Rt(o.y01, o.x01);
          e.arc(i + a.cx, n + a.cy, E, Rt(a.y01, a.x01), t, !p);
        } else {
          s > 0 && e.arc(i + a.cx, n + a.cy, s, Rt(a.y01, a.x01), Rt(a.y11, a.x11), !p);
          const t = Rt(a.cy + a.y11, a.cx + a.x11),
            o = d - l - 0.03;
          e.arc(i, n, r, t, o, p);
        }
      } else e.lineTo(i + r * Ot(x), n + r * Dt(x));
      return g;
    }
    drawShape(t, e, i, n, s, r, o, l) {
      const h = Zk(t, null == r ? void 0 : r.theme).arc,
        {
          fill: c = h.fill,
          background: d,
          stroke: u = h.stroke,
          opacity: p = h.opacity,
          fillOpacity: g = h.fillOpacity,
          lineWidth: f = h.lineWidth,
          strokeOpacity: v = h.strokeOpacity,
          visible: m = h.visible,
          x: y = h.x,
          y: _ = h.y
        } = t.attribute,
        b = hP(p, g, c),
        x = dP(p, v),
        S = oP(c, d),
        w = lP(u, f);
      if (!t.valid || !m) return;
      if (!S && !w) return;
      if (!(b || x || o || l || d)) return;
      const {
        outerRadius: A = h.outerRadius,
        innerRadius: k = h.innerRadius,
        cap: M = h.cap,
        forceShowCap: T = h.forceShowCap
      } = t.attribute;
      let C = 0;
      const E = ((a(M) && M) || M[0]) && 'conical' === c.gradient;
      if (E) {
        const { sc: e, startAngle: i, endAngle: n } = t.getParsedAngle();
        Pt(n - i) < Et - kt && ((C = e || 0), (c.startAngle -= C), (c.endAngle -= C));
      }
      let P = !1;
      const { isFullStroke: R, stroke: O } = (t => {
        var e;
        let i = !0;
        if (a(t, !0)) {
          for (let n = 0; n < 4; n++) (BM[n] = t), i && (i = !(null !== (e = BM[n]) && void 0 !== e && !e));
          i = t;
        } else if (Array.isArray(t)) for (let e = 0; e < 4; e++) (BM[e] = !!t[e]), i && (i = !!BM[e]);
        else (BM[0] = !1), (BM[1] = !1), (BM[2] = !1), (BM[3] = !1);
        return { isFullStroke: i, stroke: BM };
      })(u);
      if (S || R) {
        if ((e.beginPath(), vP(t, e, i, n, A, k), !this._arcBeforeRenderContribitions)) {
          (this._arcBeforeRenderContribitions = []), (this._arcAfterRenderContribitions = []);
          const t = this.arcRenderContribitions.getContributions() || [];
          t.sort((t, e) => e.order - t.order),
            t.forEach(t => {
              t.time === Lw.beforeFillStroke
                ? this._arcBeforeRenderContribitions.push(t)
                : this._arcAfterRenderContribitions.push(t);
            });
        }
        (P = !0),
          this._arcBeforeRenderContribitions.forEach(r => {
            r.drawShape(t, e, i, n, S, w, b, x, h, s, o, l);
          }),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, h),
          S && (o ? o(e, t.attribute, h) : b && (e.setCommonStyle(t, t.attribute, y - i, _ - n, h), e.fill())),
          w && R && (l ? l(e, t.attribute, h) : x && (e.setStrokeStyle(t, t.attribute, y - i, _ - n, h), e.stroke()));
      }
      if (!R && w) {
        if ((e.beginPath(), vP(t, e, i, n, A, k, O), !P)) {
          if (!this._arcBeforeRenderContribitions) {
            (this._arcBeforeRenderContribitions = []), (this._arcAfterRenderContribitions = []);
            const t = this.arcRenderContribitions.getContributions() || [];
            t.sort((t, e) => e.order - t.order),
              t.forEach(t => {
                t.time === Lw.beforeFillStroke
                  ? this._arcBeforeRenderContribitions.push(t)
                  : this._arcAfterRenderContribitions.push(t);
              });
          }
          (P = !0),
            this._arcBeforeRenderContribitions.forEach(r => {
              r.drawShape(t, e, i, n, S, w, b, x, h, s, o, l);
            });
        }
        l ? l(e, t.attribute, h) : x && (e.setStrokeStyle(t, t.attribute, i, n, h), e.stroke());
      }
      if (((a(M) && M) || M[1]) && T) {
        const { startAngle: r, endAngle: a } = t.getParsedAngle();
        if (Pt(a - r) >= Et - kt) {
          e.beginPath();
          const r = Math.abs(A - k) / 2 / A,
            { endAngle: a = h.endAngle, fill: c = h.fill } = t.attribute,
            d = a;
          if ((this.drawArcTailCapPath(t, e, i, n, A, k, d, d + r), !P)) {
            if (!this._arcBeforeRenderContribitions) {
              (this._arcBeforeRenderContribitions = []), (this._arcAfterRenderContribitions = []);
              const t = this.arcRenderContribitions.getContributions() || [];
              t.sort((t, e) => e.order - t.order),
                t.forEach(t => {
                  t.time === Lw.beforeFillStroke
                    ? this._arcBeforeRenderContribitions.push(t)
                    : this._arcAfterRenderContribitions.push(t);
                });
            }
            (P = !0),
              this._arcBeforeRenderContribitions.forEach(r => {
                r.drawShape(t, e, i, n, S, w, b, x, h, s, o, l);
              });
          }
          if (S) {
            const s = c;
            if ('conical' === s.gradient) {
              const r = (function (t, e, i, n) {
                const { stops: s, startAngle: r, endAngle: a } = n;
                for (; i < 0; ) i += Et;
                for (; i > Et; ) i -= Et;
                if (i < r) return s[0].color;
                if (i > a) return s[0].color;
                let o,
                  l,
                  h = (i - r) / (a - r);
                for (let t = 0; t < s.length; t++)
                  if (s[t].offset >= h) {
                    (o = s[t - 1]), (l = s[t]);
                    break;
                  }
                return (h = (h - o.offset) / (l.offset - o.offset)), AT(o.color, l.color, h, !1);
              })(0, 0, a, s);
              o || (hP && (e.setCommonStyle(t, t.attribute, i, n, h), (e.fillStyle = r), e.fill()));
            }
          }
          w && (l || (x && (e.setStrokeStyle(t, t.attribute, i, n, h), e.stroke())));
        }
      }
      this._arcAfterRenderContribitions.forEach(r => {
        r.drawShape(t, e, i, n, S, w, b, x, h, s, o, l);
      }),
        E && ((c.startAngle += C), (c.endAngle += C));
    }
    draw(t, e, i, n) {
      const { context: s } = i;
      if (!s) return;
      const r = Zk(t, null == n ? void 0 : n.theme).arc;
      s.highPerformanceSave();
      let { x: a = r.x, y: o = r.y } = t.attribute;
      if (t.transMatrix.onlyTranslate()) {
        const e = t.getOffsetXY(r);
        (a += e.x), (o += e.y), s.setTransformForCurrent();
      } else (a = 0), (o = 0), s.transformFromMatrix(t.transMatrix, !0);
      pP(t, s, a, o, 0, n) || this.drawShape(t, s, a, o, i, n), s.highPerformanceRestore();
    }
  };
  IP = RP([ZS(), BP(0, tw(rw)), BP(0, JS(bP)), OP('design:paramtypes', [Object])], IP);
  var DP = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    LP = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    FP = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let jP = class {
    constructor(t) {
      (this.circleRenderContribitions = t), (this.numberType = ME);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      const l = Zk(t, null == r ? void 0 : r.theme).circle,
        {
          fill: h = l.fill,
          background: c,
          stroke: d = l.stroke,
          radius: u = l.radius,
          startAngle: p = l.startAngle,
          endAngle: g = l.endAngle,
          fillOpacity: f = l.fillOpacity,
          strokeOpacity: v = l.strokeOpacity,
          opacity: m = l.opacity,
          lineWidth: y = l.lineWidth,
          visible: _ = l.visible,
          x: b = l.x,
          y: x = l.y
        } = t.attribute,
        S = hP(m, f, h),
        w = dP(m, v),
        A = oP(h, c),
        k = lP(d, y);
      t.valid &&
        _ &&
        (A || k) &&
        (S || w || a || o || c) &&
        (e.beginPath(),
        e.arc(i, n, u, p, g),
        e.closePath(),
        this._circleRenderContribitions ||
          ((this._circleRenderContribitions = this.circleRenderContribitions.getContributions() || []),
          this._circleRenderContribitions.sort((t, e) => e.order - t.order)),
        this._circleRenderContribitions.forEach(r => {
          r.time === Lw.beforeFillStroke && r.drawShape(t, e, i, n, A, k, S, w, l, s, a, o);
        }),
        e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
        A && (a ? a(e, t.attribute, l) : S && (e.setCommonStyle(t, t.attribute, b - i, x - n, l), e.fill())),
        k && (o ? o(e, t.attribute, l) : w && (e.setStrokeStyle(t, t.attribute, b - i, x - n, l), e.stroke())),
        this._circleRenderContribitions.forEach(r => {
          r.time === Lw.afterFillStroke && r.drawShape(t, e, i, n, A, k, S, w, l, s, a, o);
        }));
    }
    draw(t, e, i, n) {
      const { context: s } = i;
      if (!s) return;
      s.highPerformanceSave();
      const r = Zk(t, null == n ? void 0 : n.theme).circle;
      let { x: a = r.x, y: o = r.y } = t.attribute;
      if (t.transMatrix.onlyTranslate()) {
        const e = t.getOffsetXY(r);
        (a += e.x), (o += e.y), s.setTransformForCurrent();
      } else (a = 0), (o = 0), s.transformFromMatrix(t.transMatrix, !0);
      pP(t, s, a, o, 0, n) || this.drawShape(t, s, a, o, i, n), s.highPerformanceRestore();
    }
  };
  jP = DP([ZS(), FP(0, tw(rw)), FP(0, JS(SP)), LP('design:paramtypes', [Object])], jP);
  const zP = ['radius', 'startAngle', 'endAngle', ...VT];
  class HP extends $T {
    constructor() {
      super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { radius: 1 }),
        (this.type = 'circle'),
        (this.numberType = ME);
    }
    isValid() {
      return super.isValid() && this._isValid();
    }
    _isValid() {
      const { startAngle: t, endAngle: e, radius: i } = this.attribute;
      return this._validNumber(t) && this._validNumber(e) && this._validNumber(i);
    }
    doUpdateAABBBounds(t) {
      const e = Zk(this).circle;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const i = this.attribute,
        n = WA.graphicService.updateCircleAABBBounds(i, Zk(this).circle, this._AABBBounds, t, this),
        { boundsPadding: s = e.boundsPadding } = i,
        r = DM(s);
      return r && n.expand(r), this.clearUpdateBoundTag(), n;
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    getDefaultAttribute(t) {
      return Zk(this).circle[t];
    }
    needUpdateTags(t) {
      for (let e = 0; e < zP.length; e++) {
        const i = zP[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < zP.length; e++) if (t === zP[e]) return !0;
      return !1;
    }
    toCustomPath() {
      var t, e, i;
      const n = this.attribute,
        s = null !== (t = n.radius) && void 0 !== t ? t : this.getDefaultAttribute('radius'),
        r = null !== (e = n.startAngle) && void 0 !== e ? e : this.getDefaultAttribute('startAngle'),
        a = null !== (i = n.endAngle) && void 0 !== i ? i : this.getDefaultAttribute('endAngle'),
        o = new mA();
      return o.arc(0, 0, s, r, a), o;
    }
    clone() {
      return new HP(Object.assign({}, this.attribute));
    }
  }
  function NP(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      i = arguments.length > 2 ? arguments[2] : void 0;
    i || (i = 1);
    const {
      fontStyle: n = e.fontStyle,
      fontVariant: s = e.fontVariant,
      fontWeight: r = e.fontWeight,
      fontSize: a = e.fontSize,
      fontFamily: o = e.fontFamily
    } = t;
    return (n ? n + ' ' : '') + (s ? s + ' ' : '') + (r ? r + ' ' : '') + a * i + 'px ' + (o || 'sans-serif');
  }
  function VP(t, e) {
    return 'end' === t || 'right' === t ? -e : 'center' === t ? -e / 2 : 0;
  }
  function WP(t, e, i) {
    return 'middle' === t
      ? -e / 2
      : 'top' === t
      ? 0
      : 'bottom' === t
      ? (arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0) - e
      : t && 'alphabetic' !== t
      ? 0
      : (i || (i = e), -(e - i) / 2 - 0.79 * i);
  }
  class GP {
    constructor(t, e, i) {
      (this.fontFamily = t), (this.textOptions = e), (this.textMeasure = i);
    }
    LayoutBBox(t, e, i) {
      if ('left' === e || 'start' === e) t.xOffset = 0;
      else if ('center' === e) t.xOffset = t.width / -2;
      else {
        if ('right' !== e && 'end' !== e) throw new Error('非法的textAlign');
        t.xOffset = -t.width;
      }
      return (
        (t.yOffset =
          'top' === i ? 0 : 'middle' === i ? t.height / -2 : 'alphabetic' === i ? -0.79 * t.height : -t.height),
        t
      );
    }
    GetLayout(t, e, i, n, s, r, a, o, l) {
      const h = [],
        c = [e, i],
        d = [0, 0];
      for (; t.length > 0; ) {
        const { str: i } = this.textMeasure.clipTextWithSuffix(t, this.textOptions, e, a, o);
        h.push({ str: i, width: this.textMeasure.measureTextWidth(i, this.textOptions) }), (t = t.substring(i.length));
      }
      'left' === n ||
        'start' === n ||
        ('center' === n ? (d[0] = c[0] / -2) : ('right' !== n && 'end' !== n) || (d[0] = -c[0])),
        'top' === s || ('middle' === s ? (d[1] = c[1] / -2) : 'bottom' === s && (d[1] = -c[1]));
      const u = { xOffset: d[0], yOffset: d[1], width: c[0], height: c[1] };
      return this.layoutWithBBox(u, h, n, s, r);
    }
    GetLayoutByLines(t, e, i, n) {
      let s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : '',
        r = arguments.length > 5 ? arguments[5] : void 0,
        a = arguments.length > 6 ? arguments[6] : void 0;
      t = t.map(t => t.toString());
      const o = [],
        l = [0, 0];
      if ('number' == typeof a && a !== 1 / 0) {
        let e;
        for (let i = 0, n = t.length; i < n; i++)
          (e = Math.min(this.textMeasure.measureTextWidth(t[i], this.textOptions), a)),
            o.push({ str: this.textMeasure.clipTextWithSuffix(t[i], this.textOptions, e, s, r).str, width: e });
        l[0] = a;
      } else {
        let e, i;
        a = 0;
        for (let n = 0, s = t.length; n < s; n++)
          (i = t[n]),
            (e = this.textMeasure.measureTextWidth(i, this.textOptions)),
            (a = Math.max(a, e)),
            o.push({ str: i, width: e });
        l[0] = a;
      }
      (l[1] = o.length * n), (l[0] = o.reduce((t, e) => Math.max(t, e.width), 0));
      const h = { xOffset: 0, yOffset: 0, width: l[0], height: l[1] };
      return this.LayoutBBox(h, e, i), this.layoutWithBBox(h, o, e, i, n);
    }
    layoutWithBBox(t, e, i, n, s) {
      const r = [0, 0],
        a = e.length * s;
      'top' === n || ('middle' === n ? (r[1] = (t.height - a) / 2) : 'bottom' === n && (r[1] = t.height - a));
      for (let a = 0; a < e.length; a++) this.lineOffset(t, e[a], i, n, s, r);
      return {
        bbox: t,
        lines: e,
        fontFamily: this.fontFamily,
        fontSize: this.textOptions.fontSize,
        fontWeight: this.textOptions.fontWeight,
        lineHeight: s,
        textAlign: i,
        textBaseline: n
      };
    }
    lineOffset(t, e, i, n, s, r) {
      return (
        'left' === i || 'start' === i
          ? (e.leftOffset = 0)
          : 'center' === i
          ? (e.leftOffset = (t.width - e.width) / 2)
          : ('right' !== i && 'end' !== i) || (e.leftOffset = t.width - e.width),
        (e.topOffset = (s - this.textOptions.fontSize) / 2 + 0.79 * this.textOptions.fontSize + r[1]),
        (r[1] += s),
        e
      );
    }
  }
  const UP = ['text', 'maxLineWidth', 'fontSize', 'fontFamily', 'fontWeight', 'ellipsis', 'lineHeight', ...VT];
  class YP extends $T {
    get font() {
      const t = Zk(this).text;
      return this._font || (this._font = NP(this.attribute, t)), this._font;
    }
    get clipedText() {
      var t;
      const e = this.attribute,
        i = Zk(this).text;
      if (Array.isArray(e.text)) return;
      const { maxLineWidth: n = i.maxLineWidth } = e;
      return Number.isFinite(n)
        ? (this.tryUpdateAABBBounds(), this.cache.clipedText)
        : (null !== (t = e.text) && void 0 !== t ? t : i.text).toString();
    }
    get clipedWidth() {
      if (!Array.isArray(this.attribute.text)) return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
    }
    get cliped() {
      const t = Zk(this).text,
        e = this.attribute;
      if (Array.isArray(e.text)) return;
      const { maxLineWidth: i = t.maxLineWidth } = e;
      return !!Number.isFinite(i) && (this.tryUpdateAABBBounds(), this.clipedText !== e.text.toString());
    }
    get multilineLayout() {
      if (Array.isArray(this.attribute.text)) return this.tryUpdateAABBBounds(), this.cache.layoutData;
    }
    constructor() {
      super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { text: '', fontSize: 16 }),
        (this.type = 'text'),
        (this.numberType = jE),
        (this.cache = {});
    }
    isValid() {
      return super.isValid() && this._isValid();
    }
    _isValid() {
      const { text: t } = this.attribute;
      return null != t && '' !== t;
    }
    doUpdateAABBBounds() {
      const t = Zk(this).text;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const e = this.attribute,
        i = WA.graphicService.updateTextAABBBounds(e, t, this._AABBBounds, this),
        { boundsPadding: n = t.boundsPadding } = this.attribute,
        s = DM(n);
      return s && i.expand(s), this.clearUpdateBoundTag(), i;
    }
    updateSingallineAABBBounds(t) {
      const e = Zk(this).text,
        { direction: i = e.direction } = this.attribute;
      return 'horizontal' === i
        ? this.updateHorizontalSinglelineAABBBounds(t)
        : this.updateVerticalSinglelineAABBBounds(t);
    }
    updateMultilineAABBBounds(t) {
      const e = Zk(this).text,
        { direction: i = e.direction } = this.attribute;
      return 'horizontal' === i
        ? this.updateHorizontalMultilineAABBBounds(t)
        : this.updateVerticalMultilineAABBBounds(t);
    }
    updateHorizontalSinglelineAABBBounds(t) {
      var e, i;
      const n = Zk(this).text,
        s = WA.graphicUtil.textMeasure;
      let r, a;
      const o = this.attribute,
        {
          maxLineWidth: l = n.maxLineWidth,
          ellipsis: h = n.ellipsis,
          textAlign: c = n.textAlign,
          textBaseline: d = n.textBaseline,
          fontFamily: u = n.fontFamily,
          fontSize: p = n.fontSize,
          fontWeight: g = n.fontWeight,
          stroke: f = n.stroke,
          lineWidth: v = n.lineWidth,
          wordBreak: m = n.wordBreak,
          ignoreBuf: y = n.ignoreBuf
        } = o,
        _ = y ? 0 : Math.max(2, 0.075 * p),
        { lineHeight: b = null !== (e = o.lineHeight) && void 0 !== e ? e : (o.fontSize || n.fontSize) + _ } = o;
      if (!this.shouldUpdateShape() && this.cache) {
        r = null !== (i = this.cache.clipedWidth) && void 0 !== i ? i : 0;
        const t = VP(c, r),
          e = WP(d, b, p);
        return this._AABBBounds.set(t, e, t + r, e + b), f && this._AABBBounds.expand(v / 2), this._AABBBounds;
      }
      if (Number.isFinite(l)) {
        if (h) {
          const e = !0 === h ? n.ellipsis : h,
            i = s.clipTextWithSuffix(t.toString(), { fontSize: p, fontWeight: g, fontFamily: u }, l, e, !1);
          (a = i.str), (r = i.width);
        } else {
          const e = s.clipText(t.toString(), { fontSize: p, fontWeight: g, fontFamily: u }, l, !1);
          (a = e.str), (r = e.width);
        }
        (this.cache.clipedText = a), (this.cache.clipedWidth = r);
      } else (r = s.measureTextWidth(t.toString(), { fontSize: p, fontWeight: g, fontFamily: u })), (this.cache.clipedText = t.toString()), (this.cache.clipedWidth = r);
      this.clearUpdateShapeTag();
      const x = VP(c, r);
      let S = b;
      WA.global && WA.global.isSafari() && (S += 0.2 * p);
      const w = WP(d, S, p, _);
      return this._AABBBounds.set(x, w, x + r, w + S), f && this._AABBBounds.expand(v / 2), this._AABBBounds;
    }
    updateVerticalSinglelineAABBBounds(t) {
      var e;
      const i = Zk(this).text,
        n = WA.graphicUtil.textMeasure;
      let s;
      const r = this.attribute,
        { ignoreBuf: a = i.ignoreBuf } = r,
        o = a ? 0 : 2,
        {
          maxLineWidth: l = i.maxLineWidth,
          ellipsis: h = i.ellipsis,
          textAlign: c = i.textAlign,
          textBaseline: d = i.textBaseline,
          fontSize: u = i.fontSize,
          fontWeight: p = i.fontWeight,
          fontFamily: g = i.fontFamily,
          stroke: f = i.stroke,
          lineHeight: v = null !== (e = r.lineHeight) && void 0 !== e ? e : (r.fontSize || i.fontSize) + o,
          lineWidth: m = i.lineWidth,
          wordBreak: y = i.wordBreak
        } = r;
      if (!this.shouldUpdateShape() && this.cache) {
        s = this.cache.clipedWidth;
        const t = VP(c, s),
          e = WP(d, v, u);
        return this._AABBBounds.set(e, t, e + v, t + s), f && this._AABBBounds.expand(m / 2), this._AABBBounds;
      }
      let _ = [_E(t.toString())];
      if (Number.isFinite(l)) {
        if (h) {
          const t = !0 === h ? i.ellipsis : h,
            e = n.clipTextWithSuffixVertical(_[0], { fontSize: u, fontWeight: p, fontFamily: g }, l, t, !1);
          (_ = [e.verticalList]), (s = e.width);
        } else {
          const t = n.clipTextVertical(_[0], { fontSize: u, fontWeight: p, fontFamily: g }, l, !1);
          (_ = [t.verticalList]), (s = t.width);
        }
        (this.cache.verticalList = _), (this.cache.clipedWidth = s);
      } else
        (s = 0),
          _[0].forEach(t => {
            const e =
              t.direction === yE.HORIZONTAL
                ? u
                : n.measureTextWidth(t.text, { fontSize: u, fontWeight: p, fontFamily: g });
            (s += e), (t.width = e);
          }),
          (this.cache.verticalList = _),
          (this.cache.clipedWidth = s);
      this.clearUpdateShapeTag();
      const b = VP(c, s),
        x = WP(d, v, u);
      return this._AABBBounds.set(x, b, x + v, b + s), f && this._AABBBounds.expand(m / 2), this._AABBBounds;
    }
    updateHorizontalMultilineAABBBounds(t) {
      var e;
      const i = Zk(this).text,
        n = this.attribute,
        {
          fontFamily: s = i.fontFamily,
          textAlign: r = i.textAlign,
          textBaseline: a = i.textBaseline,
          fontSize: o = i.fontSize,
          fontWeight: l = i.fontWeight,
          lineHeight: h = n.lineHeight || n.fontSize || i.fontSize,
          ellipsis: c = i.ellipsis,
          maxLineWidth: d,
          stroke: u = i.stroke,
          lineWidth: p = i.lineWidth,
          wordBreak: g = i.wordBreak
        } = n;
      if (!this.shouldUpdateShape() && (null === (e = this.cache) || void 0 === e ? void 0 : e.layoutData)) {
        const t = this.cache.layoutData.bbox;
        return (
          this._AABBBounds.set(t.xOffset, t.yOffset, t.xOffset + t.width, t.yOffset + t.height),
          u && this._AABBBounds.expand(p / 2),
          this._AABBBounds
        );
      }
      const f = WA.graphicUtil.textMeasure,
        v = new GP(s, { fontSize: o, fontWeight: l, fontFamily: s }, f).GetLayoutByLines(
          t,
          r,
          a,
          h,
          !0 === c ? i.ellipsis : c || void 0,
          !1,
          d
        ),
        { bbox: m } = v;
      return (
        (this.cache.layoutData = v),
        this.clearUpdateShapeTag(),
        this._AABBBounds.set(m.xOffset, m.yOffset, m.xOffset + m.width, m.yOffset + m.height),
        u && this._AABBBounds.expand(p / 2),
        this._AABBBounds
      );
    }
    updateVerticalMultilineAABBBounds(t) {
      var e;
      const i = Zk(this).text,
        n = WA.graphicUtil.textMeasure;
      let s;
      const r = this.attribute,
        { ignoreBuf: a = i.ignoreBuf } = r,
        o = a ? 0 : 2,
        {
          maxLineWidth: l = i.maxLineWidth,
          ellipsis: h = i.ellipsis,
          textAlign: c = i.textAlign,
          textBaseline: d = i.textBaseline,
          fontFamily: u = i.fontFamily,
          fontSize: p = i.fontSize,
          fontWeight: g = i.fontWeight,
          stroke: f = i.stroke,
          lineHeight: v = null !== (e = r.lineHeight) && void 0 !== e ? e : (r.fontSize || i.fontSize) + o,
          lineWidth: m = i.lineWidth,
          wordBreak: y = i.wordBreak
        } = r;
      if (((s = 0), !this.shouldUpdateShape() && this.cache)) {
        this.cache.verticalList.forEach(t => {
          const e = t.reduce((t, e) => t + e.width, 0);
          s = Bt(e, s);
        });
        const t = VP(c, s),
          e = this.cache.verticalList.length * v,
          i = WP(d, e, p);
        return this._AABBBounds.set(i, t, i + e, t + s), f && this._AABBBounds.expand(m / 2), this._AABBBounds;
      }
      const _ = t.map(t => _E(t.toString()));
      _.forEach((t, e) => {
        if (Number.isFinite(l))
          if (h) {
            const r = !0 === h ? i.ellipsis : h,
              a = n.clipTextWithSuffixVertical(t, { fontSize: p, fontWeight: g, fontFamily: u }, l, r, !1);
            (_[e] = a.verticalList), (s = a.width);
          } else {
            const i = n.clipTextVertical(t, { fontSize: p, fontWeight: g, fontFamily: u }, l, !1);
            (_[e] = i.verticalList), (s = i.width);
          }
        else
          (s = 0),
            t.forEach(t => {
              const e =
                t.direction === yE.HORIZONTAL
                  ? p
                  : n.measureTextWidth(t.text, { fontSize: p, fontWeight: g, fontFamily: u });
              (s += e), (t.width = e);
            });
      }),
        (this.cache.verticalList = _),
        this.clearUpdateShapeTag(),
        this.cache.verticalList.forEach(t => {
          const e = t.reduce((t, e) => t + e.width, 0);
          s = Bt(e, s);
        });
      const b = VP(c, s),
        x = this.cache.verticalList.length * v,
        S = WP(d, x, p);
      return this._AABBBounds.set(S, b, S + x, b + s), f && this._AABBBounds.expand(m / 2), this._AABBBounds;
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    getDefaultAttribute(t) {
      return Zk(this).text[t];
    }
    needUpdateTags(t) {
      for (let e = 0; e < UP.length; e++) {
        const i = UP[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < UP.length; e++) if (t === UP[e]) return !0;
      return !1;
    }
    clone() {
      return new YP(Object.assign({}, this.attribute));
    }
  }
  const $P = ['heightLimit', 'lineClamp'];
  class XP extends YP {
    _isValid() {
      const { text: t } = this.attribute;
      return f(t) ? !t.every(t => null == t || '' === t) : null != t && '' !== t;
    }
    updateMultilineAABBBounds(t) {
      var e, i, n;
      const s = Zk(this).text,
        {
          fontFamily: r = s.fontFamily,
          textAlign: a = s.textAlign,
          textBaseline: o = s.textBaseline,
          fontSize: l = s.fontSize,
          lineHeight: h = this.attribute.lineHeight || this.attribute.fontSize || s.fontSize,
          ellipsis: c = s.ellipsis,
          maxLineWidth: d,
          stroke: u = s.stroke,
          lineWidth: p = s.lineWidth,
          wordBreak: g = s.wordBreak,
          fontWeight: f = s.fontWeight,
          ignoreBuf: v = s.ignoreBuf,
          heightLimit: m = 0,
          lineClamp: y
        } = this.attribute,
        _ = v ? 0 : 2;
      if (!this.shouldUpdateShape() && (null === (e = this.cache) || void 0 === e ? void 0 : e.layoutData)) {
        const t = this.cache.layoutData.bbox;
        return (
          this._AABBBounds.set(t.xOffset, t.yOffset, t.xOffset + t.width, t.yOffset + t.height),
          u && this._AABBBounds.expand(p / 2),
          this._AABBBounds
        );
      }
      const b = WA.graphicUtil.textMeasure,
        x = new GP(r, { fontSize: l, fontWeight: f, fontFamily: r }, b),
        S = t.map(t => t.toString()),
        w = [],
        A = [0, 0];
      let k = 1 / 0;
      if (
        (m > 0 && (k = Math.max(Math.floor(m / h), 1)), y && (k = Math.min(k, y)), 'number' == typeof d && d !== 1 / 0)
      ) {
        if (d > 0)
          for (let t = 0; t < S.length; t++) {
            const e = S[t];
            let s = !0;
            if (t === k - 1) {
              const t = x.textMeasure.clipTextWithSuffix(e, x.textOptions, d, c, !1);
              w.push({ str: t.str, width: t.width });
              break;
            }
            const r = x.textMeasure.clipText(e, x.textOptions, d, 'break-word' === g);
            if ('' !== e && '' === r.str) {
              if (c) {
                const t = x.textMeasure.clipTextWithSuffix(e, x.textOptions, d, c, !1);
                (r.str = null !== (i = t.str) && void 0 !== i ? i : ''),
                  (r.width = null !== (n = t.width) && void 0 !== n ? n : 0);
              } else (r.str = ''), (r.width = 0);
              s = !1;
            }
            if ((w.push({ str: r.str, width: r.width }), r.str.length === e.length));
            else if (s) {
              const i = e.substring(r.str.length);
              S.splice(t + 1, 0, i);
            }
          }
        let t = 0;
        w.forEach(e => {
          t = Math.max(t, e.width);
        }),
          (A[0] = t);
      } else {
        let t,
          e,
          i = 0;
        for (let n = 0, s = S.length; n < s; n++) {
          if (n === k - 1) {
            const t = x.textMeasure.clipTextWithSuffix(S[n], x.textOptions, d, c, !1);
            w.push({ str: t.str, width: t.width }), (i = Math.max(i, t.width));
            break;
          }
          (e = S[n]),
            (t = x.textMeasure.measureTextWidth(e, x.textOptions, 'break-word' === g)),
            (i = Math.max(i, t)),
            w.push({ str: e, width: t });
        }
        A[0] = i;
      }
      A[1] = w.length * (h + _);
      const M = { xOffset: 0, yOffset: 0, width: A[0], height: A[1] };
      x.LayoutBBox(M, a, o);
      const T = x.layoutWithBBox(M, w, a, o, h);
      return (
        (this.cache.layoutData = T),
        this.clearUpdateShapeTag(),
        this._AABBBounds.set(M.xOffset, M.yOffset, M.xOffset + M.width, M.yOffset + M.height),
        u && this._AABBBounds.expand(p / 2),
        this._AABBBounds
      );
    }
    needUpdateTags(t) {
      for (let e = 0; e < $P.length; e++) {
        const i = $P[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return super.needUpdateTags(t);
    }
    needUpdateTag(t) {
      for (let e = 0; e < $P.length; e++) if (t === $P[e]) return !0;
      return super.needUpdateTag(t);
    }
  }
  function KP(t, e, i, n, s) {
    return s ? t.arc(i, n, e, 0, Ct, !1, s) : t.arc(i, n, e, 0, Ct), !1;
  }
  var qP = new (class {
    constructor() {
      (this.type = 'circle'), (this.pathStr = 'M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0');
    }
    draw(t, e, i, n, s) {
      return KP(t, e / 2, i, n, s);
    }
    drawOffset(t, e, i, n, s, r) {
      return KP(t, e / 2 + s, i, n, r);
    }
    drawToSvgPath(t, e, i, n) {
      const s = t / 2;
      return `M ${e - s}, ${i} a ${s},${s} 0 1,0 ${2 * s},0 a ${s},${s} 0 1,0 -${2 * s},0`;
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  var ZP = new (class {
    constructor() {
      (this.type = 'cross'),
        (this.pathStr =
          'M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z');
    }
    draw(t, e, i, n, s) {
      return (function (t, e, i, n, s) {
        return (
          t.moveTo(-3 * e + i, -e + n, s),
          t.lineTo(-e + i, -e + n, s),
          t.lineTo(-e + i, -3 * e + n, s),
          t.lineTo(e + i, -3 * e + n, s),
          t.lineTo(e + i, -e + n, s),
          t.lineTo(3 * e + i, -e + n, s),
          t.lineTo(3 * e + i, e + n, s),
          t.lineTo(e + i, e + n, s),
          t.lineTo(e + i, 3 * e + n, s),
          t.lineTo(-e + i, 3 * e + n, s),
          t.lineTo(-e + i, e + n, s),
          t.lineTo(-3 * e + i, e + n, s),
          t.closePath(),
          !0
        );
      })(t, e / 6, i, n, s);
    }
    drawOffset(t, e, i, n, s, r) {
      return (function (t, e, i, n, s, r) {
        return (
          t.moveTo(-3 * e + i - s, -e + n - s, r),
          t.lineTo(-e + i - s, -e + n - s, r),
          t.lineTo(-e + i - s, -3 * e + n - s, r),
          t.lineTo(e + i + s, -3 * e + n - s, r),
          t.lineTo(e + i + s, -e + n - s, r),
          t.lineTo(3 * e + i + s, -e + n - s, r),
          t.lineTo(3 * e + i + s, e + n + s, r),
          t.lineTo(e + i + s, e + n + s, r),
          t.lineTo(e + i + s, 3 * e + n + s, r),
          t.lineTo(-e + i - s, 3 * e + n + s, r),
          t.lineTo(-e + i - s, e + n + s, r),
          t.lineTo(-3 * e + i - s, e + n + s, r),
          t.closePath(),
          !0
        );
      })(t, e / 6, i, n, s, r);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function JP(t, e, i, n, s) {
    return (
      t.moveTo(i, n - e, s), t.lineTo(e + i, n, s), t.lineTo(i, n + e, s), t.lineTo(i - e, n, s), t.closePath(), !0
    );
  }
  var QP = new (class {
    constructor() {
      (this.type = 'diamond'), (this.pathStr = 'M-0.5,0L0,-0.5L0.5,0L0,0.5Z');
    }
    draw(t, e, i, n, s) {
      return JP(t, e / 2, i, n, s);
    }
    drawFitDir(t, e, i, n, s) {
      return JP(t, e / 2, i, n, s);
    }
    drawOffset(t, e, i, n, s, r) {
      return JP(t, e / 2 + s, i, n, r);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function tR(t, e, i, n) {
    const s = 2 * e;
    return t.rect(i - e, n - e, s, s), !1;
  }
  var eR = new (class {
    constructor() {
      (this.type = 'square'), (this.pathStr = 'M-0.5,-0.5h1v1h-1Z');
    }
    draw(t, e, i, n) {
      return tR(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return tR(t, e / 2 + s, i, n);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  class iR {
    constructor() {
      (this.type = 'triangleUp'), (this.pathStr = 'M0.5,0.5 L-0.5,0.5 L0,-0.5 Z');
    }
    draw(t, e, i, n) {
      return (function (t, e, i, n) {
        return t.moveTo(i + e, e + n), t.lineTo(i - e, e + n), t.lineTo(i, n - e), t.closePath(), !0;
      })(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return (function (t, e, i, n, s) {
        return (
          t.moveTo(i + e + 2 * s, e + n + s),
          t.lineTo(i - e - 2 * s, e + n + s),
          t.lineTo(i, n - e - 2 * s),
          t.closePath(),
          !0
        );
      })(t, e / 2, i, n, s);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  }
  var nR = new iR();
  var sR = new (class extends iR {
    constructor() {
      super(...arguments), (this.type = 'triangle');
    }
  })();
  const rR = Math.sin(Math.PI / 10) / Math.sin((7 * Math.PI) / 10),
    aR = Math.sin(Ct / 10) * rR,
    oR = -Math.cos(Ct / 10) * rR;
  function lR(t, e, i, n) {
    const s = aR * e,
      r = oR * e;
    t.moveTo(i, -e + n), t.lineTo(s + i, r + n);
    for (let a = 1; a < 5; ++a) {
      const o = (Ct * a) / 5,
        l = Math.cos(o),
        h = Math.sin(o);
      t.lineTo(h * e + i, -l * e + n), t.lineTo(l * s - h * r + i, h * s + l * r + n);
    }
    return t.closePath(), !0;
  }
  var hR = new (class {
    constructor() {
      (this.type = 'star'),
        (this.pathStr =
          'M4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,-4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,4.51351666838205,0');
    }
    draw(t, e, i, n) {
      return lR(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return lR(t, e / 2 + s, i, n);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  const cR = Lt(3);
  function dR(t, e, i, n) {
    const s = e,
      r = s / cR,
      a = r / 5,
      o = e;
    return (
      t.moveTo(0 + i, -s + n),
      t.lineTo(r / 2 + i, n),
      t.lineTo(a / 2 + i, n),
      t.lineTo(a / 2 + i, o + n),
      t.lineTo(-a / 2 + i, o + n),
      t.lineTo(-a / 2 + i, n),
      t.lineTo(-r / 2 + i, n),
      t.closePath(),
      !0
    );
  }
  var uR = new (class {
    constructor() {
      (this.type = 'arrow'),
        (this.pathStr =
          'M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z');
    }
    draw(t, e, i, n) {
      return dR(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return dR(t, e / 2 + s, i, n);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function pR(t, e, i, n) {
    const s = 2 * e;
    return t.moveTo(i, -e + n), t.lineTo(s / 3 / 2 + i, e + n), t.lineTo(-s / 3 / 2 + i, e + n), t.closePath(), !0;
  }
  var gR = new (class {
    constructor() {
      (this.type = 'wedge'),
        (this.pathStr = 'M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z');
    }
    draw(t, e, i, n) {
      return pR(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return pR(t, e / 2 + s, i, n);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function fR(t, e, i, n) {
    return t.moveTo(-e + i, n), t.lineTo(i, e + n), !1;
  }
  var vR = new (class {
    constructor() {
      (this.type = 'stroke'), (this.pathStr = '');
    }
    draw(t, e, i, n) {
      return fR(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return fR(t, e / 2 + s, i, n);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  const mR = -0.5,
    yR = Lt(3) / 2,
    _R = 1 / Lt(12);
  function bR(t, e, i, n) {
    const s = e / 2,
      r = e * _R,
      a = s,
      o = e * _R + e,
      l = -a,
      h = o;
    return (
      t.moveTo(s + i, r + n),
      t.lineTo(a + i, o + n),
      t.lineTo(l + i, h + n),
      t.lineTo(mR * s - yR * r + i, yR * s + mR * r + n),
      t.lineTo(mR * a - yR * o + i, yR * a + mR * o + n),
      t.lineTo(mR * l - yR * h + i, yR * l + mR * h + n),
      t.lineTo(mR * s + yR * r + i, mR * r - yR * s + n),
      t.lineTo(mR * a + yR * o + i, mR * o - yR * a + n),
      t.lineTo(mR * l + yR * h + i, mR * h - yR * l + n),
      t.closePath(),
      !1
    );
  }
  var xR = new (class {
    constructor() {
      (this.type = 'wye'),
        (this.pathStr =
          'M4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,-4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,4.51351666838205,0');
    }
    draw(t, e, i, n) {
      return bR(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return bR(t, e / 2 + s, i, n);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  var SR = new (class {
    constructor() {
      (this.type = 'triangleLeft'), (this.pathStr = 'M-0.5,0 L0.5,0.5 L0.5,-0.5 Z');
    }
    draw(t, e, i, n) {
      return (function (t, e, i, n) {
        return t.moveTo(-e + i, n), t.lineTo(e + i, e + n), t.lineTo(e + i, n - e), t.closePath(), !0;
      })(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return (function (t, e, i, n, s) {
        return (
          t.moveTo(-e + i - 2 * s, n),
          t.lineTo(e + i + s, e + n + 2 * s),
          t.lineTo(e + i + s, n - e - 2 * s),
          t.closePath(),
          !0
        );
      })(t, e / 2, i, n, s);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  var wR = new (class {
    constructor() {
      (this.type = 'triangleRight'), (this.pathStr = 'M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z');
    }
    draw(t, e, i, n) {
      return (function (t, e, i, n) {
        return t.moveTo(i - e, e + n), t.lineTo(e + i, n), t.lineTo(i - e, n - e), t.closePath(), !0;
      })(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return (function (t, e, i, n, s) {
        return (
          t.moveTo(i - e - s, e + n + 2 * s),
          t.lineTo(e + i + 2 * s, n),
          t.lineTo(i - e - s, n - e - 2 * s),
          t.closePath(),
          !0
        );
      })(t, e / 2, i, n, s);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  var AR = new (class {
    constructor() {
      (this.type = 'triangleDown'), (this.pathStr = 'M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z');
    }
    draw(t, e, i, n) {
      return (function (t, e, i, n) {
        return t.moveTo(i - e, n - e), t.lineTo(i + e, n - e), t.lineTo(i, n + e), t.closePath(), !0;
      })(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return (function (t, e, i, n, s) {
        return (
          t.moveTo(i - e - 2 * s, n - e - s),
          t.lineTo(i + e + 2 * s, n - e - s),
          t.lineTo(i, n + e + 2 * s),
          t.closePath(),
          !0
        );
      })(t, e / 2, i, n, s);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  const kR = Lt(3);
  function MR(t, e, i, n) {
    const s = e * kR;
    return t.moveTo(i, n + (-s / 3) * 2), t.lineTo(e + i, n + s), t.lineTo(i - e, n + s), t.closePath(), !0;
  }
  var TR = new (class extends iR {
    constructor() {
      super(...arguments),
        (this.type = 'thinTriangle'),
        (this.pathStr = 'M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z');
    }
    draw(t, e, i, n) {
      return MR(t, e / 2 / kR, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return MR(t, e / 2 / kR + s, i, n);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function CR(t, e, i, n) {
    const s = 2 * e;
    return t.moveTo(e + i, n - s), t.lineTo(i - e, n), t.lineTo(e + i, s + n), !0;
  }
  var ER = new (class {
    constructor() {
      (this.type = 'arrow2Left'), (this.pathStr = 'M 0.25 -0.5 L -0.25 0 l 0.25 0.5');
    }
    draw(t, e, i, n) {
      return CR(t, e / 4, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return CR(t, e / 4 + s, i, n);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function PR(t, e, i, n) {
    const s = 2 * e;
    return t.moveTo(i - e, n - s), t.lineTo(i + e, n), t.lineTo(i - e, s + n), !0;
  }
  var RR = new (class {
    constructor() {
      (this.type = 'arrow2Right'), (this.pathStr = 'M -0.25 -0.5 l 0.25 0 l -0.25 0.5');
    }
    draw(t, e, i, n) {
      return PR(t, e / 4, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return PR(t, e / 4 + s, i, n);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function OR(t, e, i, n) {
    const s = 2 * e;
    return t.moveTo(i - s, n + e), t.lineTo(i, n - e), t.lineTo(i + s, n + e), !0;
  }
  var BR = new (class {
    constructor() {
      (this.type = 'arrow2Up'), (this.pathStr = 'M -0.5 0.25 L 0 -0.25 l 0.5 0.25');
    }
    draw(t, e, i, n) {
      return OR(t, e / 4, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return OR(t, e / 4 + s, i, n);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function IR(t, e, i, n) {
    const s = 2 * e;
    return t.moveTo(i - s, n - e), t.lineTo(i, n + e), t.lineTo(i + s, n - e), !0;
  }
  var DR = new (class {
    constructor() {
      (this.type = 'arrow2Down'), (this.pathStr = 'M -0.5 -0.25 L 0 0.25 l 0.5 -0.25');
    }
    draw(t, e, i, n) {
      return IR(t, e / 4, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return IR(t, e / 4 + s, i, n);
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function LR(t, e, i, n, s) {
    return t.moveTo(i, n - e), t.lineTo(i, n + e), !0;
  }
  var FR = new (class {
    constructor() {
      (this.type = 'lineV'), (this.pathStr = 'M0,-0.5L0,0.5');
    }
    draw(t, e, i, n, s) {
      return LR(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s, r) {
      return LR(t, e / 2 + s, i, n);
    }
    drawToSvgPath(t, e, i, n) {
      const s = t / 2;
      return `M ${e}, ${i - s} L ${e},${i + s}`;
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function jR(t, e, i, n, s) {
    return t.moveTo(i - e, n), t.lineTo(i + e, n), !0;
  }
  var zR = new (class {
    constructor() {
      (this.type = 'lineH'), (this.pathStr = 'M-0.5,0L0.5,0');
    }
    draw(t, e, i, n, s) {
      return jR(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s, r) {
      return jR(t, e / 2 + s, i, n);
    }
    drawToSvgPath(t, e, i, n) {
      const s = t / 2;
      return `M ${e - s}, ${i} L ${e + s},${i}`;
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function HR(t, e, i, n, s) {
    return t.moveTo(i - e, n - e), t.lineTo(i + e, n + e), t.moveTo(i + e, n - e), t.lineTo(i - e, n + e), !0;
  }
  var NR = new (class {
    constructor() {
      (this.type = 'close'), (this.pathStr = 'M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5');
    }
    draw(t, e, i, n, s) {
      return HR(t, e / 2, i, n);
    }
    drawOffset(t, e, i, n, s, r) {
      return HR(t, e / 2 + s, i, n);
    }
    drawToSvgPath(t, e, i, n) {
      const s = t / 2;
      return `M ${e - s}, ${i - s} L ${e + s},${i + s} M ${e + s}, ${i - s} L ${e - s},${i + s}`;
    }
    bounds(t, e) {
      const i = t / 2;
      (e.x1 = -i), (e.x2 = i), (e.y1 = -i), (e.y2 = i);
    }
  })();
  function VR(t, e, i, n) {
    return t.rect(i - e[0] / 2, n - e[1] / 2, e[0], e[1]), !1;
  }
  var WR = new (class {
    constructor() {
      (this.type = 'rect'), (this.pathStr = 'M-0.5,-0.5h1v1h-1Z');
    }
    draw(t, e, i, n) {
      return VR(t, y(e) ? [e, e] : e, i, n);
    }
    drawOffset(t, e, i, n, s) {
      return VR(t, y(e) ? [e + 2 * s, e + 2 * s] : [e[0] + 2 * s, e[1] + 2 * s], i, n);
    }
    bounds(t, e) {
      const i = y(t) ? [t, t] : t;
      (e.x1 = -i[0] / 2), (e.x2 = i[0] / 2), (e.y1 = -i[1] / 2), (e.y2 = i[1] / 2);
    }
  })();
  const GR = new Kt();
  class UR {
    constructor(t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      (this.pathStr = ''), (this.type = t), f(e) ? (this.svgCache = e) : (this.path = e), (this.isSvg = i);
    }
    drawOffset(t, e, i, n, s, r, a) {
      return this.isSvg
        ? !!this.svgCache &&
            (this.svgCache.forEach(s => {
              t.beginPath(), Nw(s.path.commandList, t, i, n, e, e), a && a(s.path, s.attribute);
            }),
            !1)
        : (Nw(this.path.commandList, t, i, n, e + s, e + s), !1);
    }
    draw(t, e, i, n, s, r) {
      return this.isSvg
        ? !!this.svgCache &&
            (this.svgCache.forEach(s => {
              t.beginPath(), Nw(s.path.commandList, t, i, n, e, e), r && r(s.path, s.attribute);
            }),
            !1)
        : (Nw(this.path.commandList, t, i, n, e, e), !1);
    }
    bounds(t, e) {
      if (this.isSvg) {
        if (!this.svgCache) return;
        return (
          e.clear(),
          void this.svgCache.forEach(i => {
            let { path: n } = i;
            (GR.x1 = n.bounds.x1 * t),
              (GR.y1 = n.bounds.y1 * t),
              (GR.x2 = n.bounds.x2 * t),
              (GR.y2 = n.bounds.y2 * t),
              e.union(GR);
          })
        );
      }
      this.path.bounds &&
        ((e.x1 = this.path.bounds.x1 * t),
        (e.y1 = this.path.bounds.y1 * t),
        (e.x2 = this.path.bounds.x2 * t),
        (e.y2 = this.path.bounds.y2 * t));
    }
  }
  const YR = {};
  [qP, ZP, QP, eR, TR, sR, hR, uR, gR, vR, xR, SR, wR, nR, AR, ER, RR, BR, DR, WR, FR, zR, NR].forEach(t => {
    YR[t.type] = t;
  });
  const $R = ['symbolType', 'size', ...VT];
  let XR = class t extends $T {
    constructor() {
      super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { symbolType: 'circle' }),
        (this.type = 'symbol'),
        (this.numberType = FE);
    }
    getParsedPath() {
      return this.shouldUpdateShape() && (this.doUpdateParsedPath(), this.clearUpdateShapeTag()), this._parsedPath;
    }
    isValid() {
      return super.isValid() && this._isValid();
    }
    _isValid() {
      const { size: t } = this.attribute;
      return f(t) ? 2 === t.length && t.every(this._validNumber) : this._validNumber(t);
    }
    doUpdateParsedPath() {
      const e = Zk(this).symbol,
        { symbolType: i = e.symbolType } = this.attribute;
      let n = YR[i];
      if (n) return (this._parsedPath = n), n;
      if (((n = t.userSymbolMap[i]), n)) return (this._parsedPath = n), n;
      if (!0 === pE.XMLValidator.validate(i, { allowBooleanAttributes: !0 })) {
        const e = new pE.XMLParser({ ignoreAttributes: !1 }),
          { svg: n } = e.parse(i);
        if (!n) return null;
        const s = f(n.path) ? n.path : [n.path],
          r = new Kt(),
          a = [];
        s.forEach(t => {
          const e = new mA().fromString(t['@_d']),
            i = { fill: 'black' };
          VE.forEach(e => {
            t[e] && (i[NE[e]] = t[e]);
          }),
            a.push({ path: e, attribute: i }),
            r.union(e.bounds);
        });
        const o = r.width(),
          l = r.height(),
          h = 1 / Bt(o, l);
        return (
          a.forEach(t => t.path.transform(0, 0, h, h)),
          (this._parsedPath = new UR(i, a, !0)),
          (t.userSymbolMap[i] = this._parsedPath),
          this._parsedPath
        );
      }
      const s = new mA().fromString(i),
        r = s.bounds.width(),
        a = s.bounds.height(),
        o = 1 / Bt(r, a);
      return (
        s.transform(0, 0, o, o),
        (this._parsedPath = new UR(i, s)),
        (t.userSymbolMap[i] = this._parsedPath),
        this._parsedPath
      );
    }
    doUpdateAABBBounds(t) {
      const e = Zk(this).symbol;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const i = this.attribute,
        n = WA.graphicService.updateSymbolAABBBounds(i, Zk(this).symbol, this._AABBBounds, t, this),
        { boundsPadding: s = e.boundsPadding } = i,
        r = DM(s);
      return r && n.expand(r), this.clearUpdateBoundTag(), n;
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    getDefaultAttribute(t) {
      return Zk(this).symbol[t];
    }
    needUpdateTags(t) {
      for (let e = 0; e < $R.length; e++) {
        const i = $R[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < $R.length; e++) if (t === $R[e]) return !0;
      return !1;
    }
    toCustomPath() {
      const t = this.getParsedPath(),
        e = this.attribute.size,
        i = f(e) ? e : [e, e];
      return t.path
        ? new mA().fromCustomPath2D(t.path, 0, 0, i[0], i[1])
        : new mA().fromString(t.pathStr, 0, 0, i[0], i[1]);
    }
    clone() {
      return new t(Object.assign({}, this.attribute));
    }
  };
  XR.userSymbolMap = {};
  const KR = ['segments', 'points', 'curveType', ...VT];
  let qR = class t extends $T {
    constructor() {
      super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}),
        (this.type = 'line'),
        (this.numberType = PE);
    }
    isValid() {
      return super.isValid() && this._isValid();
    }
    _isValid() {
      const { points: t, segments: e } = this.attribute;
      return e ? 0 !== e.length : !(!t || t.length <= 1);
    }
    _interpolate(t, e, i, n, s) {
      'points' === t && (s.points = HM(i, n, e));
    }
    doUpdateAABBBounds() {
      const t = Zk(this).line;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const e = this.attribute,
        i = WA.graphicService.updateLineAABBBounds(e, Zk(this).line, this._AABBBounds, this),
        { boundsPadding: n = t.boundsPadding } = e,
        s = DM(n);
      return s && i.expand(s), this.clearUpdateBoundTag(), i;
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    getDefaultAttribute(t) {
      return Zk(this).line[t];
    }
    needUpdateTags(t) {
      for (let e = 0; e < KR.length; e++) {
        const i = KR[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < KR.length; e++) if (t === KR[e]) return !0;
      return !1;
    }
    toCustomPath() {
      const t = this.attribute,
        e = new mA(),
        i = t.segments,
        n = t => {
          if (t && t.length) {
            let i = !0;
            t.forEach(t => {
              !1 !== t.defined && (i ? e.moveTo(t.x, t.y) : e.lineTo(t.x, t.y), (i = !1));
            });
          }
        };
      return (
        i && i.length
          ? i.forEach(t => {
              n(t.points);
            })
          : t.points && n(t.points),
        e
      );
    }
    clone() {
      return new t(Object.assign({}, this.attribute));
    }
  };
  const ZR = ['width', 'height', 'cornerRadius', ...VT];
  class JR extends $T {
    constructor(t) {
      super(t), (this.type = 'rect'), (this.numberType = IE);
    }
    isValid() {
      return super.isValid() && this._isValid();
    }
    _isValid() {
      const { width: t, height: e } = this.attribute;
      return this._validNumber(t) && this._validNumber(e);
    }
    doUpdateAABBBounds() {
      const t = Zk(this).rect;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const e = this.attribute,
        i = WA.graphicService.updateRectAABBBounds(e, Zk(this).rect, this._AABBBounds, this),
        { boundsPadding: n = t.boundsPadding } = e,
        s = DM(n);
      return s && i.expand(s), this.clearUpdateBoundTag(), i;
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    getDefaultAttribute(t) {
      return Zk(this).rect[t];
    }
    needUpdateTags(t) {
      for (let e = 0; e < ZR.length; e++) {
        const i = ZR[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < ZR.length; e++) if (t === ZR[e]) return !0;
      return !1;
    }
    toCustomPath() {
      const t = this.attribute,
        e = t.width,
        i = t.height,
        n = new mA();
      return n.moveTo(0, 0), n.rect(0, 0, e, i), n;
    }
    clone() {
      return new JR(Object.assign({}, this.attribute));
    }
  }
  const QR = [
    [0, 0, 0],
    [1, 0, 0],
    [1, 1, 0],
    [0, 1, 0],
    [0, 0, 1],
    [1, 0, 1],
    [1, 1, 1],
    [0, 1, 1]
  ];
  class tO extends JR {
    constructor(t) {
      super(t), (this.type = 'rect3d'), (this.numberType = DE);
    }
    findFace() {
      const t = { polygons: [], vertices: [], edges: [] },
        e = Zk(this).rect3d,
        { width: i = e.width, height: n = e.width, length: s = It(e.width, e.height) } = this.attribute;
      for (let e = 0; e < QR.length; e++) {
        const r = QR[e];
        t.vertices.push([r[0] * i, r[1] * n, r[2] * s]);
      }
      return (
        t.polygons.push({ polygon: [0, 1, 5, 4], normal: [0, -1, 0] }),
        t.polygons.push({ polygon: [2, 3, 7, 6], normal: [0, 1, 0] }),
        t.polygons.push({ polygon: [4, 7, 3, 0], normal: [-1, 0, 0] }),
        t.polygons.push({ polygon: [1, 2, 6, 5], normal: [1, 0, 0] }),
        t.polygons.push({ polygon: [0, 1, 2, 3], normal: [0, 0, -1] }),
        t.polygons.push({ polygon: [4, 5, 6, 7], normal: [0, 0, 1] }),
        (t.edges = [
          [0, 1],
          [1, 2],
          [2, 3],
          [3, 0],
          [4, 5],
          [5, 6],
          [6, 7],
          [7, 4],
          [0, 4],
          [3, 7],
          [1, 5],
          [2, 6]
        ]),
        t
      );
    }
  }
  class eO extends $T {
    constructor(t) {
      super(t),
        (this.type = 'glyph'),
        (this.numberType = TE),
        (this.subGraphic = []),
        this._onInit && this._onInit(this),
        (this.valid = this.isValid());
    }
    setSubGraphic(t) {
      this.detachSubGraphic(),
        (this.subGraphic = t),
        t.forEach(t => {
          (t.glyphHost = this), Object.setPrototypeOf(t.attribute, this.attribute);
        }),
        (this.valid = this.isValid()),
        this.addUpdateBoundTag();
    }
    detachSubGraphic() {
      this.subGraphic.forEach(t => {
        (t.glyphHost = null), Object.setPrototypeOf(t.attribute, {});
      });
    }
    getSubGraphic() {
      return this.subGraphic;
    }
    onInit(t) {
      this._onInit = t;
    }
    onUpdate(t) {
      this._onUpdate = t;
    }
    isValid() {
      return !0;
    }
    setAttribute(t, e, i, n) {
      super.setAttribute(t, e, i, n),
        this.subGraphic.forEach(t => {
          t.addUpdateShapeAndBoundsTag(), t.addUpdatePositionTag();
        });
    }
    setAttributes(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
        i = arguments.length > 2 ? arguments[2] : void 0;
      super.setAttributes(t, e, i),
        this.subGraphic.forEach(t => {
          t.addUpdateShapeAndBoundsTag(), t.addUpdatePositionTag();
        });
    }
    translate(t, e) {
      return (
        super.translate(t, e),
        this.subGraphic.forEach(t => {
          t.addUpdatePositionTag(), t.addUpdateBoundTag();
        }),
        this
      );
    }
    translateTo(t, e) {
      return (
        super.translateTo(t, e),
        this.subGraphic.forEach(t => {
          t.addUpdatePositionTag(), t.addUpdateBoundTag();
        }),
        this
      );
    }
    scale(t, e, i) {
      return (
        super.scale(t, e, i),
        this.subGraphic.forEach(t => {
          t.addUpdatePositionTag(), t.addUpdateBoundTag();
        }),
        this
      );
    }
    scaleTo(t, e) {
      return (
        super.scaleTo(t, e),
        this.subGraphic.forEach(t => {
          t.addUpdatePositionTag(), t.addUpdateBoundTag();
        }),
        this
      );
    }
    rotate(t) {
      return (
        super.rotate(t),
        this.subGraphic.forEach(t => {
          t.addUpdatePositionTag(), t.addUpdateBoundTag();
        }),
        this
      );
    }
    rotateTo(t) {
      return (
        super.rotate(t),
        this.subGraphic.forEach(t => {
          t.addUpdatePositionTag(), t.addUpdateBoundTag();
        }),
        this
      );
    }
    doUpdateAABBBounds() {
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const t = WA.graphicService.updateGlyphAABBBounds(this.attribute, Zk(this).glyph, this._AABBBounds, this);
      return this.clearUpdateBoundTag(), t;
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    needUpdateTags(t) {
      return !1;
    }
    needUpdateTag(t) {
      return !1;
    }
    useStates(t, e) {
      var i;
      if (!t.length) return void this.clearStates(e);
      if (
        (null === (i = this.currentStates) || void 0 === i ? void 0 : i.length) === t.length &&
        !t.some((t, e) => this.currentStates[e] !== t)
      )
        return;
      const n = {},
        s = this.subGraphic.map(() => ({}));
      t.forEach(e => {
        var i;
        const r = this.glyphStateProxy ? this.glyphStateProxy(e, t) : this.glyphStates[e];
        r &&
          (Object.assign(n, r.attributes),
          (null === (i = r.subAttributes) || void 0 === i ? void 0 : i.length) &&
            s.forEach((t, e) => {
              Object.assign(t, r.subAttributes[e]);
            }));
      }),
        this.subGraphic.forEach((i, n) => {
          i.updateNormalAttrs(s[n]), i.applyStateAttrs(s[n], t, e);
        }),
        this.updateNormalAttrs(n),
        (this.currentStates = t),
        this.applyStateAttrs(n, t, e);
    }
    clearStates(t) {
      this.hasState() &&
        this.normalAttrs &&
        (this.subGraphic.forEach(e => {
          e.applyStateAttrs(e.normalAttrs, this.currentStates, t, !0), (e.normalAttrs = null);
        }),
        this.applyStateAttrs(this.normalAttrs, this.currentStates, t, !0),
        (this.normalAttrs = null),
        (this.currentStates = []));
    }
    clone() {
      const t = new eO(Object.assign({}, this.attribute));
      return t.setSubGraphic(this.subGraphic.map(t => t.clone())), t;
    }
  }
  class iO {
    constructor(t, e, i, n, s, r, a, o, l, h, c, d, u, p) {
      (this.left = t),
        (this.top = e),
        (this.width = i),
        (this.height = n),
        (this.actualHeight = 0),
        (this.bottom = e + n),
        (this.right = t + i),
        (this.ellipsis = s),
        (this.wordBreak = r),
        (this.verticalDirection = a),
        (this.lines = []),
        (this.globalAlign = o),
        (this.globalBaseline = l),
        (this.layoutDirection = h),
        (this.directionKey = GA[this.layoutDirection]),
        (this.isWidthMax = c),
        (this.isHeightMax = d),
        (this.singleLine = u),
        p ? (p.clear(), (this.icons = p)) : (this.icons = new Map());
    }
    draw(t, e) {
      const { width: i, height: n } = this.getActualSize(),
        s = this.isWidthMax ? Math.min(this.width, i) : this.width || i || 0;
      let r = this.isHeightMax ? Math.min(this.height, n) : this.height || n || 0;
      r = Math.min(r, n);
      let a = 0;
      switch (this.globalBaseline) {
        case 'top':
          a = 0;
          break;
        case 'middle':
          a = -r / 2;
          break;
        case 'bottom':
          a = -r;
      }
      let o = 0;
      switch (this.globalAlign) {
        case 'left':
          o = 0;
          break;
        case 'center':
          o = -s / 2;
          break;
        case 'right':
          o = -s;
      }
      let l = this[this.directionKey.height];
      this.singleLine && (l = this.lines[0].height + 1);
      let h = !1;
      if ('middle' === this.verticalDirection)
        if (this.actualHeight >= l && 0 !== l)
          for (let i = 0; i < this.lines.length; i++) {
            const { top: n, height: s } = this.lines[i];
            if (n + s < this[this.directionKey.top] || n + s > this[this.directionKey.top] + l) return h;
            let r = !1;
            this.ellipsis &&
              this.lines[i + 1] &&
              this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + l &&
              ((r = !0), (h = !0)),
              this.lines[i].draw(
                t,
                r,
                this.lines[i][this.directionKey.left] + o,
                this.lines[i][this.directionKey.top] + a,
                e
              );
          }
        else {
          const i = Math.floor((l - this.actualHeight) / 2);
          'vertical' === this.layoutDirection ? (o += i) : (a += i);
          for (let i = 0; i < this.lines.length; i++)
            this.lines[i].draw(
              t,
              !1,
              this.lines[i][this.directionKey.left] + o,
              this.lines[i][this.directionKey.top] + a,
              e
            );
        }
      else if ('bottom' === this.verticalDirection && 'vertical' !== this.layoutDirection)
        for (let i = 0; i < this.lines.length; i++) {
          const { top: n, height: s } = this.lines[i],
            r = l - this.lines[i].top - this.lines[i].height;
          if (0 === l) this.lines[i].draw(t, !1, o, r + a, e);
          else {
            if (r + s > this[this.directionKey.top] + l || r < this[this.directionKey.top]) return h;
            {
              let n = !1;
              this.ellipsis &&
                this.lines[i + 1] &&
                r - this.lines[i + 1].height < this[this.directionKey.top] &&
                ((n = !0), (h = !0)),
                this.lines[i].draw(t, n, o, r + a, e);
            }
          }
        }
      else {
        'bottom' === this.verticalDirection &&
          'vertical' === this.layoutDirection &&
          this.singleLine &&
          this.isWidthMax &&
          (o += this.lines[0].height + 1);
        for (let i = 0; i < this.lines.length; i++) {
          'bottom' === this.verticalDirection &&
            'vertical' === this.layoutDirection &&
            (o -= this.lines[i].height + this.lines[i].top);
          const { top: n, height: s } = this.lines[i];
          if (0 === l)
            this.lines[i].draw(
              t,
              !1,
              this.lines[i][this.directionKey.left] + o,
              this.lines[i][this.directionKey.top] + a,
              e
            );
          else {
            if (n + s < this[this.directionKey.top] || n + s > this[this.directionKey.top] + l) return h;
            {
              let n = !1;
              this.ellipsis &&
                this.lines[i + 1] &&
                this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + l &&
                ((n = !0), (h = !0)),
                this.lines[i].draw(
                  t,
                  n,
                  this.lines[i][this.directionKey.left] + o,
                  this.lines[i][this.directionKey.top] + a,
                  e
                );
            }
          }
        }
      }
      return h;
    }
    getActualSize() {
      return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();
    }
    getRawActualSize() {
      let t = 0,
        e = 0;
      for (let i = 0; i < this.lines.length; i++) {
        const n = this.lines[i];
        n.actualWidth > t && (t = n.actualWidth), (e += n.height);
      }
      return {
        width: 'vertical' === this.layoutDirection ? e : t,
        height: 'vertical' === this.layoutDirection ? t : e
      };
    }
    getActualSizeWidthEllipsis() {
      let t = 0,
        e = 0;
      const { width: i, height: n } = this.getRawActualSize();
      this.width, this.height;
      let s = this[this.directionKey.height];
      if ((this.singleLine && (s = this.lines[0].height + 1), 'middle' === this.verticalDirection))
        if (this.actualHeight >= s && 0 !== s)
          for (let i = 0; i < this.lines.length; i++) {
            const { top: n, height: r } = this.lines[i];
            if (n + r < this[this.directionKey.top] || n + r > this[this.directionKey.top] + s);
            else if (
              this.ellipsis &&
              this.lines[i + 1] &&
              this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + s
            ) {
              const n = this.lines[i].getWidthWithEllips();
              n > t && (t = n), (e += this.lines[i].height);
            } else this.lines[i].actualWidth > t && (t = this.lines[i].actualWidth), (e += this.lines[i].height);
          }
        else {
          Math.floor((s - this.actualHeight) / 2);
          for (let i = 0; i < this.lines.length; i++)
            this.lines[i].actualWidth > t && (t = this.lines[i].actualWidth), (e += this.lines[i].height);
        }
      else if ('bottom' === this.verticalDirection)
        for (let i = 0; i < this.lines.length; i++) {
          const { top: n, height: r } = this.lines[i],
            a = s - this.lines[i].top - this.lines[i].height;
          if (0 === s) this.lines[i].actualWidth > t && (t = this.lines[i].actualWidth), (e += this.lines[i].height);
          else if (a + r > this[this.directionKey.top] + s || a < this[this.directionKey.top]);
          else if (this.ellipsis && this.lines[i + 1] && a - this.lines[i + 1].height < this[this.directionKey.top]) {
            const n = this.lines[i].getWidthWithEllips();
            n > t && (t = n), (e += this.lines[i].height);
          } else this.lines[i].actualWidth > t && (t = this.lines[i].actualWidth), (e += this.lines[i].height);
        }
      else
        for (let i = 0; i < this.lines.length; i++) {
          const { top: n, height: r } = this.lines[i];
          if (0 === s) this.lines[i].actualWidth > t && (t = this.lines[i].actualWidth), (e += this.lines[i].height);
          else if (n + r < this[this.directionKey.top] || n + r > this[this.directionKey.top] + s);
          else if (
            this.ellipsis &&
            this.lines[i + 1] &&
            this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + s
          ) {
            const n = this.lines[i].getWidthWithEllips();
            n > t && (t = n), (e += this.lines[i].height);
          } else this.lines[i].actualWidth > t && (t = this.lines[i].actualWidth), (e += this.lines[i].height);
        }
      return {
        width: 'vertical' === this.layoutDirection ? e : t,
        height: 'vertical' === this.layoutDirection ? t : e
      };
    }
  }
  class nO {
    constructor(t, e, i) {
      (this.fontSize = i.fontSize || 16),
        (this.textBaseline = i.textBaseline || 'alphabetic'),
        'number' == typeof i.lineHeight
          ? (this.lineHeight = i.lineHeight > this.fontSize ? i.lineHeight : this.fontSize)
          : (this.lineHeight = Math.floor(1.2 * this.fontSize)),
        (this.height = this.lineHeight);
      const { ascent: n, height: s, descent: r, width: a } = JA(t, i);
      let o = 0,
        l = 0,
        h = 0;
      this.height > s && ((o = (this.height - s) / 2), (l = Math.ceil(o)), (h = Math.floor(o))),
        'top' === this.textBaseline
          ? ((this.ascent = o), (this.descent = s - o))
          : 'bottom' === this.textBaseline
          ? ((this.ascent = s - o), (this.descent = o))
          : 'middle' === this.textBaseline
          ? ((this.ascent = this.height / 2), (this.descent = this.height / 2))
          : ((this.ascent = n + l), (this.descent = r + h)),
        (this.length = t.length),
        (this.width = a || 0),
        (this.text = t || ''),
        (this.newLine = e || !1),
        (this.character = i),
        (this.left = 0),
        (this.top = 0),
        (this.ellipsis = 'normal'),
        (this.ellipsisWidth = 0),
        (this.ellipsisOtherParagraphWidth = 0),
        'vertical' === i.direction &&
          ((this.direction = i.direction),
          (this.widthOrigin = this.width),
          (this.heightOrigin = this.height),
          (this.width = this.heightOrigin),
          (this.height = this.widthOrigin),
          (this.lineHeight = this.height));
    }
    updateWidth() {
      const { width: t } = JA(this.text, this.character);
      (this.width = t),
        'vertical' === this.direction &&
          ((this.widthOrigin = this.width), (this.width = this.heightOrigin), (this.height = this.widthOrigin));
    }
    draw(t, e, i, n, s) {
      let r = this.text,
        a = this.left + i;
      e += this.top;
      let o = this.direction;
      if (this.verticalEllipsis) (r = '...'), (o = 'vertical'), (e -= this.ellipsisWidth / 2);
      else {
        if ('hide' === this.ellipsis) return;
        if ('add' === this.ellipsis) (r += '...'), 'right' === s && (a -= this.ellipsisWidth);
        else if ('replace' === this.ellipsis) {
          const t = qA(
            r,
            ('vertical' === o ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth,
            this.character,
            r.length - 1
          );
          if (((r = r.slice(0, t)), (r += '...'), 'right' === s)) {
            const { width: e } = JA(this.text.slice(t), this.character);
            'vertical' === o || (a -= this.ellipsisWidth - e);
          }
        }
      }
      switch (this.character.script) {
        case 'super':
          e -= this.ascent * (1 / 3);
          break;
        case 'sub':
          e += this.descent / 2;
      }
      'vertical' === o &&
        (t.save(),
        t.rotateAbout(Math.PI / 2, a, e),
        t.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2),
        t.translate(a, e),
        (a = 0),
        (e = 0)),
        this.character.stroke &&
          ((function (t, e) {
            const i = (e && e.stroke) || YA;
            if (!i) return void (t.globalAlpha = 0);
            (t.globalAlpha = 1), (t.lineWidth = 1), (t.strokeStyle = i);
            let n = e.fontSize || 16;
            switch (e.script) {
              case 'super':
              case 'sub':
                n *= 0.8;
            }
            t.setTextStyle({
              textAlign: 'left',
              textBaseline: e.textBaseline || 'alphabetic',
              fontStyle: e.fontStyle || '',
              fontWeight: e.fontWeight || '',
              fontSize: n,
              fontFamily: e.fontFamily || 'sans-serif'
            });
          })(t, this.character),
          t.strokeText(r, a, e)),
        (function (t, e) {
          const i = (e && e.fill) || UA;
          if (!i) return void (t.globalAlpha = 0);
          (t.globalAlpha = 1), (t.fillStyle = i);
          let n = e.fontSize || 16;
          switch (e.script) {
            case 'super':
            case 'sub':
              n *= 0.8;
          }
          t.setTextStyle({
            textAlign: 'left',
            textBaseline: e.textBaseline || 'alphabetic',
            fontStyle: e.fontStyle || '',
            fontWeight: e.fontWeight || '',
            fontSize: n,
            fontFamily: e.fontFamily || 'sans-serif'
          });
        })(t, this.character),
        this.character.fill && t.fillText(r, a, e),
        this.character.fill &&
          ('boolean' == typeof this.character.lineThrough || 'boolean' == typeof this.character.underline
            ? (this.character.underline &&
                t.fillRect(
                  a,
                  1 + e,
                  this.widthOrigin || this.width,
                  this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1
                ),
              this.character.lineThrough &&
                t.fillRect(
                  a,
                  1 + e - this.ascent / 2,
                  this.widthOrigin || this.width,
                  this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1
                ))
            : 'underline' === this.character.textDecoration
            ? t.fillRect(
                a,
                1 + e,
                this.widthOrigin || this.width,
                this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1
              )
            : 'line-through' === this.character.textDecoration &&
              t.fillRect(
                a,
                1 + e - this.ascent / 2,
                this.widthOrigin || this.width,
                this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1
              )),
        'vertical' === o && t.restore();
    }
    getWidthWithEllips(t) {
      let e = this.text;
      const i = 'vertical' === t ? this.height : this.width;
      if ('hide' === this.ellipsis) return i;
      if ('add' === this.ellipsis) return i + this.ellipsisWidth;
      if ('replace' === this.ellipsis) {
        const t = qA(e, i - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, e.length - 1);
        (e = e.slice(0, t)), (e += '...');
        const { width: n } = JA(this.text.slice(t), this.character);
        return i + this.ellipsisWidth - n;
      }
      return i;
    }
  }
  const sO = ['width', 'height', 'image', ...VT];
  class rO extends $T {
    constructor(t) {
      super(t), (this.type = 'image'), (this.numberType = EE), this.loadImage(this.attribute.image);
    }
    get width() {
      var t;
      return null !== (t = this.attribute.width) && void 0 !== t ? t : 0;
    }
    set width(t) {
      this.attribute.width === t && ((this.attribute.width = t), this.addUpdateShapeAndBoundsTag());
    }
    get height() {
      var t;
      return null !== (t = this.attribute.height) && void 0 !== t ? t : 0;
    }
    set height(t) {
      this.attribute.height === t && ((this.attribute.height = t), this.addUpdateShapeAndBoundsTag());
    }
    get repeatX() {
      var t;
      return null !== (t = this.attribute.repeatX) && void 0 !== t ? t : 'no-repeat';
    }
    set repeatX(t) {
      this.attribute.repeatX === t && (this.attribute.repeatX = t);
    }
    get repeatY() {
      var t;
      return null !== (t = this.attribute.repeatY) && void 0 !== t ? t : 'no-repeat';
    }
    set repeatY(t) {
      this.attribute.repeatY === t && (this.attribute.repeatY = t);
    }
    get image() {
      return this.attribute.image;
    }
    set image(t) {
      t !== this.attribute.image && ((this.attribute.image = t), this.loadImage(this.attribute.image));
    }
    imageLoadSuccess(t, e, i) {
      super.imageLoadSuccess(t, e, () => {
        this.successCallback && this.successCallback();
      });
    }
    imageLoadFail(t, e) {
      super.imageLoadFail(t, () => {
        this.failCallback && this.failCallback();
      });
    }
    doUpdateAABBBounds() {
      const t = Zk(this).image;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const e = this.attribute,
        i = WA.graphicService.updateImageAABBBounds(e, Zk(this).image, this._AABBBounds, this),
        { boundsPadding: n = t.boundsPadding } = e,
        s = DM(n);
      return s && i.expand(s), this.clearUpdateBoundTag(), i;
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    getDefaultAttribute(t) {
      return NA[t];
    }
    needUpdateTags(t) {
      for (let e = 0; e < sO.length; e++) {
        const i = sO[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < sO.length; e++) if (t === sO[e]) return !0;
      return !1;
    }
    clone() {
      return new rO(Object.assign({}, this.attribute));
    }
  }
  class aO extends rO {
    constructor(t) {
      if (
        (super(t),
        (this._x = 0),
        (this._y = 0),
        (this._hovered = !1),
        (this._marginArray = [0, 0, 0, 0]),
        'always' === t.backgroundShowMode && (this._hovered = !0),
        t.margin)
      ) {
        const e = DM(t.margin);
        this._marginArray = 'number' == typeof e ? [e, e, e, e] : e;
      }
      this.onBeforeAttributeUpdate = (t, e, i) => {
        if ((f(i) && -1 !== i.indexOf('margin')) || 'margin' === i)
          if (e.margin) {
            const t = DM(e.margin);
            this._marginArray = 'number' == typeof t ? [t, t, t, t] : t;
          } else this._marginArray = [0, 0, 0, 0];
      };
    }
    get width() {
      var t;
      return (
        (null !== (t = this.attribute.width) && void 0 !== t ? t : 0) + this._marginArray[1] + this._marginArray[3]
      );
    }
    get height() {
      var t;
      return (
        (null !== (t = this.attribute.height) && void 0 !== t ? t : 0) + this._marginArray[0] + this._marginArray[2]
      );
    }
    tryUpdateAABBBounds() {
      if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
      this.doUpdateAABBBounds();
      const { width: t = NA.width, height: e = NA.height } = this.attribute,
        { backgroundWidth: i = t, backgroundHeight: n = e } = this.attribute,
        s = (i - t) / 2,
        r = (n - e) / 2;
      return this._AABBBounds.expand([0, 2 * s, 2 * r, 0]), this._AABBBounds;
    }
    setHoverState(t) {
      'hover' === this.attribute.backgroundShowMode && this._hovered !== t && (this._hovered = t);
    }
  }
  class oO {
    constructor(t, e, i, n, s, r, a, o) {
      (this.left = t),
        (this.width = e),
        (this.baseline = i),
        (this.ascent = n),
        (this.descent = s),
        (this.top = i - n),
        (this.paragraphs = r.map(t => t)),
        (this.textAlign =
          (this.paragraphs[0] instanceof aO
            ? this.paragraphs[0].attribute.textAlign
            : this.paragraphs[0].character.textAlign) || 'left'),
        (this.direction = a),
        (this.directionKey = GA[this.direction]);
      const l = this.directionKey;
      this.actualWidth = 0;
      let h = 0;
      this.paragraphs.forEach((t, e) => {
        if (0 === e && t instanceof nO) {
          const e = KA.exec(t.text);
          0 !== (null == e ? void 0 : e.index) &&
            ((t.text = t.text.slice(null == e ? void 0 : e.index)), t.updateWidth());
        }
        (this.actualWidth += t[this.directionKey.width]), (h = Math.max(t[this.directionKey.height], h));
      }),
        (this.height = h),
        (this.blankWidth = o ? 0 : this.width - this.actualWidth);
      let c = this.left,
        d = 0;
      if (this.actualWidth < e && !o)
        switch (this.textAlign) {
          case 'right':
            c = e - this.actualWidth;
            break;
          case 'center':
            c = (e - this.actualWidth) / 2;
            break;
          case 'justify':
            this.paragraphs.length < 2
              ? (c = (e - this.actualWidth) / 2)
              : (d = (e - this.actualWidth) / (this.paragraphs.length - 1));
        }
      this.paragraphs.map(function (t) {
        t instanceof aO
          ? ((t['_' + l.x] = c),
            (c += t[l.width] + d),
            (t['_' + l.y] =
              'top' === t.attribute.textBaseline
                ? 0
                : 'bottom' === t.attribute.textBaseline
                ? h - t.height
                : (h - t.height) / 2))
          : ((t[l.left] = c), (c += t[l.width] + d));
      });
    }
    draw(t, e, i, n, s) {
      if (e) {
        let t = 0;
        for (let e = this.paragraphs.length - 1; e >= 0; e--) {
          const i = this.paragraphs[e];
          if (i instanceof aO) break;
          if ('vertical' === this.direction && 'vertical' !== i.direction) {
            i.verticalEllipsis = !0;
            break;
          }
          const { width: n } = JA('...', i.character),
            s = n || 0;
          if (s <= this.blankWidth + t) {
            i.ellipsis = 'add';
            break;
          }
          if (s <= this.blankWidth + t + i.width) {
            (i.ellipsis = 'replace'), (i.ellipsisWidth = s), (i.ellipsisOtherParagraphWidth = this.blankWidth + t);
            break;
          }
          (i.ellipsis = 'hide'), (t += i.width);
        }
      }
      this.paragraphs.map((e, r) => {
        if (e instanceof aO)
          return e.setAttributes({ x: i + e._x, y: n + e._y }), void s(e, t, i + e._x, n + e._y, this.ascent);
        e.draw(t, n + this.ascent, i, 0 === r, this.textAlign);
      });
    }
    getWidthWithEllips() {
      let t = 0;
      for (let e = this.paragraphs.length - 1; e >= 0; e--) {
        const i = this.paragraphs[e];
        if (i instanceof aO) break;
        const { width: n } = JA('...', i.character),
          s = n || 0;
        if (s <= this.blankWidth + t) {
          (i.ellipsis = 'add'), (i.ellipsisWidth = s);
          break;
        }
        if (s <= this.blankWidth + t + i.width) {
          (i.ellipsis = 'replace'), (i.ellipsisWidth = s), (i.ellipsisOtherParagraphWidth = this.blankWidth + t);
          break;
        }
        (i.ellipsis = 'hide'), (t += i.width);
      }
      let e = 0;
      return (
        this.paragraphs.map((t, i) => {
          e += t instanceof aO ? t.width : t.getWidthWithEllips(this.direction);
        }),
        e
      );
    }
  }
  class lO {
    constructor(t) {
      (this.frame = t),
        (this.width = this.frame.width),
        (this.height = this.frame.height),
        (this.lineWidth = 0),
        (this.y = this.frame.top),
        (this.maxAscent = 0),
        (this.maxDescent = 0),
        (this.maxAscentForBlank = 0),
        (this.maxDescentForBlank = 0),
        (this.lineBuffer = []),
        (this.direction = t.layoutDirection),
        (this.directionKey = GA[this.direction]);
    }
    store(t) {
      if (t instanceof aO) {
        this.frame.icons.set(t.richtextId, t), this.lineBuffer.push(t), (this.lineWidth += t[this.directionKey.width]);
        let e = 0,
          i = 0;
        'top' === t.attribute.textBaseline
          ? ((e = 0), (i = t.height))
          : 'bottom' === t.attribute.textBaseline
          ? ((e = t.height), (i = 0))
          : ((e = t.height / 2), (i = t.height / 2)),
          (this.maxAscent = Math.max(this.maxAscent, e)),
          (this.maxDescent = Math.max(this.maxDescent, i));
      } else this.lineBuffer.push(t), 0 !== t.text.length ? ((this.lineWidth += t[this.directionKey.width]), (this.maxAscent = Math.max(this.maxAscent, t.ascent)), (this.maxDescent = Math.max(this.maxDescent, t.descent))) : ((this.maxAscentForBlank = Math.max(this.maxAscentForBlank, t.ascent)), (this.maxDescentForBlank = Math.max(this.maxDescentForBlank, t.descent)));
    }
    send() {
      if (0 === this.lineBuffer.length) return;
      const t = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent,
        e = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent,
        i = new oO(
          this.frame.left,
          this[this.directionKey.width],
          this.y + t,
          t,
          e,
          this.lineBuffer,
          this.direction,
          'horizontal' === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax
        );
      this.frame.lines.push(i),
        (this.frame.actualHeight += i.height),
        (this.y += i.height),
        (this.lineBuffer.length = 0),
        (this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0);
    }
    deal(t) {
      t instanceof aO
        ? ('horizontal' === this.direction && 0 === this.width) ||
          ('vertical' === this.direction && 0 === this.height) ||
          this.lineWidth + t[this.directionKey.width] <= this[this.directionKey.width]
          ? this.store(t)
          : 0 === this.lineBuffer.length
          ? (this.store(t), this.send())
          : (this.send(), this.deal(t))
        : 'number' != typeof this.width ||
          this.width < 0 ||
          (t.newLine && this.send(),
          0 !== t.text.length &&
            (('horizontal' === this.direction && 0 === this.width) ||
            ('vertical' === this.direction && 0 === this.height) ||
            this.lineWidth + t[this.directionKey.width] <= this[this.directionKey.width]
              ? this.store(t)
              : this.lineWidth === this[this.directionKey.width]
              ? (this.send(), this.deal(t))
              : this.cut(t)));
    }
    cut(t) {
      const e = this[this.directionKey.width] - this.lineWidth || 0,
        i = Math.ceil((e / t[this.directionKey.width]) * t.length) || 0,
        n = qA(t.text, e, t.character, i, 'break-word' === this.frame.wordBreak);
      if (0 !== n) {
        const [e, i] = (function (t, e) {
          const i = t.text.slice(0, e),
            n = t.text.slice(e);
          return [new nO(i, t.newLine, t.character), new nO(n, !0, t.character)];
        })(t, n);
        this.store(e), this.deal(i);
      } else 0 !== this.lineBuffer.length && (this.send(), this.deal(t));
    }
  }
  const hO = [
    'width',
    'height',
    'ellipsis',
    'wordBreak',
    'verticalDirection',
    'maxHeight',
    'maxWidth',
    'textAlign',
    'textBaseline',
    'textConfig',
    'layoutDirection',
    ...VT
  ];
  class cO extends $T {
    constructor(t) {
      super(t), (this.type = 'richtext'), (this._currentHoverIcon = null), (this.numberType = LE);
    }
    get width() {
      var t;
      return null !== (t = this.attribute.width) && void 0 !== t ? t : HA.width;
    }
    set width(t) {
      this.attribute.width !== t && ((this.attribute.width = t), this.addUpdateShapeAndBoundsTag());
    }
    get height() {
      var t;
      return null !== (t = this.attribute.height) && void 0 !== t ? t : HA.height;
    }
    set height(t) {
      this.attribute.height !== t && ((this.attribute.height = t), this.addUpdateShapeAndBoundsTag());
    }
    get maxWidth() {
      return this.attribute.maxWidth;
    }
    set maxWidth(t) {
      this.attribute.maxWidth !== t && ((this.attribute.maxWidth = t), this.addUpdateShapeAndBoundsTag());
    }
    get maxHeight() {
      return this.attribute.maxHeight;
    }
    set maxHeight(t) {
      this.attribute.maxHeight !== t && ((this.attribute.maxHeight = t), this.addUpdateShapeAndBoundsTag());
    }
    get ellipsis() {
      var t;
      return null !== (t = this.attribute.ellipsis) && void 0 !== t ? t : HA.ellipsis;
    }
    set ellipsis(t) {
      this.attribute.ellipsis !== t && ((this.attribute.ellipsis = t), this.addUpdateShapeAndBoundsTag());
    }
    get wordBreak() {
      var t;
      return null !== (t = this.attribute.wordBreak) && void 0 !== t ? t : HA.wordBreak;
    }
    set wordBreak(t) {
      this.attribute.wordBreak !== t && ((this.attribute.wordBreak = t), this.addUpdateShapeAndBoundsTag());
    }
    get verticalDirection() {
      var t;
      return null !== (t = this.attribute.verticalDirection) && void 0 !== t ? t : HA.verticalDirection;
    }
    set verticalDirection(t) {
      this.attribute.verticalDirection !== t &&
        ((this.attribute.verticalDirection = t), this.addUpdateShapeAndBoundsTag());
    }
    get textAlign() {
      var t;
      return null !== (t = this.attribute.textAlign) && void 0 !== t ? t : HA.textAlign;
    }
    set textAlign(t) {
      this.attribute.textAlign !== t && ((this.attribute.textAlign = t), this.addUpdateShapeAndBoundsTag());
    }
    get textBaseline() {
      var t;
      return null !== (t = this.attribute.textBaseline) && void 0 !== t ? t : HA.textBaseline;
    }
    set textBaseline(t) {
      this.attribute.textBaseline !== t && ((this.attribute.textBaseline = t), this.addUpdateShapeAndBoundsTag());
    }
    get textConfig() {
      var t;
      return null !== (t = this.attribute.textConfig) && void 0 !== t ? t : HA.textConfig;
    }
    set textConfig(t) {
      (this.attribute.textConfig = t), this.addUpdateShapeAndBoundsTag();
    }
    doUpdateAABBBounds() {
      const t = Zk(this).richtext;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const e = this.attribute,
        i = WA.graphicService.updateRichTextAABBBounds(e, Zk(this).richtext, this._AABBBounds, this),
        { boundsPadding: n = t.boundsPadding } = e,
        s = DM(n);
      return s && i.expand(s), this.clearUpdateBoundTag(), i;
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    getDefaultAttribute(t) {
      return HA[t];
    }
    needUpdateTags(t) {
      for (let e = 0; e < hO.length; e++) {
        const i = hO[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < hO.length; e++) if (t === hO[e]) return !0;
      return !1;
    }
    getFrameCache() {
      return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), this._frameCache;
    }
    doUpdateFrameCache() {
      var t;
      const {
          textConfig: e,
          maxWidth: i,
          maxHeight: n,
          width: s,
          height: r,
          ellipsis: a,
          wordBreak: o,
          verticalDirection: l,
          textAlign: h,
          textBaseline: c,
          layoutDirection: d,
          singleLine: u
        } = this.attribute,
        p = [];
      for (let t = 0; t < e.length; t++)
        if ('image' in e[t]) {
          const i = e[t],
            n = i.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(i.id);
          if (n) p.push(n);
          else {
            const t = new aO(i);
            (t.successCallback = () => {
              var t;
              this.addUpdateBoundTag(), null === (t = this.stage) || void 0 === t || t.renderNextFrame();
            }),
              (t.richtextId = i.id),
              p.push(t);
          }
        } else if (e[t].text.includes('\n')) {
          const i = e[t].text.split('\n');
          for (let n = 0; n < i.length; n++) p.push(new nO(i[n], 0 !== n, e[t]));
        } else p.push(new nO(e[t].text, !1, e[t]));
      const g = new iO(
          0,
          0,
          ('number' == typeof i && (!s || s > i) ? i : s) || 0,
          ('number' == typeof n && (!r || r > n) ? n : r) || 0,
          a,
          o,
          l,
          h,
          c,
          d || 'horizontal',
          'number' == typeof i && (!s || s > i),
          'number' == typeof n && (!r || r > n),
          u || !1,
          null === (t = this._frameCache) || void 0 === t ? void 0 : t.icons
        ),
        f = new lO(g);
      for (let t = 0; t < p.length; t++) f.deal(p[t]);
      f.send(), (this._frameCache = g);
    }
    clone() {
      return new cO(Object.assign({}, this.attribute));
    }
    setStage(t, e) {
      super.setStage(t, e),
        this.getFrameCache().icons.forEach(i => {
          i.setStage(t, e);
        });
    }
    bindIconEvent() {
      this.addEventListener('pointermove', t => {
        var e, i, n, s, r;
        const a = this.pickIcon(t.global);
        (a && a === this._currentHoverIcon) ||
          (a
            ? (null === (e = this._currentHoverIcon) || void 0 === e || e.setHoverState(!1),
              (this._currentHoverIcon = a),
              this._currentHoverIcon.setHoverState(!0),
              null === (i = this.stage) || void 0 === i || i.setCursor(a.attribute.cursor),
              null === (n = this.stage) || void 0 === n || n.renderNextFrame())
            : !a &&
              this._currentHoverIcon &&
              (this._currentHoverIcon.setHoverState(!1),
              (this._currentHoverIcon = null),
              null === (s = this.stage) || void 0 === s || s.setCursor(),
              null === (r = this.stage) || void 0 === r || r.renderNextFrame()));
      }),
        this.addEventListener('pointerleave', t => {
          var e, i;
          this._currentHoverIcon &&
            (this._currentHoverIcon.setHoverState(!1),
            (this._currentHoverIcon = null),
            null === (e = this.stage) || void 0 === e || e.setCursor(),
            null === (i = this.stage) || void 0 === i || i.renderNextFrame());
        });
    }
    pickIcon(t) {
      const e = this.getFrameCache(),
        { e: i, f: n } = this.globalTransMatrix;
      let s;
      return (
        e.icons.forEach(e => {
          var r, a;
          e.AABBBounds.containsPoint({ x: t.x - i, y: t.y - n }) &&
            ((s = e),
            (s.globalX = (null !== (r = s.attribute.x) && void 0 !== r ? r : 0) + i),
            (s.globalY = (null !== (a = s.attribute.y) && void 0 !== a ? a : 0) + n));
        }),
        s
      );
    }
  }
  const dO = ['path', 'customPath', ...VT];
  class uO extends $T {
    constructor(t) {
      super(t), (this.type = 'path'), (this.numberType = RE);
    }
    get pathShape() {
      return this.tryUpdateAABBBounds(), this.getParsedPathShape();
    }
    isValid() {
      return super.isValid() && this._isValid();
    }
    _isValid() {
      const { path: t } = this.attribute;
      return null != t && '' !== t;
    }
    getParsedPathShape() {
      const t = Zk(this).path;
      if (!this.valid) return t.path;
      const e = this.attribute;
      return e.path instanceof mA
        ? e.path
        : (l(this.cache) && this.doUpdatePathShape(), this.cache instanceof mA ? this.cache : t.path);
    }
    doUpdateAABBBounds() {
      const t = Zk(this).path;
      this.doUpdatePathShape(), this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const e = this.attribute,
        i = WA.graphicService.updatePathAABBBounds(e, Zk(this).path, this._AABBBounds, this),
        { boundsPadding: n = t.boundsPadding } = e,
        s = DM(n);
      return s && i.expand(s), this.clearUpdateBoundTag(), i;
    }
    doUpdatePathShape() {
      const t = this.attribute;
      g(t.path, !0)
        ? (this.cache = new mA().fromString(t.path))
        : t.customPath && ((this.cache = new mA()), t.customPath(this.cache, this));
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    getDefaultAttribute(t) {
      return Zk(this).path[t];
    }
    needUpdateTags(t) {
      for (let e = 0; e < dO.length; e++) {
        const i = dO[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < dO.length; e++) if (t === dO[e]) return !0;
      return !1;
    }
    toCustomPath() {
      return new mA().fromCustomPath2D(this.getParsedPathShape(), 0, 0);
    }
    clone() {
      return new uO(Object.assign({}, this.attribute));
    }
  }
  const pO = ['segments', 'points', 'curveType', ...VT];
  class gO extends $T {
    constructor(t) {
      super(t), (this.type = 'area'), (this.numberType = kE);
    }
    isValid() {
      return super.isValid() && this._isValid();
    }
    _isValid() {
      const { points: t, segments: e } = this.attribute;
      return e ? 0 !== e.length : !!t && 0 !== t.length;
    }
    doUpdateAABBBounds() {
      const t = Zk(this).area;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const e = this.attribute,
        i = WA.graphicService.updateAreaAABBBounds(e, Zk(this).area, this._AABBBounds, this),
        { boundsPadding: n = t.boundsPadding } = e,
        s = DM(n);
      return s && i.expand(s), this.clearUpdateBoundTag(), i;
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    _interpolate(t, e, i, n, s) {
      'points' === t && (s.points = HM(i, n, e));
    }
    getDefaultAttribute(t) {
      return Zk(this).area[t];
    }
    needUpdateTags(t) {
      for (let e = 0; e < pO.length; e++) {
        const i = pO[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < pO.length; e++) if (t === pO[e]) return !0;
      return !1;
    }
    toCustomPath() {
      const t = new mA(),
        e = this.attribute,
        i = e.segments,
        n = e => {
          if (e && e.length) {
            let i = !0;
            const n = [];
            if (
              (e.forEach(e => {
                var s, r;
                !1 !== e.defined &&
                  (i ? t.moveTo(e.x, e.y) : t.lineTo(e.x, e.y),
                  n.push({
                    x: null !== (s = e.x1) && void 0 !== s ? s : e.x,
                    y: null !== (r = e.y1) && void 0 !== r ? r : e.y
                  }),
                  (i = !1));
              }),
              n.length)
            ) {
              for (let e = n.length - 1; e >= 0; e--) t.lineTo(n[e].x, n[e].y);
              t.closePath();
            }
          }
        };
      return (
        e.points
          ? n(e.points)
          : i &&
            i.length &&
            i.forEach(t => {
              n(t.points);
            }),
        t
      );
    }
    clone() {
      return new gO(Object.assign({}, this.attribute));
    }
  }
  const fO = [
    'innerRadius',
    'outerRadius',
    'startAngle',
    'endAngle',
    'cornerRadius',
    'padAngle',
    'padRadius',
    'cap',
    ...VT
  ];
  class vO extends $T {
    constructor(t) {
      super(t), (this.type = 'arc'), (this.numberType = wE);
    }
    isValid() {
      return super.isValid() && this._isValid();
    }
    _isValid() {
      const { startAngle: t, endAngle: e, outerRadius: i, innerRadius: n } = this.attribute;
      return this._validNumber(t) && this._validNumber(e) && this._validNumber(i) && this._validNumber(n);
    }
    getParsedCornerRadius() {
      const t = Zk(this).arc,
        {
          cornerRadius: e = t.cornerRadius,
          outerRadius: i = t.outerRadius,
          innerRadius: n = t.innerRadius
        } = this.attribute;
      if (0 === e || '0%' === e) return 0;
      const s = Math.abs(i - n);
      return Math.min(y(e, !0) ? e : (s * parseFloat(e)) / 100, s / 2);
    }
    getParsedAngle() {
      const t = Zk(this).arc;
      let { startAngle: e = t.startAngle, endAngle: i = t.endAngle } = this.attribute;
      const { cap: n = t.cap } = this.attribute,
        s = i - e >= 0 ? 1 : -1,
        r = i - e;
      if (((e = Qt(e)), (i = e + r), n && Pt(r) < Et - kt)) {
        let r = 1,
          a = 1;
        n.length && ((r = Number(n[0])), (a = Number(n[1])));
        const { outerRadius: o = t.outerRadius, innerRadius: l = t.innerRadius } = this.attribute,
          h = Math.abs(o - l) / 2,
          c = h / o;
        if (h > kt && o > kt)
          return { startAngle: e - s * c * r, endAngle: i + s * c * a, sc: s * c * r, ec: s * c * a };
      }
      return { startAngle: e, endAngle: i };
    }
    getParsePadAngle(t, e) {
      const i = Zk(this).arc,
        { outerRadius: n = i.outerRadius, innerRadius: s = i.innerRadius, padAngle: r = i.padAngle } = this.attribute,
        { padRadius: a = Lt(n * n + s * s) } = this.attribute,
        o = Pt(e - t);
      let l = t,
        h = e,
        c = t,
        d = e;
      const u = r / 2;
      let p = o,
        g = o;
      if (u > kt && a > kt) {
        const i = e > t ? 1 : -1;
        let r = zt((Number(a) / s) * Dt(u)),
          o = zt((Number(a) / n) * Dt(u));
        return (
          (p -= 2 * r) > kt ? ((r *= i), (c += r), (d -= r)) : ((p = 0), (c = d = (t + e) / 2)),
          (g -= 2 * o) > kt ? ((o *= i), (l += o), (h -= o)) : ((g = 0), (l = h = (t + e) / 2)),
          {
            outerStartAngle: l,
            outerEndAngle: h,
            innerStartAngle: c,
            innerEndAngle: d,
            innerDeltaAngle: p,
            outerDeltaAngle: g
          }
        );
      }
      return {
        outerStartAngle: l,
        outerEndAngle: h,
        innerStartAngle: c,
        innerEndAngle: d,
        innerDeltaAngle: p,
        outerDeltaAngle: g
      };
    }
    doUpdateAABBBounds(t) {
      const e = Zk(this).arc;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const i = this.attribute,
        n = WA.graphicService.updateArcAABBBounds(i, Zk(this).arc, this._AABBBounds, t, this),
        { boundsPadding: s = e.boundsPadding } = i,
        r = DM(s);
      return r && n.expand(r), this.clearUpdateBoundTag(), n;
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    needUpdateTags(t) {
      for (let e = 0; e < fO.length; e++) {
        const i = fO[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < fO.length; e++) if (t === fO[e]) return !0;
      return !1;
    }
    getDefaultAttribute(t) {
      return Zk(this).arc[t];
    }
    toCustomPath() {
      const t = this.attribute,
        { startAngle: e, endAngle: i } = this.getParsedAngle();
      let n = t.innerRadius,
        s = t.outerRadius;
      const r = Pt(i - e),
        a = i > e;
      if (s < n) {
        const t = s;
        (s = n), (n = t);
      }
      const o = new mA();
      if (s <= kt) o.moveTo(0, 0);
      else if (r >= Et - kt)
        o.moveTo(0 + s * Ot(e), 0 + s * Dt(e)),
          o.arc(0, 0, s, e, i, !a),
          n > kt && (o.moveTo(0 + n * Ot(i), 0 + n * Dt(i)), o.arc(0, 0, n, i, e, a));
      else {
        const t = s * Ot(e),
          r = s * Dt(e),
          l = n * Ot(i),
          h = n * Dt(i);
        o.moveTo(0 + t, 0 + r),
          o.arc(0, 0, s, e, i, !a),
          o.lineTo(0 + l, 0 + h),
          o.arc(0, 0, n, i, e, a),
          o.closePath();
      }
      return o;
    }
    clone() {
      return new vO(Object.assign({}, this.attribute));
    }
  }
  class mO extends vO {
    constructor(t) {
      super(t), (this.type = 'arc3d'), (this.numberType = AE);
    }
    doUpdateAABBBounds() {
      const t = Zk(this).arc;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const e = this.attribute,
        i = WA.graphicService.updateArc3dAABBBounds(e, Zk(this).polygon, this._AABBBounds, this),
        { boundsPadding: n = t.boundsPadding } = e,
        s = DM(n);
      return s && i.expand(s), this.clearUpdateBoundTag(), this._AABBBounds;
    }
  }
  const yO = ['points', 'cornerRadius', ...VT];
  class _O extends $T {
    constructor(t) {
      super(t), (this.type = 'polygon'), (this.numberType = OE);
    }
    isValid() {
      return super.isValid() && this._isValid();
    }
    _isValid() {
      const { points: t } = this.attribute;
      return t && t.length >= 2;
    }
    doUpdateAABBBounds() {
      const t = Zk(this).polygon;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const e = this.attribute,
        i = WA.graphicService.updatePolygonAABBBounds(e, Zk(this).polygon, this._AABBBounds, this),
        { boundsPadding: n = t.boundsPadding } = e,
        s = DM(n);
      return s && i.expand(s), this.clearUpdateBoundTag(), this._AABBBounds;
    }
    tryUpdateOBBBounds() {
      throw new Error('暂不支持');
    }
    _interpolate(t, e, i, n, s) {
      'points' === t && (s.points = HM(i, n, e));
    }
    getDefaultAttribute(t) {
      return Zk(this).polygon[t];
    }
    needUpdateTags(t) {
      for (let e = 0; e < yO.length; e++) {
        const i = yO[e];
        if (-1 !== t.indexOf(i)) return !0;
      }
      return !1;
    }
    needUpdateTag(t) {
      for (let e = 0; e < yO.length; e++) if (t === yO[e]) return !0;
      return !1;
    }
    toCustomPath() {
      const t = this.attribute.points,
        e = new mA();
      return (
        t.forEach((t, i) => {
          0 === i ? e.moveTo(t.x, t.y) : e.lineTo(t.x, t.y);
        }),
        e.closePath(),
        e
      );
    }
    clone() {
      return new _O(Object.assign({}, this.attribute));
    }
  }
  class bO extends _O {
    constructor(t) {
      super(t), (this.type = 'pyramid3d'), (this.numberType = BE);
    }
    doUpdateAABBBounds() {
      const t = Zk(this).polygon;
      this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      const e = this.attribute,
        i = WA.graphicService.updatePyramid3dAABBBounds(e, Zk(this).polygon, this._AABBBounds, this),
        { boundsPadding: n = t.boundsPadding } = e,
        s = DM(n);
      return s && i.expand(s), this.clearUpdateBoundTag(), this._AABBBounds;
    }
    findFace() {
      const { points: t } = this.attribute,
        e = t.map((e, i) => {
          const n = 3 === i ? t[0] : t[i + 1],
            s = e.x - n.x;
          return 0 === s ? 0 : (e.y - n.y) / s;
        }),
        i = t.map(t => ({ p: t, d: 0 }));
      let n = !1,
        s = 0;
      for (let t = 0; t < e.length - 1; t++) {
        for (let r = t + 1; r < e.length; r++) {
          if (e[t] === e[r]) {
            n = !0;
            const e = Yt.distancePP(i[t].p, i[t + 1].p);
            (i[t].d = e), (i[t + 1].d = e), (s = Bt(s, e));
            const a = Yt.distancePP(i[r].p, i[r + 1].p);
            (i[r].d = a), (i[r + 1].d = a), (s = Bt(s, a));
          }
          if (n) break;
        }
        if (n) break;
      }
      for (let e = t.length - 1; e >= 0; e--) {
        const n = t[e];
        i.unshift({ p: n, d: 0 });
      }
      for (let e = 0; e < t.length; e++) {
        const n = (s - i[e + t.length].d) / 2;
        (i[e].d += n), (i[e + t.length].d += n);
      }
      const r = { polygons: [], vertices: [], edges: [] };
      return (
        i.forEach(t => {
          r.vertices.push([t.p.x, t.p.y, t.d]);
        }),
        r.polygons.push({ polygon: [0, 4, 5, 1], normal: [0, -1, 0] }),
        r.polygons.push({ polygon: [7, 6, 2, 3], normal: [0, 1, 0] }),
        r.polygons.push({ polygon: [0, 4, 7, 3], normal: [-1, 0, 0] }),
        r.polygons.push({ polygon: [1, 5, 6, 2], normal: [1, 0, 0] }),
        r.polygons.push({ polygon: [0, 1, 2, 3], normal: [0, 0, -1] }),
        r.polygons.push({ polygon: [4, 5, 6, 7], normal: [0, 0, 1] }),
        (r.edges = [
          [0, 1],
          [1, 2],
          [2, 3],
          [3, 0],
          [4, 5],
          [5, 6],
          [6, 7],
          [7, 4],
          [0, 4],
          [3, 7],
          [1, 5],
          [2, 6]
        ]),
        r
      );
    }
    _isValid() {
      return super._isValid() && 4 === this.attribute.points.length;
    }
  }
  var xO = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let SO = class {
    updateBounds(t, e, i, n) {
      const { outerBorder: s, shadowBlur: r = e.shadowBlur } = t;
      if (s) {
        const t = e.outerBorder,
          { distance: n = t.distance, lineWidth: a = t.lineWidth } = s;
        i.expand(n + r + a / 2);
      }
      return i;
    }
  };
  SO = xO([ZS()], SO);
  var wO = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  const AO = Symbol.for('RectBoundsContribution');
  let kO = class extends SO {};
  kO = wO([ZS()], kO);
  var MO = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  const TO = Symbol.for('SymbolBoundsContribution');
  let CO = class extends SO {
    updateBounds(t, e, i, n) {
      const { outerBorder: s, shadowBlur: r = e.shadowBlur, strokeBoundsBuffer: a = e.strokeBoundsBuffer } = t;
      if (s) {
        const t = e.outerBorder,
          { distance: n = t.distance, lineWidth: o = t.lineWidth } = s;
        fE(i, n + r + o / 2, !0, a);
      }
      return i;
    }
  };
  CO = MO([ZS()], CO);
  var EO = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  const PO = Symbol.for('CircleBoundsContribution');
  let RO = class extends SO {};
  RO = EO([ZS()], RO);
  var OO = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  const BO = Symbol.for('ArcBoundsContribution');
  let IO = class extends SO {};
  IO = OO([ZS()], IO);
  var DO = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  const LO = Symbol.for('PathBoundsContribution');
  let FO = class extends SO {};
  FO = DO([ZS()], FO);
  class jO {
    constructor() {
      this.pools = [];
    }
    static identity(t) {
      return (
        (t[0] = 1),
        (t[1] = 0),
        (t[2] = 0),
        (t[3] = 0),
        (t[4] = 0),
        (t[5] = 1),
        (t[6] = 0),
        (t[7] = 0),
        (t[8] = 0),
        (t[9] = 0),
        (t[10] = 1),
        (t[11] = 0),
        (t[12] = 0),
        (t[13] = 0),
        (t[14] = 0),
        (t[15] = 1),
        t
      );
    }
    allocate() {
      if (!this.pools.length) return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      const t = this.pools.pop();
      return jO.identity(t), t;
    }
    allocateByObj(t) {
      let e;
      e = this.pools.length ? this.pools.pop() : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      for (let i = 0; i < e.length; i++) e[i] = t[i];
      return e;
    }
    free(t) {
      t && this.pools.push(t);
    }
    get length() {
      return this.pools.length;
    }
    release() {
      this.pools = [];
    }
  }
  const zO = new (class {
      constructor() {
        this.pools = [];
      }
      allocate(t, e, i, n, s, r) {
        if (!this.pools.length) return new ie(t, e, i, n, s, r);
        const a = this.pools.pop();
        return (a.a = t), (a.b = e), (a.c = i), (a.d = n), (a.e = s), (a.f = r), a;
      }
      allocateByObj(t) {
        if (!this.pools.length) return new ie(t.a, t.b, t.c, t.d, t.e, t.f);
        const e = this.pools.pop();
        return (e.a = t.a), (e.b = t.b), (e.c = t.c), (e.d = t.d), (e.e = t.e), (e.f = t.f), e;
      }
      free(t) {
        this.pools.push(t);
      }
      get length() {
        return this.pools.length;
      }
      release() {
        this.pools = [];
      }
    })(),
    HO = new jO();
  var NO = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    VO = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    WO = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  function GO(t, e, i) {
    const n = i[0],
      s = i[1],
      r = i[2];
    let a, o, l, h, c, d, u, p, g, f, v, m;
    return (
      e === t
        ? ((t[12] = e[0] * n + e[4] * s + e[8] * r + e[12]),
          (t[13] = e[1] * n + e[5] * s + e[9] * r + e[13]),
          (t[14] = e[2] * n + e[6] * s + e[10] * r + e[14]),
          (t[15] = e[3] * n + e[7] * s + e[11] * r + e[15]))
        : ((a = e[0]),
          (o = e[1]),
          (l = e[2]),
          (h = e[3]),
          (c = e[4]),
          (d = e[5]),
          (u = e[6]),
          (p = e[7]),
          (g = e[8]),
          (f = e[9]),
          (v = e[10]),
          (m = e[11]),
          (t[0] = a),
          (t[1] = o),
          (t[2] = l),
          (t[3] = h),
          (t[4] = c),
          (t[5] = d),
          (t[6] = u),
          (t[7] = p),
          (t[8] = g),
          (t[9] = f),
          (t[10] = v),
          (t[11] = m),
          (t[12] = a * n + c * s + g * r + e[12]),
          (t[13] = o * n + d * s + f * r + e[13]),
          (t[14] = l * n + u * s + v * r + e[14]),
          (t[15] = h * n + p * s + m * r + e[15])),
      t
    );
  }
  function UO(t, e) {
    (t[0] = e.a),
      (t[1] = e.b),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = e.c),
      (t[5] = e.d),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = 0),
      (t[9] = 0),
      (t[10] = 1),
      (t[11] = 0),
      (t[12] = e.e),
      (t[13] = e.f),
      (t[14] = 0),
      (t[15] = 1);
  }
  function YO(t, e, i) {
    const n = e[0],
      s = e[1],
      r = e[2],
      a = e[3],
      o = e[4],
      l = e[5],
      h = e[6],
      c = e[7],
      d = e[8],
      u = e[9],
      p = e[10],
      g = e[11],
      f = e[12],
      v = e[13],
      m = e[14],
      y = e[15];
    let _ = i[0],
      b = i[1],
      x = i[2],
      S = i[3];
    return (
      (t[0] = _ * n + b * o + x * d + S * f),
      (t[1] = _ * s + b * l + x * u + S * v),
      (t[2] = _ * r + b * h + x * p + S * m),
      (t[3] = _ * a + b * c + x * g + S * y),
      (_ = i[4]),
      (b = i[5]),
      (x = i[6]),
      (S = i[7]),
      (t[4] = _ * n + b * o + x * d + S * f),
      (t[5] = _ * s + b * l + x * u + S * v),
      (t[6] = _ * r + b * h + x * p + S * m),
      (t[7] = _ * a + b * c + x * g + S * y),
      (_ = i[8]),
      (b = i[9]),
      (x = i[10]),
      (S = i[11]),
      (t[8] = _ * n + b * o + x * d + S * f),
      (t[9] = _ * s + b * l + x * u + S * v),
      (t[10] = _ * r + b * h + x * p + S * m),
      (t[11] = _ * a + b * c + x * g + S * y),
      (_ = i[12]),
      (b = i[13]),
      (x = i[14]),
      (S = i[15]),
      (t[12] = _ * n + b * o + x * d + S * f),
      (t[13] = _ * s + b * l + x * u + S * v),
      (t[14] = _ * r + b * h + x * p + S * m),
      (t[15] = _ * a + b * c + x * g + S * y),
      t
    );
  }
  function $O(t, e, i) {
    var n;
    const {
        x: s = i.x,
        y: r = i.y,
        z: a = i.z,
        dx: o = i.dx,
        dy: l = i.dy,
        dz: h = i.dz,
        scaleX: c = i.scaleX,
        scaleY: d = i.scaleY,
        scaleZ: u = i.scaleZ,
        alpha: p = i.alpha,
        beta: g = i.beta,
        angle: f = i.angle,
        anchor3d: v = e.attribute.anchor,
        anchor: m
      } = e.attribute,
      y = [0, 0, 0];
    if (v) {
      if ('string' == typeof v[0]) {
        const t = parseFloat(v[0]) / 100,
          i = e.AABBBounds;
        y[0] = i.x1 + (i.x2 - i.x1) * t;
      } else y[0] = v[0];
      if ('string' == typeof v[1]) {
        const t = parseFloat(v[1]) / 100,
          i = e.AABBBounds;
        y[1] = i.x1 + (i.x2 - i.x1) * t;
      } else y[1] = v[1];
      y[2] = null !== (n = v[2]) && void 0 !== n ? n : 0;
    }
    if (
      ((function (t) {
        (t[0] = 1),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = 0),
          (t[5] = 1),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 0),
          (t[9] = 0),
          (t[10] = 1),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1);
      })(t),
      GO(t, t, [s + o, r + l, a + h]),
      GO(t, t, [y[0], y[1], y[2]]),
      (function (t, e, i) {
        const n = Math.sin(i),
          s = Math.cos(i),
          r = e[4],
          a = e[5],
          o = e[6],
          l = e[7],
          h = e[8],
          c = e[9],
          d = e[10],
          u = e[11];
        e !== t &&
          ((t[0] = e[0]),
          (t[1] = e[1]),
          (t[2] = e[2]),
          (t[3] = e[3]),
          (t[12] = e[12]),
          (t[13] = e[13]),
          (t[14] = e[14]),
          (t[15] = e[15])),
          (t[4] = r * s + h * n),
          (t[5] = a * s + c * n),
          (t[6] = o * s + d * n),
          (t[7] = l * s + u * n),
          (t[8] = h * s - r * n),
          (t[9] = c * s - a * n),
          (t[10] = d * s - o * n),
          (t[11] = u * s - l * n);
      })(t, t, g),
      (function (t, e, i) {
        const n = Math.sin(i),
          s = Math.cos(i),
          r = e[0],
          a = e[1],
          o = e[2],
          l = e[3],
          h = e[8],
          c = e[9],
          d = e[10],
          u = e[11];
        e !== t &&
          ((t[4] = e[4]),
          (t[5] = e[5]),
          (t[6] = e[6]),
          (t[7] = e[7]),
          (t[12] = e[12]),
          (t[13] = e[13]),
          (t[14] = e[14]),
          (t[15] = e[15])),
          (t[0] = r * s - h * n),
          (t[1] = a * s - c * n),
          (t[2] = o * s - d * n),
          (t[3] = l * s - u * n),
          (t[8] = r * n + h * s),
          (t[9] = a * n + c * s),
          (t[10] = o * n + d * s),
          (t[11] = l * n + u * s);
      })(t, t, p),
      GO(t, t, [-y[0], -y[1], y[2]]),
      (function (t, e, i) {
        const n = i[0],
          s = i[1],
          r = i[2];
        (t[0] = e[0] * n),
          (t[1] = e[1] * n),
          (t[2] = e[2] * n),
          (t[3] = e[3] * n),
          (t[4] = e[4] * s),
          (t[5] = e[5] * s),
          (t[6] = e[6] * s),
          (t[7] = e[7] * s),
          (t[8] = e[8] * r),
          (t[9] = e[9] * r),
          (t[10] = e[10] * r),
          (t[11] = e[11] * r),
          (t[12] = e[12]),
          (t[13] = e[13]),
          (t[14] = e[14]),
          (t[15] = e[15]);
      })(t, t, [c, d, u]),
      f)
    ) {
      const i = HO.allocate(),
        n = [0, 0];
      if (m) {
        if ('string' == typeof v[0]) {
          const t = parseFloat(v[0]) / 100,
            i = e.AABBBounds;
          n[0] = i.x1 + (i.x2 - i.x1) * t;
        } else n[0] = v[0];
        if ('string' == typeof v[1]) {
          const t = parseFloat(v[1]) / 100,
            i = e.AABBBounds;
          n[1] = i.x1 + (i.x2 - i.x1) * t;
        } else n[1] = v[1];
      }
      GO(i, i, [n[0], n[1], 0]),
        (function (t, e, i) {
          const n = Math.sin(i),
            s = Math.cos(i),
            r = e[0],
            a = e[1],
            o = e[2],
            l = e[3],
            h = e[4],
            c = e[5],
            d = e[6],
            u = e[7];
          e !== t &&
            ((t[8] = e[8]),
            (t[9] = e[9]),
            (t[10] = e[10]),
            (t[11] = e[11]),
            (t[12] = e[12]),
            (t[13] = e[13]),
            (t[14] = e[14]),
            (t[15] = e[15])),
            (t[0] = r * s + h * n),
            (t[1] = a * s + c * n),
            (t[2] = o * s + d * n),
            (t[3] = l * s + u * n),
            (t[4] = h * s - r * n),
            (t[5] = c * s - a * n),
            (t[6] = d * s - o * n),
            (t[7] = u * s - l * n);
        })(i, i, f),
        GO(i, i, [-n[0], -n[1], 0]),
        YO(t, t, i);
    }
  }
  let XO = class {
    constructor(t, e, i, n, s, r) {
      (this.creator = t),
        (this.rectBoundsContribitions = e),
        (this.symbolBoundsContribitions = i),
        (this.circleBoundsContribitions = n),
        (this.arcBoundsContribitions = s),
        (this.pathBoundsContribitions = r),
        (this.hooks = {
          onAttributeUpdate: new hw(['graphic']),
          onSetStage: new hw(['graphic', 'stage']),
          onRemove: new hw(['graphic']),
          onAddIncremental: new hw(['graphic', 'group', 'stage']),
          onClearIncremental: new hw(['graphic', 'group', 'stage']),
          beforeUpdateAABBBounds: new hw(['graphic', 'stage', 'willUpdate', 'aabbBounds']),
          afterUpdateAABBBounds: new hw(['graphic', 'stage', 'aabbBounds', 'globalAABBBounds', 'selfChange'])
        }),
        (this.tempAABBBounds1 = new Kt()),
        (this.tempAABBBounds2 = new Kt());
    }
    onAttributeUpdate(t) {
      this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(t);
    }
    onSetStage(t, e) {
      this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(t, e);
    }
    onRemove(t) {
      this.hooks.onRemove.taps.length && this.hooks.onRemove.call(t);
    }
    onAddIncremental(t, e, i) {
      this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(t, e, i);
    }
    onClearIncremental(t, e) {
      this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(t, e);
    }
    beforeUpdateAABBBounds(t, e, i, n) {
      this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(t, e, i, n);
    }
    afterUpdateAABBBounds(t, e, i, n, s) {
      this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(t, e, i, n, s);
    }
    updatePathProxyAABBBounds(t, e) {
      const i = 'function' == typeof e.pathProxy ? e.pathProxy(e.attribute) : e.pathProxy;
      if (!i) return !1;
      const n = new mw(t);
      return Nw(i.commandList, n, 0, 0), !0;
    }
    updateRectAABBBounds(t, e, i, n) {
      if (!this.updatePathProxyAABBBounds(i, n)) {
        const { width: n = e.width, height: s = e.height } = t;
        i.set(0, 0, n, s);
      }
      const s = this.tempAABBBounds1,
        r = this.tempAABBBounds2;
      return (
        s.setValue(i.x1, i.y1, i.x2, i.y2),
        r.setValue(i.x1, i.y1, i.x2, i.y2),
        this._rectBoundsContribitions ||
          (this._rectBoundsContribitions = this.rectBoundsContribitions.getContributions() || []),
        this._rectBoundsContribitions.length &&
          this._rectBoundsContribitions.forEach(a => {
            a.updateBounds(t, e, s, n), i.union(s), s.setValue(r.x1, r.y1, r.x2, r.y2);
          }),
        this.transformAABBBounds(t, i, e, !1, n),
        i
      );
    }
    updateGroupAABBBounds(t, e, i, n) {
      const { width: s, height: r, path: a, clip: o = e.clip } = t;
      a && a.length
        ? a.forEach(t => {
            i.union(t.AABBBounds);
          })
        : null != s && null != r && i.set(0, 0, s, r),
        o ||
          n.forEachChildren(t => {
            i.union(t.AABBBounds);
          });
      const l = this.tempAABBBounds1,
        h = this.tempAABBBounds2;
      return (
        l.setValue(i.x1, i.y1, i.x2, i.y2),
        h.setValue(i.x1, i.y1, i.x2, i.y2),
        this.transformAABBBounds(t, i, e, !1, n),
        i
      );
    }
    updateGlyphAABBBounds(t, e, i, n) {
      return (
        n.getSubGraphic().forEach(t => {
          i.union(t.AABBBounds);
        }),
        i
      );
    }
    updateRichTextAABBBounds(t, e, i, n) {
      if (!n) return i;
      const {
        width: s = e.width,
        height: r = e.height,
        maxWidth: a = e.maxWidth,
        maxHeight: o = e.maxHeight,
        textAlign: l = e.textAlign,
        textBaseline: h = e.textBaseline
      } = t;
      if (s > 0 && r > 0) i.set(0, 0, s, r);
      else {
        const t = n.getFrameCache(),
          { width: e, height: l } = t.getActualSize();
        let h = s || e || 0,
          c = r || l || 0;
        (c = 'number' == typeof o && c > o ? o : c || 0),
          (h = 'number' == typeof a && h > a ? a : h || 0),
          i.set(0, 0, h, c);
      }
      let c = 0;
      switch (h) {
        case 'top':
          c = 0;
          break;
        case 'middle':
          c = -i.height() / 2;
          break;
        case 'bottom':
          c = -i.height();
      }
      let d = 0;
      switch (l) {
        case 'left':
          d = 0;
          break;
        case 'center':
          d = -i.width() / 2;
          break;
        case 'right':
          d = -i.width();
      }
      i.translate(d, c);
      const u = this.tempAABBBounds1,
        p = this.tempAABBBounds2;
      return (
        u.setValue(i.x1, i.y1, i.x2, i.y2),
        p.setValue(i.x1, i.y1, i.x2, i.y2),
        this.transformAABBBounds(t, i, e, !1, n),
        i
      );
    }
    updateTextAABBBounds(t, e, i, n) {
      if (!n) return i;
      const { text: s = e.text } = n.attribute;
      Array.isArray(s) ? n.updateMultilineAABBBounds(s) : n.updateSingallineAABBBounds(s);
      const r = this.tempAABBBounds1,
        a = this.tempAABBBounds2;
      r.setValue(i.x1, i.y1, i.x2, i.y2), a.setValue(i.x1, i.y1, i.x2, i.y2);
      const {
        scaleX: o = e.scaleX,
        scaleY: l = e.scaleY,
        shadowBlur: h = e.shadowBlur,
        strokeBoundsBuffer: c = e.strokeBoundsBuffer
      } = t;
      if (h) {
        fE(r, h / Math.abs(o + l), !0, c), i.union(r);
      }
      return this.combindShadowAABBBounds(i, n), $t(i, i, n.transMatrix), i;
    }
    updatePathAABBBounds(t, e, i, n) {
      this.updatePathProxyAABBBounds(i, n) || this.updatePathAABBBoundsImprecise(t, e, i, n);
      const s = this.tempAABBBounds1,
        r = this.tempAABBBounds2;
      s.setValue(i.x1, i.y1, i.x2, i.y2),
        r.setValue(i.x1, i.y1, i.x2, i.y2),
        this._pathBoundsContribitions ||
          (this._pathBoundsContribitions = this.pathBoundsContribitions.getContributions() || []),
        this._pathBoundsContribitions.length &&
          this._pathBoundsContribitions.forEach(a => {
            a.updateBounds(t, e, s, n), i.union(s), s.setValue(r.x1, r.y1, r.x2, r.y2);
          });
      const { lineJoin: a = e.lineJoin } = t;
      return this.transformAABBBounds(t, i, e, 'miter' === a, n), i;
    }
    updatePathAABBBoundsImprecise(t, e, i, n) {
      if (!n) return i;
      const s = n.getParsedPathShape();
      return i.union(s.getBounds()), i;
    }
    updatePyramid3dAABBBounds(t, e, i, n) {
      if (!n) return i;
      const s = n.stage;
      if (!s || !s.camera) return i;
      n.findFace().vertices.forEach(t => {
        const e = t[0],
          n = t[1];
        i.add(e, n);
      });
      const r = this.tempAABBBounds1,
        a = this.tempAABBBounds2;
      return (
        r.setValue(i.x1, i.y1, i.x2, i.y2),
        a.setValue(i.x1, i.y1, i.x2, i.y2),
        this.transformAABBBounds(t, i, e, !1, n),
        i
      );
    }
    updateArc3dAABBBounds(t, e, i, n) {
      if (!n) return i;
      const s = n.stage;
      if (!s || !s.camera) return i;
      const { outerRadius: r = e.outerRadius, height: a = 0 } = t,
        o = r + a;
      i.setValue(-o, -o, o, o);
      const l = this.tempAABBBounds1,
        h = this.tempAABBBounds2;
      return (
        l.setValue(i.x1, i.y1, i.x2, i.y2),
        h.setValue(i.x1, i.y1, i.x2, i.y2),
        this.transformAABBBounds(t, i, e, !1, n),
        i
      );
    }
    updatePolygonAABBBounds(t, e, i, n) {
      this.updatePathProxyAABBBounds(i, n) || this.updatePolygonAABBBoundsImprecise(t, e, i, n);
      const s = this.tempAABBBounds1,
        r = this.tempAABBBounds2;
      s.setValue(i.x1, i.y1, i.x2, i.y2), r.setValue(i.x1, i.y1, i.x2, i.y2);
      const { lineJoin: a = e.lineJoin } = t;
      return this.transformAABBBounds(t, i, e, 'miter' === a, n), i;
    }
    updatePolygonAABBBoundsImprecise(t, e, i, n) {
      const { points: s = e.points } = t;
      return (
        s.forEach(t => {
          i.add(t.x, t.y);
        }),
        i
      );
    }
    updateLineAABBBounds(t, e, i, n) {
      this.updatePathProxyAABBBounds(i, n) ||
        (t.segments ? this.updateLineAABBBoundsBySegments(t, e, i, n) : this.updateLineAABBBoundsByPoints(t, e, i, n));
      const s = this.tempAABBBounds1,
        r = this.tempAABBBounds2;
      s.setValue(i.x1, i.y1, i.x2, i.y2), r.setValue(i.x1, i.y1, i.x2, i.y2);
      const { lineJoin: a = e.lineJoin } = t;
      return this.transformAABBBounds(t, i, e, 'miter' === a, n), i;
    }
    updateLineAABBBoundsByPoints(t, e, i, n) {
      const { points: s = e.points } = t,
        r = i;
      return (
        s.forEach(t => {
          r.add(t.x, t.y);
        }),
        r
      );
    }
    updateLineAABBBoundsBySegments(t, e, i, n) {
      const { segments: s = e.segments } = t,
        r = i;
      return (
        s.forEach(t => {
          t.points.forEach(t => {
            r.add(t.x, t.y);
          });
        }),
        r
      );
    }
    updateAreaAABBBounds(t, e, i, n) {
      this.updatePathProxyAABBBounds(i, n) ||
        (t.segments ? this.updateAreaAABBBoundsBySegments(t, e, i, n) : this.updateAreaAABBBoundsByPoints(t, e, i, n));
      const s = this.tempAABBBounds1,
        r = this.tempAABBBounds2;
      s.setValue(i.x1, i.y1, i.x2, i.y2), r.setValue(i.x1, i.y1, i.x2, i.y2);
      const { lineJoin: a = e.lineJoin } = t;
      return this.transformAABBBounds(t, i, e, 'miter' === a, n), i;
    }
    updateAreaAABBBoundsByPoints(t, e, i, n) {
      const { points: s = e.points } = t,
        r = i;
      return (
        s.forEach(t => {
          var e, i;
          r.add(t.x, t.y),
            r.add(null !== (e = t.x1) && void 0 !== e ? e : t.x, null !== (i = t.y1) && void 0 !== i ? i : t.y);
        }),
        r
      );
    }
    updateAreaAABBBoundsBySegments(t, e, i, n) {
      const { segments: s = e.segments } = t,
        r = i;
      return (
        s.forEach(t => {
          t.points.forEach(t => {
            var e, i;
            r.add(t.x, t.y),
              r.add(null !== (e = t.x1) && void 0 !== e ? e : t.x, null !== (i = t.y1) && void 0 !== i ? i : t.y);
          });
        }),
        r
      );
    }
    updateCircleAABBBounds(t, e, i, n, s) {
      this.updatePathProxyAABBBounds(i, s) ||
        (n ? this.updateCircleAABBBoundsImprecise(t, e, i, s) : this.updateCircleAABBBoundsAccurate(t, e, i, s));
      const r = this.tempAABBBounds1,
        a = this.tempAABBBounds2;
      return (
        r.setValue(i.x1, i.y1, i.x2, i.y2),
        a.setValue(i.x1, i.y1, i.x2, i.y2),
        this._circleBoundsContribitions ||
          (this._circleBoundsContribitions = this.circleBoundsContribitions.getContributions() || []),
        this._circleBoundsContribitions.length &&
          this._circleBoundsContribitions.forEach(n => {
            n.updateBounds(t, e, r, s), i.union(r), r.setValue(a.x1, a.y1, a.x2, a.y2);
          }),
        this.transformAABBBounds(t, i, e, !1, s),
        i
      );
    }
    updateCircleAABBBoundsImprecise(t, e, i, n) {
      const { radius: s = e.radius } = t;
      return i.set(-s, -s, s, s), i;
    }
    updateCircleAABBBoundsAccurate(t, e, i, n) {
      const { startAngle: s = e.startAngle, endAngle: r = e.endAngle, radius: a = e.radius } = t;
      return r - s > Et - kt ? i.set(-a, -a, a, a) : jM(s, r, a, i), i;
    }
    updateArcAABBBounds(t, e, i, n, s) {
      this.updatePathProxyAABBBounds(i, s) ||
        (n ? this.updateArcAABBBoundsImprecise(t, e, i, s) : this.updateArcAABBBoundsAccurate(t, e, i, s));
      const r = this.tempAABBBounds1,
        a = this.tempAABBBounds2;
      r.setValue(i.x1, i.y1, i.x2, i.y2),
        a.setValue(i.x1, i.y1, i.x2, i.y2),
        this._arcBoundsContribitions ||
          (this._arcBoundsContribitions = this.arcBoundsContribitions.getContributions() || []),
        this._arcBoundsContribitions.length &&
          this._arcBoundsContribitions.forEach(n => {
            n.updateBounds(t, e, r, s), i.union(r), r.setValue(a.x1, a.y1, a.x2, a.y2);
          });
      const { lineJoin: o = e.lineJoin } = t;
      return this.transformAABBBounds(t, i, e, 'miter' === o, s), i;
    }
    updateArcAABBBoundsImprecise(t, e, i, n) {
      const { outerRadius: s = e.outerRadius } = t;
      return i.set(-s, -s, s, s), i;
    }
    updateArcAABBBoundsAccurate(t, e, i, n) {
      let { outerRadius: s = e.outerRadius, innerRadius: r = e.innerRadius } = t;
      if (s < r) {
        const t = s;
        (s = r), (r = t);
      }
      let { endAngle: a = e.endAngle, startAngle: o = e.startAngle } = t;
      if (o > a) {
        const t = o;
        (o = a), (a = t);
      }
      return (
        s <= kt
          ? i.set(0, 0, 0, 0)
          : Math.abs(a - o) > Et - kt
          ? i.set(-s, -s, s, s)
          : (jM(o, a, s, i), jM(o, a, r, i)),
        i
      );
    }
    updateSymbolAABBBounds(t, e, i, n, s) {
      this.updatePathProxyAABBBounds(i, s) ||
        (n ? this.updateSymbolAABBBoundsImprecise(t, e, i, s) : this.updateSymbolAABBBoundsAccurate(t, e, i, s));
      const r = this.tempAABBBounds1,
        a = this.tempAABBBounds2;
      r.setValue(i.x1, i.y1, i.x2, i.y2),
        a.setValue(i.x1, i.y1, i.x2, i.y2),
        this._symbolBoundsContribitions ||
          (this._symbolBoundsContribitions = this.symbolBoundsContribitions.getContributions() || []),
        this._symbolBoundsContribitions.length &&
          this._symbolBoundsContribitions.forEach(n => {
            n.updateBounds(t, e, r, s), i.union(r), r.setValue(a.x1, a.y1, a.x2, a.y2);
          });
      const { lineJoin: o = e.lineJoin } = t;
      return this.transformAABBBounds(t, i, e, 'miter' === o, s), i;
    }
    updateSymbolAABBBoundsImprecise(t, e, i, n) {
      const { size: s = e.size } = t;
      if (f(s)) i.set(-s[0] / 2, -s[1] / 2, s[0] / 2, s[1] / 2);
      else {
        const t = s / 2;
        i.set(-t, -t, t, t);
      }
      return i;
    }
    updateSymbolAABBBoundsAccurate(t, e, i, n) {
      if (!n) return i;
      const { size: s = e.size } = t;
      return n.getParsedPath().bounds(s, i), i;
    }
    updateImageAABBBounds(t, e, i, n) {
      if (!this.updatePathProxyAABBBounds(i, n)) {
        const { width: n = e.width, height: s = e.height } = t;
        i.set(0, 0, n, s);
      }
      const s = this.tempAABBBounds1,
        r = this.tempAABBBounds2;
      return (
        s.setValue(i.x1, i.y1, i.x2, i.y2),
        r.setValue(i.x1, i.y1, i.x2, i.y2),
        this.transformAABBBounds(t, i, e, !1, n),
        i
      );
    }
    combindShadowAABBBounds(t, e) {
      if (e && e.shadowRoot) {
        const i = e.shadowRoot.AABBBounds;
        t.union(i);
      }
    }
    transformAABBBounds(t, e, i, n, s) {
      const {
          scaleX: r = i.scaleX,
          scaleY: a = i.scaleY,
          stroke: o = i.stroke,
          shadowBlur: l = i.shadowBlur,
          lineWidth: h = i.lineWidth,
          strokeBoundsBuffer: c = i.strokeBoundsBuffer
        } = t,
        d = this.tempAABBBounds1,
        u = this.tempAABBBounds2;
      if (o) {
        fE(d, h / Math.abs(r + a), n, c), e.union(d), d.setValue(u.x1, u.y1, u.x2, u.y2);
      }
      if (l) {
        fE(d, l / Math.abs(r + a), n, c), e.union(d);
      }
      this.combindShadowAABBBounds(e, s), $t(e, e, s.transMatrix);
    }
  };
  XO = NO(
    [
      ZS(),
      WO(0, tw(HE)),
      WO(1, tw(rw)),
      WO(1, JS(AO)),
      WO(2, tw(rw)),
      WO(2, JS(TO)),
      WO(3, tw(rw)),
      WO(3, JS(PO)),
      WO(4, tw(rw)),
      WO(4, JS(BO)),
      WO(5, tw(rw)),
      WO(5, JS(LO)),
      VO('design:paramtypes', [Object, Object, Object, Object, Object, Object])
    ],
    XO
  );
  class KO extends GE {
    constructor(t) {
      super({ x: 0, y: 0 }), (this.type = 'shadowroot'), (this.shadowHost = t);
    }
    addUpdateBoundTag() {
      super.addUpdateBoundTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
    }
    addUpdateShapeAndBoundsTag() {
      super.addUpdateShapeAndBoundsTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
    }
    tryUpdateGlobalTransMatrix() {
      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      if (this.shouldUpdateGlobalMatrix()) {
        const e = this.transMatrix;
        this._globalTransMatrix
          ? this._globalTransMatrix.setValue(e.a, e.b, e.c, e.d, e.e, e.f)
          : (this._globalTransMatrix = e.clone()),
          this.doUpdateGlobalMatrix(),
          t && this.clearUpdateGlobalPositionTag();
      }
      return this._globalTransMatrix;
    }
    doUpdateGlobalMatrix() {
      if (this.shadowHost) {
        const t = this.shadowHost.globalTransMatrix;
        this._globalTransMatrix.multiply(t.a, t.b, t.c, t.d, t.e, t.f);
      }
    }
    tryUpdateGlobalAABBBounds() {
      return (
        this._globalAABBBounds
          ? this._globalAABBBounds.setValue(
              this._AABBBounds.x1,
              this._AABBBounds.y1,
              this._AABBBounds.x2,
              this._AABBBounds.y2
            )
          : (this._globalAABBBounds = this._AABBBounds.clone()),
        this.shadowHost && this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix),
        this._globalAABBBounds
      );
    }
  }
  function qO(t) {
    return new vO(t);
  }
  function ZO(t) {
    return new gO(t);
  }
  function JO(t) {
    return new HP(t);
  }
  function QO(t) {
    return new GE(t);
  }
  function tB(t) {
    return new qR(t);
  }
  function eB(t) {
    return new uO(t);
  }
  function iB(t) {
    return new JR(t);
  }
  function nB(t) {
    return new tO(t);
  }
  function sB(t) {
    return new YP(t);
  }
  function rB(t) {
    return new XR(t);
  }
  function aB(t) {
    return new rO(t);
  }
  function oB(t) {
    return new _O(t);
  }
  function lB(t) {
    return new cO(t);
  }
  const hB = {
      arc: qO,
      area: ZO,
      circle: JO,
      group: QO,
      image: aB,
      line: tB,
      path: eB,
      rect: iB,
      rect3d: nB,
      symbol: rB,
      text: sB,
      richtext: lB,
      polygon: oB,
      shadowRoot: function (t) {
        return new KO(t);
      },
      wrapText: function (t) {
        return new XP(t);
      }
    },
    cB = sB({ text: '' });
  function dB(t) {
    return cB.setAttributes(t), cB.AABBBounds;
  }
  const uB = lB({});
  var pB = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let gB = class {
    transform(t, e, i) {
      let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
      const s = t.transMatrix,
        {
          x: r = e.x,
          y: a = e.y,
          z: o = e.z,
          scaleX: l = e.scaleX,
          scaleY: h = e.scaleY,
          angle: c = e.angle,
          postMatrix: d
        } = t.attribute,
        u = s.onlyTranslate() && !d,
        p = i.modelMatrix,
        g = i.camera,
        f = { x: r, y: a, z: o, lastModelMatrix: p },
        v =
          g &&
          (n ||
            (function (t) {
              const { alpha: e, beta: i } = t.attribute;
              return e || i;
            })(t));
      if (v) {
        const n = HO.allocate(),
          s = HO.allocate();
        $O(s, t, e),
          YO(n, p || n, s),
          (f.x = 0),
          (f.y = 0),
          (f.z = 0),
          (i.modelMatrix = n),
          i.setTransform(1, 0, 0, 1, 0, 0, !0),
          HO.free(s);
      }
      if (u && !p) {
        const n = t.getOffsetXY(e);
        (f.x += n.x), (f.y += n.y), (f.z = o), i.setTransformForCurrent();
      } else if (v) (f.x = 0), (f.y = 0), (f.z = 0), i.setTransform(1, 0, 0, 1, 0, 0, !0);
      else if (g && i.project) {
        const n = t.getOffsetXY(e);
        (f.x += n.x), (f.y += n.y), this.transformWithoutTranslate(i, f.x, f.y, f.z, l, h, c);
      } else i.transformFromMatrix(t.transMatrix, !0), (f.x = 0), (f.y = 0), (f.z = 0);
      return f;
    }
    transformUseContext2d(t, e, i, n) {
      const s = n.camera;
      if (((this.camera = s), s)) {
        const e = t.AABBBounds,
          s = e.x2 - e.x1,
          r = e.y2 - e.y1,
          a = n.project(0, 0, i),
          o = n.project(s, 0, i),
          l = n.project(s, r, i),
          h = { x: 0, y: 0 },
          c = { x: s, y: 0 },
          d = { x: s, y: r };
        n.camera = null;
        const u = 1 / (h.x * (d.y - c.y) - c.x * d.y + d.x * c.y + (c.x - d.x) * h.y),
          p = -(h.y * (l.x - o.x) - c.y * l.x + d.y * o.x + (c.y - d.y) * a.x) * u,
          g = (c.y * l.y + h.y * (o.y - l.y) - d.y * o.y + (d.y - c.y) * a.y) * u,
          f = (h.x * (l.x - o.x) - c.x * l.x + d.x * o.x + (c.x - d.x) * a.x) * u,
          v = -(c.x * l.y + h.x * (o.y - l.y) - d.x * o.y + (d.x - c.x) * a.y) * u,
          m = (h.x * (d.y * o.x - c.y * l.x) + h.y * (c.x * l.x - d.x * o.x) + (d.x * c.y - c.x * d.y) * a.x) * u,
          y = (h.x * (d.y * o.y - c.y * l.y) + h.y * (c.x * l.y - d.x * o.y) + (d.x * c.y - c.x * d.y) * a.y) * u;
        n.setTransform(p, g, f, v, m, y, !0);
      }
    }
    restoreTransformUseContext2d(t, e, i, n) {
      this.camera && (n.camera = this.camera);
    }
    transformWithoutTranslate(t, e, i, n, s, r, a) {
      const o = t.project(e, i, n);
      t.translate(o.x, o.y, !1),
        t.scale(s, r, !1),
        t.rotate(a, !1),
        t.translate(-o.x, -o.y, !1),
        t.setTransformForCurrent();
    }
  };
  function fB(t, e, i, n, s) {
    var r;
    const {
      offsetX: a = 0,
      offsetY: o = 0,
      offsetZ: l = 0,
      mode: h = 'none',
      drawConnect: c = !1,
      zeroX: d = 0,
      zeroY: u = 0
    } = s || {};
    if (c && 'none' === h) return;
    if (!e) return;
    let p = !0;
    const { curves: g } = e;
    if (i >= 1) {
      if (c) {
        let e,
          i = !0;
        g.forEach((n, s) => {
          var r;
          let h = n.p0;
          if (n.originP1 !== n.originP2) {
            if ((e && e.originP1 === e.originP2 && (h = e.p0), n.defined))
              i || (t.lineTo(h.x + a, h.y + o, l), (i = !i));
            else {
              const { originP1: e, originP2: s } = n;
              let c;
              if (
                (e && !1 !== e.defined
                  ? (c = h)
                  : e && !1 !== s.defined && (c = null !== (r = n.p3) && void 0 !== r ? r : n.p1),
                i)
              ) {
                i = !i;
                const e = c ? c.x : n.p0.x,
                  s = c ? c.y : n.p0.y;
                t.moveTo(e + a, s + o, l);
              } else c && ((i = !i), t.lineTo(c.x + a, c.y + o, l));
            }
            e = n;
          } else e = n;
        });
      } else
        g.forEach(e => {
          e.defined ? (p && t.moveTo(e.p0.x + a, e.p0.y + o, l), vB(t, e, 1, s), (p = !1)) : (p = !0);
        });
      return;
    }
    if (i <= 0) return;
    let f;
    'x' === n ? (f = Iw.ROW) : 'y' === n ? (f = Iw.COLUMN) : 'auto' === n && (f = e.direction);
    const v = i * e.tryUpdateLength(f);
    let m = 0,
      y = !0,
      _ = null;
    for (let e = 0, i = g.length; e < i; e++) {
      const i = g[e],
        n = i.getLength(f),
        h = (v - m) / n;
      if (((m += n), h < 0)) break;
      if (c) {
        let e = i.p0;
        if (i.originP1 === i.originP2) {
          _ = i;
          continue;
        }
        if ((_ && _.originP1 === _.originP2 && (e = _.p0), i.defined)) y || (t.lineTo(e.x + a, e.y + o, l), (y = !y));
        else {
          const { originP1: n, originP2: s } = i;
          let h;
          if (
            (n && !1 !== n.defined
              ? (h = e)
              : n && !1 !== s.defined && (h = null !== (r = i.p3) && void 0 !== r ? r : i.p1),
            y)
          ) {
            y = !y;
            const e = h ? h.x : i.p0.x,
              n = h ? h.y : i.p0.y;
            t.moveTo(e + a, n + o, l);
          } else h && ((y = !y), t.lineTo(h.x + a, h.y + o, l));
        }
        _ = i;
      } else {
        if (!i.defined) {
          p = !0;
          continue;
        }
        p && t.moveTo(i.p0.x + a, i.p0.y + o, l), vB(t, i, It(h, 1), s), (p = !1);
      }
    }
  }
  function vB(t, e, i, n) {
    if (!e.p1) return;
    const { offsetX: s = 0, offsetY: r = 0, offsetZ: a = 0 } = n || {};
    if (1 === i)
      e.p2 && e.p3
        ? t.bezierCurveTo(s + e.p1.x, r + e.p1.y, s + e.p2.x, r + e.p2.y, s + e.p3.x, r + e.p3.y, a)
        : t.lineTo(s + e.p1.x, r + e.p1.y, a);
    else if (e.p2 && e.p3) {
      const [n] = Yw(e, i);
      t.bezierCurveTo(s + n.p1.x, r + n.p1.y, s + n.p2.x, r + n.p2.y, s + n.p3.x, r + n.p3.y, a);
    } else {
      const n = e.getPointAt(i);
      t.lineTo(s + n.x, r + n.y, a);
    }
  }
  gB = pB([ZS()], gB);
  var mB = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let yB = class extends gB {
    constructor() {
      super(...arguments), (this.numberType = PE);
    }
    draw(t, e, i, n) {
      const { context: s } = i;
      s.highPerformanceSave();
      const r = Zk(t, null == n ? void 0 : n.theme).line,
        a = this.transform(t, r, s),
        { x: o, y: l, z: h, lastModelMatrix: c } = a;
      (this.z = h),
        pP(t, s, o, l) ||
          (this.drawShape(t, s, o, l, i, n),
          (this.z = 0),
          s.modelMatrix !== c && HO.free(s.modelMatrix),
          (s.modelMatrix = c)),
        s.highPerformanceRestore();
    }
    drawSegmentItem(t, e, i, n, s, r, a, o, l, h, c, d, u, p, g) {
      var v, m, y, _, b;
      if (!e) return;
      t.beginPath();
      const x = null !== (v = this.z) && void 0 !== v ? v : 0;
      fB(t.camera ? t : t.nativeContext, e, l, h, { offsetX: c, offsetY: d, offsetZ: x }),
        u.cache && !f(u.cache) && u.attribute.curveType && u.attribute.curveType.includes('Closed') && t.closePath(),
        t.setShadowStyle && t.setShadowStyle(u, a, o);
      const { x: S = 0, x: w = 0 } = a;
      !1 !== i && (p ? p(t, a, o) : s && (t.setCommonStyle(u, a, S - c, w - d, o), t.fill())),
        !1 !== n && (g ? g(t, a, o) : r && (t.setStrokeStyle(u, a, S - c, w - d, o), t.stroke()));
      let { connectedType: A, connectedX: k, connectedY: M, connectedStyle: T } = a;
      if (
        (f(o)
          ? ((A = null !== (m = null != A ? A : o[0].connectedType) && void 0 !== m ? m : o[1].connectedType),
            (k = null !== (y = null != k ? k : o[0].connectedX) && void 0 !== y ? y : o[1].connectedX),
            (M = null !== (_ = null != M ? M : o[0].connectedY) && void 0 !== _ ? _ : o[1].connectedY),
            (T = null !== (b = null != T ? T : o[0].connectedStyle) && void 0 !== b ? b : o[1].connectedStyle))
          : ((A = null != A ? A : o.connectedType),
            (k = null != k ? k : o.connectedX),
            (M = null != M ? M : o.connectedY),
            (T = null != T ? T : o.connectedStyle)),
        'connect' !== A && 'zero' !== A && (A = 'none'),
        'none' !== A)
      ) {
        t.beginPath(),
          fB(t.camera ? t : t.nativeContext, e, l, h, {
            offsetX: c,
            offsetY: d,
            offsetZ: x,
            drawConnect: !0,
            mode: A,
            zeroX: k,
            zeroY: M
          });
        const v = [];
        f(o) ? o.forEach(t => v.push(t)) : v.push(o),
          v.push(a),
          !1 !== i && (p ? p(t, a, o) : s && (t.setCommonStyle(u, T, S - c, w - d, v), t.fill())),
          !1 !== n && (g ? g(t, a, o) : r && (t.setStrokeStyle(u, T, S - c, w - d, v), t.stroke()));
      }
      return !1;
    }
    drawShape(t, e, i, n, s, r, a, o) {
      const l = Zk(t, null == r ? void 0 : r.theme).line,
        {
          fill: h = l.fill,
          stroke: c = l.stroke,
          opacity: d = l.opacity,
          fillOpacity: u = l.fillOpacity,
          strokeOpacity: p = l.strokeOpacity,
          lineWidth: g = l.lineWidth,
          visible: f = l.visible
        } = t.attribute,
        v = hP(d, u, h),
        m = dP(d, p),
        y = oP(h),
        _ = lP(c, g);
      if (!t.valid || !f) return;
      if (!y && !_) return;
      if (!(v || m || a || o)) return;
      if (t.shouldUpdateShape()) {
        const { points: e, segments: i, closePath: n } = t.attribute;
        let { curveType: s = l.curveType } = t.attribute;
        n && 'linear' === s && (s = 'linearClosed');
        const r = e;
        if (i && i.length) {
          let e, n;
          if (
            ((t.cache = i
              .map((t, i) => {
                if (t.points.length <= 1 && 0 === i)
                  return (
                    t.points[0] &&
                      (n = {
                        endX: t.points[0].x,
                        endY: t.points[0].y,
                        curves: [{ defined: !1 !== t.points[0].defined }]
                      }),
                    null
                  );
                1 === i
                  ? (e = { x: n.endX, y: n.endY, defined: n.curves[n.curves.length - 1].defined })
                  : i > 1 && ((e.x = n.endX), (e.y = n.endY), (e.defined = n.curves[n.curves.length - 1].defined));
                const r = vA(t.points, s, { startPoint: e });
                return (n = r), r;
              })
              .filter(t => !!t)),
            'linearClosed' === s)
          ) {
            let e;
            for (let i = 0; i < t.cache.length; i++) {
              const n = t.cache[i];
              for (let t = 0; t < n.curves.length; t++)
                if (n.curves[t].defined) {
                  e = n.curves[t].p0;
                  break;
                }
              if (e) break;
            }
            t.cache[t.cache.length - 1] && t.cache[t.cache.length - 1].lineTo(e.x, e.y, !0);
          }
        } else {
          if (!e || !e.length) return (t.cache = null), void t.clearUpdateShapeTag();
          t.cache = vA(r, s);
        }
        t.clearUpdateShapeTag();
      }
      const { clipRange: b = l.clipRange, clipRangeByDimension: x = l.clipRangeByDimension } = t.attribute;
      if (Array.isArray(t.cache)) {
        const s = t.attribute.segments.filter(t => t.points.length);
        if ((1 === s[0].points.length && s.shift(), 1 === b)) {
          let r = !1;
          t.cache.forEach((d, g) => {
            r || (r = this.drawSegmentItem(e, d, !!h, !!c, u, p, s[g], [l, t.attribute], b, x, i, n, t, a, o));
          });
        } else {
          const r = t.cache.reduce((t, e) => t + e.getLength(), 0),
            d = b * r;
          let g = 0,
            f = !1;
          t.cache.forEach((r, v) => {
            if (f) return;
            const m = r.getLength(),
              y = (d - g) / m;
            (g += m),
              y > 0 &&
                (f = this.drawSegmentItem(e, r, !!h, !!c, u, p, s[v], [l, t.attribute], It(y, 1), x, i, n, t, a, o));
          });
        }
      } else this.drawSegmentItem(e, t.cache, !!h, !!c, u, p, t.attribute, l, b, x, i, n, t, a, o);
    }
  };
  function _B(t, e, i, n) {
    if (e.length < 2) return;
    const { offsetX: s = 0, offsetY: r = 0, offsetZ: a = 0, mode: o } = n || {};
    let l = e[0];
    t.moveTo(l.p0.x + s, l.p0.y + r, a), (l = e[e.length - 1]);
    let h = l.p3 || l.p1;
    t.lineTo(h.x + s, h.y + r, a),
      (l = i[i.length - 1]),
      t.lineTo(l.p0.x + s, l.p0.y + r, a),
      (l = i[0]),
      (h = l.p3 || l.p1),
      t.lineTo(h.x + s, h.y + r, a),
      t.closePath();
  }
  function bB(t, e, i, n) {
    const { offsetX: s = 0, offsetY: r = 0, offsetZ: a = 0 } = n || {};
    let o = !0;
    e.forEach(e => {
      e.defined ? (o && t.moveTo(e.p0.x + s, e.p0.y + r, a), xB(t, e, 1, n), (o = !1)) : (o = !0);
    }),
      (o = !0);
    for (let e = i.length - 1; e >= 0; e--) {
      const l = i[e];
      l.defined ? (o && t.lineTo(l.p0.x + s, l.p0.y + r, a), xB(t, l, 1, n), (o = !1)) : (o = !0);
    }
    t.closePath();
  }
  function xB(t, e, i, n) {
    if (!e.p1) return;
    const { offsetX: s = 0, offsetY: r = 0, offsetZ: a = 0 } = n || {};
    if (1 === i)
      e.p2 && e.p3
        ? t.bezierCurveTo(s + e.p1.x, r + e.p1.y, s + e.p2.x, r + e.p2.y, s + e.p3.x, r + e.p3.y, a)
        : t.lineTo(s + e.p1.x, r + e.p1.y, a);
    else if (e.p2 && e.p3) {
      const [n] = Yw(e, i);
      t.bezierCurveTo(s + n.p1.x, r + n.p1.y, s + n.p2.x, r + n.p2.y, s + n.p3.x, r + n.p3.y, a);
    } else {
      const n = e.getPointAt(i);
      t.lineTo(s + n.x, r + n.y, a);
    }
  }
  yB = mB([ZS()], yB);
  var SB = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    wB = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    AB = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  function kB(t, e, i) {
    switch (e) {
      case 'linear':
      default:
        return tA(t, i);
      case 'basis':
        return nA(t, i);
      case 'monotoneX':
        return cA(t, i);
      case 'monotoneY':
        return dA(t, i);
      case 'step':
        return pA(t, 0.5, i);
      case 'stepBefore':
        return pA(t, 0, i);
      case 'stepAfter':
        return pA(t, 1, i);
      case 'linearClosed':
        return fA(t, i);
    }
  }
  let MB = class {
    constructor(t) {
      (this.areaRenderContribitions = t), (this.numberType = kE);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      var l, h, c, d, u, p;
      const g = Zk(t, null == r ? void 0 : r.theme).area,
        {
          fill: f = g.fill,
          fillOpacity: v = g.fillOpacity,
          opacity: m = g.opacity,
          visible: y = g.visible,
          z: _ = g.z,
          background: b,
          stroke: x = t.attribute.stroke,
          lineWidth: S = g.lineWidth,
          strokeOpacity: w = g.strokeOpacity
        } = t.attribute,
        A = hP(m, v, f),
        k = oP(f, b),
        M = lP(x, S),
        T = dP(m, w);
      if (!t.valid || !y) return;
      if (!k && !M) return;
      if (!(A || a || T || o)) return;
      const { clipRange: C = g.clipRange } = t.attribute;
      if (t.shouldUpdateShape()) {
        const { points: e, segments: i, closePath: n } = t.attribute;
        let { curveType: s = g.curveType } = t.attribute;
        if ((n && 'linear' === s && (s = 'linearClosed'), i && i.length)) {
          let e, n;
          const r = i
            .map((t, i) => {
              if (t.points.length <= 1 && 0 === i)
                return t.points[0] && (n = { endX: t.points[0].x, endY: t.points[0].y }), null;
              1 === i ? (e = { x: n.endX, y: n.endY }) : i > 1 && ((e.x = n.endX), (e.y = n.endY));
              const r = kB(t.points, s, { startPoint: e });
              return (n = r), r;
            })
            .filter(t => !!t);
          let a;
          const o = [];
          for (let t = i.length - 1; t >= 0; t--) {
            const e = i[t].points,
              n = [];
            for (let t = e.length - 1; t >= 0; t--)
              n.push({
                x: null !== (l = e[t].x1) && void 0 !== l ? l : e[t].x,
                y: null !== (h = e[t].y1) && void 0 !== h ? h : e[t].y
              });
            if (0 !== t) {
              const e = i[t - 1].points,
                s = e[e.length - 1];
              s &&
                n.push({
                  x: null !== (c = s.x1) && void 0 !== c ? c : s.x,
                  y: null !== (d = s.y1) && void 0 !== d ? d : s.y
                });
            }
            (a = kB(n, 'stepBefore' === s ? 'stepAfter' : 'stepAfter' === s ? 'stepBefore' : s)), o.unshift(a);
          }
          t.cacheArea = o.map((t, e) => ({ top: r[e], bottom: t }));
        } else {
          if (!e || !e.length) return (t.cacheArea = null), void t.clearUpdateShapeTag();
          {
            const i = e,
              n = [];
            for (let t = e.length - 1; t >= 0; t--)
              n.push({
                x: null !== (u = e[t].x1) && void 0 !== u ? u : e[t].x,
                y: null !== (p = e[t].y1) && void 0 !== p ? p : e[t].y
              });
            const r = kB(i, s),
              a = kB(n, 'stepBefore' === s ? 'stepAfter' : 'stepAfter' === s ? 'stepBefore' : s);
            t.cacheArea = { top: r, bottom: a };
          }
        }
        t.clearUpdateShapeTag();
      }
      if (Array.isArray(t.cacheArea)) {
        const r = t.attribute.segments.filter(t => t.points.length);
        if ((1 === r[0].points.length && r.shift(), 1 === C)) {
          let l = !1;
          t.cacheArea.forEach((h, c) => {
            l || (l = this.drawSegmentItem(e, h, k, v, M, w, r[c], [g, t.attribute], C, i, n, _, t, s, a, o));
          });
        } else {
          const l = t.cacheArea.reduce((t, e) => t + e.top.getLength(), 0),
            h = C * l;
          let c = 0,
            d = !1;
          t.cacheArea.forEach((l, u) => {
            if (d) return;
            const p = l.top.getLength(),
              f = (h - c) / p;
            (c += p),
              f > 0 &&
                (d = this.drawSegmentItem(e, l, k, v, M, w, r[u], [g, t.attribute], It(f, 1), i, n, _, t, s, a, o));
          });
        }
      } else this.drawSegmentItem(e, t.cacheArea, k, v, M, w, t.attribute, g, C, i, n, _, t, s, a, o);
    }
    draw(t, e, i, n) {
      const { context: s } = i,
        r = Zk(t, null == n ? void 0 : n.theme).area;
      let { x: a = r.x, y: o = r.y } = t.attribute;
      if ((s.highPerformanceSave(), t.transMatrix.onlyTranslate())) {
        const e = t.getOffsetXY(r);
        (a += e.x), (o += e.y), s.setTransformForCurrent();
      } else (a = 0), (o = 0), s.transformFromMatrix(t.transMatrix, !0);
      pP(t, s, a, o, 0, n) || this.drawShape(t, s, a, o, i, n), s.highPerformanceRestore();
    }
    drawSegmentItem(t, e, i, n, s, r, a, o, l, h, c, d, u, p, g, f) {
      let v = !1;
      return (
        (v = v || this._drawSegmentItem(t, e, i, n, s, r, a, o, l, h, c, d, u, p, !1, g, f)),
        (v = v || this._drawSegmentItem(t, e, i, n, s, r, a, o, l, h, c, d, u, p, !0, g, f)),
        v
      );
    }
    _drawSegmentItem(t, e, i, n, s, r, a, o, l, h, c, d, u, p, g, v, m) {
      var y, _, b, x;
      let { connectedType: S, connectedX: w, connectedY: A, connectedStyle: k } = a;
      const M = [];
      if (
        (g &&
          (f(o)
            ? ((S = null !== (y = null != S ? S : o[0].connectedType) && void 0 !== y ? y : o[1].connectedType),
              (w = null !== (_ = null != w ? w : o[0].connectedX) && void 0 !== _ ? _ : o[1].connectedX),
              (A = null !== (b = null != A ? A : o[0].connectedY) && void 0 !== b ? b : o[1].connectedY),
              (k = null !== (x = null != k ? k : o[0].connectedStyle) && void 0 !== x ? x : o[1].connectedStyle))
            : ((S = null != S ? S : o.connectedType),
              (w = null != w ? w : o.connectedX),
              (A = null != A ? A : o.connectedY),
              (k = null != k ? k : o.connectedStyle)),
          'connect' !== S && 'zero' !== S && (S = 'none'),
          f(o) ? o.forEach(t => M.push(t)) : M.push(o),
          M.push(a)),
        g && 'none' === S)
      )
        return !1;
      if (!e) return;
      t.beginPath();
      const { points: T, segments: C } = u.attribute;
      let E,
        P,
        R = Iw.ROW;
      if (C) {
        const t = C[C.length - 1];
        (P = C[0].points[0]), (E = t.points[t.points.length - 1]);
      } else (P = T[0]), (E = T[T.length - 1]);
      (R = Pt(E.x - P.x) > Pt(E.y - P.y) ? Iw.ROW : Iw.COLUMN),
        (function (t, e, i, n) {
          var s;
          const { drawConnect: r = !1, mode: a = 'none' } = n || {};
          if (r && 'none' === a) return;
          const { top: o, bottom: l } = e;
          if (i >= 1) {
            const e = [],
              i = [];
            let s = !0;
            if (r) {
              let s,
                r,
                a = !0;
              const h = o.curves.length;
              o.curves.forEach((o, c) => {
                const d = l.curves[h - c - 1];
                let u = o,
                  p = d;
                if (o.originP1 === o.originP2) return (s = o), void (r = d);
                if ((s && s.originP1 === s.originP2 && ((u = s), (p = r)), o.defined))
                  a || (e.push(u), i.push(p), _B(t, e, i, n), (e.length = 0), (i.length = 0), (a = !a));
                else {
                  const { originP1: s, originP2: r } = o;
                  let l, h;
                  s && !1 !== s.defined ? ((l = u), (h = p)) : s && !1 !== r.defined && ((l = o), (h = d)),
                    a
                      ? ((a = !a), e.push(l || o), i.push(h || d))
                      : l && ((a = !a), e.push(l || o), i.push(h || d), _B(t, e, i, n), (e.length = 0), (i.length = 0));
                }
                s = o;
              }),
                _B(t, e, i, n);
            } else {
              for (let r = 0, a = o.curves.length; r < a; r++) {
                const h = o.curves[r];
                s !== h.defined
                  ? (s ? (bB(t, e, i, n), (e.length = 0), (i.length = 0)) : (e.push(h), i.push(l.curves[a - r - 1])),
                    (s = !s))
                  : s && (e.push(h), i.push(l.curves[a - r - 1]));
              }
              bB(t, e, i, n);
            }
            return;
          }
          if (i <= 0) return;
          let { direction: h } = n || {};
          const { curves: c } = o,
            d = null !== (s = c[c.length - 1].p3) && void 0 !== s ? s : c[c.length - 1].p1,
            u = Pt(d.x - c[0].p0.x),
            p = Pt(d.y - c[0].p0.y);
          (h = null != h ? h : u > p ? Iw.ROW : Iw.COLUMN),
            Number.isFinite(u) || (h = Iw.COLUMN),
            Number.isFinite(p) || (h = Iw.ROW);
          const g = i * (h === Iw.ROW ? u : p);
          let f = 0,
            v = !0;
          const m = [],
            y = [];
          let _,
            b,
            x = !0;
          for (let e = 0, i = o.curves.length; e < i; e++) {
            const s = o.curves[e],
              a = s.getLength(h),
              c = (g - f) / a;
            if (c < 0) break;
            if (((f += a), r)) {
              const r = l.curves[i - e - 1];
              let a = s,
                o = r;
              if (s.originP1 === s.originP2) {
                (_ = s), (b = r);
                continue;
              }
              if ((_ && _.originP1 === _.originP2 && ((a = _), (o = b)), s.defined))
                x || (m.push(a), y.push(o), _B(t, m, y, n), (m.length = 0), (y.length = 0), (x = !x));
              else {
                const { originP1: e, originP2: i } = s;
                let l, h;
                e && !1 !== e.defined ? ((l = a), (h = o)) : e && !1 !== i.defined && ((l = s), (h = r)),
                  x
                    ? ((x = !x), m.push(l || s), y.push(h || r))
                    : l && ((x = !x), m.push(l || s), y.push(h || r), _B(t, m, y, n), (m.length = 0), (y.length = 0));
              }
              _ = s;
            } else {
              let r = null,
                a = null;
              v !== s.defined
                ? (v ? (bB(t, m, y, n), (m.length = 0), (y.length = 0)) : ((r = s), (a = l.curves[i - e - 1])),
                  (v = !v))
                : v && ((r = s), (a = l.curves[i - e - 1])),
                r &&
                  a &&
                  (c < 1 &&
                    ((r = r.p2 && r.p3 ? Yw(r, c)[0] : Xw(r, c)[0]),
                    (a = a.p2 && a.p3 ? Yw(a, 1 - c)[1] : Xw(a, 1 - c)[1])),
                  (r.defined = v),
                  (a.defined = v),
                  m.push(r),
                  y.push(a)),
                (r = null),
                (a = null);
            }
          }
          r ? _B(t, m, y, n) : bB(t, m, y, n);
        })(t.camera ? t : t.nativeContext, e, l, {
          offsetX: h,
          offsetY: c,
          offsetZ: d,
          direction: R,
          drawConnect: g,
          mode: S,
          zeroX: w,
          zeroY: A
        }),
        this._areaRenderContribitions ||
          ((this._areaRenderContribitions = this.areaRenderContribitions.getContributions() || []),
          this._areaRenderContribitions.sort((t, e) => e.order - t.order)),
        this._areaRenderContribitions.forEach(e => {
          e.time === Lw.beforeFillStroke && e.drawShape(u, t, h, c, !!n, !1, i, !1, o, p, v, null, { attribute: a });
        }),
        t.setShadowStyle && t.setShadowStyle(u, a, o);
      const { x: O = 0, x: B = 0 } = a;
      if (
        (!1 !== i && (v ? v(t, a, o) : n && (t.setCommonStyle(u, g ? k : a, O - h, B - c, g ? M : o), t.fill())),
        this._areaRenderContribitions ||
          (this._areaRenderContribitions = this.areaRenderContribitions.getContributions() || []),
        this._areaRenderContribitions.forEach(e => {
          e.time === Lw.afterFillStroke && e.drawShape(u, t, h, c, !!n, !1, i, !1, o, p, v, null, { attribute: a });
        }),
        !1 !== s)
      )
        if (m) m(t, a, o);
        else {
          const { stroke: i = o && o[1] && o[1].stroke } = a;
          f(i) &&
            (i[0] || i[2]) &&
            !1 === i[1] &&
            (t.beginPath(),
            fB(t.camera ? t : t.nativeContext, i[0] ? e.top : e.bottom, l, R === Iw.ROW ? 'x' : 'y', {
              offsetX: h,
              offsetY: c,
              offsetZ: d,
              drawConnect: g,
              mode: S,
              zeroX: w,
              zeroY: A
            })),
            t.setStrokeStyle(u, g ? k : a, O - h, B - c, g ? M : o),
            t.stroke();
        }
      return !1;
    }
  };
  MB = SB([ZS(), AB(0, tw(rw)), AB(0, JS(xP)), wB('design:paramtypes', [Object])], MB);
  var TB = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    CB = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    EB = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let PB = class extends gB {
    constructor(t) {
      super(), (this.pathRenderContribitions = t), (this.numberType = RE);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      var l, h;
      const c = Zk(t, null == r ? void 0 : r.theme).path,
        {
          fill: d = c.fill,
          stroke: u = c.stroke,
          fillOpacity: p = c.fillOpacity,
          strokeOpacity: g = c.strokeOpacity,
          opacity: f = c.opacity,
          background: v,
          lineWidth: m = c.lineWidth,
          visible: y = c.visible,
          x: _ = c.x,
          y: b = c.y
        } = t.attribute,
        x = null !== (l = this.z) && void 0 !== l ? l : 0,
        S = hP(f, p, d),
        w = dP(f, g),
        A = oP(d, v),
        k = lP(u, m);
      if (t.valid && y && (A || k) && (S || w || a || o || v)) {
        if ((e.beginPath(), t.pathShape)) Nw(t.pathShape.commandList, e, i, n, 1, 1, x);
        else {
          Nw((null !== (h = t.attribute.path) && void 0 !== h ? h : c.path).commandList, e, i, n, 1, 1, x);
        }
        this._pathRenderContribitions ||
          ((this._pathRenderContribitions = this.pathRenderContribitions.getContributions() || []),
          this._pathRenderContribitions.sort((t, e) => e.order - t.order)),
          this._pathRenderContribitions.forEach(r => {
            r.time === Lw.beforeFillStroke && r.drawShape(t, e, i, n, A, k, S, w, c, s, a, o);
          }),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, c),
          k && (o ? o(e, t.attribute, c) : w && (e.setStrokeStyle(t, t.attribute, _ - i, b - n, c), e.stroke())),
          A && (a ? a(e, t.attribute, c) : S && (e.setCommonStyle(t, t.attribute, _ - i, b - n, c), e.fill())),
          this._pathRenderContribitions.forEach(r => {
            r.time === Lw.afterFillStroke && r.drawShape(t, e, i, n, A, k, S, w, c, s, a, o);
          });
      }
    }
    draw(t, e, i, n) {
      const { context: s } = i;
      if (!s) return;
      s.highPerformanceSave();
      const r = Zk(t, null == n ? void 0 : n.theme).path,
        a = this.transform(t, r, s),
        { x: o, y: l, z: h, lastModelMatrix: c } = a;
      (this.z = h),
        pP(t, s, o, l, 0, n) ||
          (this.drawShape(t, s, o, l, i, n),
          (this.z = 0),
          s.modelMatrix !== c && HO.free(s.modelMatrix),
          (s.modelMatrix = c)),
        s.highPerformanceRestore();
    }
  };
  PB = TB([ZS(), EB(0, tw(rw)), EB(0, JS(kP)), CB('design:paramtypes', [Object])], PB);
  const RB = Mt / 2;
  function OB(t, e, i, n, s, r) {
    let a;
    if (y(r, !0)) a = [r, r, r, r];
    else if (Array.isArray(r)) {
      const t = r;
      switch (t.length) {
        case 0:
          a = [0, 0, 0, 0];
          break;
        case 1:
          a = [t[0], t[0], t[0], t[0]];
          break;
        case 2:
        case 3:
          a = [t[0], t[1], t[0], t[1]];
          break;
        default:
          a = t.slice(0, 5);
      }
    } else a = [0, 0, 0, 0];
    if (n < 0 || Math.abs(a[0]) + Math.abs(a[1]) + Math.abs(a[2]) + Math.abs(a[3]) < 1e-12) return t.rect(e, i, n, s);
    const [o, l, h, c] = [
        [e, i],
        [e + n, i],
        [e + n, i + s],
        [e, i + s]
      ],
      d = Math.min(n / 2, s / 2),
      u = [Math.min(d, a[0]), Math.min(d, a[1]), Math.min(d, a[2]), Math.min(d, a[3])],
      p = [o[0] + u[0], o[1]],
      g = [o[0], o[1] + u[0]],
      f = [l[0] - u[1], l[1]],
      v = [l[0], l[1] + u[1]],
      m = [h[0] - u[2], h[1]],
      _ = [h[0], h[1] - u[2]],
      b = [c[0] + u[3], c[1]],
      x = [c[0], c[1] - u[3]];
    if ((t.moveTo(p[0], p[1]), t.lineTo(f[0], f[1]), !U(f, v))) {
      const e = f[0],
        i = f[1] + u[1];
      t.arc(e, i, u[1], -RB, 0, !1);
    }
    if ((t.lineTo(_[0], _[1]), !U(m, _))) {
      const e = _[0] - u[2],
        i = _[1];
      t.arc(e, i, u[2], 0, RB, !1);
    }
    if ((t.lineTo(b[0], b[1]), !U(b, x))) {
      const e = b[0],
        i = b[1] - u[3];
      t.arc(e, i, u[3], RB, Mt, !1);
    }
    if ((t.lineTo(g[0], g[1]), !U(p, g))) {
      const e = p[0],
        i = p[1] + u[0];
      t.arc(e, i, u[0], Mt, Mt + RB, !1);
    }
    return t.closePath(), t;
  }
  var BB = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    IB = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    DB = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let LB = class {
    constructor(t) {
      (this.rectRenderContribitions = t), (this.type = 'rect'), (this.numberType = IE);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      const l = Zk(t, null == r ? void 0 : r.theme).rect,
        {
          fill: h = l.fill,
          background: c,
          stroke: d = l.stroke,
          width: u = l.width,
          height: p = l.height,
          cornerRadius: g = l.cornerRadius,
          opacity: v = l.opacity,
          fillOpacity: m = l.fillOpacity,
          lineWidth: y = l.lineWidth,
          strokeOpacity: _ = l.strokeOpacity,
          visible: b = l.visible,
          x: x = l.x,
          y: S = l.y
        } = t.attribute,
        w = cP(v, m, u, p, h),
        A = uP(v, _, u, p),
        k = oP(h, c),
        M = lP(d, y);
      if (!t.valid || !b) return;
      if (!k && !M) return;
      if (!(w || A || a || o || c)) return;
      0 === g || (f(g) && g.every(t => 0 === t))
        ? (e.beginPath(), e.rect(i, n, u, p))
        : (e.beginPath(), OB(e, i, n, u, p, g)),
        this._rectRenderContribitions ||
          ((this._rectRenderContribitions = this.rectRenderContribitions.getContributions() || []),
          this._rectRenderContribitions.sort((t, e) => e.order - t.order));
      const T = { doFill: k, doStroke: M };
      this._rectRenderContribitions.forEach(r => {
        r.time === Lw.beforeFillStroke && r.drawShape(t, e, i, n, k, M, w, A, l, s, a, o, T);
      }),
        e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
        T.doFill && (a ? a(e, t.attribute, l) : w && (e.setCommonStyle(t, t.attribute, x - i, S - n, l), e.fill())),
        T.doStroke && (o ? o(e, t.attribute, l) : A && (e.setStrokeStyle(t, t.attribute, x - i, S - n, l), e.stroke())),
        this._rectRenderContribitions.forEach(r => {
          r.time === Lw.afterFillStroke && r.drawShape(t, e, i, n, k, M, w, A, l, s, a, o);
        });
    }
    draw(t, e, i, n) {
      const { context: s } = i;
      if (!s) return;
      s.highPerformanceSave();
      const r = Zk(t, null == n ? void 0 : n.theme).rect;
      let { x: a = r.x, y: o = r.y } = t.attribute;
      if (t.transMatrix.onlyTranslate()) {
        const e = t.getOffsetXY(r);
        (a += e.x), (o += e.y), s.setTransformForCurrent();
      } else (a = 0), (o = 0), s.transformFromMatrix(t.transMatrix, !0);
      pP(t, s, a, o, 0, n) || this.drawShape(t, s, a, o, i, n), s.highPerformanceRestore();
    }
  };
  LB = BB([ZS(), DB(0, tw(rw)), DB(0, JS(TP)), IB('design:paramtypes', [Object])], LB);
  var FB = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    jB = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    zB = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let HB = class extends gB {
    constructor(t) {
      super(), (this.symbolRenderContribitions = t), (this.numberType = FE);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      var l;
      const h = Zk(t, null == r ? void 0 : r.theme).symbol,
        {
          size: c = h.size,
          fill: d = h.fill,
          background: u,
          fillOpacity: p = h.fillOpacity,
          strokeOpacity: g = h.strokeOpacity,
          opacity: f = h.opacity,
          lineWidth: v = h.lineWidth,
          stroke: m = h.stroke,
          visible: y = h.visible,
          x: _ = h.x,
          y: b = h.y,
          scaleX: x = h.scaleX,
          scaleY: S = h.scaleY
        } = t.attribute,
        w = hP(f, p, d),
        A = dP(f, g),
        k = oP(d, u),
        M = lP(m, v);
      if (!t.valid || !y) return;
      if (!k && !M) return;
      if (!(w || A || a || o || u)) return;
      const T = t.getParsedPath();
      if (!T) return;
      const { keepDirIn3d: C = h.keepDirIn3d } = t.attribute,
        E = null !== (l = this.z) && void 0 !== l ? l : 0;
      if ((e.beginPath(), C && e.camera && e.project)) {
        const s = e.project(i, n, E),
          r = e.camera;
        (e.camera = null),
          !1 ===
            T.draw(e, c, s.x, s.y, void 0, (s, r) => {
              r.fill && (a ? a(e, t.attribute, h) : (e.setCommonStyle(t, r, _ - i, b - n), e.fill())),
                r.stroke && (o ? o(e, t.attribute, h) : (e.setStrokeStyle(t, r, (_ - i) / x, (b - n) / S), e.stroke()));
            }) && e.closePath(),
          (e.camera = r);
      } else
        !1 ===
          T.draw(e, c, i, n, E, (s, r) => {
            r.fill && (a ? a(e, t.attribute, h) : (e.setCommonStyle(t, r, _ - i, b - n), e.fill())),
              r.stroke && (o ? o(e, t.attribute, h) : (e.setStrokeStyle(t, r, (_ - i) / x, (b - n) / S), e.stroke()));
          }) && e.closePath();
      this._symbolRenderContribitions ||
        ((this._symbolRenderContribitions = this.symbolRenderContribitions.getContributions() || []),
        this._symbolRenderContribitions.sort((t, e) => e.order - t.order)),
        this._symbolRenderContribitions.forEach(r => {
          r.time === Lw.beforeFillStroke && r.drawShape(t, e, i, n, k, M, w, A, h, s, a, o);
        }),
        e.setShadowStyle && e.setShadowStyle(t, t.attribute, h),
        k &&
          !T.isSvg &&
          (a ? a(e, t.attribute, h) : w && (e.setCommonStyle(t, t.attribute, _ - i, b - n, h), e.fill())),
        M &&
          !T.isSvg &&
          (o ? o(e, t.attribute, h) : A && (e.setStrokeStyle(t, t.attribute, (_ - i) / x, (b - n) / S, h), e.stroke())),
        this._symbolRenderContribitions.forEach(r => {
          r.time === Lw.afterFillStroke && r.drawShape(t, e, i, n, k, M, w, A, h, s, a, o);
        });
    }
    draw(t, e, i, n) {
      const { context: s } = i;
      if (!s) return;
      s.highPerformanceSave();
      const r = Zk(t, null == n ? void 0 : n.theme).symbol,
        a = this.transform(t, r, s),
        { x: o, y: l, z: h, lastModelMatrix: c } = a;
      (this.z = h),
        pP(t, s, o, l, 0, n) ||
          (this.drawShape(t, s, o, l, i, n),
          (this.z = 0),
          s.modelMatrix !== c && HO.free(s.modelMatrix),
          (s.modelMatrix = c)),
        s.highPerformanceRestore();
    }
  };
  HB = FB([ZS(), zB(0, tw(rw)), zB(0, JS(CP)), jB('design:paramtypes', [Object])], HB);
  var NB = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    VB = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    WB = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let GB = class extends gB {
    constructor(t) {
      super(), (this.textRenderContribitions = t), (this.numberType = jE);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      var l;
      const h = Zk(t, null == r ? void 0 : r.theme).text,
        {
          text: c,
          fill: d = h.fill,
          stroke: u = h.stroke,
          fillOpacity: p = h.fillOpacity,
          strokeOpacity: g = h.strokeOpacity,
          opacity: f = h.opacity,
          lineWidth: v = h.lineWidth,
          visible: m = h.visible,
          underline: y = h.underline,
          lineThrough: _ = h.lineThrough,
          keepDirIn3d: b = h.keepDirIn3d,
          direction: x = h.direction,
          fontSize: S = h.fontSize,
          textBaseline: w = h.textBaseline,
          textAlign: A = h.textAlign,
          x: k = h.x,
          y: M = h.y
        } = t.attribute,
        T = null !== (l = t.attribute.lineHeight) && void 0 !== l ? l : S,
        C = hP(f, p, d),
        E = dP(f, g),
        P = oP(d),
        R = lP(u, v);
      if (!t.valid || !m) return;
      if (!(P || R || C || E)) return;
      const O = !b,
        B = this.z || 0;
      if ((e.beginPath(), !this._textBeforeRenderContribitions)) {
        const t = this.textRenderContribitions.getContributions() || [];
        t.sort((t, e) => e.order - t.order),
          (this._textBeforeRenderContribitions = []),
          (this._textAfterRenderContribitions = []),
          t.forEach(t => {
            t.time === Lw.beforeFillStroke
              ? this._textBeforeRenderContribitions.push(t)
              : this._textAfterRenderContribitions.push(t);
          });
      }
      this._textBeforeRenderContribitions.forEach(r => {
        r.drawShape(t, e, i, n, P, R, C, E, h, s, a, o);
      }),
        e.setShadowStyle && e.setShadowStyle(t, t.attribute, h),
        O && this.transformUseContext2d(t, h, B, e);
      const I = (s, r, l, c) => {
        let d = i + r;
        const u = n + l;
        if (c) {
          e.highPerformanceSave(), (d += S);
          const t = zO.allocate(1, 0, 0, 1, 0, 0);
          t.rotateByCenter(Math.PI / 2, d, u), e.transformFromMatrix(t, !0), zO.free(t);
        }
        R &&
          (o
            ? o(e, t.attribute, h)
            : E && (e.setStrokeStyle(t, t.attribute, k - i, M - n, h), e.strokeText(s, d, u, B))),
          P &&
            (a
              ? a(e, t.attribute, h)
              : C &&
                (e.setCommonStyle(t, t.attribute, k - i, M - n, h),
                e.fillText(s, d, u, B),
                this.drawUnderLine(y, _, t, d, u, B, h, e))),
          c && (e.highPerformanceRestore(), e.setTransformForCurrent());
      };
      if (Array.isArray(c))
        if ((e.setTextStyleWithoutAlignBaseline(t.attribute, h, B), 'horizontal' === x)) {
          const { multilineLayout: s } = t;
          if (!s) return void e.highPerformanceRestore();
          const { xOffset: r, yOffset: l } = s.bbox;
          R &&
            (o
              ? o(e, t.attribute, h)
              : E &&
                (e.setStrokeStyle(t, t.attribute, k - i, M - n, h),
                s.lines.forEach(t => {
                  e.strokeText(t.str, (t.leftOffset || 0) + r + i, (t.topOffset || 0) + l + n, B);
                }))),
            P &&
              (a
                ? a(e, t.attribute, h)
                : C &&
                  (e.setCommonStyle(t, t.attribute, k - i, M - n, h),
                  s.lines.forEach(s => {
                    e.fillText(s.str, (s.leftOffset || 0) + r + i, (s.topOffset || 0) + l + n, B),
                      this.drawMultiUnderLine(
                        y,
                        _,
                        t,
                        (s.leftOffset || 0) + i,
                        (s.topOffset || 0) + l + n,
                        B,
                        s.width,
                        h,
                        e
                      );
                  })));
        } else {
          const i = t.cache,
            { verticalList: n } = i;
          (e.textAlign = 'left'), (e.textBaseline = 'top');
          const s = T * n.length;
          let r = 0;
          n.forEach(t => {
            const e = t.reduce((t, e) => t + (e.width || 0), 0);
            r = Bt(e, r);
          });
          let a = 0,
            o = 0;
          'bottom' === w ? (o = -s) : 'middle' === w && (o = -s / 2),
            'center' === A ? (a -= r / 2) : 'right' === A && (a -= r),
            n.forEach((t, e) => {
              const i = t.reduce((t, e) => t + (e.width || 0), 0),
                n = r - i;
              let l = a;
              'center' === A ? (l += n / 2) : 'right' === A && (l += n),
                t.forEach(t => {
                  const { text: i, width: n, direction: r } = t;
                  I(i, s - (e + 1) * T + o, l, r), (l += n);
                });
            });
        }
      else {
        const i = t.cache;
        if ('horizontal' === x) {
          e.setTextStyle(t.attribute, h, B);
          const i = t.clipedText;
          let n = 0;
          T !== S && ('top' === w ? (n = (T - S) / 2) : 'middle' === w || ('bottom' === w && (n = -(T - S) / 2))),
            I(i, 0, n, 0);
        } else if (i) {
          e.setTextStyleWithoutAlignBaseline(t.attribute, h, B);
          const { verticalList: n } = i;
          let s = 0;
          const r = n[0].reduce((t, e) => t + (e.width || 0), 0);
          let a = 0;
          'bottom' === w ? (a = -T) : 'middle' === w && (a = -T / 2),
            'center' === A ? (s -= r / 2) : 'right' === A && (s -= r),
            (e.textAlign = 'left'),
            (e.textBaseline = 'top'),
            n[0].forEach(t => {
              const { text: e, width: i, direction: n } = t;
              I(e, a, s, n), (s += i);
            });
        }
      }
      O && this.restoreTransformUseContext2d(t, h, B, e),
        this._textAfterRenderContribitions.forEach(r => {
          r.drawShape(t, e, i, n, P, R, C, E, h, s, a, o);
        });
    }
    draw(t, e, i, n) {
      const { context: s } = i;
      if (!s) return;
      s.highPerformanceSave();
      const r = Zk(t, null == n ? void 0 : n.theme).text,
        { keepDirIn3d: a = r.keepDirIn3d } = t.attribute,
        o = !a,
        l = this.transform(t, r, s, o),
        { x: h, y: c, z: d, lastModelMatrix: u } = l;
      (this.z = d), this.drawShape(t, s, h, c, i, n), (this.z = 0), (s.modelMatrix = u), s.highPerformanceRestore();
    }
    drawUnderLine(t, e, i, n, s, r, a, o) {
      if (e + t <= 0) return;
      const {
          textAlign: l = a.textAlign,
          textBaseline: h = a.textBaseline,
          fontSize: c = a.fontSize,
          fill: d = a.fill,
          opacity: u = a.opacity,
          fillOpacity: p = a.fillOpacity
        } = i.attribute,
        g = i.clipedWidth,
        f = VP(l, g),
        v = WP(h, c, c),
        m = { lineWidth: 0, stroke: d, opacity: u, strokeOpacity: p };
      if (t) {
        (m.lineWidth = t), o.setStrokeStyle(i, m, n, s, a), o.beginPath();
        const e = s + v + c;
        o.moveTo(n + f, e, r), o.lineTo(n + f + g, e, r), o.stroke();
      }
      if (e) {
        (m.lineWidth = e), o.setStrokeStyle(i, m, n, s, a), o.beginPath();
        const t = s + v + c / 2;
        o.moveTo(n + f, t, r), o.lineTo(n + f + g, t, r), o.stroke();
      }
    }
    drawMultiUnderLine(t, e, i, n, s, r, a, o, l) {
      if (e + t <= 0) return;
      const {
          textAlign: h = o.textAlign,
          fontSize: c = o.fontSize,
          fill: d = o.fill,
          opacity: u = o.opacity,
          fillOpacity: p = o.fillOpacity
        } = i.attribute,
        g = VP(h, a),
        f = WP('alphabetic', c, c),
        v = { lineWidth: 0, stroke: d, opacity: u, strokeOpacity: p };
      let m = -3;
      if (t) {
        (v.lineWidth = t), l.setStrokeStyle(i, v, n, s, o), l.beginPath();
        const e = s + f + c + m;
        l.moveTo(n + g, e, r), l.lineTo(n + g + a, e, r), l.stroke();
      }
      if (((m = -1), e)) {
        (v.lineWidth = e), l.setStrokeStyle(i, v, n, s, o), l.beginPath();
        const t = s + f + c / 2 + m;
        l.moveTo(n + g, t, r), l.lineTo(n + g + a, t, r), l.stroke();
      }
    }
  };
  GB = NB([ZS(), WB(0, tw(rw)), WB(0, JS(EP)), VB('design:paramtypes', [Object])], GB);
  var UB = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let YB = class {};
  function $B(t, e, i, n) {
    t.moveTo(e[0].x + i, e[0].y + n);
    for (let s = 1; s < e.length; s++) t.lineTo(e[s].x + i, e[s].y + n);
  }
  function XB(t, e) {
    return Math.sqrt(t * t + e * e);
  }
  function KB(t, e, i, n, s) {
    const r = e / i;
    return { x: t.x - n * r, y: t.y - s * r };
  }
  YB = UB([ZS()], YB);
  var qB = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    ZB = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    JB = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let QB = class {
    constructor(t) {
      (this.polygonRenderContribitions = t), (this.numberType = OE);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      const l = Zk(t, null == r ? void 0 : r.theme).polygon,
        {
          points: h = l.points,
          fill: c = l.fill,
          stroke: d = l.stroke,
          cornerRadius: u = l.cornerRadius,
          fillOpacity: p = l.fillOpacity,
          background: g,
          strokeOpacity: v = l.strokeOpacity,
          lineWidth: m = l.lineWidth,
          opacity: y = l.opacity,
          visible: _ = l.visible,
          x: b = l.x,
          y: x = l.y
        } = t.attribute,
        S = hP(y, p, c),
        w = dP(y, v),
        A = oP(c, g),
        k = lP(d, m);
      t.valid &&
        _ &&
        (A || k) &&
        (S || w || a || o || g) &&
        (e.beginPath(),
        u <= 0 || (f(u) && u.every(t => 0 === t))
          ? $B(e.camera ? e : e.nativeContext, h, i, n)
          : (function (t, e, i, n, s) {
              var r;
              if (e.length < 3) $B(t, e, i, n);
              else
                for (let a = 0; a < e.length; a++) {
                  const o = e[a],
                    l = e[(a + 1) % e.length],
                    h = e[(a + 2) % e.length],
                    c = l.x - o.x,
                    d = l.y - o.y,
                    u = l.x - h.x,
                    p = l.y - h.y,
                    g = (Math.atan2(d, c) - Math.atan2(p, u)) / 2,
                    f = Math.abs(Math.tan(g));
                  let v = Array.isArray(s) ? (null !== (r = s[(a + 1) % e.length]) && void 0 !== r ? r : 0) : s,
                    m = v / f;
                  const y = XB(c, d),
                    _ = XB(u, p),
                    b = Math.min(y, _);
                  m > b && ((m = b), (v = b * f));
                  const x = KB(l, m, y, c, d),
                    S = KB(l, m, _, u, p),
                    w = 2 * l.x - x.x - S.x,
                    A = 2 * l.y - x.y - S.y,
                    k = XB(w, A),
                    M = KB(l, XB(m, v), k, w, A);
                  let T = Math.atan2(x.y - M.y, x.x - M.x);
                  const C = Math.atan2(S.y - M.y, S.x - M.x);
                  let E = C - T;
                  E < 0 && ((T = C), (E = -E)),
                    E > Math.PI && (E -= Math.PI),
                    0 === a ? t.moveTo(x.x + i, x.y + n) : t.lineTo(x.x + i, x.y + n),
                    E && t.arcTo(l.x + i, l.y + n, S.x + i, S.y + n, v),
                    t.lineTo(S.x + i, S.y + n);
                }
            })(e.camera ? e : e.nativeContext, h, i, n, u),
        e.closePath(),
        this._polygonRenderContribitions ||
          ((this._polygonRenderContribitions = this.polygonRenderContribitions.getContributions() || []),
          this._polygonRenderContribitions.sort((t, e) => e.order - t.order)),
        this._polygonRenderContribitions.forEach(r => {
          r.time === Lw.beforeFillStroke && r.drawShape(t, e, i, n, A, k, S, w, l, s, a, o);
        }),
        e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
        A && (a ? a(e, t.attribute, l) : p && (e.setCommonStyle(t, t.attribute, b - i, x - n, l), e.fill())),
        k && (o ? o(e, t.attribute, l) : v && (e.setStrokeStyle(t, t.attribute, b - i, x - n, l), e.stroke())),
        this._polygonRenderContribitions.forEach(r => {
          r.time === Lw.afterFillStroke && r.drawShape(t, e, i, n, A, k, S, w, l, s, a, o);
        }));
    }
    draw(t, e, i, n) {
      const { context: s } = i;
      if (!s) return;
      s.highPerformanceSave();
      const r = Zk(t, null == n ? void 0 : n.theme).polygon;
      let { x: a = r.x, y: o = r.y } = t.attribute;
      if (t.transMatrix.onlyTranslate()) {
        const e = t.getOffsetXY(r);
        (a += e.x), (o += e.y), s.setTransformForCurrent();
      } else (a = 0), (o = 0), s.transformFromMatrix(t.transMatrix, !0);
      pP(t, s, a, o, 0, n) || this.drawShape(t, s, a, o, i, n), s.highPerformanceRestore();
    }
  };
  QB = qB([ZS(), JB(0, tw(rw)), JB(0, JS(MP)), ZB('design:paramtypes', [Object])], QB);
  var tI = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    eI = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    iI = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  const nI = ['', 'repeat-x', 'repeat-y', 'repeat'];
  let sI = class {
    constructor(t) {
      (this.imageRenderContribitions = t), (this.numberType = EE);
    }
    drawShape(t, e, i, n, s, r, a) {
      const o = Zk(t).image,
        {
          fill: l = o.fill,
          width: h = o.width,
          height: c = o.height,
          opacity: d = o.opacity,
          fillOpacity: u = o.fillOpacity,
          visible: p = o.visible,
          repeatX: g = o.repeatX,
          repeatY: v = o.repeatY,
          cornerRadius: m = o.cornerRadius,
          image: y
        } = t.attribute,
        _ = hP(d, u, l),
        b = oP(l);
      if (t.valid && p && b && (_ || a)) {
        if (
          (this._imageRenderContribitions ||
            (this._imageRenderContribitions = this.imageRenderContribitions.getContributions() || []),
          this._imageRenderContribitions.forEach(r => {
            r.time === Lw.beforeFillStroke && r.drawShape(t, e, i, n, b, !1, _, !1, o, s, a);
          }),
          e.setShadowStyle && e.setShadowStyle(t, o),
          b)
        )
          if (a) a(e, t.attribute, o);
          else if (_) {
            if (!y || !t.resources) return;
            const s = t.resources.get(y);
            if ('success' !== s.state) return;
            let r = !1;
            0 === m ||
              (f(m) && m.every(t => 0 === t)) ||
              (e.beginPath(), OB(e, i, n, h, c, m), e.save(), e.clip(), (r = !0)),
              e.setCommonStyle(t, t.attribute, i, n, o);
            let a = 0;
            if (('repeat' === g && (a |= 1), 'repeat' === v && (a |= 2), a)) {
              const t = e.createPattern(s.data, nI[a]);
              (e.fillStyle = t), e.fillRect(i, n, h, c);
            } else e.drawImage(s.data, i, n, h, c);
            r && e.restore();
          }
        this._imageRenderContribitions.forEach(r => {
          r.time === Lw.afterFillStroke && r.drawShape(t, e, i, n, b, !1, _, !1, o, s, a);
        });
      }
    }
    draw(t, e, i) {
      const { context: n } = e.drawParams;
      if (!n) return;
      const s = Zk(t).image;
      let { x: r = s.x, y: a = s.y } = t.attribute;
      const { image: o } = t.attribute;
      if (o && t.resources && 'success' === t.resources.get(o).state) {
        if ((n.highPerformanceSave(), t.transMatrix.onlyTranslate())) {
          const e = t.getOffsetXY(s);
          (r += e.x), (a += e.y), n.setTransformForCurrent();
        } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
        this.drawShape(t, n, r, a, i), n.highPerformanceRestore();
      }
    }
  };
  sI = tI([ZS(), iI(0, tw(rw)), iI(0, JS(AP)), eI('design:paramtypes', [Object])], sI);
  const rI = Symbol.for('IncrementalDrawContribution'),
    aI = Symbol.for('ArcRender'),
    oI = Symbol.for('Arc3dRender'),
    lI = Symbol.for('AreaRender'),
    hI = Symbol.for('CircleRender'),
    cI = Symbol.for('GraphicRender'),
    dI = Symbol.for('GroupRender'),
    uI = Symbol.for('LineRender'),
    pI = Symbol.for('PathRender'),
    gI = Symbol.for('PolygonRender'),
    fI = Symbol.for('RectRender'),
    vI = Symbol.for('Rect3DRender'),
    mI = Symbol.for('SymbolRender'),
    yI = Symbol.for('TextRender'),
    _I = Symbol.for('RichTextRender'),
    bI = Symbol.for('Pyramid3dRender'),
    xI = Symbol.for('GlyphRender'),
    SI = Symbol.for('ImageRender'),
    wI = Symbol.for('RenderSelector'),
    AI = Symbol.for('DrawContribution');
  function kI(t, e, i) {
    let n = e;
    const { a: s, b: r, c: a, d: o } = t.currentMatrix,
      l = Math.sign(s) * Math.sqrt(s * s + r * r),
      h = Math.sign(o) * Math.sqrt(a * a + o * o);
    return l + h === 0 ? 0 : ((n = (n / Math.abs(l + h)) * 2 * i), n);
  }
  function MI(t, e, i, n, s) {
    if (!e || !0 === e) return 'black';
    let r, a;
    if (f(e)) for (let t = 0; t < e.length && ((a = e[t]), !a); t++);
    else a = e;
    return 'string' == typeof a
      ? a
      : ('linear' === a.gradient
          ? (r = (function (t, e, i) {
              let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
              var r, a, o, l;
              const h = i.AABBBounds;
              if (!h) return;
              let c = h.x2 - h.x1,
                d = h.y2 - h.y1,
                u = h.x1 - n,
                p = h.y1 - s;
              if (i.attribute) {
                const { scaleX: t = 1, scaleY: e = 1 } = i.attribute;
                if (t * e == 0) return;
                (c /= t), (d /= e), (u /= t), (p /= e);
              }
              const g = t.createLinearGradient(
                u + (null !== (r = e.x0) && void 0 !== r ? r : 0) * c,
                p + (null !== (a = e.y0) && void 0 !== a ? a : 0) * d,
                u + (null !== (o = e.x1) && void 0 !== o ? o : 1) * c,
                p + (null !== (l = e.y1) && void 0 !== l ? l : 0) * d
              );
              return (
                e.stops.forEach(t => {
                  g.addColorStop(t.offset, t.color);
                }),
                g
              );
            })(t, a, i, n, s))
          : 'conical' === a.gradient
          ? (r = (function (t, e, i) {
              let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
              var r, a;
              const o = i.AABBBounds;
              if (!o) return;
              let l = o.x2 - o.x1,
                h = o.y2 - o.y1,
                c = o.x1 - n,
                d = o.y1 - s;
              if (i.attribute) {
                const { scaleX: t = 1, scaleY: e = 1 } = i.attribute;
                if (t * e == 0) return;
                (l /= t), (h /= e), (c /= t), (d /= e);
              }
              const u = t.createConicGradient(
                c + (null !== (r = e.x) && void 0 !== r ? r : 0) * l,
                d + (null !== (a = e.y) && void 0 !== a ? a : 0) * h,
                e.startAngle,
                e.endAngle
              );
              return (
                e.stops.forEach(t => {
                  u.addColorStop(t.offset, t.color);
                }),
                u.GetPattern(l + c, h + d, void 0)
              );
            })(t, a, i, n, s))
          : 'radial' === a.gradient &&
            (r = (function (t, e, i) {
              let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
              var r, a, o, l, h, c;
              const d = i.AABBBounds;
              if (!d) return;
              let u = d.x2 - d.x1,
                p = d.y2 - d.y1,
                g = d.x1 - n,
                f = d.y1 - s;
              if (i.attribute) {
                const { scaleX: t = 1, scaleY: e = 1 } = i.attribute;
                if (t * e == 0) return;
                (g /= t), (f /= e), (u /= t), (p /= e);
              }
              const v = t.createRadialGradient(
                g + (null !== (r = e.x0) && void 0 !== r ? r : 0.5) * u,
                f + (null !== (a = e.y0) && void 0 !== a ? a : 0.5) * p,
                Math.max(u, p) * (null !== (o = e.r0) && void 0 !== o ? o : 0),
                g + (null !== (l = e.x1) && void 0 !== l ? l : 0.5) * u,
                f + (null !== (h = e.y1) && void 0 !== h ? h : 0.5) * p,
                Math.max(u, p) * (null !== (c = e.r1) && void 0 !== c ? c : 0.5)
              );
              return (
                e.stops.forEach(t => {
                  v.addColorStop(t.offset, t.color);
                }),
                v
              );
            })(t, a, i, n, s)),
        r || 'orange');
  }
  const TI = new (class {
    constructor() {
      this.pools = [];
    }
    allocate(t) {
      if (!this.pools.length) return ok(Object.assign({ nativeCanvas: WA.global.createCanvas(t) }, t));
      const e = this.pools.pop();
      return e.resize(t.width, t.height), (e.dpr = t.dpr), e;
    }
    allocateByObj(t) {
      if (!this.pools.length) {
        const e = { width: t.width / t.dpr, height: t.height / t.dpr, dpr: t.dpr };
        return ok(Object.assign({ nativeCanvas: WA.global.createCanvas(e) }, e));
      }
      const e = this.pools.pop();
      return (e.width = t.width), (e.height = t.height), e;
    }
    free(t) {
      this.pools.push(t);
    }
    get length() {
      return this.pools.length;
    }
    release() {
      this.pools = [];
    }
  })();
  var CI = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    EI = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    PI = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let RI = class {
    constructor() {
      (this.time = Lw.beforeFillStroke), (this.useStyle = !0), (this.order = 0);
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, c, d, u) {
      const { background: p } = t.attribute;
      if (p)
        if (t.backgroundImg && t.resources) {
          const s = t.resources.get(p);
          if ('success' !== s.state || !s.data) return;
          if ((e.save(), t.parent && !t.transMatrix.onlyTranslate())) {
            const i = Zk(t.parent).group,
              { scrollX: n = i.scrollX, scrollY: s = i.scrollY } = t.parent.attribute;
            e.setTransformFromMatrix(t.parent.globalTransMatrix, !0), e.translate(n, s);
          }
          e.clip();
          const r = t.AABBBounds;
          e.setCommonStyle(t, t.attribute, i, n, l),
            e.drawImage(s.data, r.x1, r.y1, r.width(), r.height()),
            e.restore(),
            t.transMatrix.onlyTranslate() || e.setTransformForCurrent();
        } else
          e.highPerformanceSave(),
            e.setCommonStyle(t, t.attribute, i, n, l),
            (e.fillStyle = p),
            e.fill(),
            e.highPerformanceRestore();
    }
  };
  RI = CI([ZS()], RI);
  let OI = class {
    constructor(t) {
      (this.subRenderContribitions = t), (this.time = Lw.afterFillStroke), (this.useStyle = !0), (this.order = 0);
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, c, d, u) {
      this._subRenderContribitions || (this._subRenderContribitions = this.subRenderContribitions.getContributions()),
        this._subRenderContribitions.forEach(p => {
          p.render(t, e, i, n, s, r, a, o, l, h, c, d, u);
        });
    }
  };
  OI = CI([ZS(), PI(0, tw(rw)), PI(0, JS(PP)), EI('design:paramtypes', [Object])], OI);
  let BI = class {
    constructor() {
      (this.time = Lw.afterFillStroke), (this.useStyle = !0), (this.order = 10);
    }
    createCommonPattern(t, e, i, n, s) {
      const r = (t - 2 * e) / 2,
        a = TI.allocate({ width: t, height: t, dpr: 1 }),
        o = a.getContext('2d');
      if (!o) return null;
      o.clearRect(0, 0, t, t), s(r, o);
      const l = n.createPattern(a.nativeCanvas, 'repeat');
      return TI.free(a), l;
    }
    createCirclePattern(t, e, i, n) {
      return this.createCommonPattern(t, e, i, n, (t, e) => {
        (e.fillStyle = i), e.arc(t, t, t, 0, Et), e.fill();
      });
    }
    createDiamondPattern(t, e, i, n) {
      return this.createCommonPattern(t, e, i, n, (e, n) => {
        const s = t / 2,
          r = s;
        (n.fillStyle = i),
          n.moveTo(s, r - e),
          n.lineTo(e + s, r),
          n.lineTo(s, r + e),
          n.lineTo(s - e, r),
          n.closePath(),
          n.fill();
      });
    }
    createRectPattern(t, e, i, n) {
      return this.createCommonPattern(t, e, i, n, (t, n) => {
        const s = e,
          r = s;
        (n.fillStyle = i), n.fillRect(s, r, 2 * t, 2 * t);
      });
    }
    createVerticalLinePattern(t, e, i, n) {
      return this.createCommonPattern(t, e, i, n, (n, s) => {
        const r = e;
        (s.fillStyle = i), s.fillRect(r, 0, 2 * n, t);
      });
    }
    createHorizontalLinePattern(t, e, i, n) {
      return this.createCommonPattern(t, e, i, n, (n, s) => {
        const r = e;
        (s.fillStyle = i), s.fillRect(0, r, t, 2 * n);
      });
    }
    createBiasLRLinePattern(t, e, i, n) {
      return this.createCommonPattern(t, e, i, n, (e, n) => {
        (n.strokeStyle = i), (n.lineWidth = e), n.moveTo(0, 0), n.lineTo(t, t);
        const s = t / 2,
          r = -s;
        n.moveTo(s, r), n.lineTo(s + t, r + t), n.moveTo(-s, -r), n.lineTo(-s + t, -r + t), n.stroke();
      });
    }
    createBiasRLLinePattern(t, e, i, n) {
      return this.createCommonPattern(t, e, i, n, (e, n) => {
        (n.strokeStyle = i), (n.lineWidth = e), n.moveTo(t, 0), n.lineTo(0, t);
        const s = t / 2,
          r = s;
        n.moveTo(t + s, r), n.lineTo(s, r + t), n.moveTo(t - s, -r), n.lineTo(-s, -r + t), n.stroke();
      });
    }
    createGridPattern(t, e, i, n) {
      return this.createCommonPattern(t, e, i, n, (t, n) => {
        const s = e,
          r = s;
        (n.fillStyle = i), n.fillRect(s, r, t, t), n.fillRect(s + t, r + t, t, t);
      });
    }
    initTextureMap(t, e) {
      this.textureMap = new Map();
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, c, d, u) {
      this.textureMap || this.initTextureMap(e, t.stage);
      const {
        texture: p = l.texture,
        textureColor: g = l.textureColor,
        textureSize: f = l.textureSize,
        texturePadding: v = l.texturePadding
      } = t.attribute;
      if (!p) return;
      let m = this.textureMap.get(p);
      if (!m)
        switch (p) {
          case 'circle':
            m = this.createCirclePattern(f, v, g, e);
            break;
          case 'diamond':
            m = this.createDiamondPattern(f, v, g, e);
            break;
          case 'rect':
            m = this.createRectPattern(f, v, g, e);
            break;
          case 'vertical-line':
            m = this.createVerticalLinePattern(f, v, g, e);
            break;
          case 'horizontal-line':
            m = this.createHorizontalLinePattern(f, v, g, e);
            break;
          case 'bias-lr':
            m = this.createBiasLRLinePattern(f, v, g, e);
            break;
          case 'bias-rl':
            m = this.createBiasRLLinePattern(f, v, g, e);
            break;
          case 'grid':
            m = this.createGridPattern(f, v, g, e);
        }
      m &&
        (e.highPerformanceSave(),
        e.setCommonStyle(t, t.attribute, i, n, l),
        (e.fillStyle = m),
        e.fill(),
        e.highPerformanceRestore());
    }
  };
  BI = CI([ZS()], BI);
  var II = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let DI = class {
    constructor() {
      (this.time = Lw.afterFillStroke), (this.useStyle = !0), (this.order = 0);
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, c, d) {
      const { outerBorder: u, innerBorder: p } = t.attribute,
        g = u && !1 !== u.visible,
        f = p && !1 !== p.visible;
      if (!g && !f) return;
      const {
          innerRadius: v = l.innerRadius,
          outerRadius: m = l.outerRadius,
          startAngle: y = l.startAngle,
          endAngle: _ = l.endAngle,
          opacity: b = l.opacity,
          x: x = l.x,
          y: S = l.y,
          scaleX: w = l.scaleX,
          scaleY: A = l.scaleY
        } = t.attribute,
        k = !(!u || !u.stroke),
        M = !(!p || !p.stroke);
      if (g) {
        const { distance: s = l.outerBorder.distance } = u,
          r = kI(e, s, e.dpr),
          a = s / m;
        if (
          (t.setAttributes({ outerRadius: m + r, innerRadius: v - r, startAngle: y - a, endAngle: _ + a }),
          e.beginPath(),
          vP(t, e, i, n, m + r, v - r),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
          d)
        )
          d(e, u, l.outerBorder);
        else if (k) {
          const s = l.outerBorder.opacity;
          (l.outerBorder.opacity = b),
            e.setStrokeStyle(t, u, (x - i) / w, (S - n) / A, l.outerBorder),
            (l.outerBorder.opacity = s),
            e.stroke();
        }
      }
      if (f) {
        const { distance: s = l.innerBorder.distance } = p,
          r = kI(e, s, e.dpr),
          a = s / m;
        if (
          (t.setAttributes({ outerRadius: m - r, innerRadius: v + r, startAngle: y + a, endAngle: _ - a }),
          e.beginPath(),
          vP(t, e, i, n, m - r, v + r),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
          d)
        )
          d(e, p, l.innerBorder);
        else if (M) {
          const s = l.innerBorder.opacity;
          (l.innerBorder.opacity = b),
            e.setStrokeStyle(t, p, (x - i) / w, (S - n) / A, l.innerBorder),
            (l.innerBorder.opacity = s),
            e.stroke();
        }
      }
      t.setAttributes({ outerRadius: m, innerRadius: v, startAngle: y, endAngle: _ });
    }
  };
  DI = II([ZS()], DI);
  let LI = class extends RI {
    constructor() {
      super(...arguments), (this.time = Lw.beforeFillStroke);
    }
  };
  LI = II([ZS()], LI);
  let FI = class extends BI {
    constructor() {
      super(...arguments), (this.time = Lw.afterFillStroke);
    }
  };
  FI = II([ZS()], FI);
  var jI = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let zI = class {
    constructor() {
      (this.time = Lw.afterFillStroke), (this.useStyle = !0), (this.order = 0);
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, c, d) {
      const { outerBorder: u, innerBorder: p } = t.attribute,
        g = u && !1 !== u.visible,
        f = p && !1 !== p.visible;
      if (!g && !f) return;
      const {
          radius: v = l.radius,
          startAngle: m = l.startAngle,
          endAngle: y = l.endAngle,
          opacity: _ = l.opacity,
          x: b = l.x,
          y: x = l.y,
          scaleX: S = l.scaleX,
          scaleY: w = l.scaleY
        } = t.attribute,
        A = !(!u || !u.stroke),
        k = !(!p || !p.stroke);
      if (g) {
        const { distance: s = l.outerBorder.distance } = u,
          r = kI(e, s, e.dpr);
        if (
          (e.beginPath(),
          e.arc(i, n, v + r, m, y),
          e.closePath(),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
          d)
        )
          d(e, u, l.outerBorder);
        else if (A) {
          const s = l.outerBorder.opacity;
          (l.outerBorder.opacity = _),
            e.setStrokeStyle(t, u, (b - i) / S, (x - n) / w, l.outerBorder),
            (l.outerBorder.opacity = s),
            e.stroke();
        }
      }
      if (f) {
        const { distance: s = l.innerBorder.distance } = p,
          r = kI(e, s, e.dpr);
        if (
          (e.beginPath(),
          e.arc(i, n, v - r, m, y),
          e.closePath(),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
          d)
        )
          d(e, p, l.innerBorder);
        else if (k) {
          const s = l.innerBorder.opacity;
          (l.innerBorder.opacity = _),
            e.setStrokeStyle(t, p, (b - i) / S, (x - n) / w, l.innerBorder),
            (l.innerBorder.opacity = s),
            e.stroke();
        }
      }
    }
  };
  zI = jI([ZS()], zI);
  let HI = class extends RI {
    constructor() {
      super(...arguments), (this.time = Lw.beforeFillStroke);
    }
  };
  HI = jI([ZS()], HI);
  let NI = class extends BI {
    constructor() {
      super(...arguments), (this.time = Lw.afterFillStroke);
    }
  };
  NI = jI([ZS()], NI);
  var VI = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let WI = class extends RI {
    constructor() {
      super(...arguments), (this.time = Lw.beforeFillStroke);
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, c, d) {
      const { background: u } = t.attribute;
      if (u)
        if (t.backgroundImg && t.resources) {
          const i = t.resources.get(u);
          if ('success' !== i.state || !i.data) return;
          e.highPerformanceSave(), e.setTransformFromMatrix(t.parent.globalTransMatrix, !0);
          const n = t.AABBBounds;
          e.drawImage(i.data, n.x1, n.y1, n.width(), n.height()),
            e.highPerformanceRestore(),
            e.setTransformForCurrent();
        } else e.highPerformanceSave(), (e.fillStyle = u), e.fill(), e.highPerformanceRestore();
    }
  };
  WI = VI([ZS()], WI);
  var GI = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let UI = class extends RI {
    constructor() {
      super(...arguments), (this.time = Lw.beforeFillStroke);
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, d, u) {
      const { background: p, width: g, height: f } = t.attribute;
      if (p)
        if (t.backgroundImg) {
          const i = t.resources.get(p);
          if ('success' !== i.state || !i.data) return;
          if ((e.save(), t.parent && !t.transMatrix.onlyTranslate())) {
            const i = Zk(t.parent).group,
              { scrollX: n = i.scrollX, scrollY: s = i.scrollY } = t.parent.attribute;
            e.setTransformFromMatrix(t.parent.globalTransMatrix, !0), e.translate(n, s);
          }
          const n = t.AABBBounds;
          e.drawImage(i.data, n.x1, n.y1, n.width(), n.height()),
            e.restore(),
            t.transMatrix.onlyTranslate() || e.setTransformForCurrent();
        } else if (c(p)) {
          const { stroke: i, fill: n, lineWidth: s = 1, cornerRadius: r = 0, expandX: a = 0, expandY: o = 0 } = p;
          if (!i && !n) return;
          e.beginPath();
          const {
            x: l,
            y: h,
            width: c,
            height: d
          } = (function (t) {
            const e = DM(t.attribute.boundsPadding),
              i = t.AABBBounds;
            let n = i.x1,
              s = i.y1,
              r = i.width(),
              a = i.height();
            return (
              y(e)
                ? ((n += e), (s += e), (r -= 2 * e), (a -= 2 * e))
                : ((n += e[3]), (s += e[0]), (r -= e[1] + e[3]), (a -= e[0] + e[2])),
              { x: n, y: s, width: r, height: a }
            );
          })(t);
          r ? OB(e, l - a, h - o, c + 2 * a, d + 2 * o, r) : e.rect(l - a, h - o, c + 2 * a, d + 2 * o),
            (e.globalAlpha = 1),
            n && ((e.fillStyle = n), e.fill()),
            i && s > 0 && ((e.lineWidth = s), (e.strokeStyle = i), e.stroke());
        } else {
          e.beginPath();
          const s = t.AABBBounds;
          e.rect(i, n, s.width(), s.height()), (e.fillStyle = p), (e.globalAlpha = 1), e.fill();
        }
    }
  };
  UI = GI([ZS()], UI);
  var YI = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let $I = class {
    constructor() {
      (this.time = Lw.afterFillStroke), (this.useStyle = !0), (this.order = 0);
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, c, d) {
      const { outerBorder: u, innerBorder: p } = t.attribute,
        g = u && !1 !== u.visible,
        v = p && !1 !== p.visible;
      if (!g && !v) return;
      const {
          width: m = l.width,
          height: y = l.height,
          cornerRadius: _ = l.cornerRadius,
          opacity: b = l.opacity,
          x: x = l.x,
          y: S = l.y,
          scaleX: w = l.scaleX,
          scaleY: A = l.scaleY
        } = t.attribute,
        k = !(!u || !u.stroke),
        M = !(!p || !p.stroke);
      if (g) {
        const { distance: s = l.outerBorder.distance } = u,
          r = kI(e, s, e.dpr),
          a = i - r,
          o = n - r,
          h = 2 * r;
        if (
          (0 === _ || (f(_) && _.every(t => 0 === t))
            ? (e.beginPath(), e.rect(a, o, m + h, y + h))
            : (e.beginPath(), OB(e, a, o, m + h, y + h, _)),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
          d)
        )
          d(e, u, l.outerBorder);
        else if (k) {
          const s = l.outerBorder.opacity;
          (l.outerBorder.opacity = b),
            e.setStrokeStyle(t, u, (x - i) / w, (S - n) / A, l.outerBorder),
            (l.outerBorder.opacity = s),
            e.stroke();
        }
      }
      if (v) {
        const { distance: s = l.innerBorder.distance } = p,
          r = kI(e, s, e.dpr),
          a = i + r,
          o = n + r,
          h = 2 * r;
        if (
          (0 === _ || (f(_) && _.every(t => 0 === t))
            ? (e.beginPath(), e.rect(a, o, m - h, y - h))
            : (e.beginPath(), OB(e, a, o, m - h, y - h, _)),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
          d)
        )
          d(e, p, l.innerBorder);
        else if (M) {
          const s = l.innerBorder.opacity;
          (l.innerBorder.opacity = b),
            e.setStrokeStyle(t, p, (x - i) / w, (S - n) / A, l.innerBorder),
            (l.innerBorder.opacity = s),
            e.stroke();
        }
      }
    }
  };
  $I = YI([ZS()], $I);
  let XI = class extends RI {
    constructor() {
      super(...arguments), (this.time = Lw.beforeFillStroke);
    }
  };
  XI = YI([ZS()], XI);
  let KI = class extends BI {
    constructor() {
      super(...arguments), (this.time = Lw.afterFillStroke);
    }
  };
  KI = YI([ZS()], KI);
  let qI = class {
    constructor() {
      (this.time = Lw.beforeFillStroke), (this.useStyle = !0), (this.order = 0);
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, c, d, u) {
      const { stroke: p = l.stroke } = t.attribute;
      Array.isArray(p) && p.some(t => !1 === t) && (u.doStroke = !1);
    }
  };
  qI = YI([ZS()], qI);
  let ZI = class {
    constructor() {
      (this.time = Lw.afterFillStroke), (this.useStyle = !0), (this.order = 0);
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, c, d) {
      const { width: u = l.width, height: p = l.height, stroke: g = l.stroke } = t.attribute;
      if (Array.isArray(g) && g.some(t => !1 === t)) {
        if (
          (e.setStrokeStyle(t, t.attribute, i, n, l),
          e.beginPath(),
          e.moveTo(i, n),
          g[0] ? e.lineTo(i + u, n) : e.moveTo(i + u, n),
          g[1] ? e.lineTo(i + u, n + p) : e.moveTo(i + u, n + p),
          g[2] ? e.lineTo(i, n + p) : e.moveTo(i, n + p),
          g[3])
        ) {
          const t = g[0] ? n - e.lineWidth / 2 : n;
          e.lineTo(i, t);
        } else e.moveTo(i, n);
        e.stroke();
      }
    }
  };
  ZI = YI([ZS()], ZI);
  var JI = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let QI = class {
    constructor() {
      (this.time = Lw.afterFillStroke), (this.useStyle = !0), (this.order = 0);
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, c, d) {
      const u = t.getParsedPath();
      if (!u) return;
      const { outerBorder: p, innerBorder: g } = t.attribute,
        f = p && !1 !== p.visible,
        v = g && !1 !== g.visible;
      if (!f && !v) return;
      const {
          size: m = l.size,
          opacity: y = l.opacity,
          x: _ = l.x,
          y: b = l.y,
          scaleX: x = l.scaleX,
          scaleY: S = l.scaleY
        } = t.attribute,
        w = !(!p || !p.stroke),
        A = !(!g || !g.stroke);
      if (f) {
        const { distance: s = l.outerBorder.distance } = p,
          r = kI(e, s, e.dpr);
        if (
          (e.beginPath(),
          !1 === u.drawOffset(e, m, i, n, r) && e.closePath(),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
          d)
        )
          d(e, p, l.outerBorder);
        else if (w) {
          const s = l.outerBorder.opacity;
          (l.outerBorder.opacity = y),
            e.setStrokeStyle(t, p, (_ - i) / x, (b - n) / S, l.outerBorder),
            (l.outerBorder.opacity = s),
            e.stroke();
        }
      }
      if (v) {
        const { distance: s = l.innerBorder.distance } = g,
          r = kI(e, s, e.dpr);
        if (
          (e.beginPath(),
          !1 === u.drawOffset(e, m, i, n, -r) && e.closePath(),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
          d)
        )
          d(e, g, l.innerBorder);
        else if (A) {
          const s = l.innerBorder.opacity;
          (l.innerBorder.opacity = y),
            e.setStrokeStyle(t, g, (_ - i) / x, (b - n) / S, l.innerBorder),
            (l.innerBorder.opacity = s),
            e.stroke();
        }
      }
    }
  };
  QI = JI([ZS()], QI);
  class tD extends RI {
    constructor() {
      super(...arguments), (this.time = Lw.beforeFillStroke);
    }
  }
  class eD extends BI {
    constructor() {
      super(...arguments), (this.time = Lw.afterFillStroke);
    }
  }
  var iD = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    nD = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    sD = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  const rD = Symbol.for('RenderService');
  let aD = class {
    constructor(t) {
      this.drawContribution = t;
    }
    prepare(t) {
      this.renderTreeRoots.forEach(e => {
        this._prepare(e, t);
      });
    }
    _prepare(t, e) {
      t.forEachChildren(t => {
        this._prepare(t, e);
      }),
        t.update({ bounds: e, trans: !0 });
    }
    prepareRenderList() {}
    beforeDraw(t) {}
    draw(t) {
      this.drawContribution.draw(this, Object.assign({}, this.drawParams));
    }
    afterDraw(t) {
      this.drawContribution.afterDraw && this.drawContribution.afterDraw(this, Object.assign({}, this.drawParams));
    }
    render(t, e) {
      (this.renderTreeRoots = t), (this.drawParams = e);
      const i = e.updateBounds;
      this.prepare(i), this.prepareRenderList(), this.beforeDraw(e), this.draw(e), this.afterDraw(e);
    }
  };
  aD = iD([ZS(), sD(0, tw(AI)), nD('design:paramtypes', [Object])], aD);
  var oD = new YS(t => {
      t(aD).toSelf(), t(rD).toService(aD);
    }),
    lD = function (t, e, i, n) {
      return new (i || (i = Promise))(function (s, r) {
        function a(t) {
          try {
            l(n.next(t));
          } catch (t) {
            r(t);
          }
        }
        function o(t) {
          try {
            l(n.throw(t));
          } catch (t) {
            r(t);
          }
        }
        function l(t) {
          var e;
          t.done
            ? s(t.value)
            : ((e = t.value),
              e instanceof i
                ? e
                : new i(function (t) {
                    t(e);
                  })).then(a, o);
        }
        l((n = n.apply(t, e || [])).next());
      });
    };
  function hD(t, e, i) {
    let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
      s = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    const r = {},
      a = [];
    let o = !1;
    if (s) o = !0;
    else {
      let i;
      t.forEachChildren((t, n) => {
        const { zIndex: s = e } = t.attribute;
        if (0 === n) i = s;
        else if (i !== s) return (o = !0), !0;
        return !1;
      }, n);
    }
    if (o) {
      t.forEachChildren(t => {
        const { zIndex: i = e } = t.attribute;
        r[i] ? r[i].push(t) : ((r[i] = [t]), a.push(i));
      }, n),
        a.sort((t, e) => (n ? e - t : t - e));
      let o = !1;
      for (let t = 0; t < a.length && !o; t++) {
        const e = a[t],
          l = r[e];
        s &&
          l.sort((t, e) => {
            var i, s;
            return (
              (n ? -1 : 1) *
              ((null !== (i = e.attribute.z) && void 0 !== i ? i : 0) -
                (null !== (s = t.attribute.z) && void 0 !== s ? s : 0))
            );
          });
        for (let t = 0; t < l.length; t++)
          if (i(l[t], t)) {
            o = !0;
            break;
          }
      }
    } else t.forEachChildren(i, n);
  }
  function cD(t, e, i) {
    let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    return lD(this, void 0, void 0, function* () {
      yield t.forEachChildrenAsync(i, n);
    });
  }
  function dD(t, e, i) {
    let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    const s = {},
      r = [];
    let a = !1;
    t.forEachChildren((t, e) => {
      const { zIndex: n = i } = t.attribute;
      if (0 === e);
      else if (void 0 !== n) return (a = !0), !0;
      return !1;
    }, n);
    let o = null,
      l = !1;
    if (a) {
      t.forEachChildren(t => {
        const { zIndex: e = i } = t.attribute;
        s[e] ? s[e].push(t) : ((s[e] = [t]), r.push(e));
      }, n),
        r.sort((t, e) => (n ? e - t : t - e));
      let a = !1;
      for (let t = 0; t < r.length && !a; t++) {
        const i = r[t],
          n = s[i];
        for (let t = 0; t < n.length; t++) {
          if (l) {
            (a = !0), (o = n[t]);
            break;
          }
          n[t]._uid !== e || (l = !0);
        }
      }
    } else t.forEachChildren(t => (l ? ((o = t), !0) : (t._uid === e && (l = !0), !1)), n);
    return o;
  }
  var uD = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  const pD = Symbol.for('PickItemInterceptor');
  let gD = class {
    constructor() {
      this.order = 1;
    }
    afterPickItem(t, e, i, n, s) {
      return (t.attribute.shadowRootIdx > 0 || !t.attribute.shadowRootIdx) && this._pickItem(t, e, i, n, s);
    }
    beforePickItem(t, e, i, n, s) {
      return t.attribute.shadowRootIdx < 0 && this._pickItem(t, e, i, n, s);
    }
    _pickItem(t, e, i, n, s) {
      if (!t.shadowRoot) return !1;
      const { parentMatrix: r } = s || {};
      if (!r) return !1;
      const a = e.pickContext;
      a.highPerformanceSave();
      const o = t.shadowRoot,
        l = zO.allocateByObj(r),
        h = new Ut(i.x, i.y);
      r.transformPoint(h, h);
      const c = t.transMatrix;
      l.multiply(c.a, c.b, c.c, c.d, c.e, c.f);
      const d = e.pickGroup(o, h.clone(), l, n);
      return a.highPerformanceRestore(), d;
    }
  };
  gD = uD([ZS()], gD);
  let fD = class {
    constructor() {
      this.order = 1;
    }
    beforePickItem(t, e, i, n, s) {
      if (!t.in3dMode || n.in3dInterceptor) return null;
      const r = e.pickContext,
        a = t.stage;
      if (!r || !a) return null;
      if (((n.in3dInterceptor = !0), r.save(), this.initCanvasCtx(r), (r.camera = a.camera), t.isContainer)) {
        let a,
          o = !1,
          l = !1;
        if (
          (t.forEachChildren(t => ((o = t.numberType === AE), !o)), t.forEachChildren(t => ((l = !!t.findFace), !l)), o)
        ) {
          const r = t.getChildren(),
            o = [...r];
          o.sort((t, e) => {
            var i, n, s, r;
            let a =
                (null !== (n = null !== (i = t.attribute.startAngle) && void 0 !== i ? i : 0 + t.attribute.endAngle) &&
                void 0 !== n
                  ? n
                  : 0) / 2,
              o =
                (null !== (r = null !== (s = e.attribute.startAngle) && void 0 !== s ? s : 0 + e.attribute.endAngle) &&
                void 0 !== r
                  ? r
                  : 0) / 2;
            for (; a < 0; ) a += Et;
            for (; o < 0; ) o += Et;
            return o - a;
          }),
            o.forEach(t => {
              (t._next = null), (t._prev = null);
            }),
            t.removeAllChild(),
            t.update(),
            o.forEach(e => {
              t.appendChild(e);
            }),
            (n.hack_pieFace = 'outside'),
            (a = e.pickGroup(t, i, s.parentMatrix, n)),
            a.graphic || ((n.hack_pieFace = 'inside'), (a = e.pickGroup(t, i, s.parentMatrix, n))),
            a.graphic || ((n.hack_pieFace = 'top'), (a = e.pickGroup(t, i, s.parentMatrix, n))),
            t.removeAllChild(),
            r.forEach(t => {
              (t._next = null), (t._prev = null);
            }),
            r.forEach(e => {
              t.appendChild(e);
            });
        } else if (l) {
          const o = t.getChildren(),
            l = o.map(t => ({
              ave_z: t
                .findFace()
                .vertices.map(e => {
                  var i;
                  return r.view(e[0], e[1], null !== (i = e[2] + t.attribute.z) && void 0 !== i ? i : 0)[2];
                })
                .reduce((t, e) => t + e, 0),
              g: t
            }));
          l.sort((t, e) => e.ave_z - t.ave_z),
            t.removeAllChild(),
            l.forEach(t => {
              (t.g._next = null), (t.g._prev = null);
            }),
            t.update(),
            l.forEach(e => {
              t.add(e.g);
            }),
            (a = e.pickGroup(t, i, s.parentMatrix, n)),
            t.removeAllChild(),
            o.forEach(t => {
              (t._next = null), (t._prev = null);
            }),
            t.update(),
            o.forEach(e => {
              t.add(e);
            });
        } else a = e.pickGroup(t, i, s.parentMatrix, n);
        return (r.camera = null), (n.in3dInterceptor = !1), a;
      }
      return r.restore(), null;
    }
    initCanvasCtx(t) {
      t.setTransformForCurrent();
    }
  };
  fD = uD([ZS()], fD);
  var vD = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    mD = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    yD = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  const _D = Symbol.for('PickerService');
  let bD = class {
    constructor(t, e) {
      (this.global = t), (this.pickItemInterceptorContributions = e), (this.type = 'default');
    }
    _init() {
      this.InterceptorContributions = this.pickItemInterceptorContributions
        .getContributions()
        .sort((t, e) => t.order - e.order);
    }
    pick(t, e, i) {
      let n = { graphic: null, group: null };
      i.pickerService = this;
      let s = 0,
        r = 0;
      if (i && i.bounds) {
        if (!i.bounds.contains(e.x, e.y)) return n;
        (s = i.bounds.x1), (r = i.bounds.y1);
      }
      this.pickContext && (this.pickContext.inuse = !0),
        (i.pickContext = this.pickContext),
        this.pickContext && this.pickContext.clearMatrix(!0, 1);
      const a = new ie(1, 0, 0, 1, s, r);
      let o;
      for (
        let s = t.length - 1;
        s >= 0 &&
        (t[s].isContainer ? (n = this.pickGroup(t[s], e, a, i)) : (n.graphic = this.pickItem(t[s], e, a, i)),
        !n.graphic);
        s--
      )
        o || (o = n.group);
      if ((n.graphic || (n.group = o), this.pickContext && (this.pickContext.inuse = !1), n.graphic)) {
        let t = n.graphic;
        for (; t.parent; ) t = t.parent;
        t.shadowHost && ((n.params = { shadowTarget: n.graphic }), (n.graphic = t.shadowHost));
      }
      return n;
    }
    containsPoint(t, e, i) {
      return !!this.pickItem(t, e, null, i);
    }
    pickGroup(t, e, i, n) {
      let s = { group: null, graphic: null };
      if (!1 === t.attribute.visibleAll) return s;
      const r = n.pickContext,
        a = r.modelMatrix;
      if (r.camera) {
        const e = t.transMatrix,
          i = HO.allocate();
        if ((UO(i, e), a)) {
          if (i) {
            const t = HO.allocate();
            (r.modelMatrix = YO(t, a, i)), HO.free(i);
          }
        } else UO(i, t.globalTransMatrix), (r.modelMatrix = i);
      }
      if (this.InterceptorContributions.length)
        for (let s = 0; s < this.InterceptorContributions.length; s++) {
          const o = this.InterceptorContributions[s];
          if (o.beforePickItem) {
            const s = o.beforePickItem(t, this, e, n, { parentMatrix: i });
            if (s) return r.modelMatrix !== a && HO.free(r.modelMatrix), (r.modelMatrix = a), s;
          }
        }
      const o = t.transMatrix,
        l = zO.allocateByObj(i),
        h = new Ut(e.x, e.y);
      l.transformPoint(h, h);
      const c = t.AABBBounds.containsPoint(h);
      if (!c && !t.stage.camera) return s;
      const d = this.pickItem(t, h.clone(), i, n);
      d && (s.graphic = d);
      const u = !1 !== t.attribute.pickable && c;
      return (
        l.multiply(o.a, o.b, o.c, o.d, o.e, o.f),
        !1 === t.attribute.childrenPickable ||
          d ||
          hD(
            t,
            TA.zIndex,
            r => {
              if (r.isContainer) {
                const i = new Ut(e.x, e.y),
                  a = Zk(t).group,
                  { scrollX: o = a.scrollX, scrollY: h = a.scrollY } = t.attribute;
                (i.x -= o), (i.y -= h), (s = this.pickGroup(r, i, l, n));
              } else {
                const a = new Ut(e.x, e.y);
                l.transformPoint(a, a);
                const o = Zk(t).group,
                  { scrollX: h = o.scrollX, scrollY: c = o.scrollY } = t.attribute;
                (a.x -= h), (a.y -= c);
                const d = this.pickItem(r, a, i, n);
                s.graphic = d;
              }
              return !!s.graphic || !!s.group;
            },
            !0,
            !!r.camera
          ),
        r.modelMatrix !== a && HO.free(r.modelMatrix),
        (r.modelMatrix = a),
        s.graphic || s.group || !u || t.stage.camera || (s.group = t),
        zO.free(l),
        s
      );
    }
    selectPicker(t) {
      return this.pickerMap.get(t.numberType) || null;
    }
  };
  bD = vD([ZS(), yD(0, tw(dw)), yD(1, tw(rw)), yD(1, JS(pD)), mD('design:paramtypes', [Object, Object])], bD);
  var xD = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    SD = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    wD = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  const AD = Symbol.for('GlobalPickerService');
  let kD = class {
    constructor(t) {
      (this.global = t),
        this.global.hooks.onSetEnv.tap('global-picker-service', (t, e, i) => {
          this.configure(i, e);
        }),
        this.configure(this.global, this.global.env);
    }
    configure(t, e) {}
    pick(t, e, i) {
      let n = { graphic: null, group: null };
      const s = new ie(1, 0, 0, 1, 0, 0);
      let r;
      for (
        let a = 0;
        a < t.length &&
        (t[a].isContainer ? (n = this.pickGroup(t[a], e, s, i)) : (n.graphic = this.pickItem(t[a], e, s, i)),
        !n.graphic);
        a++
      )
        r || (r = n.group);
      if ((n.graphic || (n.group = r), n.graphic)) {
        let t = n.graphic;
        for (; t.parent; ) t = t.parent;
        t.shadowHost && ((n.params = { shadowTarget: n.graphic }), (n.graphic = t.shadowHost));
      }
      return n;
    }
    containsPoint(t, e, i) {
      return !!this.pickItem(t, e, null, i);
    }
    pickGroup(t, e, i, n) {
      let s = { group: null, graphic: null };
      if (!1 === t.attribute.visibleAll) return s;
      const r = t.transMatrix,
        a = new Ut(e.x, e.y);
      i.transformPoint(a, a);
      const o = t.AABBBounds.containsPoint(a);
      if (!o) return s;
      const l = !1 !== t.attribute.pickable && o;
      return (
        i.multiply(r.a, r.b, r.c, r.d, r.e, r.f),
        !1 !== t.attribute.childrenPickable &&
          t.forEachChildren(t => {
            if (t.isContainer) s = this.pickGroup(t, e, i, n);
            else {
              const r = new Ut(e.x, e.y);
              i.transformPoint(r, r), (s.graphic = this.pickItem(t, r, i, n));
            }
            return !!s.graphic || !!s.group;
          }),
        s.graphic || s.group || !l || (s.group = t),
        s
      );
    }
    pickItem(t, e, i, n) {
      return !1 === t.attribute.pickable ? null : t.AABBBounds.containsPoint(e) ? t : null;
    }
  };
  function MD(t, e, i) {
    const n = e[0],
      s = e[1],
      r = e[2],
      a = e[3],
      o = e[4],
      l = e[5],
      h = e[6],
      c = e[7],
      d = e[8],
      u = e[9],
      p = e[10],
      g = e[11],
      f = e[12],
      v = e[13],
      m = e[14],
      y = e[15];
    let _ = i[0],
      b = i[1],
      x = i[2],
      S = i[3];
    return (
      (t[0] = _ * n + b * o + x * d + S * f),
      (t[1] = _ * s + b * l + x * u + S * v),
      (t[2] = _ * r + b * h + x * p + S * m),
      (t[3] = _ * a + b * c + x * g + S * y),
      (_ = i[4]),
      (b = i[5]),
      (x = i[6]),
      (S = i[7]),
      (t[4] = _ * n + b * o + x * d + S * f),
      (t[5] = _ * s + b * l + x * u + S * v),
      (t[6] = _ * r + b * h + x * p + S * m),
      (t[7] = _ * a + b * c + x * g + S * y),
      (_ = i[8]),
      (b = i[9]),
      (x = i[10]),
      (S = i[11]),
      (t[8] = _ * n + b * o + x * d + S * f),
      (t[9] = _ * s + b * l + x * u + S * v),
      (t[10] = _ * r + b * h + x * p + S * m),
      (t[11] = _ * a + b * c + x * g + S * y),
      (_ = i[12]),
      (b = i[13]),
      (x = i[14]),
      (S = i[15]),
      (t[12] = _ * n + b * o + x * d + S * f),
      (t[13] = _ * s + b * l + x * u + S * v),
      (t[14] = _ * r + b * h + x * p + S * m),
      (t[15] = _ * a + b * c + x * g + S * y),
      t
    );
  }
  function TD(t, e, i) {
    const n = e[0],
      s = e[1],
      r = e[2];
    let a = i[3] * n + i[7] * s + i[11] * r + i[15];
    return (
      (a = a || 1),
      (t[0] = (i[0] * n + i[4] * s + i[8] * r + i[12]) / a),
      (t[1] = (i[1] * n + i[5] * s + i[9] * r + i[13]) / a),
      (t[2] = (i[2] * n + i[6] * s + i[10] * r + i[14]) / a),
      t
    );
  }
  kD = xD([ZS(), wD(0, tw(dw)), SD('design:paramtypes', [Object])], kD);
  class CD {
    set params(t) {
      (this._params = Object.assign({}, t)),
        (this._projectionMatrixCached = this.forceGetProjectionMatrix()),
        (this._viewMatrixCached = this.forceGetViewMatrix());
    }
    get params() {
      return Object.assign({}, this._params);
    }
    constructor(t) {
      this.params = t;
    }
    getViewMatrix() {
      return this._viewMatrixCached || (this._viewMatrixCached = HO.allocate()), this._viewMatrixCached;
    }
    forceGetViewMatrix() {
      this._viewMatrixCached || (this._viewMatrixCached = HO.allocate());
      const { pos: t, center: e, up: i } = this.params.viewParams;
      return (
        (function (t, e, i, n) {
          let s, r, a, o, l, h, c, d, u, p;
          const g = e[0],
            f = e[1],
            v = e[2],
            m = n[0],
            y = n[1],
            _ = n[2],
            b = i[0],
            x = i[1],
            S = i[2];
          Math.abs(g - b) < kt && Math.abs(f - x) < kt && Math.abs(v - S) < kt
            ? jO.identity(t)
            : ((c = g - b),
              (d = f - x),
              (u = v - S),
              (p = 1 / Math.hypot(c, d, u)),
              (c *= p),
              (d *= p),
              (u *= p),
              (s = y * u - _ * d),
              (r = _ * c - m * u),
              (a = m * d - y * c),
              (p = Math.hypot(s, r, a)),
              p ? ((p = 1 / p), (s *= p), (r *= p), (a *= p)) : ((s = 0), (r = 0), (a = 0)),
              (o = d * a - u * r),
              (l = u * s - c * a),
              (h = c * r - d * s),
              (p = Math.hypot(o, l, h)),
              p ? ((p = 1 / p), (o *= p), (l *= p), (h *= p)) : ((o = 0), (l = 0), (h = 0)),
              (t[0] = s),
              (t[1] = o),
              (t[2] = c),
              (t[3] = 0),
              (t[4] = r),
              (t[5] = l),
              (t[6] = d),
              (t[7] = 0),
              (t[8] = a),
              (t[9] = h),
              (t[10] = u),
              (t[11] = 0),
              (t[12] = -(s * g + r * f + a * v)),
              (t[13] = -(o * g + l * f + h * v)),
              (t[14] = -(c * g + d * f + u * v)),
              (t[15] = 1));
        })(this._viewMatrixCached, t, e, i),
        this._vp || (this._vp = HO.allocate()),
        (this._vp = MD(this._vp, this.getProjectionMatrix(), this.getViewMatrix())),
        this._viewMatrixCached
      );
    }
    getProjectionMatrix() {
      return (
        this._projectionMatrixCached || (this._projectionMatrixCached = HO.allocate()), this._projectionMatrixCached
      );
    }
    forceGetProjectionMatrix() {
      this._projectionMatrixCached || (this._projectionMatrixCached = HO.allocate());
      const { left: t, top: e, right: i, bottom: n } = this._params;
      return (
        (function (t, e, i, n, s, r, a) {
          const o = 1 / (e - i),
            l = 1 / (n - s),
            h = 1 / (r - a);
          (t[0] = -2 * o),
            (t[1] = 0),
            (t[2] = 0),
            (t[3] = 0),
            (t[4] = 0),
            (t[5] = -2 * l),
            (t[6] = 0),
            (t[7] = 0),
            (t[8] = 0),
            (t[9] = 0),
            (t[10] = 2 * h),
            (t[11] = 0),
            (t[12] = (e + i) * o),
            (t[13] = (s + n) * l),
            (t[14] = (a + r) * h),
            (t[15] = 1);
        })(this._projectionMatrixCached, t, i, n, e, 0, -2e6),
        this._vp || (this._vp = HO.allocate()),
        (this._vp = MD(this._vp, this.getProjectionMatrix(), this.getViewMatrix())),
        this._projectionMatrixCached
      );
    }
    getField() {
      const { fieldRatio: t = 0.8, fieldDepth: e, left: i, right: n } = this._params;
      return (null != e ? e : n - i) * t;
    }
    getProjectionScale(t) {
      const e = this.getField();
      return e / (e + t);
    }
    view(t, e, i) {
      const n = [0, 0, 0];
      return TD(n, [t, e, i], this._viewMatrixCached), n;
    }
    vp(t, e, i) {
      const n = [0, 0, 0],
        { pos: s } = this._params.viewParams;
      TD(n, [t, e, i], this._viewMatrixCached), (t = n[0]), (e = n[1]), (i = n[2]);
      const r = this.getProjectionScale(i);
      return { x: t * r + s[0], y: e * r + s[1] };
    }
  }
  var ED = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    PD = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  const RD = [0, 0, 0],
    OD = new ie(1, 0, 0, 1, 0, 0);
  let BD = class {
    set fillStyle(t) {
      this.nativeContext.fillStyle = t;
    }
    get fillStyle() {
      return this.nativeContext.fillStyle;
    }
    set font(t) {
      this.nativeContext.font = t;
    }
    get font() {
      return this.nativeContext.font;
    }
    set globalAlpha(t) {
      this.nativeContext.globalAlpha = t;
    }
    get globalAlpha() {
      return this.nativeContext.globalAlpha;
    }
    set lineCap(t) {
      this.nativeContext.lineCap = t;
    }
    get lineCap() {
      return this.nativeContext.lineCap;
    }
    set lineDashOffset(t) {
      this.nativeContext.lineDashOffset = t;
    }
    get lineDashOffset() {
      return this.nativeContext.lineDashOffset;
    }
    set lineJoin(t) {
      this.nativeContext.lineJoin = t;
    }
    get lineJoin() {
      return this.nativeContext.lineJoin;
    }
    set lineWidth(t) {
      this.nativeContext.lineWidth = t;
    }
    get lineWidth() {
      return this.nativeContext.lineWidth;
    }
    set miterLimit(t) {
      this.nativeContext.miterLimit = t;
    }
    get miterLimit() {
      return this.nativeContext.miterLimit;
    }
    set shadowBlur(t) {
      this.nativeContext.shadowBlur = t;
    }
    get shadowBlur() {
      return this.nativeContext.shadowBlur;
    }
    set shadowColor(t) {
      this.nativeContext.shadowColor = t;
    }
    get shadowColor() {
      return this.nativeContext.shadowColor;
    }
    set shadowOffsetX(t) {
      this.nativeContext.shadowOffsetX = t;
    }
    get shadowOffsetX() {
      return this.nativeContext.shadowOffsetX;
    }
    set shadowOffsetY(t) {
      this.nativeContext.shadowOffsetY = t;
    }
    get shadowOffsetY() {
      return this.nativeContext.shadowOffsetY;
    }
    set strokeStyle(t) {
      this.nativeContext.strokeStyle = t;
    }
    get strokeStyle() {
      return this.nativeContext.strokeStyle;
    }
    set textAlign(t) {
      this.nativeContext.textAlign = t;
    }
    get textAlign() {
      return this.nativeContext.textAlign;
    }
    set textBaseline(t) {
      this.nativeContext.textBaseline = t;
    }
    get textBaseline() {
      return this.nativeContext.textBaseline;
    }
    get inuse() {
      return !!this._inuse;
    }
    set inuse(t) {
      t !== !!this._inuse &&
        ((this._inuse = t), t ? (this.nativeContext.save(), this.reset()) : this.nativeContext.restore());
    }
    constructor(t, e) {
      (this.fillAttributes = Object.assign(Object.assign({}, xA), { opacity: 1 })),
        (this.strokeAttributes = Object.assign(Object.assign({}, wA), { opacity: 1 })),
        (this.textAttributes = Object.assign(Object.assign({}, AA), { opacity: 1 })),
        (this._clearShadowStyle = !1),
        (this._clearFilterStyle = !1);
      const i = t.nativeCanvas.getContext('2d');
      if (!i) throw new Error('发生错误，获取2d上下文失败');
      (this.nativeContext = i),
        (this.canvas = t),
        (this.matrix = new ie(1, 0, 0, 1, 0, 0)),
        (this.stack = []),
        (this.dpr = e),
        (this.applyedMatrix = new ie(1, 0, 0, 1, 0, 0));
    }
    reset() {
      this.stack.length && console.warn('可能存在bug，matrix没有清空'),
        this.matrix.setValue(1, 0, 0, 1, 0, 0),
        (this.applyedMatrix = new ie(1, 0, 0, 1, 0, 0)),
        (this.stack.length = 0),
        this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);
    }
    getCanvas() {
      return this.canvas;
    }
    getContext() {
      return this.nativeContext;
    }
    setTransformForCurrent() {
      (!(arguments.length > 0 && void 0 !== arguments[0] && arguments[0]) &&
        this.applyedMatrix.equalToMatrix(this.matrix)) ||
        (this.applyedMatrix.setValue(
          this.matrix.a,
          this.matrix.b,
          this.matrix.c,
          this.matrix.d,
          this.matrix.e,
          this.matrix.f
        ),
        this.nativeContext.setTransform(
          this.matrix.a,
          this.matrix.b,
          this.matrix.c,
          this.matrix.d,
          this.matrix.e,
          this.matrix.f
        ));
    }
    get currentMatrix() {
      return this.matrix;
    }
    cloneMatrix(t) {
      return zO.allocateByObj(t);
    }
    clear() {
      this.save(),
        this.resetTransform(),
        this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height),
        this.restore();
    }
    restore() {
      this.nativeContext.restore(),
        this.stack.length > 0 &&
          (zO.free(this.matrix), (this.matrix = this.stack.pop()), this.setTransformForCurrent(!0));
    }
    highPerformanceRestore() {
      this.stack.length > 0 && (zO.free(this.matrix), (this.matrix = this.stack.pop()));
    }
    rotate(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      this.matrix.rotate(t), e && this.setTransformForCurrent();
    }
    save() {
      const t = this.cloneMatrix(this.matrix);
      this.stack.push(t), this.nativeContext.save();
    }
    highPerformanceSave() {
      const t = this.cloneMatrix(this.matrix);
      this.stack.push(t);
    }
    scale(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      this.matrix.scale(t, e), i && this.setTransformForCurrent();
    }
    setScale(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      this.matrix.setScale(t, e), i && this.setTransformForCurrent();
    }
    scalePoint(t, e, i, n) {
      let s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
      this.translate(i, n, !1), this.scale(t, e, !1), this.translate(-i, -n, !1), s && this.setTransformForCurrent();
    }
    setTransform(t, e, i, n, s, r) {
      let a = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6],
        o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : this.dpr;
      this.matrix.setValue(o * t, o * e, o * i, o * n, o * s, o * r), a && this.setTransformForCurrent();
    }
    setTransformFromMatrix(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dpr;
      this.matrix.setValue(t.a * i, t.b * i, t.c * i, t.d * i, t.e * i, t.f * i), e && this.setTransformForCurrent();
    }
    resetTransform() {
      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.dpr;
      this.setTransform(e, 0, 0, e, 0, 0), t && this.setTransformForCurrent();
    }
    transform(t, e, i, n, s, r) {
      let a = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6];
      this.matrix.multiply(t, e, i, n, s, r), a && this.setTransformForCurrent();
    }
    transformFromMatrix(t, e) {
      this.matrix.multiply(t.a, t.b, t.c, t.d, t.e, t.f), e && this.setTransformForCurrent();
    }
    translate(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      this.matrix.translate(t, e), i && this.setTransformForCurrent();
    }
    rotateDegrees(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      const i = (t * Math.PI) / 180;
      this.rotate(i, e);
    }
    rotateAbout(t, e, i) {
      let n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      this.translate(e, i, !1), this.rotate(t, !1), this.translate(-e, -i, !1), n && this.setTransformForCurrent();
    }
    rotateDegreesAbout(t, e, i) {
      let n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      this.translate(e, i, !1),
        this.rotateDegrees(t, !1),
        this.translate(-e, -i, !1),
        n && this.setTransformForCurrent();
    }
    beginPath() {
      this.disableBeginPath || this.nativeContext.beginPath();
    }
    clip(t, e) {
      t
        ? 'string' == typeof t
          ? this.nativeContext.clip(t)
          : this.nativeContext.clip(t, e)
        : this.nativeContext.clip();
    }
    arc(t, e, i, n, s, r, a) {
      if (((a = a || 0), this.camera)) {
        const o = [];
        ((t, e, i, n, s, r, a, o) => {
          if (o) for (; i > e; ) i -= Et;
          else for (; i < e; ) i += Et;
          const l = (Mt / 3) * (i > e ? 1 : -1);
          let h = e,
            c = h;
          for (; c !== i; ) {
            c = l > 0 ? Math.min(c + l, i) : Math.max(c + l, i);
            const e = Math.abs(c - h),
              o = (4 * Math.tan(e / 4)) / 3,
              d = c < h ? -1 : 1,
              u = Math.cos(h),
              p = Math.sin(h),
              g = Math.cos(c),
              f = Math.sin(c),
              v = u * r + n,
              m = p * a + s,
              y = g * r + n,
              _ = f * a + s,
              b = r * o * d,
              x = a * o * d;
            t.push([v - b * p, m + x * u, y + b * f, _ - x * g, y, _]), (h = c);
          }
        })(o, n, s, t, e, i, i, r);
        for (let t = 0; t < o.length; ++t) {
          const e = o[t];
          this.bezierCurveTo(e[0], e[1], e[2], e[3], e[4], e[5], a);
        }
      } else this.nativeContext.arc(t, e, i, n, s, r);
    }
    arcTo(t, e, i, n, s) {
      this.nativeContext.arcTo(t, e, i, n, s);
    }
    bezierCurveTo(t, e, i, n, s, r, a) {
      if (((a = a || 0), this.camera)) {
        let o = a,
          l = a;
        this.modelMatrix &&
          (TD(RD, [t, e, a], this.modelMatrix),
          (t = RD[0]),
          (e = RD[1]),
          (o = RD[2]),
          TD(RD, [i, n, a], this.modelMatrix),
          (i = RD[0]),
          (n = RD[1]),
          (l = RD[2]),
          TD(RD, [s, r, a], this.modelMatrix),
          (s = RD[0]),
          (r = RD[1]),
          (a = RD[2]));
        let h = this.camera.vp(s, r, a);
        (s = h.x),
          (r = h.y),
          (h = this.camera.vp(t, e, o)),
          (t = h.x),
          (e = h.y),
          (h = this.camera.vp(i, n, l)),
          (i = h.x),
          (n = h.y);
      }
      this.nativeContext.bezierCurveTo(t, e, i, n, s, r);
    }
    closePath() {
      this.nativeContext.closePath();
    }
    ellipse(t, e, i, n, s, r, a, o) {
      null == o ? this.nativeContext.ellipse(t, e, i, n, s, r, a) : this.nativeContext.ellipse(t, e, i, n, s, r, a, o);
    }
    lineTo(t, e, i) {
      if (((i = i || 0), this.camera)) {
        this.modelMatrix && (TD(RD, [t, e, i], this.modelMatrix), (t = RD[0]), (e = RD[1]), (i = RD[2]));
        const n = this.camera.vp(t, e, i);
        (t = n.x), (e = n.y);
      }
      this.nativeContext.lineTo(t, e);
    }
    moveTo(t, e, i) {
      if (((i = i || 0), this.camera)) {
        this.modelMatrix && (TD(RD, [t, e, i], this.modelMatrix), (t = RD[0]), (e = RD[1]), (i = RD[2]));
        const n = this.camera.vp(t, e, i);
        (t = n.x), (e = n.y);
      }
      this.nativeContext.moveTo(t, e);
    }
    quadraticCurveTo(t, e, i, n, s) {
      if (((s = s || 0), this.camera)) {
        let r = s;
        this.modelMatrix &&
          (TD(RD, [t, e, s], this.modelMatrix),
          (t = RD[0]),
          (e = RD[1]),
          (r = RD[2]),
          TD(RD, [i, n, s], this.modelMatrix),
          (i = RD[0]),
          (n = RD[1]),
          (s = RD[2]));
        let a = this.camera.vp(i, n, s);
        (i = a.x), (n = a.y), (a = this.camera.vp(t, e, r)), (t = a.x), (e = a.y);
      }
      this.nativeContext.quadraticCurveTo(t, e, i, n);
    }
    rect(t, e, i, n, s) {
      (s = s || 0),
        this.camera
          ? (this.moveTo(t, e, s),
            this.lineTo(t + i, e, s),
            this.lineTo(t + i, e + n, s),
            this.lineTo(t, e + n, s),
            this.closePath())
          : this.nativeContext.rect(t, e, i, n);
    }
    createImageData() {
      const t = arguments;
      return 2 === t.length
        ? this.nativeContext.createImageData(t[0], t[1])
        : 1 === t.length
        ? this.nativeContext.createImageData(t[0])
        : null;
    }
    createLinearGradient(t, e, i, n) {
      return this.nativeContext.createLinearGradient(t, e, i, n);
    }
    createPattern(t, e) {
      return 0 === t.width || 0 === t.height ? null : this.nativeContext.createPattern(t, e);
    }
    createRadialGradient(t, e, i, n, s, r) {
      return this.nativeContext.createRadialGradient(t, e, i, n, s, r);
    }
    createConicGradient(t, e, i, n) {
      let s,
        r = !1;
      const a = this;
      return {
        stops: [],
        addColorStop(t, e) {
          this.stops.push([t, e]), (r = !0);
        },
        GetPattern(o, l, h) {
          return (
            r &&
              (h || (h = n - i),
              (s = (function (t, e, i, n, s, r, a, o, l) {
                const h = Math.floor((180 * s) / Math.PI),
                  c = mP.GetCanvas(),
                  d = mP.GetCtx();
                if (!d) return null;
                const u = _P.GetSize(o),
                  p = _P.GetSize(l);
                let g = _P.Get(e, i, n, r, a, u, p);
                if (g) return g;
                const f = Math.sqrt(
                    Math.max(
                      Math.max(Math.pow(i, 2) + Math.pow(n, 2), Math.pow(u - i, 2) + Math.pow(n, 2)),
                      Math.max(Math.pow(u - i, 2) + Math.pow(p - n, 2), Math.pow(i, 2) + Math.pow(p - n, 2))
                    )
                  ),
                  v = h + 1,
                  m = s / Math.max(1, v - 1),
                  y = yP.GetOrCreate(e, v),
                  _ = (2 * Math.PI * f) / 360;
                (c.width = u),
                  (c.height = p),
                  d.setTransform(1, 0, 0, 1, 0, 0),
                  d.clearRect(0, 0, u, p),
                  d.translate(i, n),
                  d.rotate(r);
                for (let t = 0, e = v - 1; t < e && !(r + t * m > a); t++) {
                  const e = y.getColor(t);
                  d.beginPath(),
                    d.rotate(m),
                    d.moveTo(0, 0),
                    d.lineTo(f, -2 * _),
                    d.lineTo(f, 0),
                    (d.fillStyle = e),
                    d.closePath(),
                    d.fill();
                }
                const b = d.getImageData(0, 0, u, p);
                return (
                  (c.width = b.width),
                  (c.height = b.height),
                  d.putImageData(b, 0, 0),
                  (g = t.createPattern(c, 'no-repeat')),
                  g && _P.Set(e, i, n, r, a, g, u, p),
                  g
                );
              })(a, this.stops, t, e, h, i, n, o, l)),
              (r = !1)),
            s
          );
        }
      };
    }
    fill(t, e) {
      this.disableFill || (t ? this.nativeContext.fill(t) : this.nativeContext.fill());
    }
    fillRect(t, e, i, n) {
      this.nativeContext.fillRect(t, e, i, n);
    }
    clearRect(t, e, i, n) {
      this.nativeContext.clearRect(t, e, i, n);
    }
    project(t, e, i) {
      if (((i = i || 0), this.camera)) {
        this.modelMatrix && (TD(RD, [t, e, i], this.modelMatrix), (t = RD[0]), (e = RD[1]), (i = RD[2]));
        const n = this.camera.vp(t, e, i);
        (t = n.x), (e = n.y);
      }
      return { x: t, y: e };
    }
    view(t, e, i) {
      return (
        (i = i || 0),
        this.camera
          ? (this.modelMatrix && (TD(RD, [t, e, i], this.modelMatrix), (t = RD[0]), (e = RD[1]), (i = RD[2])),
            this.camera.view(t, e, i))
          : [t, e, i]
      );
    }
    fillText(t, e, i, n) {
      if (((n = n || 0), this.camera)) {
        this.modelMatrix && (TD(RD, [e, i, n], this.modelMatrix), (e = RD[0]), (i = RD[1]), (n = RD[2]));
        const t = this.camera.vp(e, i, n);
        (e = t.x), (i = t.y);
      }
      this.nativeContext.fillText(t, e, i);
    }
    getImageData(t, e, i, n) {
      return this.nativeContext.getImageData(t, e, i, n);
    }
    getLineDash() {
      return this.nativeContext.getLineDash();
    }
    isPointInPath(t, e) {
      return this.nativeContext.isPointInPath(t, e);
    }
    isPointInStroke(t, e) {
      return this.nativeContext.isPointInStroke(t, e);
    }
    measureText(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : WA.global.measureTextMethod;
      var i, n;
      return e && 'native' !== e
        ? (this.mathTextMeasure ||
            (this.mathTextMeasure = WA.graphicUtil.createTextMeasureInstance({}, {}, () => this.canvas)),
          (this.mathTextMeasure.textSpec.fontFamily =
            null !== (i = this.fontFamily) && void 0 !== i ? i : AA.fontFamily),
          (this.mathTextMeasure.textSpec.fontSize = null !== (n = this.fontSize) && void 0 !== n ? n : AA.fontSize),
          (this.mathTextMeasure._numberCharSize = null),
          (this.mathTextMeasure._fullCharSize = null),
          (this.mathTextMeasure._letterCharSize = null),
          (this.mathTextMeasure._specialCharSizeMap = {}),
          this.mathTextMeasure.measure(t, e))
        : this.nativeContext.measureText(t);
    }
    putImageData(t, e, i) {
      this.nativeContext.putImageData(t, e, i);
    }
    setLineDash(t) {
      const e = arguments,
        i = this.nativeContext;
      this.nativeContext.setLineDash
        ? i.setLineDash(e[0])
        : 'mozDash' in i
        ? (i.mozDash = e[0])
        : 'webkitLineDash' in i && (i.webkitLineDash = e[0]);
    }
    stroke(t) {
      this.disableStroke || (t ? this.nativeContext.stroke(t) : this.nativeContext.stroke());
    }
    strokeRect(t, e, i, n) {
      this.nativeContext.strokeRect(t, e, i, n);
    }
    strokeText(t, e, i, n) {
      if (((n = n || 0), this.camera)) {
        this.modelMatrix && (TD(RD, [e, i, n], this.modelMatrix), (e = RD[0]), (i = RD[1]), (n = RD[2]));
        const t = this.camera.vp(e, i, n);
        (e = t.x), (i = t.y);
      }
      this.nativeContext.strokeText(t, e, i);
    }
    drawImage() {
      const t = this.nativeContext,
        e = arguments;
      3 === e.length
        ? t.drawImage(e[0], e[1], e[2])
        : 5 === e.length
        ? t.drawImage(e[0], e[1], e[2], e[3], e[4])
        : 9 === e.length && t.drawImage(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
    }
    setCommonStyle(t, e, i, n, s) {
      if (Array.isArray(s)) {
        if (s.length <= 1) return this._setCommonStyle(t, e, i, n, s[0]);
        const r = {};
        return (
          s.forEach(t => {
            Object.assign(r, t);
          }),
          this._setCommonStyle(t, e, i, n, r)
        );
      }
      return this._setCommonStyle(t, e, i, n, s);
    }
    _setCommonStyle(t, e, i, n, s) {
      const r = this.nativeContext;
      s || (s = this.fillAttributes);
      const { fillOpacity: a = s.fillOpacity, opacity: o = s.opacity, fill: l = s.fill } = e;
      a > 1e-12 && o > 1e-12
        ? ((r.globalAlpha = a * o), (r.fillStyle = MI(this, l, t, i, n)))
        : (r.globalAlpha = a * o);
    }
    setShadowStyle(t, e, i) {
      if (Array.isArray(i)) {
        if (i.length <= 1) return this._setShadowStyle(t, i[0]);
        const n = {};
        return (
          i.forEach(t => {
            Object.assign(n, t);
          }),
          this._setShadowStyle(t, e, n)
        );
      }
      return this._setShadowStyle(t, e, i);
    }
    _setShadowStyle(t, e, i) {
      const n = this.nativeContext;
      i || (i = this.fillAttributes);
      const {
        opacity: s = i.opacity,
        shadowBlur: r = i.shadowBlur,
        shadowColor: a = i.shadowColor,
        shadowOffsetX: o = i.shadowOffsetX,
        shadowOffsetY: l = i.shadowOffsetY,
        blur: h = i.blur
      } = e;
      s <= 1e-12 ||
        (r || o || l
          ? ((n.shadowBlur = r),
            (n.shadowColor = a),
            (n.shadowOffsetX = o),
            (n.shadowOffsetY = l),
            (this._clearShadowStyle = !0))
          : this._clearShadowStyle && ((n.shadowBlur = 0), (n.shadowOffsetX = 0), (n.shadowOffsetY = 0)),
        h
          ? ((n.filter = `blur(${h}px)`), (this._clearFilterStyle = !0))
          : this._clearFilterStyle && ((n.filter = 'blur(0px)'), (this._clearFilterStyle = !1)));
    }
    setStrokeStyle(t, e, i, n, s) {
      if (Array.isArray(s)) {
        if (s.length <= 1) return this._setStrokeStyle(t, e, i, n, s[0]);
        const r = {};
        return (
          s.forEach(t => {
            Object.assign(r, t);
          }),
          this._setStrokeStyle(t, e, i, n, r)
        );
      }
      return this._setStrokeStyle(t, e, i, n, s);
    }
    _setStrokeStyle(t, e, i, n, s) {
      const r = this.nativeContext;
      s || (s = this.strokeAttributes);
      const { strokeOpacity: a = s.strokeOpacity, opacity: o = s.opacity } = e;
      if (a > 1e-12 && o > 1e-12) {
        const {
          lineWidth: l = s.lineWidth,
          stroke: h = s.stroke,
          lineJoin: c = s.lineJoin,
          lineDash: d = s.lineDash,
          lineCap: u = s.lineCap,
          miterLimit: p = s.miterLimit
        } = e;
        (r.globalAlpha = a * o),
          (r.lineWidth = kI(this, l, this.dpr)),
          (r.strokeStyle = MI(this, h, t, i, n)),
          (r.lineJoin = c),
          r.setLineDash(d),
          (r.lineCap = u),
          (r.miterLimit = p);
      }
    }
    setTextStyleWithoutAlignBaseline(t, e, i) {
      const n = this.nativeContext;
      e || (e = this.textAttributes);
      const { scaleIn3d: s = e.scaleIn3d } = t;
      t.font ? (n.font = t.font) : (n.font = NP(t, e, s && this.camera && this.camera.getProjectionScale(i)));
      const { fontFamily: r = e.fontFamily, fontSize: a = e.fontSize } = t;
      (this.fontFamily = r), (this.fontSize = a), (n.textAlign = 'left'), (n.textBaseline = 'alphabetic');
    }
    setTextStyle(t, e, i) {
      var n, s;
      const r = this.nativeContext;
      e || (e = this.textAttributes),
        t.font ? (r.font = t.font) : (r.font = NP(t, e, this.camera && this.camera.getProjectionScale(i)));
      const { fontFamily: a = e.fontFamily, fontSize: o = e.fontSize } = t;
      (this.fontFamily = a),
        (this.fontSize = o),
        (r.textAlign = null !== (n = t.textAlign) && void 0 !== n ? n : e.textAlign),
        (r.textBaseline = null !== (s = t.textBaseline) && void 0 !== s ? s : e.textBaseline);
    }
    draw() {}
    clearMatrix() {
      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.dpr;
      this.setTransformFromMatrix(OD, t, e);
    }
    onlyTranslate() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.dpr;
      return this.matrix.a === t && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === t;
    }
    release() {
      this.stack.forEach(t => zO.free(t)), (this.stack.length = 0);
    }
  };
  (BD.env = 'browser'), (BD = ED([ZS(), PD('design:paramtypes', [Object, Number])], BD));
  var ID = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    DD = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  const LD = { WIDTH: 500, HEIGHT: 500, DPR: 1 };
  let FD = class {
    get displayWidth() {
      return this._pixelWidth / this._dpr;
    }
    get displayHeight() {
      return this._pixelHeight / this._dpr;
    }
    get id() {
      return this._id;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x = t;
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y = t;
    }
    get nativeCanvas() {
      return this._nativeCanvas;
    }
    get width() {
      return this._pixelWidth;
    }
    set width(t) {
      (this._pixelWidth = t), (this._displayWidth = t / (this._dpr || 1));
    }
    get height() {
      return this._pixelHeight;
    }
    set height(t) {
      (this._pixelHeight = t), (this._displayHeight = t / (this._dpr || 1));
    }
    getContext(t) {
      return this._context;
    }
    get visiable() {
      return this._visiable;
    }
    set visiable(t) {
      (this._visiable = t), t ? this.show() : this.hide();
    }
    get dpr() {
      return this._dpr;
    }
    set dpr(t) {
      (this._dpr = t), this.resize(this._displayWidth, this._displayHeight);
    }
    constructor(t) {
      const {
        nativeCanvas: e,
        width: i = LD.WIDTH,
        height: n = LD.HEIGHT,
        dpr: s = LD.DPR,
        container: r,
        x: a,
        y: o,
        canvasControled: l = !0
      } = t;
      if (
        ((this._x = null != a ? a : 0),
        (this._y = null != o ? o : 0),
        (this._pixelWidth = i * s),
        (this._pixelHeight = n * s),
        (this._visiable = !1 !== t.visiable),
        (this.controled = l),
        'string' == typeof r)
      ) {
        const t = WA.global.getElementById(r);
        t && (this._container = t);
      } else this._container = r;
      (this._displayWidth = i),
        (this._displayHeight = n),
        (this._dpr = s),
        (this._nativeCanvas = e),
        (this._context = new BD(this, this._dpr)),
        (this._id = e.id),
        this.initStyle();
    }
    initStyle() {
      if (!this.controled) return;
      const { nativeCanvas: t } = this;
      (t.width = this._pixelWidth),
        (t.height = this._pixelHeight),
        !t.style || this.setCanvasStyle(t, this._x, this._y, this._displayWidth, this._displayHeight),
        null != this.id && (t.id = this.id.toString()),
        this._container && this._container.appendChild(t),
        this.visiable || this.hide();
    }
    applyPosition() {
      const t = this._nativeCanvas;
      (t.style.position = 'absolute'), (t.style.top = `${this._y}px`), (t.style.left = `${this._x}px`);
    }
    getNativeCanvas() {
      return this._nativeCanvas;
    }
    resetStyle(t) {
      if (!this.controled) return;
      const {
          width: e = this._displayWidth,
          height: i = this._displayHeight,
          dpr: n = this._dpr,
          x: s = this._x,
          y: r = this._y
        } = t,
        { nativeCanvas: a } = this;
      (a.width = e * n),
        (a.height = i * n),
        !a.style || this.setCanvasStyle(a, s, r, e, i),
        t.id && (a.id = t.id),
        this.visiable || this.hide();
    }
    setCanvasStyle(t, e, i, n, s) {
      this.controled &&
        ((t.style.padding = '0'),
        (t.style.margin = '0'),
        (t.style.border = '0'),
        (t.style.background = 'transparent'),
        (t.style.width = `${n}px`),
        (t.style.height = `${s}px`));
    }
    hide() {
      this._nativeCanvas && (this._nativeCanvas.style.display = 'none');
    }
    show() {
      this._nativeCanvas && (this._nativeCanvas.style.display = 'block');
    }
    resize(t, e) {
      this.controled &&
        ((this._pixelWidth = t * this._dpr),
        (this._pixelHeight = e * this._dpr),
        (this._displayWidth = t),
        (this._displayHeight = e),
        this._nativeCanvas.style &&
          ((this._nativeCanvas.style.width = `${t}px`), (this._nativeCanvas.style.height = `${e}px`)),
        (this._nativeCanvas.width = this._pixelWidth),
        (this._nativeCanvas.height = this._pixelHeight),
        (this._context.dpr = this._dpr));
    }
    toDataURL(t, e) {
      return 'image/jpeg' === t
        ? this._nativeCanvas.toDataURL(t, e)
        : 'image/png' === t
        ? this._nativeCanvas.toDataURL(t)
        : this._nativeCanvas.toDataURL(t, e);
    }
    readPixels(t, e, i, n) {
      return this._context.getImageData(t, e, i, n);
    }
    convertToBlob(t) {
      throw new Error('暂未实现');
    }
    transferToImageBitmap() {
      throw new Error('暂未实现');
    }
    release() {
      this.controled &&
        this._nativeCanvas.parentElement &&
        this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
    }
  };
  (FD.env = 'browser'), (FD = ID([ZS(), DD('design:paramtypes', [Object])], FD));
  const jD = Symbol.for('CanvasArcPicker'),
    zD = Symbol.for('CanvasArc3dPicker'),
    HD = Symbol.for('CanvasAreaPicker'),
    ND = Symbol.for('CanvasCirclePicker'),
    VD = Symbol.for('CanvasImagePicker'),
    WD = Symbol.for('CanvasLinePicker'),
    GD = Symbol.for('CanvasPathPicker'),
    UD = Symbol.for('CanvasRectPicker'),
    YD = Symbol.for('CanvasRect3dPicker'),
    $D = Symbol.for('CanvasSymbolPicker'),
    XD = Symbol.for('CanvasTextPicker'),
    KD = Symbol.for('CanvasPolygonPicker'),
    qD = Symbol.for('CanvasPyramid3dPicker'),
    ZD = Symbol.for('CanvasRichTextPicker'),
    JD = Symbol.for('CanvasGlyphPicker'),
    QD = Symbol.for('CanvasGroupPicker'),
    tL = Symbol.for('CanvasPickerContribution'),
    eL = Symbol.for('MathArcPicker'),
    iL = Symbol.for('MathAreaPicker'),
    nL = Symbol.for('MathCirclePicker'),
    sL = Symbol.for('MathLinePicker'),
    rL = Symbol.for('MathPathPicker'),
    aL = Symbol.for('MathRectPicker'),
    oL = Symbol.for('MathSymbolPicker'),
    lL = Symbol.for('MathTextPicker'),
    hL = Symbol.for('MathPolygonPicker'),
    cL = Symbol.for('MathGlyphPicker'),
    dL = Symbol.for('MathPickerContribution');
  var uL = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    pL = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    gL = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let fL = class extends bD {
    constructor(t, e, i, n, s, r, a, o, l, h, c, d, u, p, g) {
      super(p, g),
        (this.contributions = t),
        (this.circlePicker = e),
        (this.rectPicker = i),
        (this.arcPicker = n),
        (this.areaPicker = s),
        (this.imagePicker = r),
        (this.linePicker = a),
        (this.pathPicker = o),
        (this.symbolPicker = l),
        (this.textPicker = h),
        (this.polygonPicker = c),
        (this.richtextPicker = d),
        (this.drawContribution = u),
        (this.global = p),
        (this.pickItemInterceptorContributions = g),
        this.global.hooks.onSetEnv.tap('canvas-picker-service', (t, e, i) => {
          this.configure(i, e);
        }),
        this.configure(this.global, this.global.env),
        (this.pickerMap = new Map());
    }
    init() {
      this.contributions.getContributions().forEach(t => {
        this.pickerMap.set(t.numberType, t);
      }),
        super._init();
    }
    configure(t, e) {
      const i = { width: 100, height: 100, nativeCanvas: t.createCanvas({ width: 100, height: 100 }), id: 'for-pick' };
      (this.pickCanvas = new FD(i)), (this.pickContext = this.pickCanvas.getContext('2d'));
    }
    pickItem(t, e, i, n) {
      if (!1 === t.attribute.pickable) return null;
      if (this.InterceptorContributions.length)
        for (let s = 0; s < this.InterceptorContributions.length; s++) {
          const r = this.InterceptorContributions[s];
          if (r.beforePickItem) {
            const s = r.beforePickItem(t, this, e, n, { parentMatrix: i });
            if (s) return !0 === s ? t : s.graphic;
          }
        }
      const s = this.pickerMap.get(t.numberType);
      if (!s) return null;
      const r = s.contains(t, e, n) ? t : null;
      if (r) return r;
      if (this.InterceptorContributions.length)
        for (let s = 0; s < this.InterceptorContributions.length; s++) {
          const r = this.InterceptorContributions[s];
          if (r.afterPickItem) {
            const s = r.afterPickItem(t, this, e, n, { parentMatrix: i });
            if (s) return !0 === s ? t : s.graphic;
          }
        }
      return r;
    }
  };
  uL(
    [sw(), pL('design:type', Function), pL('design:paramtypes', []), pL('design:returntype', void 0)],
    fL.prototype,
    'init',
    null
  ),
    (fL = uL(
      [
        ZS(),
        gL(0, tw(rw)),
        gL(0, JS(tL)),
        gL(1, tw(ND)),
        gL(2, tw(UD)),
        gL(3, tw(jD)),
        gL(4, tw(HD)),
        gL(5, tw(VD)),
        gL(6, tw(WD)),
        gL(7, tw(GD)),
        gL(8, tw($D)),
        gL(9, tw(XD)),
        gL(10, tw(KD)),
        gL(11, tw(ZD)),
        gL(12, tw(AI)),
        gL(13, tw(dw)),
        gL(14, tw(rw)),
        gL(14, JS(pD)),
        pL('design:paramtypes', [
          Object,
          Object,
          Object,
          Object,
          Object,
          Object,
          Object,
          Object,
          Object,
          Object,
          Object,
          Object,
          Object,
          Object,
          Object
        ])
      ],
      fL
    ));
  var vL = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    mL = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  const yL = new ie(1, 0, 0, 1, 0, 0),
    _L = { x: 0, y: 0 };
  let bL = class {
    get nativeContext() {
      return this.path;
    }
    constructor(t, e) {
      (this.matrix = new ie(1, 0, 0, 1, 0, 0)),
        (this.stack = []),
        (this.dpr = e),
        (this.applyedMatrix = new ie(1, 0, 0, 1, 0, 0)),
        (this.path = new mA());
    }
    getCanvas() {
      throw new Error('不支持getCanvas');
    }
    getContext() {
      throw new Error('不支持getContext');
    }
    setTransformForCurrent() {
      (!(arguments.length > 0 && void 0 !== arguments[0] && arguments[0]) &&
        this.applyedMatrix.equalToMatrix(this.matrix)) ||
        (this.applyedMatrix = this.cloneMatrix(this.matrix));
    }
    get currentMatrix() {
      return this.matrix;
    }
    cloneMatrix(t) {
      return zO.allocateByObj(t);
    }
    clear() {
      this.save(), this.resetTransform(), this.restore();
    }
    restore() {
      this.stack.length > 0 && (zO.free(this.matrix), (this.matrix = this.stack.pop()), this.setTransformForCurrent());
    }
    highPerformanceRestore() {
      this.stack.length > 0 && (zO.free(this.matrix), (this.matrix = this.stack.pop()));
    }
    rotate(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      this.matrix.rotate(t), e && this.setTransformForCurrent();
    }
    save() {
      const t = this.cloneMatrix(this.matrix);
      this.stack.push(t);
    }
    highPerformanceSave() {
      const t = this.cloneMatrix(this.matrix);
      this.stack.push(t);
    }
    scale(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      this.matrix.scale(t, e), i && this.setTransformForCurrent();
    }
    setScale(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      this.matrix.setScale(t, e), i && this.setTransformForCurrent();
    }
    scalePoint(t, e, i, n) {
      let s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
      this.translate(i, n, !1), this.scale(t, e, !1), this.translate(-i, -n, !1), s && this.setTransformForCurrent();
    }
    setTransform(t, e, i, n, s, r) {
      let a = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6],
        o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : this.dpr;
      this.matrix.setValue(o * t, o * e, o * i, o * n, o * s, o * r), a && this.setTransformForCurrent();
    }
    setTransformFromMatrix(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dpr;
      this.matrix.setValue(t.a * i, t.b * i, t.c * i, t.d * i, t.e * i, t.f * i), e && this.setTransformForCurrent();
    }
    resetTransform() {
      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.dpr;
      this.setTransform(e, 0, 0, e, 0, 0), t && this.setTransformForCurrent();
    }
    transform(t, e, i, n, s, r) {
      let a = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6];
      this.matrix.multiply(t, e, i, n, s, r), a && this.setTransformForCurrent();
    }
    transformFromMatrix(t, e) {
      this.matrix.multiply(t.a, t.b, t.c, t.d, t.e, t.f), e && this.setTransformForCurrent();
    }
    translate(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      this.matrix.translate(t, e), i && this.setTransformForCurrent();
    }
    rotateDegrees(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      const i = (t * Math.PI) / 180;
      this.rotate(i, e);
    }
    rotateAbout(t, e, i) {
      let n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      this.translate(e, i, !1), this.rotate(t, !1), this.translate(-e, -i, !1), n && this.setTransformForCurrent();
    }
    rotateDegreesAbout(t, e, i) {
      let n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      this.translate(e, i, !1),
        this.rotateDegrees(t, !1),
        this.translate(-e, -i, !1),
        n && this.setTransformForCurrent();
    }
    beginPath() {
      this.path.clear();
    }
    clip(t, e) {}
    arc(t, e, i, n, s, r) {
      this.path.arc(t, e, i, n, s, r);
    }
    arcTo(t, e, i, n, s) {
      this.path.arcTo(t, e, i, n, s);
    }
    bezierCurveTo(t, e, i, n, s, r) {
      this.path.bezierCurveTo(t, e, i, n, s, r);
    }
    closePath() {
      this.path.closePath();
    }
    ellipse(t, e, i, n, s, r, a, o) {}
    lineTo(t, e) {
      this.path.lineTo(t, e);
    }
    moveTo(t, e) {
      this.path.moveTo(t, e);
    }
    quadraticCurveTo(t, e, i, n) {
      this.path.quadraticCurveTo(t, e, i, n);
    }
    rect(t, e, i, n) {
      this.path.rect(t, e, i, n);
    }
    createImageData(t, e) {
      return null;
    }
    createLinearGradient(t, e, i, n) {
      throw new Error('不支持createLinearGradient');
    }
    createPattern(t, e) {
      throw new Error('不支持createPattern');
    }
    createRadialGradient(t, e, i, n, s, r) {
      throw new Error('不支持createRadialGradient');
    }
    createConicGradient(t, e, i, n) {
      return null;
    }
    fill(t, e) {}
    fillRect(t, e, i, n) {
      this.path.rect(t, e, i, n);
    }
    clearRect(t, e, i, n) {}
    fillText(t, e, i) {}
    getImageData(t, e, i, n) {
      return null;
    }
    getLineDash() {
      return [];
    }
    isPointInPath(t, e) {
      return (
        this.matrix.transformPoint({ x: t, y: e }, _L),
        (function (t, e, i) {
          return Lk(t, 0, !1, e, i);
        })(this.path.commandList, _L.x, _L.y)
      );
    }
    isPointInStroke(t, e) {
      if (!this.lineWidth) return !1;
      this.matrix.transformPoint({ x: t, y: e }, _L);
      const i = kI(this, this.lineWidth, this.dpr);
      return (function (t, e, i, n) {
        return Lk(t, e, !0, i, n);
      })(this.path.commandList, i, _L.x, _L.y);
    }
    measureText(t) {
      throw new Error('不支持measureText');
    }
    putImageData(t, e, i) {
      throw new Error('不支持measureText');
    }
    setLineDash(t) {}
    stroke(t) {}
    strokeRect(t, e, i, n) {
      this.path.rect(t, e, i, n);
    }
    strokeText(t, e, i) {}
    drawImage() {}
    setCommonStyle(t, e, i, n, s) {}
    _setCommonStyle(t, e, i, n) {}
    setStrokeStyle(t, e, i, n, s) {}
    _setStrokeStyle(t, e, i, n) {}
    setTextStyleWithoutAlignBaseline(t, e) {}
    setTextStyle(t, e) {}
    draw() {}
    clearMatrix() {
      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.dpr;
      this.setTransformFromMatrix(yL, t, e);
    }
    onlyTranslate() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.dpr;
      return this.matrix.a === t && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === t;
    }
    release() {
      this.stack.forEach(t => zO.free(t)), (this.stack.length = 0);
    }
  };
  bL = vL([ZS(), mL('design:paramtypes', [Object, Number])], bL);
  var xL = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    SL = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    wL = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let AL = class extends bD {
    constructor(t, e, i) {
      super(e, i),
        (this.contributions = t),
        (this.global = e),
        (this.pickItemInterceptorContributions = i),
        this.global.hooks.onSetEnv.tap('math-picker-service', (t, e, i) => {
          this.configure(i, e);
        }),
        this.configure(this.global, this.global.env),
        (this.pickerMap = new Map());
    }
    init() {
      this.contributions.getContributions().forEach(t => {
        this.pickerMap.set(t.numberType, t);
      }),
        super._init();
    }
    configure(t, e) {
      this.pickContext = new bL(null, 1);
    }
    pickItem(t, e, i, n) {
      if (!1 === t.attribute.pickable) return null;
      const s = this.pickerMap.get(t.numberType);
      return s && s.contains(t, e, n) ? t : null;
    }
  };
  xL(
    [sw(), SL('design:type', Function), SL('design:paramtypes', []), SL('design:returntype', void 0)],
    AL.prototype,
    'init',
    null
  ),
    (AL = xL(
      [
        ZS(),
        wL(0, tw(rw)),
        wL(0, JS(dL)),
        wL(1, tw(dw)),
        wL(2, tw(rw)),
        wL(2, JS(pD)),
        SL('design:paramtypes', [Object, Object, Object])
      ],
      AL
    ));
  var kL = new YS(t => {
      t(fL).toSelf().inSingletonScope(),
        t(AL).toSelf().inSingletonScope(),
        t(_D).toService(fL),
        t(kD).toSelf().inSingletonScope(),
        t(AD).toService(kD),
        t(fD).toSelf().inSingletonScope(),
        t(pD).toService(fD),
        t(gD).toSelf().inSingletonScope(),
        t(pD).toService(gD),
        ow(t, pD);
    }),
    ML = new YS(t => {
      t(XO).toSelf().inSingletonScope(),
        t(zE).toService(XO),
        t(kO).toSelf().inSingletonScope(),
        t(AO).toService(kO),
        ow(t, AO),
        t(CO).toSelf().inSingletonScope(),
        t(TO).toService(CO),
        ow(t, TO),
        t(RO).toSelf().inSingletonScope(),
        t(PO).toService(RO),
        ow(t, PO),
        t(IO).toSelf().inSingletonScope(),
        t(BO).toService(IO),
        ow(t, BO),
        t(FO).toSelf().inSingletonScope(),
        t(LO).toService(FO),
        ow(t, LO),
        t(HE).toConstantValue(hB);
    });
  const TL = Symbol.for('AutoEnablePlugins'),
    CL = Symbol.for('PluginService');
  var EL = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    PL = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    RL = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let OL = class {
    constructor(t) {
      (this.autoEnablePlugins = t),
        (this.onStartupFinishedPlugin = []),
        (this.onRegisterPlugin = []),
        (this.actived = !1);
    }
    active(t, e) {
      (this.stage = t), (this.actived = !0);
      const { pluginList: i } = e;
      i &&
        sk.isBound(TL) &&
        this.autoEnablePlugins.getContributions().forEach(t => {
          i.includes(t.name) && this.register(t);
        });
    }
    findPluginsByName(t) {
      const e = [];
      return (
        this.onStartupFinishedPlugin.forEach(i => {
          i.name === t && e.push(i);
        }),
        this.onRegisterPlugin.forEach(i => {
          i.name === t && e.push(i);
        }),
        e
      );
    }
    register(t) {
      'onStartupFinished' === t.activeEvent
        ? this.onStartupFinishedPlugin.push(t)
        : 'onRegister' === t.activeEvent && (this.onRegisterPlugin.push(t), t.activate(this));
    }
    release() {
      this.onStartupFinishedPlugin.forEach(t => {
        t.deactivate(this);
      }),
        (this.onStartupFinishedPlugin = []),
        this.onRegisterPlugin.forEach(t => {
          t.deactivate(this);
        }),
        (this.onRegisterPlugin = []);
    }
  };
  OL = EL([ZS(), RL(0, tw(rw)), RL(0, JS(TL)), PL('design:paramtypes', [Object])], OL);
  var BL = new YS(t => {
      t(OL).toSelf(),
        t(CL).toService(OL),
        (function (t, e) {
          t(rw)
            .toDynamicValue(t => {
              let { container: i } = t;
              return new aw(e, i);
            })
            .whenTargetNamed(e);
        })(t, TL);
    }),
    IL = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    };
  let DL = class {
    configure(t) {
      t.env === this.type && t.setActiveEnvContribution(this);
    }
    getNativeAABBBounds(t) {
      return new Kt();
    }
    removeDom(t) {
      return !1;
    }
    createDom(t) {
      return null;
    }
    getDynamicCanvasCount() {
      return 999;
    }
    getStaticCanvasCount() {
      return 999;
    }
    getElementById(t) {
      return document.getElementById(t);
    }
    getRootElement() {
      return document.body;
    }
    loadJson(t) {
      const e = fetch(t).then(t => t.json());
      return e.then(t => ({ data: t, state: 'success' })).catch(() => ({ data: null, state: 'fail' })), e;
    }
    loadArrayBuffer(t) {
      return fetch(t)
        .then(t => t.arrayBuffer())
        .then(t => ({ data: t, loadState: 'success' }))
        .catch(() => ({ data: null, loadState: 'fail' }));
    }
    loadBlob(t) {
      return fetch(t)
        .then(t => t.blob())
        .then(t => ({ data: t, loadState: 'success' }))
        .catch(() => ({ data: null, loadState: 'fail' }));
    }
    getElementTop(t, e) {
      return 0;
    }
    getElementLeft(t, e) {
      return 0;
    }
    getElementTopLeft(t, e) {
      return { top: 0, left: 0 };
    }
  };
  DL = IL([ZS()], DL);
  var LL = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    FL = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  class jL {
    get x1() {
      return this.dom.getBoundingClientRect().left;
    }
    get x2() {
      return this.dom.getBoundingClientRect().right;
    }
    get y1() {
      return this.dom.getBoundingClientRect().top;
    }
    get y2() {
      return this.dom.getBoundingClientRect().bottom;
    }
    get width() {
      return this.dom.getBoundingClientRect().width;
    }
    get height() {
      return this.dom.getBoundingClientRect().height;
    }
    constructor(t) {
      this.dom = t;
    }
  }
  function zL(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const i = document.createElement('img');
    if (((i.crossOrigin = 'anonymous'), e)) {
      const e = new Blob([t], { type: 'image/svg+xml' });
      t = window.URL.createObjectURL(e);
    }
    return (
      (i.src = t),
      i.complete
        ? Promise.resolve(i)
        : new Promise((t, e) => {
            (i.onload = () => {
              t(i);
            }),
              (i.onerror = () => {
                e(new Error('加载失败'));
              });
          })
    );
  }
  let HL = class extends DL {
    constructor() {
      super(), (this.type = 'browser'), (this.supportEvent = !0);
      try {
        (this.supportsTouchEvents = 'ontouchstart' in globalThis),
          (this.supportsPointerEvents = !!globalThis.PointerEvent),
          (this.supportsMouseEvents = !!globalThis.MouseEvent);
      } catch (t) {
        (this.supportsTouchEvents = !1), (this.supportsPointerEvents = !1), (this.supportsPointerEvents = !1);
      }
      this.applyStyles = !0;
    }
    mapToCanvasPoint(t, e) {
      var i;
      if (e) {
        const { clientX: n, clientY: s } = t,
          r = e.getBoundingClientRect(),
          a = null === (i = e.getNativeHandler) || void 0 === i ? void 0 : i.call(e).nativeCanvas;
        let o, l;
        return (
          a && ((o = r.width / a.offsetWidth), (l = r.height / a.offsetHeight)),
          { x: (n - r.left) / (_(o) ? o : 1), y: (s - r.top) / (_(l) ? o : 1) }
        );
      }
      return { x: t.offsetX, y: t.offsetY };
    }
    getNativeAABBBounds(t) {
      let e = t;
      if (
        ('string' == typeof t && (e = new DOMParser().parseFromString(t, 'text/xml').firstChild),
        e.getBoundingClientRect)
      ) {
        const t = e.getBoundingClientRect();
        return new jL(t);
      }
      return new Kt();
    }
    removeDom(t) {
      return t.parentElement.removeChild(t), !0;
    }
    createDom(t) {
      const { tagName: e = 'div', width: i, height: n, style: s, parent: r } = t,
        a = document.createElement(e);
      if (
        (s &&
          (g(s)
            ? a.setAttribute('style', s)
            : Object.keys(s).forEach(t => {
                a.setAttribute(t, s[t]);
              })),
        null != i && (a.style.width = `${i}px`),
        null != n && (a.style.height = `${n}px`),
        r)
      ) {
        const t = g(r) ? this.getElementById(r) : r;
        t && t.appendChild && t.appendChild(a);
      }
      return a;
    }
    loadImage(t) {
      return zL(t, !1)
        .then(t => ({ data: t, loadState: 'success' }))
        .catch(() => ({ data: null, loadState: 'fail' }));
    }
    loadSvg(t) {
      return zL(t, !0)
        .then(t => ({ data: t, loadState: 'success' }))
        .catch(() => ({ data: null, loadState: 'fail' }));
    }
    createCanvas(t) {
      var e, i;
      const n = document.createElement('canvas');
      t.id && (n.id = null !== (e = t.id) && void 0 !== e ? e : Jk.GenAutoIncrementId().toString());
      const s = null !== (i = t.dpr) && void 0 !== i ? i : window.devicePixelRatio;
      return (
        t.width &&
          t.height &&
          ((n.style.width = `${t.width}px`),
          (n.style.height = `${t.height}px`),
          (n.width = t.width * s),
          (n.height = t.height * s)),
        n
      );
    }
    createOffscreenCanvas(t) {
      var e;
      const i = null !== (e = t.dpr) && void 0 !== e ? e : window.devicePixelRatio;
      return new OffscreenCanvas(t.width * i, t.height * i);
    }
    releaseCanvas(t) {
      let e;
      (e = 'string' == typeof t ? document.getElementById(t) : t),
        e && e.parentElement && e.parentElement.removeChild(e);
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getRequestAnimationFrame() {
      return window.requestAnimationFrame;
    }
    getCancelAnimationFrame() {
      return window.cancelAnimationFrame;
    }
    addEventListener(t, e, i) {
      return document.addEventListener(t, e, i);
    }
    removeEventListener(t, e, i) {
      return document.removeEventListener(t, e, i);
    }
    dispatchEvent(t) {
      return document.dispatchEvent(t);
    }
    getElementById(t) {
      return document.getElementById(t);
    }
    getRootElement() {
      return document.body;
    }
    getDocument() {
      return document;
    }
    release() {}
    getElementTop(t, e) {
      let i = t.offsetTop,
        n = t.offsetParent;
      for (; null !== n; ) (i += n.offsetTop), (n = n.offsetParent);
      return i;
    }
    getElementLeft(t, e) {
      let i = t.offsetLeft,
        n = t.offsetParent;
      for (; null !== n; ) (i += n.offsetLeft), (n = n.offsetParent);
      return i;
    }
    getElementTopLeft(t, e) {
      let i = t.offsetTop,
        n = t.offsetLeft,
        s = t.offsetParent;
      for (; null !== s; ) (i += s.offsetTop), (n += s.offsetLeft), (s = s.offsetParent);
      return { top: i, left: n };
    }
  };
  function NL() {
    sk.rebind(_D).toService(AL);
  }
  HL = LL([ZS(), FL('design:paramtypes', [])], HL);
  var VL = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    WL = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  let GL = class extends DL {
    constructor() {
      super(),
        (this.type = 'feishu'),
        (this.supportEvent = !0),
        (this.canvasMap = new Map()),
        (this.freeCanvasList = []),
        (this.canvasIdx = 0),
        (this.supportsTouchEvents = !0);
      try {
        (this.supportsPointerEvents = !!globalThis.PointerEvent), (this.supportsMouseEvents = !!globalThis.MouseEvent);
      } catch (t) {
        (this.supportsPointerEvents = !1), (this.supportsMouseEvents = !1);
      }
      this.applyStyles = !0;
    }
    getDynamicCanvasCount() {
      return this.freeCanvasList.length;
    }
    getStaticCanvasCount() {
      return this.freeCanvasList.length;
    }
    configure(t, e) {
      t.env === this.type &&
        (t.setActiveEnvContribution(this),
        (function (t, e, i, n, s) {
          const r = tt.getSystemInfoSync().pixelRatio;
          e.forEach((e, a) => {
            const o = tt.createCanvasContext(e);
            o.canvas = { width: t.width * r, height: t.height * r };
            const l = {
              width: t.width * r,
              height: t.height * r,
              offsetWidth: t.width,
              offsetHeight: t.height,
              id: null != e ? e : '',
              getContext: () => o,
              getBoundingClientRect: () => ({ height: t.height, width: t.width })
            };
            i.set(e, l), a >= n && s.push(l);
          });
        })(e.domref, e.canvasIdLists, this.canvasMap, e.freeCanvasIdx, this.freeCanvasList),
        NL());
    }
    loadImage(t) {
      return Promise.resolve({ data: t, loadState: 'success' });
    }
    loadSvg(t) {
      return Promise.reject();
    }
    createCanvas(t) {
      const e = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
      return this.canvasIdx++, e;
    }
    createOffscreenCanvas(t) {}
    releaseCanvas(t) {}
    getDevicePixelRatio() {
      return tt.getSystemInfoSync().pixelRatio;
    }
    getRequestAnimationFrame() {
      return function (t) {
        return GM.call(t);
      };
    }
    getCancelAnimationFrame() {
      return t => {
        GM.clear(t);
      };
    }
    addEventListener(t, e, i) {
      return null;
    }
    removeEventListener(t, e, i) {
      return null;
    }
    dispatchEvent(t) {
      return null;
    }
    getElementById(t) {
      return this.canvasMap.get(t);
    }
    getRootElement() {
      return null;
    }
    getDocument() {
      return null;
    }
    release() {}
    mapToCanvasPoint(t) {
      var e;
      return (null === (e = null == t ? void 0 : t.type) || void 0 === e ? void 0 : e.startsWith('mouse')) ? t : null;
    }
  };
  GL = VL([ZS(), WL('design:paramtypes', [])], GL);
  var UL = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    YL = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  let $L = class extends DL {
    constructor() {
      super(),
        (this.type = 'taro'),
        (this.supportEvent = !0),
        (this.canvasMap = new Map()),
        (this.freeCanvasList = []),
        (this.canvasIdx = 0),
        (this.supportsTouchEvents = !0);
      try {
        (this.supportsPointerEvents = !!globalThis.PointerEvent), (this.supportsMouseEvents = !!globalThis.MouseEvent);
      } catch (t) {
        (this.supportsPointerEvents = !1), (this.supportsMouseEvents = !1);
      }
      this.applyStyles = !0;
    }
    getDynamicCanvasCount() {
      return this.freeCanvasList.length;
    }
    getStaticCanvasCount() {
      return this.freeCanvasList.length;
    }
    configure(t, e) {
      var i, n, s, r, a, o, l;
      t.env === this.type &&
        (t.setActiveEnvContribution(this),
        (i = e.domref),
        (n = e.canvasIdLists),
        (s = this.canvasMap),
        (r = e.freeCanvasIdx),
        (a = this.freeCanvasList),
        (o = e.taro),
        (l = e.pixelRatio),
        n.forEach((t, e) => {
          const n = o.createCanvasContext(t);
          (n.canvas = { width: i.width * l, height: i.height * l }),
            n.createRadialGradient ||
              (n.createRadialGradient = function () {
                return n.createCircularGradient(...arguments);
              }),
            !n.getImageData &&
              o.canvasGetImageData &&
              (n.getImageData = (e, i, n, s) =>
                new Promise((r, a) => {
                  try {
                    o.canvasGetImageData({
                      canvasId: t,
                      x: e,
                      y: i,
                      width: n,
                      height: s,
                      success(t) {
                        r(t);
                      }
                    });
                  } catch (t) {
                    a(t);
                  }
                }));
          const h = {
            id: t,
            width: i.width * l,
            height: i.height * l,
            offsetWidth: i.width,
            offsetHeight: i.height,
            getContext: () => n,
            getBoundingClientRect: () => ({ height: i.height, width: i.width })
          };
          return s.set(t, h), e >= r && a.push(h), h;
        }),
        (this.taro = e.taro),
        (this.pixelRatio = e.pixelRatio),
        sk.rebind(_D).toService(AL));
    }
    loadImage(t) {
      return Promise.resolve({ data: t, loadState: 'success' });
    }
    loadSvg(t) {
      const e = window || globalThis;
      if (e.DOMParser) {
        const i = new e.DOMParser().parseFromString(t, 'image/svg+xml').children[0],
          n = new XMLSerializer().serializeToString(i),
          s = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(n)}`;
        return Promise.resolve({ data: s, loadState: 'success' });
      }
      if (e.Blob) {
        const i = new e.Blob([t], { type: 'image/svg+xml' }),
          n = e.URL.createObjectURL(i);
        return Promise.resolve({ data: n, loadState: 'success' });
      }
      return Promise.reject();
    }
    createCanvas(t) {
      const e = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
      return this.canvasIdx++, e;
    }
    createOffscreenCanvas(t) {}
    releaseCanvas(t) {}
    getDevicePixelRatio() {
      return this.pixelRatio;
    }
    getRequestAnimationFrame() {
      return requestAnimationFrame;
    }
    getCancelAnimationFrame() {
      return cancelAnimationFrame;
    }
    addEventListener(t, e, i) {
      return null;
    }
    removeEventListener(t, e, i) {
      return null;
    }
    dispatchEvent(t) {
      return null;
    }
    getElementById(t) {
      return this.canvasMap.get(t);
    }
    getRootElement() {
      return null;
    }
    getDocument() {
      return null;
    }
    release() {}
  };
  $L = UL([ZS(), YL('design:paramtypes', [])], $L);
  var XL = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    KL = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  let qL = !1;
  try {
    qL = !!lynx.createCanvasNG;
  } catch (t) {}
  let ZL = class extends DL {
    constructor() {
      super(),
        (this.type = 'lynx'),
        (this.supportEvent = !0),
        (this.canvasMap = new Map()),
        (this.freeCanvasList = []),
        (this.canvasIdx = 0),
        (this.supportsTouchEvents = !0);
      try {
        (this.supportsPointerEvents = !!globalThis.PointerEvent), (this.supportsMouseEvents = !!globalThis.MouseEvent);
      } catch (t) {
        (this.supportsPointerEvents = !1), (this.supportsMouseEvents = !1);
      }
      this.applyStyles = !0;
    }
    configure(t, e) {
      t.env === this.type &&
        (t.setActiveEnvContribution(this),
        (function (t, e, i, n, s) {
          const r = SystemInfo.pixelRatio;
          e.forEach((e, a) => {
            const o = qL ? lynx.createCanvasNG(e) : lynx.createCanvas(e);
            (o.width = t.width * r), (o.height = t.height * r), qL && o.attachToCanvasView(e);
            const l = o.getContext('2d');
            l.draw = (t, e) => {
              e();
            };
            const h = {
              width: t.width * r,
              height: t.height * r,
              offsetWidth: t.width,
              offsetHeight: t.height,
              id: null != e ? e : '',
              getContext: () => l,
              getBoundingClientRect: () => ({ height: t.height, width: t.width })
            };
            i.set(e, h), a >= n && s.push(h);
          });
        })(e.domref, e.canvasIdLists, this.canvasMap, e.freeCanvasIdx, this.freeCanvasList),
        NL());
    }
    getDynamicCanvasCount() {
      return this.freeCanvasList.length;
    }
    getStaticCanvasCount() {
      return this.freeCanvasList.length;
    }
    loadImage(t) {
      return (function (t) {
        if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) return Promise.reject();
        const e = lynx.createImage(t);
        return new Promise((t, i) => {
          (e.onload = () => {
            t(e);
          }),
            (e.onerror = () => {
              i(new Error('加载失败'));
            });
        });
      })(t, !1)
        .then(t => ({ data: t, loadState: 'success' }))
        .catch(() => ({ data: null, loadState: 'fail' }));
    }
    loadSvg(t) {
      return Promise.reject();
    }
    createCanvas(t) {
      const e = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
      return this.canvasIdx++, e;
    }
    createOffscreenCanvas(t) {}
    releaseCanvas(t) {}
    getDevicePixelRatio() {
      return SystemInfo.pixelRatio;
    }
    getRequestAnimationFrame() {
      return function (t) {
        return GM.call(t);
      };
    }
    getCancelAnimationFrame() {
      return t => {
        GM.clear(t);
      };
    }
    addEventListener(t, e, i) {
      return null;
    }
    removeEventListener(t, e, i) {
      return null;
    }
    dispatchEvent(t) {
      return null;
    }
    getElementById(t) {
      return this.canvasMap.get(t);
    }
    getRootElement() {
      return null;
    }
    getDocument() {
      return null;
    }
    release() {}
  };
  ZL = XL([ZS(), KL('design:paramtypes', [])], ZL);
  var JL = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let QL = class extends DL {
    constructor() {
      super(...arguments), (this.type = 'node'), (this._lastTime = 0), (this.supportEvent = !1);
    }
    configure(t, e) {
      t.env === this.type && (t.setActiveEnvContribution(this), (this.pkg = e));
    }
    getDynamicCanvasCount() {
      return 0;
    }
    getStaticCanvasCount() {
      return 1;
    }
    loadJson(t) {
      const e = fetch(t).then(t => t.json());
      return e.then(t => ({ data: t, state: 'success' })).catch(() => ({ data: null, state: 'fail' })), e;
    }
    loadArrayBuffer(t) {
      return fetch(t)
        .then(t => t.arrayBuffer())
        .then(t => ({ data: t, loadState: 'success' }))
        .catch(() => ({ data: null, loadState: 'fail' }));
    }
    loadImage(t) {
      const { loadImage: e } = this.pkg;
      return e
        ? e(t)
            .then(t => ({ loadState: t ? 'success' : 'fail', data: t }))
            .catch(() => ({ loadState: 'fail', data: null }))
        : Promise.reject(new Error('node-canvas loadImage could not be found!'));
    }
    loadSvg(t) {
      const e = this.pkg.Resvg;
      if (!e) return Promise.reject(new Error('@resvg/resvg-js svgParser could not be found!'));
      const i = new e(t).render().asPng();
      return this.loadImage(i);
    }
    createCanvas(t) {
      return this.pkg.createCanvas(t.width, t.height);
    }
    releaseCanvas(t) {}
    getDevicePixelRatio() {
      return 1;
    }
    getRequestAnimationFrame() {
      return function (t) {
        return GM.call(t);
      };
    }
    getCancelAnimationFrame() {
      return t => {
        GM.clear(t);
      };
    }
    addEventListener(t, e, i) {}
    removeEventListener(t, e, i) {}
    getElementById(t) {
      return null;
    }
    getRootElement() {
      return null;
    }
    dispatchEvent(t) {}
    release() {}
    createOffscreenCanvas(t) {}
  };
  QL = JL([ZS()], QL);
  var tF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    eF = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    iF = function (t, e, i, n) {
      return new (i || (i = Promise))(function (s, r) {
        function a(t) {
          try {
            l(n.next(t));
          } catch (t) {
            r(t);
          }
        }
        function o(t) {
          try {
            l(n.throw(t));
          } catch (t) {
            r(t);
          }
        }
        function l(t) {
          var e;
          t.done
            ? s(t.value)
            : ((e = t.value),
              e instanceof i
                ? e
                : new i(function (t) {
                    t(e);
                  })).then(a, o);
        }
        l((n = n.apply(t, e || [])).next());
      });
    };
  let nF = class extends DL {
    constructor() {
      super(),
        (this.type = 'wx'),
        (this.supportEvent = !0),
        (this.canvasMap = new Map()),
        (this.freeCanvasList = []),
        (this.canvasIdx = 0),
        (this.supportsTouchEvents = !0);
      try {
        (this.supportsPointerEvents = !!globalThis.PointerEvent), (this.supportsMouseEvents = !!globalThis.MouseEvent);
      } catch (t) {
        (this.supportsPointerEvents = !1), (this.supportsMouseEvents = !1);
      }
      this.applyStyles = !0;
    }
    configure(t, e) {
      if (t.env === this.type)
        return (
          t.setActiveEnvContribution(this),
          (function (t, e, i, n, s, r) {
            return iF(this, void 0, void 0, function* () {
              const t = wx.getSystemInfoSync().pixelRatio;
              for (let a = 0; a < e.length; a++) {
                const o = e[a];
                yield new Promise(e => {
                  let l = wx.createSelectorQuery();
                  r && (l = l.in(r)),
                    l
                      .select(`#${o}`)
                      .fields({ node: !0, size: !0 })
                      .exec(r => {
                        if (!r[0]) return;
                        const l = r[0].node,
                          h = r[0].width,
                          c = r[0].height;
                        (l.width = h * t), (l.height = c * t), i.set(o, l), a >= n && s.push(l), e(null);
                      });
                });
              }
            });
          })(e.domref, e.canvasIdLists, this.canvasMap, e.freeCanvasIdx, this.freeCanvasList, e.component).then(() => {
            NL();
          })
        );
    }
    loadImage(t) {
      return Promise.resolve({ data: t, loadState: 'success' });
    }
    loadSvg(t) {
      return Promise.reject();
    }
    createCanvas(t) {
      const e = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
      return this.canvasIdx++, e;
    }
    createOffscreenCanvas(t) {}
    releaseCanvas(t) {}
    getDevicePixelRatio() {
      return wx.getSystemInfoSync().pixelRatio;
    }
    getRequestAnimationFrame() {
      return function (t) {
        return GM.call(t);
      };
    }
    getCancelAnimationFrame() {
      return t => {
        GM.clear(t);
      };
    }
    addEventListener(t, e, i) {
      return null;
    }
    removeEventListener(t, e, i) {
      return null;
    }
    dispatchEvent(t) {
      return null;
    }
    getElementById(t) {
      return this.canvasMap.get(t);
    }
    getRootElement() {
      return null;
    }
    getDocument() {
      return null;
    }
    release() {}
    mapToCanvasPoint(t) {
      var e;
      return (null === (e = null == t ? void 0 : t.type) || void 0 === e ? void 0 : e.startsWith('mouse')) ? t : null;
    }
  };
  nF = tF([ZS(), eF('design:paramtypes', [])], nF);
  var sF = new YS(t => {
      t(HL).toSelf().inSingletonScope(),
        t(cw).toService(HL),
        t(GL).toSelf().inSingletonScope(),
        t(cw).toService(GL),
        t($L).toSelf().inSingletonScope(),
        t(cw).toService($L),
        t(ZL).toSelf().inSingletonScope(),
        t(cw).toService(ZL),
        t(nF).toSelf().inSingletonScope(),
        t(cw).toService(nF),
        t(QL).toSelf().inSingletonScope(),
        t(cw).toService(QL),
        ow(t, cw);
    }),
    rF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    aF = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  let oF = class {
    constructor() {
      this._uid = Jk.GenAutoIncrementId();
    }
    onChange(t) {
      this._onChangeCb = t;
    }
    configure(t, e) {
      e.env === this.type && t.setWindowHandler(this);
    }
    release() {
      this.releaseWindow();
    }
    isVisible(t) {
      return !0;
    }
    onVisibleChange(t) {}
    getTopLeft(t) {
      return { top: 0, left: 0 };
    }
  };
  oF = rF([ZS(), aF('design:paramtypes', [])], oF);
  var lF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    hF = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    cF = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let dF = class extends oF {
    get container() {
      return this.canvas.nativeCanvas.parentElement;
    }
    constructor(t) {
      super(), (this.global = t), (this.type = 'browser'), (this._canvasIsIntersecting = !0);
    }
    getTitle() {
      return this.canvas.id.toString();
    }
    getWH() {
      return { width: this.canvas.width / (this.canvas.dpr || 1), height: this.canvas.height / (this.canvas.dpr || 1) };
    }
    getXY() {
      return this.canvas.nativeCanvas.getBoundingClientRect();
    }
    createWindow(t) {
      t.canvas ? this.createWindowByCanvas(t) : this.createWindowByConfig(t), this.postInit();
    }
    postInit() {
      try {
        this.observerCanvas();
      } catch (t) {
        console.error('发生错误，该环境不存在IntersectionObserver');
      }
    }
    isElementVisible(t) {
      const e = t.getBoundingClientRect(),
        i = window.innerWidth || document.documentElement.clientWidth,
        n = window.innerHeight || document.documentElement.clientHeight;
      return !(e.right < 0 || e.bottom < 0 || e.left > i || e.top > n);
    }
    observerCanvas() {
      this._canvasIsIntersecting = this.isElementVisible(this.canvas.nativeCanvas);
      const t = new IntersectionObserver((t, e) => {
        t.forEach(t => {
          this._canvasIsIntersecting !== t.isIntersecting
            ? ((this._canvasIsIntersecting = t.isIntersecting),
              this._onVisibleChangeCb && this._onVisibleChangeCb(t.isIntersecting))
            : (this._canvasIsIntersecting = t.isIntersecting);
        });
      });
      t && t.observe(this.canvas.nativeCanvas);
    }
    createWindowByConfig(t) {
      const e = this.global.createCanvas({ width: t.width, height: t.height });
      let i;
      if (
        ((i =
          'string' == typeof t.container
            ? this.global.getElementById(t.container)
            : t.container
            ? t.container
            : this.global.getRootElement()),
        !i)
      )
        throw new Error('发生错误，containerId可能传入有误');
      t.offscreen ? (i = null) : i.appendChild(e);
      const n = {
        width: t.width,
        height: t.height,
        dpr: t.dpr,
        nativeCanvas: e,
        container: i,
        id: Jk.GenAutoIncrementId().toString(),
        canvasControled: !0
      };
      this.canvas = new FD(n);
    }
    createWindowByCanvas(t) {
      var e;
      let i;
      if ('string' == typeof t.canvas) {
        if (((i = this.global.getElementById(t.canvas)), !i))
          throw new Error('canvasId 参数不正确，请确认canvas存在并插入dom');
      } else i = t.canvas;
      if (!i) throw new Error('发生错误，传入的canvas不正确');
      let n = t.width,
        s = t.height;
      if (null == n || null == s || !t.canvasControled) {
        const t = i.getBoundingClientRect();
        (n = t.width), (s = t.height);
      }
      let r = t.dpr;
      !1 === t.canvasControled && (r && console.warn('canvasControled为false后，dpr参数将无效'), (r = null)),
        null == r && (r = null !== (e = i.getContext('2d').pixelRatio) && void 0 !== e ? e : i.width / n),
        (this.canvas = new FD({ width: n, height: s, dpr: r, nativeCanvas: i, canvasControled: t.canvasControled }));
    }
    releaseWindow() {
      this.canvas.release();
    }
    resizeWindow(t, e) {
      this.canvas.resize(t, e);
    }
    setDpr(t) {
      this.canvas.dpr = t;
    }
    getContext() {
      return this.canvas.getContext();
    }
    getNativeHandler() {
      return this.canvas;
    }
    getDpr() {
      return this.canvas.dpr;
    }
    addEventListener(t, e, i) {
      return this.canvas.nativeCanvas.addEventListener(t, e, i);
    }
    removeEventListener(t, e, i) {
      return this.canvas.nativeCanvas.removeEventListener(t, e, i);
    }
    dispatchEvent(t) {
      return this.canvas.nativeCanvas.dispatchEvent(t);
    }
    getStyle() {
      return this.canvas.nativeCanvas.style;
    }
    setStyle(t) {
      this.canvas.nativeCanvas.style = t;
    }
    getBoundingClientRect() {
      const t = this.canvas.nativeCanvas,
        e = this.getWH();
      return t.parentElement
        ? this.canvas.nativeCanvas.getBoundingClientRect()
        : { x: 0, y: 0, width: e.width, height: e.height, left: 0, top: 0, right: 0, bottom: 0 };
    }
    clearViewBox(t, e) {
      const i = this.getContext(),
        n = this.getDpr();
      i.nativeContext.save(),
        i.nativeContext.setTransform(n, 0, 0, n, 0, 0),
        i.clearRect(t.x1, t.y1, t.x2 - t.x1, t.y2 - t.y1),
        e && ((i.fillStyle = e), i.fillRect(t.x1, t.y1, t.x2 - t.x1, t.y2 - t.y1)),
        i.nativeContext.restore();
    }
    isVisible(t) {
      return this._canvasIsIntersecting;
    }
    onVisibleChange(t) {
      this._onVisibleChangeCb = t;
    }
    getTopLeft(t) {
      return this.global.getElementTopLeft(this.canvas.nativeCanvas, t);
    }
  };
  (dF.env = 'browser'), (dF = lF([ZS(), cF(0, tw(dw)), hF('design:paramtypes', [Object])], dF));
  var uF = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let pF = class extends BD {
    get globalAlpha() {
      return this._globalAlpha;
    }
    set globalAlpha(t) {
      (this.nativeContext.globalAlpha = t), (this._globalAlpha = t);
    }
    getImageData(t, e, i, n) {
      return new Promise((s, r) => {
        var a;
        try {
          tt.canvasGetImageData({
            canvasId: null !== (a = this.canvas.nativeCanvas.id) && void 0 !== a ? a : this.canvas.id,
            x: t,
            y: e,
            width: i,
            height: n,
            success(t) {
              s(t);
            }
          });
        } catch (t) {
          r(t);
        }
      });
    }
    draw() {
      const t = this.nativeContext;
      this.drawPromise = new Promise(e => {
        t.draw(!0, () => {
          (this.drawPromise = null), e(null);
        });
      });
    }
    createPattern(t, e) {
      return null;
    }
  };
  (pF.env = 'feishu'), (pF = uF([ZS()], pF));
  var gF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    fF = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  const vF = { WIDTH: 500, HEIGHT: 500, DPR: 1 };
  let mF = class {
    get id() {
      return this._id;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x = t;
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y = t;
    }
    get nativeCanvas() {
      return this._nativeCanvas;
    }
    get width() {
      return this._pixelWidth;
    }
    set width(t) {
      (this._pixelWidth = t), (this._displayWidth = t / (this._dpr || 1));
    }
    get height() {
      return this._pixelHeight;
    }
    set height(t) {
      (this._pixelHeight = t), (this._displayHeight = t / (this._dpr || 1));
    }
    get displayWidth() {
      return this._displayWidth;
    }
    get displayHeight() {
      return this._displayHeight;
    }
    getContext(t) {
      return this._context;
    }
    get visiable() {
      return this._visiable;
    }
    set visiable(t) {
      (this._visiable = t), t ? this.show() : this.hide();
    }
    get dpr() {
      return this._dpr;
    }
    set dpr(t) {
      this._dpr = t;
    }
    constructor(t) {
      const { nativeCanvas: e, width: i = vF.WIDTH, height: n = vF.HEIGHT, dpr: s = vF.DPR } = t,
        { x: r, y: a } = e.getBoundingClientRect ? e.getBoundingClientRect() : { x: 0, y: 0 };
      (this._x = r),
        (this._y = a),
        (this._pixelWidth = i * s),
        (this._pixelHeight = n * s),
        (this._visiable = !1 !== t.visiable),
        (this._displayWidth = i),
        (this._displayHeight = n),
        (this._dpr = s),
        (this._nativeCanvas = e),
        (this._context = new pF(this, this._dpr)),
        (this._id = e.id);
    }
    getNativeCanvas() {
      return this._nativeCanvas;
    }
    resetStyle(t) {}
    applyPosition() {}
    hide() {}
    show() {}
    resize(t, e) {}
    toDataURL(t, e) {
      return '';
    }
    readPixels(t, e, i, n) {
      throw new Error('暂未实现');
    }
    convertToBlob(t) {
      throw new Error('暂未实现');
    }
    transferToImageBitmap() {
      throw new Error('暂未实现');
    }
    release() {}
  };
  (mF.env = 'feishu'), (mF = gF([ZS(), fF('design:paramtypes', [Object])], mF));
  var yF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    _F = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    bF = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let xF = class extends oF {
    get container() {
      return null;
    }
    constructor(t) {
      super(),
        (this.global = t),
        (this.type = 'feishu'),
        (this.eventManager = new (class {
          constructor() {
            this.cache = {};
          }
          addEventListener(t, e) {
            t && e && ((this.cache[t] = this.cache[t] || { listener: [] }), this.cache[t].listener.push(e));
          }
          removeEventListener(t, e) {
            if (!t || !e) return;
            if (!this.cache[t]) return;
            const i = this.cache[t].listener.findIndex(t => t === e);
            i >= 0 && this.cache[t].listener.splice(i, 1);
          }
          cleanEvent() {
            this.cache = {};
          }
        })());
    }
    getTitle() {
      return this.canvas.id.toString();
    }
    getWH() {
      return { width: this.canvas.width / (this.canvas.dpr || 1), height: this.canvas.height / (this.canvas.dpr || 1) };
    }
    getXY() {
      return { x: 0, y: 0 };
    }
    createWindow(t) {
      t.canvas ? this.createWindowByCanvas(t) : this.createWindowByConfig(t);
    }
    createWindowByConfig(t) {
      const e = this.global.createCanvas({ width: t.width, height: t.height }),
        i = {
          width: t.width,
          height: t.height,
          dpr: t.dpr,
          nativeCanvas: e,
          id: Jk.GenAutoIncrementId().toString(),
          canvasControled: !1
        };
      this.canvas = new mF(i);
    }
    createWindowByCanvas(t) {
      let e;
      if ('string' == typeof t.canvas) {
        if (((e = this.global.getElementById(t.canvas)), !e))
          throw new Error('canvasId 参数不正确，请确认canvas存在并插入dom');
      } else e = t.canvas;
      let i = t.width,
        n = t.height;
      if (null == i || null == n || !t.canvasControled) {
        const t = e.getBoundingClientRect();
        (i = t.width), (n = t.height);
      }
      let s = t.dpr;
      null == s && (s = e.width / i),
        (this.canvas = new mF({ width: i, height: n, dpr: s, nativeCanvas: e, canvasControled: t.canvasControled }));
    }
    releaseWindow() {}
    resizeWindow(t, e) {}
    setDpr(t) {
      this.canvas.dpr = t;
    }
    getContext() {
      return this.canvas.getContext();
    }
    getNativeHandler() {
      return this.canvas;
    }
    getDpr() {
      return this.canvas.dpr;
    }
    addEventListener(t, e) {
      this.eventManager.addEventListener(t, e);
    }
    removeEventListener(t, e) {
      this.eventManager.removeEventListener(t, e);
    }
    dispatchEvent(t) {
      const { type: e } = t;
      return (
        !!this.eventManager.cache[e] &&
        (t.changedTouches &&
          t.changedTouches[0] &&
          ((t.offsetX = t.changedTouches[0].x),
          (t.changedTouches[0].offsetX = t.changedTouches[0].x),
          (t.changedTouches[0].clientX = t.changedTouches[0].x),
          (t.offsetY = t.changedTouches[0].y),
          (t.changedTouches[0].offsetY = t.changedTouches[0].y),
          (t.changedTouches[0].clientY = t.changedTouches[0].y)),
        (t.preventDefault = () => {}),
        (t.stopPropagation = () => {}),
        this.eventManager.cache[e].listener &&
          this.eventManager.cache[e].listener.forEach(e => {
            e(t);
          }),
        !0)
      );
    }
    getStyle() {
      return {};
    }
    setStyle(t) {}
    getBoundingClientRect() {
      const t = this.getWH();
      return { x: 0, y: 0, width: t.width, height: t.height, left: 0, top: 0, right: 0, bottom: 0 };
    }
    clearViewBox(t, e) {
      const i = this.getContext(),
        n = this.getDpr();
      i.nativeContext.save(),
        i.nativeContext.setTransform(n, 0, 0, n, 0, 0),
        i.clearRect(t.x1, t.y1, t.x2 - t.x1, t.y2 - t.y1),
        e && ((i.fillStyle = e), i.fillRect(t.x1, t.y1, t.x2 - t.x1, t.y2 - t.y1)),
        i.nativeContext.restore();
    }
  };
  (xF.env = 'feishu'), (xF = yF([ZS(), bF(0, tw(dw)), _F('design:paramtypes', [Object])], xF));
  var SF = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let wF = class extends BD {
    get globalAlpha() {
      return this._globalAlpha;
    }
    set globalAlpha(t) {
      this.nativeContext.setGlobalAlpha(t), (this._globalAlpha = t);
    }
    draw() {
      this.nativeContext.draw();
    }
    strokeText(t, e, i) {}
    _setCommonStyle(t, e, i, n, s) {
      const r = this.nativeContext;
      s || (s = this.fillAttributes);
      const { fillOpacity: a = s.fillOpacity, opacity: o = s.opacity, fill: l = s.fill } = e;
      a > 1e-12 && o > 1e-12 && (r.setGlobalAlpha(a * o), r.setFillStyle(MI(this, l, t, i, n)));
    }
    _setStrokeStyle(t, e, i, n, s) {
      const r = this.nativeContext;
      s || (s = this.strokeAttributes);
      const { strokeOpacity: a = s.strokeOpacity, opacity: o = s.opacity } = e;
      if (a > 1e-12 && o > 1e-12) {
        const {
          lineWidth: l = s.lineWidth,
          stroke: h = s.stroke,
          lineJoin: c = s.lineJoin,
          lineDash: d = s.lineDash,
          lineCap: u = s.lineCap,
          miterLimit: p = s.miterLimit
        } = e;
        r.setGlobalAlpha(a * o),
          r.setLineWidth(kI(this, l, this.dpr)),
          r.setStrokeStyle(MI(this, h, t, i, n)),
          r.setLineJoin(c),
          r.setLineDash(d),
          r.setLineCap(u),
          r.setMiterLimit(p);
      }
    }
    setTextStyleWithoutAlignBaseline(t, e) {
      var i;
      const n = this.nativeContext;
      e || (e = this.textAttributes),
        t.font ? (n.font = t.font) : (n.font = NP(t, e)),
        n.setFontSize(null !== (i = t.fontSize) && void 0 !== i ? i : e.fontSize);
    }
    setTextStyle(t, e) {
      var i, n;
      const s = this.nativeContext;
      e || (e = this.textAttributes),
        t.font ? (s.font = t.font) : (s.font = NP(t, e)),
        s.setTextAlign(null !== (i = t.textAlign) && void 0 !== i ? i : e.textAlign),
        s.setTextBaseline(null !== (n = t.textBaseline) && void 0 !== n ? n : e.textBaseline);
    }
    createConicGradient(t, e, i, n) {
      return null;
    }
    createPattern(t, e) {
      return null;
    }
  };
  (wF.env = 'taro'), (wF = SF([ZS()], wF));
  var AF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    kF = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  const MF = { WIDTH: 500, HEIGHT: 500, DPR: 1 };
  let TF = class {
    get id() {
      return this._id;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x = t;
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y = t;
    }
    get nativeCanvas() {
      return this._nativeCanvas;
    }
    get width() {
      return this._pixelWidth;
    }
    set width(t) {
      (this._pixelWidth = t), (this._displayWidth = t / (this._dpr || 1));
    }
    get height() {
      return this._pixelHeight;
    }
    set height(t) {
      (this._pixelHeight = t), (this._displayHeight = t / (this._dpr || 1));
    }
    get displayWidth() {
      return this._displayWidth;
    }
    get displayHeight() {
      return this._displayHeight;
    }
    getContext(t) {
      return this._context;
    }
    get visiable() {
      return this._visiable;
    }
    set visiable(t) {
      (this._visiable = t), t ? this.show() : this.hide();
    }
    get dpr() {
      return this._dpr;
    }
    set dpr(t) {
      this._dpr = t;
    }
    constructor(t) {
      const { nativeCanvas: e, width: i = MF.WIDTH, height: n = MF.HEIGHT, dpr: s = MF.DPR } = t,
        { x: r, y: a } = e.getBoundingClientRect ? e.getBoundingClientRect() : { x: 0, y: 0 };
      (this._x = r),
        (this._y = a),
        (this._pixelWidth = i * s),
        (this._pixelHeight = n * s),
        (this._visiable = !1 !== t.visiable),
        (this._displayWidth = i),
        (this._displayHeight = n),
        (this._dpr = s),
        (this._nativeCanvas = e),
        (this._context = new wF(this, this._dpr)),
        (this._id = e.id);
    }
    getNativeCanvas() {
      return this._nativeCanvas;
    }
    resetStyle(t) {}
    applyPosition() {}
    hide() {}
    show() {}
    resize(t, e) {}
    toDataURL(t, e) {
      return '';
    }
    readPixels(t, e, i, n) {
      throw new Error('暂未实现');
    }
    convertToBlob(t) {
      throw new Error('暂未实现');
    }
    transferToImageBitmap() {
      throw new Error('暂未实现');
    }
    release() {}
  };
  (TF.env = 'taro'), (TF = AF([ZS(), kF('design:paramtypes', [Object])], TF));
  var CF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    EF = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    PF = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let RF = class extends oF {
    get container() {
      return null;
    }
    constructor(t) {
      super(),
        (this.global = t),
        (this.type = 'taro'),
        (this.eventManager = new (class {
          constructor() {
            this.cache = {};
          }
          addEventListener(t, e) {
            t && e && ((this.cache[t] = this.cache[t] || { listener: [] }), this.cache[t].listener.push(e));
          }
          removeEventListener(t, e) {
            if (!t || !e) return;
            if (!this.cache[t]) return;
            const i = this.cache[t].listener.findIndex(t => t === e);
            i >= 0 && this.cache[t].listener.splice(i, 1);
          }
          cleanEvent() {
            this.cache = {};
          }
        })());
    }
    getTitle() {
      return this.canvas.id.toString();
    }
    getWH() {
      return { width: this.canvas.width / (this.canvas.dpr || 1), height: this.canvas.height / (this.canvas.dpr || 1) };
    }
    getXY() {
      return { x: 0, y: 0 };
    }
    createWindow(t) {
      t.canvas ? this.createWindowByCanvas(t) : this.createWindowByConfig(t);
    }
    createWindowByConfig(t) {
      const e = this.global.createCanvas({ width: t.width, height: t.height }),
        i = {
          width: t.width,
          height: t.height,
          dpr: t.dpr,
          nativeCanvas: e,
          id: Jk.GenAutoIncrementId().toString(),
          canvasControled: !1
        };
      this.canvas = new TF(i);
    }
    createWindowByCanvas(t) {
      let e;
      if ('string' == typeof t.canvas) {
        if (((e = this.global.getElementById(t.canvas)), !e))
          throw new Error('canvasId 参数不正确，请确认canvas存在并插入dom');
      } else e = t.canvas;
      let i = t.width,
        n = t.height;
      if (null == i || null == n || !t.canvasControled) {
        const t = e.getBoundingClientRect();
        (i = t.width), (n = t.height);
      }
      let s = t.dpr;
      null == s && (s = e.width / i),
        (this.canvas = new TF({ width: i, height: n, dpr: s, nativeCanvas: e, canvasControled: t.canvasControled }));
    }
    releaseWindow() {}
    resizeWindow(t, e) {}
    setDpr(t) {
      this.canvas.dpr = t;
    }
    getContext() {
      return this.canvas.getContext();
    }
    getNativeHandler() {
      return this.canvas;
    }
    getDpr() {
      return this.canvas.dpr;
    }
    addEventListener(t, e) {
      this.eventManager.addEventListener(t, e);
    }
    removeEventListener(t, e) {
      this.eventManager.removeEventListener(t, e);
    }
    dispatchEvent(t) {
      const { type: e } = t;
      return (
        !!this.eventManager.cache[e] &&
        (t.changedTouches.length > 0 &&
          (t.changedTouches.forEach((e, i) => {
            t.changedTouches[i] = Object.assign(Object.assign({}, t.changedTouches[i]), { offsetX: e.x, offsetY: e.y });
          }),
          (t.offsetX = t.changedTouches[0].offsetX),
          (t.offsetY = t.changedTouches[0].offsetY)),
        t.touches.length > 0 &&
          t.touches.forEach((e, i) => {
            t.touches[i] = Object.assign(Object.assign({}, t.touches[i]), { offsetX: e.x, offsetY: e.y });
          }),
        (t.preventDefault = () => {}),
        (t.stopPropagation = () => {}),
        this.eventManager.cache[e].listener &&
          this.eventManager.cache[e].listener.forEach(e => {
            e(t);
          }),
        !0)
      );
    }
    getStyle() {
      return {};
    }
    setStyle(t) {}
    getBoundingClientRect() {
      const t = this.getWH();
      return { x: 0, y: 0, width: t.width, height: t.height, left: 0, top: 0, right: 0, bottom: 0 };
    }
    clearViewBox(t, e) {
      const i = this.getContext(),
        n = this.getDpr();
      i.nativeContext.save(),
        i.nativeContext.setTransform(n, 0, 0, n, 0, 0),
        i.clearRect(t.x1, t.y1, t.x2 - t.x1, t.y2 - t.y1),
        e && ((i.fillStyle = e), i.fillRect(t.x1, t.y1, t.x2 - t.x1, t.y2 - t.y1)),
        i.nativeContext.restore();
    }
  };
  (RF.env = 'taro'), (RF = CF([ZS(), PF(0, tw(dw)), EF('design:paramtypes', [Object])], RF));
  var OF = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let BF = class extends BD {
    get globalAlpha() {
      return this._globalAlpha;
    }
    set globalAlpha(t) {
      (this.nativeContext.globalAlpha = t), (this._globalAlpha = t);
    }
    setLineDash(t) {
      const e = arguments,
        i = this.nativeContext;
      if (this.nativeContext.setLineDash) {
        const t = e[0];
        if (0 === t[0] && 0 === t[1]) return;
        i.setLineDash(t);
      }
    }
    _setStrokeStyle(t, e, i, n, s) {
      const r = this.nativeContext;
      s || (s = this.strokeAttributes);
      const { strokeOpacity: a = s.strokeOpacity, opacity: o = s.opacity } = e;
      if (a > 1e-12 && o > 1e-12) {
        const {
          lineWidth: l = s.lineWidth,
          stroke: h = s.stroke,
          lineJoin: c = s.lineJoin,
          lineDash: d = s.lineDash,
          lineCap: u = s.lineCap,
          miterLimit: p = s.miterLimit
        } = e;
        (r.globalAlpha = a * o),
          (r.lineWidth = kI(this, l, this.dpr)),
          (r.strokeStyle = MI(this, h, t, i, n)),
          (r.lineJoin = c),
          (0 === d[0] && 0 === d[1]) || r.setLineDash(d),
          (r.lineCap = u),
          (r.miterLimit = p);
      }
    }
    createPattern(t, e) {
      return null;
    }
    draw() {
      const t = this.nativeContext;
      this.drawPromise = new Promise(e => {
        t.draw(!0, () => {
          (this.drawPromise = null), e(null);
        });
      });
    }
  };
  (BF.env = 'lynx'), (BF = OF([ZS()], BF));
  var IF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    DF = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  const LF = { WIDTH: 500, HEIGHT: 500, DPR: 1 };
  let FF = class {
    get id() {
      return this._id;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x = t;
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y = t;
    }
    get nativeCanvas() {
      return this._nativeCanvas;
    }
    get width() {
      return this._pixelWidth;
    }
    set width(t) {
      (this._pixelWidth = t), (this._displayWidth = t / (this._dpr || 1));
    }
    get height() {
      return this._pixelHeight;
    }
    set height(t) {
      (this._pixelHeight = t), (this._displayHeight = t / (this._dpr || 1));
    }
    get displayWidth() {
      return this._displayWidth;
    }
    get displayHeight() {
      return this._displayHeight;
    }
    getContext(t) {
      return this._context;
    }
    get visiable() {
      return this._visiable;
    }
    set visiable(t) {
      (this._visiable = t), t ? this.show() : this.hide();
    }
    get dpr() {
      return this._dpr;
    }
    set dpr(t) {
      this._dpr = t;
    }
    constructor(t) {
      const { nativeCanvas: e, width: i = LF.WIDTH, height: n = LF.HEIGHT, dpr: s = LF.DPR } = t,
        { x: r, y: a } = e.getBoundingClientRect ? e.getBoundingClientRect() : { x: 0, y: 0 };
      (this._x = r),
        (this._y = a),
        (this._pixelWidth = i * s),
        (this._pixelHeight = n * s),
        (this._visiable = !1 !== t.visiable),
        (this._displayWidth = i),
        (this._displayHeight = n),
        (this._dpr = s),
        (this._nativeCanvas = e),
        (this._context = new BF(this, this._dpr)),
        (this._id = e.id);
    }
    getNativeCanvas() {
      return this._nativeCanvas;
    }
    resetStyle(t) {}
    applyPosition() {}
    hide() {}
    show() {}
    resize(t, e) {}
    toDataURL(t, e) {
      return '';
    }
    readPixels(t, e, i, n) {
      throw new Error('暂未实现');
    }
    convertToBlob(t) {
      throw new Error('暂未实现');
    }
    transferToImageBitmap() {
      throw new Error('暂未实现');
    }
    release() {}
  };
  (FF.env = 'lynx'), (FF = IF([ZS(), DF('design:paramtypes', [Object])], FF));
  var jF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    zF = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    HF = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let NF = class extends oF {
    get container() {
      return null;
    }
    constructor(t) {
      super(),
        (this.global = t),
        (this.type = 'lynx'),
        (this.eventManager = new (class {
          constructor() {
            this.cache = {};
          }
          addEventListener(t, e) {
            t && e && ((this.cache[t] = this.cache[t] || { listener: [] }), this.cache[t].listener.push(e));
          }
          removeEventListener(t, e) {
            if (!t || !e) return;
            if (!this.cache[t]) return;
            const i = this.cache[t].listener.findIndex(t => t === e);
            i >= 0 && this.cache[t].listener.splice(i, 1);
          }
          cleanEvent() {
            this.cache = {};
          }
        })());
    }
    getTitle() {
      return this.canvas.id.toString();
    }
    getWH() {
      return { width: this.canvas.width / (this.canvas.dpr || 1), height: this.canvas.height / (this.canvas.dpr || 1) };
    }
    getXY() {
      return { x: 0, y: 0 };
    }
    createWindow(t) {
      t.canvas ? this.createWindowByCanvas(t) : this.createWindowByConfig(t);
    }
    createWindowByConfig(t) {
      const e = this.global.createCanvas({ width: t.width, height: t.height }),
        i = {
          width: t.width,
          height: t.height,
          dpr: t.dpr,
          nativeCanvas: e,
          id: Jk.GenAutoIncrementId().toString(),
          canvasControled: !1
        };
      this.canvas = new FF(i);
    }
    createWindowByCanvas(t) {
      let e;
      if ('string' == typeof t.canvas) {
        if (((e = this.global.getElementById(t.canvas)), !e))
          throw new Error('canvasId 参数不正确，请确认canvas存在并插入dom');
      } else e = t.canvas;
      let i = t.width,
        n = t.height;
      if (null == i || null == n || !t.canvasControled) {
        const t = e.getBoundingClientRect();
        (i = t.width), (n = t.height);
      }
      let s = t.dpr;
      null == s && (s = e.width / i),
        (this.canvas = new FF({ width: i, height: n, dpr: s, nativeCanvas: e, canvasControled: t.canvasControled }));
    }
    releaseWindow() {}
    resizeWindow(t, e) {}
    setDpr(t) {
      this.canvas.dpr = t;
    }
    getContext() {
      return this.canvas.getContext();
    }
    getNativeHandler() {
      return this.canvas;
    }
    getDpr() {
      return this.canvas.dpr;
    }
    addEventListener(t, e) {
      this.eventManager.addEventListener(t, e);
    }
    removeEventListener(t, e) {
      this.eventManager.removeEventListener(t, e);
    }
    dispatchEvent(t) {
      const { type: e } = t;
      return (
        !!this.eventManager.cache[e] &&
        (t.changedTouches &&
          t.changedTouches[0] &&
          ((t.offsetX = t.changedTouches[0].x),
          (t.changedTouches[0].offsetX = t.changedTouches[0].x),
          (t.changedTouches[0].clientX = t.changedTouches[0].x),
          (t.offsetY = t.changedTouches[0].y),
          (t.changedTouches[0].offsetY = t.changedTouches[0].y),
          (t.changedTouches[0].clientY = t.changedTouches[0].y)),
        (t.preventDefault = () => {}),
        (t.stopPropagation = () => {}),
        this.eventManager.cache[e].listener &&
          this.eventManager.cache[e].listener.forEach(e => {
            e(t);
          }),
        !0)
      );
    }
    getStyle() {
      return {};
    }
    setStyle(t) {}
    getBoundingClientRect() {
      const t = this.getWH();
      return { x: 0, y: 0, width: t.width, height: t.height, left: 0, top: 0, right: 0, bottom: 0 };
    }
    clearViewBox(t, e) {
      const i = this.getContext(),
        n = this.getDpr();
      i.nativeContext.save(),
        i.nativeContext.setTransform(n, 0, 0, n, 0, 0),
        i.clearRect(t.x1, t.y1, t.x2 - t.x1, t.y2 - t.y1),
        e && ((i.fillStyle = e), i.fillRect(t.x1, t.y1, t.x2 - t.x1, t.y2 - t.y1)),
        i.nativeContext.restore();
    }
  };
  (NF.env = 'lynx'), (NF = jF([ZS(), HF(0, tw(dw)), zF('design:paramtypes', [Object])], NF));
  var VF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    WF = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  let GF = class extends BD {
    constructor(t, e) {
      super(t, e);
      const i = t.nativeCanvas.getContext('2d');
      if (!i) throw new Error('发生错误，获取2d上下文失败');
      (this.nativeContext = i),
        (this.canvas = t),
        (this.matrix = new ie(1, 0, 0, 1, 0, 0)),
        (this.stack = []),
        (this.dpr = null != e ? e : 1);
    }
    release() {}
  };
  (GF.env = 'node'), (GF = VF([ZS(), WF('design:paramtypes', [Object, Number])], GF));
  var UF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    YF = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  const $F = { WIDTH: 500, HEIGHT: 500, DPR: 1 };
  let XF = class {
    get id() {
      return this._id;
    }
    get x() {
      return 0;
    }
    set x(t) {}
    get y() {
      return 0;
    }
    set y(t) {}
    get nativeCanvas() {
      return this._nativeCanvas;
    }
    get width() {
      return this._pixelWidth;
    }
    set width(t) {
      (this._pixelWidth = t), (this._displayWidth = t / (this._dpr || 1));
    }
    get displayWidth() {
      return this._pixelWidth / this._dpr;
    }
    get displayHeight() {
      return this._pixelHeight / this._dpr;
    }
    get height() {
      return this._pixelHeight;
    }
    set height(t) {
      (this._pixelHeight = t), (this._displayHeight = t / (this._dpr || 1));
    }
    getContext(t) {
      return this._context;
    }
    get visiable() {
      return this._visiable;
    }
    set visiable(t) {
      (this._visiable = t), t ? this.show() : this.hide();
    }
    get dpr() {
      return this._dpr;
    }
    set dpr(t) {
      (this._dpr = t), this.resize(this.width, this.height);
    }
    constructor(t) {
      const {
        nativeCanvas: e,
        width: i = $F.WIDTH,
        height: n = $F.HEIGHT,
        canvasControled: s = !0,
        dpr: r = $F.DPR
      } = t;
      (this._visiable = !1 !== t.visiable),
        (this.controled = s),
        (this._pixelWidth = i * r),
        (this._pixelHeight = n * r),
        (this._displayWidth = i),
        (this._displayHeight = n),
        (this._nativeCanvas = e),
        (this._context = new GF(this, t.dpr)),
        (this._id = e.id),
        (this._dpr = r);
    }
    applyPosition() {}
    getNativeCanvas() {
      return this._nativeCanvas;
    }
    resetStyle(t) {}
    hide() {}
    show() {}
    resize(t, e) {
      (this._pixelWidth = t * this._dpr),
        (this._pixelHeight = e * this._dpr),
        (this._displayWidth = t),
        (this._displayHeight = e),
        this._nativeCanvas &&
          ((this._nativeCanvas.width = this._pixelWidth), (this._nativeCanvas.height = this._pixelHeight));
    }
    toDataURL(t, e) {
      return '';
    }
    readPixels(t, e, i, n) {
      return this._context.getImageData(t, e, i, n);
    }
    convertToBlob(t) {
      throw new Error('暂未实现');
    }
    transferToImageBitmap() {
      throw new Error('暂未实现');
    }
    release() {
      this._nativeCanvas.release && o(this._nativeCanvas.release) && this._nativeCanvas.release();
    }
  };
  (XF.env = 'node'), (XF = UF([ZS(), YF('design:paramtypes', [Object])], XF));
  var KF = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    qF = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    ZF = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let JF = class extends oF {
    get container() {
      return null;
    }
    constructor(t) {
      super(), (this.global = t), (this.type = 'node');
    }
    getTitle() {
      return '';
    }
    getWH() {
      return { width: this.canvas.displayWidth, height: this.canvas.displayHeight };
    }
    getXY() {
      return { x: 0, y: 0 };
    }
    createWindow(t) {
      t.canvas ? this.createWindowByCanvas(t) : this.createWindowByConfig(t);
    }
    createWindowByConfig(t) {
      const e = this.global.createCanvas({ width: t.width, height: t.height }),
        i = {
          width: t.width,
          height: t.height,
          dpr: t.dpr,
          nativeCanvas: e,
          id: Jk.GenAutoIncrementId().toString(),
          canvasControled: !0
        };
      this.canvas = new XF(i);
    }
    createWindowByCanvas(t) {
      const e = t.canvas;
      let i = t.width,
        n = t.height;
      (null != i && null != n && t.canvasControled) || ((i = e.width), (n = e.height)),
        (this.canvas = new XF({ width: i, height: n, dpr: 1, nativeCanvas: e, canvasControled: t.canvasControled }));
    }
    releaseWindow() {
      this.canvas.release();
    }
    resizeWindow(t, e) {
      this.canvas.resize(t, e);
    }
    setDpr(t) {
      this.canvas.dpr = t;
    }
    getContext() {
      return this.canvas.getContext();
    }
    getNativeHandler() {
      return this.canvas;
    }
    getDpr() {
      return this.canvas.dpr;
    }
    getImageBuffer() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'image/png';
      return this.canvas.nativeCanvas.toBuffer(t);
    }
    addEventListener(t, e, i) {}
    dispatchEvent(t) {
      return !0;
    }
    removeEventListener(t, e, i) {}
    getStyle() {}
    setStyle(t) {}
    getBoundingClientRect() {
      return null;
    }
    clearViewBox(t, e) {}
  };
  (JF.env = 'node'), (JF = KF([ZS(), ZF(0, tw(dw)), qF('design:paramtypes', [Object])], JF));
  var QF = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let tj = class extends BD {
    draw() {}
    createPattern(t, e) {
      return null;
    }
  };
  (tj.env = 'wx'), (tj = QF([ZS()], tj));
  var ej = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    ij = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    };
  const nj = { WIDTH: 500, HEIGHT: 500, DPR: 1 };
  let sj = class {
    get id() {
      return this._id;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x = t;
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y = t;
    }
    get nativeCanvas() {
      return this._nativeCanvas;
    }
    get width() {
      return this._pixelWidth;
    }
    set width(t) {
      (this._pixelWidth = t), (this._displayWidth = t / (this._dpr || 1));
    }
    get height() {
      return this._pixelHeight;
    }
    set height(t) {
      (this._pixelHeight = t), (this._displayHeight = t / (this._dpr || 1));
    }
    get displayWidth() {
      return this._displayWidth;
    }
    get displayHeight() {
      return this._displayHeight;
    }
    getContext(t) {
      return this._context;
    }
    get visiable() {
      return this._visiable;
    }
    set visiable(t) {
      (this._visiable = t), t ? this.show() : this.hide();
    }
    get dpr() {
      return this._dpr;
    }
    set dpr(t) {
      this._dpr = t;
    }
    constructor(t) {
      const { nativeCanvas: e, width: i = nj.WIDTH, height: n = nj.HEIGHT, dpr: s = nj.DPR } = t,
        { x: r, y: a } = e.getBoundingClientRect ? e.getBoundingClientRect() : { x: 0, y: 0 };
      (this._x = r),
        (this._y = a),
        (this._pixelWidth = i * s),
        (this._pixelHeight = n * s),
        (this._visiable = !1 !== t.visiable),
        (this._displayWidth = i),
        (this._displayHeight = n),
        (this._dpr = s),
        (this._nativeCanvas = e),
        (this._context = new tj(this, this._dpr)),
        (this._id = e.id);
    }
    getNativeCanvas() {
      return this._nativeCanvas;
    }
    resetStyle(t) {}
    applyPosition() {}
    hide() {}
    show() {}
    resize(t, e) {}
    toDataURL(t, e) {
      return '';
    }
    readPixels(t, e, i, n) {
      throw new Error('暂未实现');
    }
    convertToBlob(t) {
      throw new Error('暂未实现');
    }
    transferToImageBitmap() {
      throw new Error('暂未实现');
    }
    release() {}
  };
  (sj.env = 'wx'), (sj = ej([ZS(), ij('design:paramtypes', [Object])], sj));
  var rj = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    aj = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    oj = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  class lj {
    constructor() {
      this.cache = {};
    }
    addEventListener(t, e) {
      t && e && ((this.cache[t] = this.cache[t] || { listener: [] }), this.cache[t].listener.push(e));
    }
    removeEventListener(t, e) {
      if (!t || !e) return;
      if (!this.cache[t]) return;
      const i = this.cache[t].listener.findIndex(t => t === e);
      i >= 0 && this.cache[t].listener.splice(i, 1);
    }
    cleanEvent() {
      this.cache = {};
    }
  }
  let hj = class extends oF {
    get container() {
      return null;
    }
    constructor(t) {
      super(), (this.global = t), (this.type = 'wx'), (this.eventManager = new lj());
    }
    getTitle() {
      return this.canvas.id.toString();
    }
    getWH() {
      return { width: this.canvas.width / (this.canvas.dpr || 1), height: this.canvas.height / (this.canvas.dpr || 1) };
    }
    getXY() {
      return { x: 0, y: 0 };
    }
    createWindow(t) {
      t.canvas ? this.createWindowByCanvas(t) : this.createWindowByConfig(t);
    }
    createWindowByConfig(t) {
      const e = this.global.createCanvas({ width: t.width, height: t.height }),
        i = {
          width: t.width,
          height: t.height,
          dpr: t.dpr,
          nativeCanvas: e,
          id: Jk.GenAutoIncrementId().toString(),
          canvasControled: !1
        };
      this.canvas = new sj(i);
    }
    createWindowByCanvas(t) {
      let e;
      if ('string' == typeof t.canvas) {
        if (((e = this.global.getElementById(t.canvas)), !e))
          throw new Error('canvasId 参数不正确，请确认canvas存在并插入dom');
      } else e = t.canvas;
      let i = t.width,
        n = t.height;
      if (null == i || null == n || !t.canvasControled) {
        const t = e.getBoundingClientRect();
        (i = t.width), (n = t.height);
      }
      let s = t.dpr;
      null == s && (s = e.width / i),
        (this.canvas = new sj({ width: i, height: n, dpr: s, nativeCanvas: e, canvasControled: t.canvasControled }));
    }
    releaseWindow() {}
    resizeWindow(t, e) {}
    setDpr(t) {
      this.canvas.dpr = t;
    }
    getContext() {
      return this.canvas.getContext();
    }
    getNativeHandler() {
      return this.canvas;
    }
    getDpr() {
      return this.canvas.dpr;
    }
    addEventListener(t, e) {
      this.eventManager.addEventListener(t, e);
    }
    removeEventListener(t, e) {
      this.eventManager.removeEventListener(t, e);
    }
    dispatchEvent(t) {
      var e, i, n, s;
      const { type: r } = t;
      return (
        !!this.eventManager.cache[r] &&
        (t.changedTouches &&
          t.changedTouches[0] &&
          ((t.offsetX = t.changedTouches[0].x),
          (t.changedTouches[0].offsetX =
            null !== (e = t.changedTouches[0].x) && void 0 !== e ? e : t.changedTouches[0].pageX),
          (t.changedTouches[0].clientX =
            null !== (i = t.changedTouches[0].x) && void 0 !== i ? i : t.changedTouches[0].pageX),
          (t.offsetY = t.changedTouches[0].y),
          (t.changedTouches[0].offsetY =
            null !== (n = t.changedTouches[0].y) && void 0 !== n ? n : t.changedTouches[0].pageY),
          (t.changedTouches[0].clientY =
            null !== (s = t.changedTouches[0].y) && void 0 !== s ? s : t.changedTouches[0].pageY)),
        (t.preventDefault = () => {}),
        (t.stopPropagation = () => {}),
        this.eventManager.cache[r].listener &&
          this.eventManager.cache[r].listener.forEach(e => {
            e(t);
          }),
        !0)
      );
    }
    getStyle() {
      return {};
    }
    setStyle(t) {}
    getBoundingClientRect() {
      const t = this.getWH();
      return { x: 0, y: 0, width: t.width, height: t.height, left: 0, top: 0, right: 0, bottom: 0 };
    }
    clearViewBox(t, e) {
      const i = this.getContext(),
        n = this.getDpr();
      i.nativeContext.save(),
        i.nativeContext.setTransform(n, 0, 0, n, 0, 0),
        i.clearRect(t.x1, t.y1, t.x2 - t.x1, t.y2 - t.y1),
        e && ((i.fillStyle = e), i.fillRect(t.x1, t.y1, t.x2 - t.x1, t.y2 - t.y1)),
        i.nativeContext.restore();
    }
  };
  (hj.env = 'wx'), (hj = rj([ZS(), oj(0, tw(dw)), aj('design:paramtypes', [Object])], hj));
  var cj = new YS(t => {
      t(dF).toSelf(),
        t(eP)
          .toDynamicValue(t => t.container.get(dF))
          .whenTargetNamed(dF.env),
        t(xF).toSelf(),
        t(eP)
          .toDynamicValue(t => t.container.get(xF))
          .whenTargetNamed(xF.env),
        t(RF).toSelf(),
        t(eP)
          .toDynamicValue(t => t.container.get(RF))
          .whenTargetNamed(RF.env),
        t(NF).toSelf(),
        t(eP)
          .toDynamicValue(t => t.container.get(NF))
          .whenTargetNamed(NF.env),
        t(hj).toSelf(),
        t(eP)
          .toDynamicValue(t => t.container.get(hj))
          .whenTargetNamed(hj.env),
        t(JF).toSelf(),
        t(eP)
          .toDynamicValue(t => t.container.get(JF))
          .whenTargetNamed(JF.env);
    }),
    dj = new YS(t => {
      t(nk).toSelf().inSingletonScope(), t(ik).toService(nk), ow(t, ik);
    }),
    uj = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    pj = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    gj = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let fj = class {
    constructor(t) {
      (this.global = t), (this.offscreen = !1);
    }
    setDpr(t) {
      this.canvas.dpr = t;
    }
    init(t, e, i) {
      if (((this.layer = t), (this.window = e), i.main))
        (this.main = !0), (this.context = e.getContext()), (this.canvas = this.context.getCanvas());
      else {
        let t;
        (this.main = !1),
          (t = i.canvasId
            ? this.global.getElementById(i.canvasId)
            : this.global.createCanvas({ width: e.width, height: e.height })),
          t.style && (t.style['pointer-events'] = 'none');
        const n = e.getContext().getCanvas().nativeCanvas,
          s = ok({
            nativeCanvas: t,
            width: e.width,
            height: e.height,
            dpr: e.dpr,
            canvasControled: !0,
            container: e.getContainer(),
            x: n.offsetLeft,
            y: n.offsetTop
          });
        s.applyPosition(), (this.canvas = s), (this.context = s.getContext());
      }
    }
    resize(t, e) {
      this.canvas.resize(t, e);
    }
    resizeView(t, e) {}
    render(t, e, i) {
      var n;
      if (!this.main) {
        const t = this.window.getContext().getCanvas().nativeCanvas;
        !t ||
          (this.canvas.x === t.offsetLeft && this.canvas.y === t.offsetTop) ||
          ((this.canvas.x = t.offsetLeft), (this.canvas.y = t.offsetTop), this.canvas.applyPosition());
      }
      e.renderService.render(
        t,
        Object.assign(
          Object.assign(
            { context: this.context, clear: null !== (n = e.background) && void 0 !== n ? n : '#ffffff' },
            e
          ),
          i
        )
      );
    }
    merge(t) {
      t.forEach(t => {
        const e = t.getContext().canvas.nativeCanvas;
        this.context.drawImage(e, 0, 0);
      });
    }
    prepare(t, e) {}
    drawTo(t, e, i) {
      var n;
      const s = t.getContext();
      i.renderService.render(
        e,
        Object.assign(Object.assign({ context: s }, i), {
          clear: i.clear ? (null !== (n = i.background) && void 0 !== n ? n : '#fff') : void 0
        })
      );
    }
    getContext() {
      return this.context;
    }
    release() {
      this.canvas.release();
    }
  };
  fj = uj([ZS(), gj(0, tw(dw)), pj('design:paramtypes', [Object])], fj);
  var vj = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    mj = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    yj = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let _j = class {
    constructor(t) {
      (this.global = t), (this.offscreen = !0);
    }
    setDpr(t) {
      this.canvas.dpr = t;
    }
    init(t, e, i) {
      this.layer = t;
      const n = ok({
        nativeCanvas: this.global.createOffscreenCanvas({ width: i.width, height: i.height, dpr: e.dpr }),
        width: i.width,
        height: i.height,
        dpr: e.dpr,
        canvasControled: !0
      });
      (this.canvas = n), (this.context = n.getContext());
    }
    resize(t, e) {
      this.canvas.resize(t, e);
    }
    resizeView(t, e) {
      this.canvas.resize(t, e);
    }
    render(t, e) {
      var i;
      e.renderService.render(
        t,
        Object.assign(Object.assign({ context: this.context }, e), {
          x: 0,
          y: 0,
          clear: null !== (i = e.background) && void 0 !== i ? i : '#ffffff'
        })
      );
    }
    prepare(t, e) {}
    release() {
      this.canvas.release();
    }
    getContext() {
      return this.context;
    }
    drawTo(t, e, i) {
      const n = t.getContext(),
        s = t.dpr,
        { x: r = 0, y: a = 0, width: o = this.layer.viewWidth, height: l = this.layer.viewHeight } = i;
      n.nativeContext.save(),
        n.nativeContext.setTransform(s, 0, 0, s, 0, 0),
        i.clear && n.clearRect(r, a, o, l),
        n.drawImage(this.canvas.nativeCanvas, 0, 0, this.canvas.width, this.canvas.height, r, a, o, l),
        n.nativeContext.restore();
    }
    merge(t) {}
  };
  _j = vj([ZS(), yj(0, tw(dw)), mj('design:paramtypes', [Object])], _j);
  var bj = new YS(t => {
    t(fj).toSelf(), t(_j).toSelf(), t(UE).toService(fj);
  });
  var xj = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  const Sj = Symbol.for('DrawItemInterceptor'),
    wj = new Kt();
  let Aj = class {
    constructor() {
      this.order = 1;
    }
    afterDrawItem(t, e, i, n, s) {
      return (t.attribute.shadowRootIdx > 0 || !t.attribute.shadowRootIdx) && this.drawItem(t, e, i, n, s), !1;
    }
    beforeDrawItem(t, e, i, n, s) {
      return t.attribute.shadowRootIdx < 0 && this.drawItem(t, e, i, n, s), !1;
    }
    drawItem(t, e, i, n, s) {
      if (!t.shadowRoot) return !1;
      const { context: r } = i;
      if ((r.highPerformanceSave(), r.transformFromMatrix(t.transMatrix, !0), n.dirtyBounds && n.backupDirtyBounds)) {
        wj.copy(n.dirtyBounds);
        const e = t.globalTransMatrix.getInverse();
        n.dirtyBounds.copy(n.backupDirtyBounds).transformWithMatrix(e);
      }
      return (
        n.renderGroup(t.shadowRoot, i),
        r.highPerformanceRestore(),
        n.dirtyBounds && n.backupDirtyBounds && n.dirtyBounds.copy(wj),
        !0
      );
    }
  };
  Aj = xj([ZS()], Aj);
  let kj = class {
    constructor() {
      this.order = 1;
    }
    beforeDrawItem(t, e, i, n, s) {
      if (!t.in3dMode || i.in3dInterceptor) return !1;
      i.in3dInterceptor = !0;
      const { context: r, stage: a } = e.drawParams;
      r.canvas, r.save(), this.initCanvasCtx(r), (r.camera = a.camera);
      const o = r.currentMatrix;
      (o.a /= r.dpr), (o.b /= r.dpr), (o.c /= r.dpr), (o.d /= r.dpr), (o.e /= r.dpr), (o.f /= r.dpr);
      const l = HO.allocate();
      UO(l, o);
      const h = r.modelMatrix;
      if (h) {
        if (l) {
          const t = HO.allocate();
          r.modelMatrix = YO(t, h, l);
        }
      } else r.modelMatrix = l;
      if ((r.setTransform(1, 0, 0, 1, 0, 0, !0), t.isContainer)) {
        let e = !1,
          s = !1;
        if (
          (t.forEachChildren(t => ((e = t.numberType === AE), !e)), t.forEachChildren(t => ((s = !!t.findFace), !s)), e)
        ) {
          const e = t.getChildren(),
            s = [...e];
          s.sort((t, e) => {
            var i, n, s, r;
            let a =
                ((null !== (i = t.attribute.startAngle) && void 0 !== i ? i : 0) +
                  (null !== (n = t.attribute.endAngle) && void 0 !== n ? n : 0)) /
                2,
              o =
                ((null !== (s = e.attribute.startAngle) && void 0 !== s ? s : 0) +
                  (null !== (r = e.attribute.endAngle) && void 0 !== r ? r : 0)) /
                2;
            for (; a < 0; ) a += Et;
            for (; o < 0; ) o += Et;
            return o - a;
          }),
            s.forEach(t => {
              (t._next = null), (t._prev = null);
            }),
            t.removeAllChild(),
            t.update(),
            s.forEach(e => {
              t.appendChild(e);
            }),
            (i.hack_pieFace = 'outside'),
            n.renderGroup(t, i),
            (i.hack_pieFace = 'inside'),
            n.renderGroup(t, i),
            (i.hack_pieFace = 'top'),
            n.renderGroup(t, i),
            t.removeAllChild(),
            e.forEach(t => {
              (t._next = null), (t._prev = null);
            }),
            e.forEach(e => {
              t.appendChild(e);
            });
        } else if (s) {
          const e = t.getChildren(),
            s = e.map(t => ({
              ave_z: t
                .findFace()
                .vertices.map(e => {
                  var i;
                  return r.view(e[0], e[1], null !== (i = e[2] + t.attribute.z) && void 0 !== i ? i : 0)[2];
                })
                .reduce((t, e) => t + e, 0),
              g: t
            }));
          s.sort((t, e) => e.ave_z - t.ave_z),
            t.removeAllChild(),
            s.forEach(t => {
              (t.g._next = null), (t.g._prev = null);
            }),
            t.update(),
            s.forEach(e => {
              t.add(e.g);
            }),
            n.renderGroup(t, i, !0),
            t.removeAllChild(),
            e.forEach(t => {
              (t._next = null), (t._prev = null);
            }),
            t.update(),
            e.forEach(e => {
              t.add(e);
            });
        } else n.renderGroup(t, i);
      } else n.renderItem(t, i);
      return (
        (r.camera = null),
        r.restore(),
        r.modelMatrix !== h && HO.free(r.modelMatrix),
        (r.modelMatrix = h),
        (i.in3dInterceptor = !1),
        !0
      );
    }
    initCanvasCtx(t) {
      t.setTransformForCurrent();
    }
  };
  kj = xj([ZS()], kj);
  var Mj = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    Tj = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    Cj = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let Ej = class {
    constructor(t, e, i, n) {
      (this.contributions = t),
        (this.renderSelector = e),
        (this.layerService = i),
        (this.drawItemInterceptorContributions = n),
        (this.currentRenderMap = new Map()),
        (this.defaultRenderMap = new Map()),
        (this.styleRenderMap = new Map()),
        (this.dirtyBounds = new Xt()),
        (this.backupDirtyBounds = new Xt());
    }
    init() {
      this.contributions.forEach(t => {
        if (t.style) {
          const e = this.styleRenderMap.get(t.style) || new Map();
          e.set(t.numberType, t), this.styleRenderMap.set(t.style, e);
        } else this.defaultRenderMap.set(t.numberType, t);
      }),
        (this.InterceptorContributions = this.drawItemInterceptorContributions
          .getContributions()
          .sort((t, e) => t.order - e.order));
    }
    draw(t, e) {
      (e.drawContribution = this),
        (this.currentRenderMap = this.styleRenderMap.get(e.renderStyle) || this.defaultRenderMap),
        (this.currentRenderService = t);
      const { context: i, stage: n, x: s = 0, y: r = 0, width: a, height: o } = e;
      if (!i) return;
      const l = this.dirtyBounds.setValue(0, 0, a, o);
      if (n.dirtyBounds && !n.dirtyBounds.empty()) {
        const t = Ce(l, n.dirtyBounds, !1);
        (l.x1 = Math.floor(t.x1)), (l.y1 = Math.floor(t.y1)), (l.x2 = Math.ceil(t.x2)), (l.y2 = Math.ceil(t.y2));
      }
      this.backupDirtyBounds.copy(l), (i.inuse = !0), i.clearMatrix(), i.setTransformForCurrent(!0);
      const h = l.width() * i.dpr !== i.canvas.width || l.height() * i.dpr !== i.canvas.height;
      i.save(),
        i.translate(s, r, !0),
        h && (i.beginPath(), i.rect(l.x1, l.y1, l.width(), l.height()), i.clip()),
        n.camera &&
          (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0),
          this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)),
        this.clearScreen(t, i, e),
        i.save(),
        t.renderTreeRoots
          .sort((t, e) => {
            var i, n;
            return (
              (null !== (i = t.attribute.zIndex) && void 0 !== i ? i : TA.zIndex) -
              (null !== (n = e.attribute.zIndex) && void 0 !== n ? n : TA.zIndex)
            );
          })
          .forEach(t => {
            this.renderGroup(t, e);
          }),
        i.restore(),
        i.restore(),
        i.draw(),
        (i.inuse = !1);
    }
    doRegister() {
      throw new Error('暂不支持');
    }
    _findNextGraphic(t) {
      let e = t.parent,
        i = t._uid;
      for (; e; ) {
        const t = dD(e, i, TA.zIndex);
        if (t) return t;
        (i = e._uid), (e = e.parent);
      }
      return null;
    }
    renderGroup(t, e, i) {
      if (e.break || !1 === t.attribute.visibleAll) return;
      if (t.incremental && (null == e.startAtId || e.startAtId === t._uid))
        return (e.break = !0), void this._increaseRender(t, e);
      if (!Pe(t.AABBBounds, this.dirtyBounds, !1)) return;
      const n = this.dirtyBounds.clone(),
        s = t.globalTransMatrix.getInverse();
      this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(s),
        this.renderItem(t, e, {
          drawingCb: () => {
            var n;
            i
              ? t.forEachChildren(t => {
                  e.break || (t.isContainer ? this.renderGroup(t, e) : this.renderItem(t, e));
                })
              : hD(
                  t,
                  TA.zIndex,
                  t => {
                    e.break || (t.isContainer ? this.renderGroup(t, e) : this.renderItem(t, e));
                  },
                  !1,
                  !!(null === (n = e.context) || void 0 === n ? void 0 : n.camera)
                );
          }
        }),
        this.dirtyBounds.copy(n);
    }
    _increaseRender(t, e) {
      const { layer: i, stage: n } = e,
        { subLayers: s } = i;
      let r = s.get(t._uid);
      r || ((r = { layer: this.layerService.createLayer(n), zIndex: s.size, group: t }), s.set(t._uid, r));
      const a = r.layer.getNativeHandler().getContext(),
        o = r.drawContribution || sk.get(rI);
      o.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0),
        o.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0),
        o.draw(
          this.currentRenderService,
          Object.assign(Object.assign({}, e), {
            drawContribution: o,
            clear: 'transparent',
            layer: r.layer,
            context: a,
            startAtId: t._uid,
            break: !1
          })
        ),
        (r.drawContribution = o);
      const l = this._findNextGraphic(t);
      if (l)
        if (l.isContainer && l.incremental) this._increaseRender(l, e);
        else {
          let t = s.get(l._uid);
          t || ((t = { layer: this.layerService.createLayer(n), zIndex: s.size }), s.set(l._uid, t));
          const i = t.layer.getNativeHandler().getContext();
          this.draw(
            this.currentRenderService,
            Object.assign(Object.assign({}, e), {
              drawContribution: o,
              clear: 'transparent',
              layer: t.layer,
              context: i,
              startAtId: l._uid,
              break: !1
            })
          );
        }
    }
    getRenderContribution(t) {
      let e = this.renderSelector.selector(t);
      return e || (e = this.selectRenderByNumberType(t.numberType)), e || (e = this.selectRenderByType(t.type)), e;
    }
    renderItem(t, e, i) {
      if (this.InterceptorContributions.length)
        for (let n = 0; n < this.InterceptorContributions.length; n++) {
          const s = this.InterceptorContributions[n];
          if (s.beforeDrawItem && s.beforeDrawItem(t, this.currentRenderService, e, this, i)) return;
        }
      const n = this.getRenderContribution(t);
      if (!n) return;
      if (!t.isContainer && !Pe(t.AABBBounds, this.dirtyBounds, !1)) return;
      const s = null != e.startAtId && t._uid !== e.startAtId;
      if (
        (t._uid === e.startAtId && (e.startAtId = null),
        i && (i.skipDraw = s),
        s ? t.isContainer && n.draw(t, this.currentRenderService, e, i) : n.draw(t, this.currentRenderService, e, i),
        this.InterceptorContributions.length)
      )
        for (let i = 0; i < this.InterceptorContributions.length; i++) {
          const n = this.InterceptorContributions[i];
          if (n.afterDrawItem && n.afterDrawItem(t, this.currentRenderService, e, this)) return;
        }
    }
    selectRenderByType(t) {
      return console.warn('未知错误，不应该走到这里'), null;
    }
    selectRenderByNumberType(t) {
      return this.currentRenderMap.get(t) || this.defaultRenderMap.get(t);
    }
    clearScreen(t, e, i) {
      const { clear: n } = i;
      if (n) {
        const t = e.getCanvas(),
          { width: s = t.width, height: r = t.height } = i,
          a = 0,
          o = 0;
        e.clearRect(a, o, s, r),
          (e.fillStyle = MI(e, n, { AABBBounds: { x1: a, y1: o, x2: a + s, y2: o + r } }, 0, 0)),
          e.fillRect(a, o, s, r);
      }
    }
    afterDraw(t, e) {}
  };
  Mj([tw(dw), Tj('design:type', Object)], Ej.prototype, 'global', void 0),
    Mj(
      [sw(), Tj('design:type', Function), Tj('design:paramtypes', []), Tj('design:returntype', void 0)],
      Ej.prototype,
      'init',
      null
    ),
    (Ej = Mj(
      [
        ZS(),
        Cj(0, ew(cI)),
        Cj(1, tw(wI)),
        Cj(2, tw(rP)),
        Cj(3, tw(rw)),
        Cj(3, JS(Sj)),
        Tj('design:paramtypes', [Array, Object, Object, Object])
      ],
      Ej
    ));
  var Pj = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let Rj = class {
    selector(t) {
      return null;
    }
  };
  Rj = Pj([ZS()], Rj);
  var Oj = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    Bj = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    Ij = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let Dj = class {
    constructor(t) {
      (this.groupRenderContribitions = t), (this.numberType = CE);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      const l = Zk(t, null == r ? void 0 : r.theme).group,
        {
          fill: h = l.fill,
          background: c,
          stroke: d = l.stroke,
          opacity: u = l.opacity,
          width: p = l.width,
          height: g = l.height,
          clip: v = l.clip,
          fillOpacity: m = l.fillOpacity,
          strokeOpacity: y = l.strokeOpacity,
          cornerRadius: _ = l.cornerRadius,
          path: b = l.path,
          lineWidth: x = l.lineWidth,
          visible: S = l.visible
        } = t.attribute,
        w = cP(u, m, p, g, h),
        A = uP(u, y, p, g),
        k = oP(h, c),
        M = lP(d, x);
      if (!t.valid || !S) return;
      if (!v) {
        if (!k && !M) return;
        if (!(w || A || a || o || c)) return;
      }
      if (b && b.length && s.drawContribution) {
        const t = e.disableFill,
          i = e.disableStroke,
          n = e.disableBeginPath;
        (e.disableFill = !0),
          (e.disableStroke = !0),
          (e.disableBeginPath = !0),
          b.forEach(t => {
            s.drawContribution.getRenderContribution(t).draw(t, s.renderService, s, r);
          }),
          (e.disableFill = t),
          (e.disableStroke = i),
          (e.disableBeginPath = n);
      } else
        0 === _ || (f(_) && _.every(t => 0 === t))
          ? (e.beginPath(), e.rect(i, n, p, g))
          : (e.beginPath(), OB(e, i, n, p, g, _));
      this._groupRenderContribitions ||
        (this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || []);
      const T = { doFill: k, doStroke: M };
      this._groupRenderContribitions.forEach(r => {
        r.time === Lw.beforeFillStroke && r.drawShape(t, e, i, n, k, M, w, A, l, s, a, o, T);
      }),
        v && e.clip(),
        e.setShadowStyle && e.setShadowStyle(t, t.attribute, l),
        T.doFill && (a ? a(e, t.attribute, l) : w && (e.setCommonStyle(t, t.attribute, i, n, l), e.fill())),
        T.doStroke && (o ? o(e, t.attribute, l) : A && (e.setStrokeStyle(t, t.attribute, i, n, l), e.stroke())),
        this._groupRenderContribitions.forEach(r => {
          r.time === Lw.afterFillStroke && r.drawShape(t, e, i, n, k, M, w, A, l, s, a, o);
        });
    }
    draw(t, e, i, n) {
      const { context: s } = i;
      if (!s) return;
      const { clip: r } = t.attribute;
      r ? s.save() : s.highPerformanceSave();
      const a = Zk(t, null == n ? void 0 : n.theme).group,
        o = s.modelMatrix;
      if (s.camera) {
        const e = HO.allocate(),
          i = HO.allocate();
        $O(i, t, a), YO(e, o || e, i), (s.modelMatrix = e), HO.free(i), s.setTransform(1, 0, 0, 1, 0, 0, !0);
      } else s.transformFromMatrix(t.transMatrix, !0);
      s.beginPath(),
        n.skipDraw
          ? this.drawShape(
              t,
              s,
              0,
              0,
              i,
              n,
              () => !1,
              () => !1
            )
          : this.drawShape(t, s, 0, 0, i);
      const { scrollX: l = a.scrollX, scrollY: h = a.scrollY } = t.attribute;
      let c;
      (l || h) && s.translate(l, h),
        n && n.drawingCb && (c = n.drawingCb()),
        s.modelMatrix !== o && HO.free(s.modelMatrix),
        (s.modelMatrix = o),
        c && c.then
          ? c.then(() => {
              r ? s.restore() : s.highPerformanceRestore();
            })
          : r
          ? s.restore()
          : s.highPerformanceRestore();
    }
  };
  Dj = Oj([ZS(), Ij(0, tw(rw)), Ij(0, JS(wP)), Bj('design:paramtypes', [Object])], Dj);
  var Lj = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let Fj = class extends yB {
    constructor() {
      super(...arguments), (this.numberType = PE);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      if (t.incremental && s.multiGraphicOptions) {
        const { startAtIdx: e, length: r } = s.multiGraphicOptions,
          { segments: l = [] } = t.attribute;
        if (e > l.length) return;
        const h = Zk(t).line,
          {
            fill: c = h.fill,
            stroke: d = h.stroke,
            opacity: u = h.opacity,
            fillOpacity: p = h.fillOpacity,
            strokeOpacity: g = h.strokeOpacity,
            lineWidth: f = h.lineWidth,
            visible: v = h.visible
          } = t.attribute,
          m = hP(u, p, c),
          y = dP(u, g),
          _ = oP(c),
          b = lP(d, f);
        if (!t.valid || !v) return;
        if (!_ && !b) return;
        if (!(m || y || a || o)) return;
        const { context: x } = s;
        for (let s = e; s < e + r; s++)
          this.drawIncreaseSegment(t, x, l[s - 1], l[s], t.attribute.segments[s], [h, t.attribute], i, n);
      } else super.drawShape(t, e, i, n, s, r, a, o);
    }
    drawIncreaseSegment(t, e, i, n, s, r, a, o) {
      n &&
        (e.beginPath(),
        (function (t, e, i, n) {
          const { offsetX: s = 0, offsetY: r = 0 } = n || {},
            a = e ? e.points[e.points.length - 1] : i.points[0];
          t.moveTo(a.x + s, a.y + r),
            i.points.forEach(e => {
              !1 !== e.defined ? t.lineTo(e.x + s, e.y + r) : t.moveTo(e.x + s, e.y + r);
            });
        })(e.nativeContext, i, n, { offsetX: a, offsetY: o }),
        e.setShadowStyle && e.setShadowStyle(t, s, r),
        e.setStrokeStyle(t, s, a, o, r),
        e.stroke());
    }
  };
  Fj = Lj([ZS()], Fj);
  var jj = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let zj = class extends MB {
    constructor() {
      super(...arguments), (this.numberType = kE);
    }
    drawShape(t, e, i, n, s, r, a) {
      if (t.incremental && s.multiGraphicOptions) {
        const { startAtIdx: r, length: o } = s.multiGraphicOptions,
          { segments: l = [] } = t.attribute;
        if (r > l.length) return;
        const h = Zk(t).area,
          {
            fill: c = h.fill,
            fillOpacity: d = h.fillOpacity,
            opacity: u = h.opacity,
            visible: p = h.visible
          } = t.attribute,
          g = hP(u, d, c),
          f = oP(c);
        if (!t.valid || !p) return;
        if (!f) return;
        if (!g && !a) return;
        for (let s = r; s < r + o; s++)
          this.drawIncreaseSegment(t, e, l[s - 1], l[s], t.attribute.segments[s], [h, t.attribute], i, n);
      } else super.drawShape(t, e, i, n, s, r, a);
    }
    drawIncreaseSegment(t, e, i, n, s, r, a, o) {
      n &&
        (e.beginPath(),
        (function (t, e, i, n) {
          const { offsetX: s = 0, offsetY: r = 0 } = n || {},
            { points: a } = i,
            o = [];
          for (let t = 0; t < a.length; t++) a[t].defined;
          o.push(a),
            o.forEach((i, n) => {
              var a, o, l, h;
              const c = e && 0 === n ? e.points[e.points.length - 1] : i[0];
              t.moveTo(c.x + s, c.y + r),
                i.forEach(e => {
                  !1 !== e.defined ? t.lineTo(e.x + s, e.y + r) : t.moveTo(e.x + s, e.y + r);
                });
              for (let e = i.length - 1; e >= 0; e--) {
                const n = i[e];
                t.lineTo(null !== (a = n.x1) && void 0 !== a ? a : n.x, null !== (o = n.y1) && void 0 !== o ? o : n.y);
              }
              t.lineTo(null !== (l = c.x1) && void 0 !== l ? l : c.x, null !== (h = c.y1) && void 0 !== h ? h : c.y),
                t.closePath();
            });
        })(e.camera ? e : e.nativeContext, i, n, { offsetX: a, offsetY: o }),
        e.setShadowStyle && e.setShadowStyle(t, s, r),
        e.setCommonStyle(t, s, a, o, r),
        e.fill());
    }
  };
  zj = jj([ZS()], zj);
  var Hj,
    Nj = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    Vj = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    Wj = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    },
    Gj = function (t, e, i, n) {
      return new (i || (i = Promise))(function (s, r) {
        function a(t) {
          try {
            l(n.next(t));
          } catch (t) {
            r(t);
          }
        }
        function o(t) {
          try {
            l(n.throw(t));
          } catch (t) {
            r(t);
          }
        }
        function l(t) {
          var e;
          t.done
            ? s(t.value)
            : ((e = t.value),
              e instanceof i
                ? e
                : new i(function (t) {
                    t(e);
                  })).then(a, o);
        }
        l((n = n.apply(t, e || [])).next());
      });
    };
  !(function (t) {
    (t[(t.NORMAL = 0)] = 'NORMAL'), (t[(t.STOP = 1)] = 'STOP');
  })(Hj || (Hj = {}));
  let Uj = class extends Ej {
    constructor(t, e, i, n, s, r) {
      super(t, e, s, r),
        (this.contributions = t),
        (this.renderSelector = e),
        (this.lineRender = i),
        (this.areaRender = n),
        (this.layerService = s),
        (this.drawItemInterceptorContributions = r),
        (this.rendering = !1),
        (this.currFrameStartAt = 0),
        (this.currentIdx = 0),
        (this.status = Hj.NORMAL),
        (this.checkingForDrawPromise = null),
        (this.hooks = { completeDraw: new hw([]) });
    }
    init() {
      super.init(),
        this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender),
        this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
    }
    draw(t, e) {
      return Gj(this, void 0, void 0, function* () {
        if (this.checkingForDrawPromise) return;
        (this.lastRenderService = t), (this.lastDrawContext = e), (this.checkingForDrawPromise = this.checkForDraw(e));
        const i = yield this.checkingForDrawPromise;
        if (((this.checkingForDrawPromise = null), i)) return;
        this.currentRenderService = t;
        const { context: n, x: s = 0, y: r = 0 } = e;
        n &&
          ((n.inuse = !0),
          n.clearMatrix(),
          n.setTransformForCurrent(!0),
          n.save(),
          e.restartIncremental && this.clearScreen(this.currentRenderService, n, e),
          n.translate(s, r, !0),
          n.save(),
          t.renderTreeRoots
            .sort((t, e) => {
              var i, n;
              return (
                (null !== (i = t.attribute.zIndex) && void 0 !== i ? i : TA.zIndex) -
                (null !== (n = e.attribute.zIndex) && void 0 !== n ? n : TA.zIndex)
              );
            })
            .forEach(t => {
              this.renderGroup(t, e);
            }),
          this.hooks.completeDraw.tap('top-draw', () => {
            n.restore(), n.restore(), n.draw(), (n.inuse = !1), (this.rendering = !1);
          }));
      });
    }
    _increaseRender(t, e) {
      return Gj(this, void 0, void 0, function* () {
        (this.rendering = !0), yield this._renderIncrementalGroup(t, e);
      });
    }
    _renderIncrementalGroup(t, e) {
      return Gj(this, void 0, void 0, function* () {
        (this.count = t.count),
          yield new Promise(i => {
            this.renderItem(t, e, {
              drawingCb: () =>
                Gj(this, void 0, void 0, function* () {
                  if (2 !== t.count)
                    yield cD(t, TA.zIndex, (i, n) => {
                      if (this.status === Hj.STOP) return !0;
                      if (i.isContainer) return !1;
                      if (n < this.currentIdx) return !1;
                      const s = this.currFrameStartAt + t.incremental;
                      return (
                        n < s && ((this.currentIdx = n + 1), this.renderItem(i, e)),
                        n === s - 1 && ((this.currFrameStartAt = this.currentIdx), this.waitToNextFrame())
                      );
                    }),
                      i(!1);
                  else {
                    const n = t.getChildAt(0);
                    if (n.incremental && n.attribute.segments)
                      for (n.incrementalAt || (n.incrementalAt = 0); n.incrementalAt < n.attribute.segments.length; )
                        (e.multiGraphicOptions = { startAtIdx: n.incrementalAt, length: n.incremental }),
                          this.renderItem(n, e),
                          (n.incrementalAt += n.incremental),
                          yield this.waitToNextFrame();
                    else this.renderItem(n, e);
                    i(!1);
                  }
                })
            });
          }),
          this.hooks.completeDraw.call();
      });
    }
    waitToNextFrame() {
      return Gj(this, void 0, void 0, function* () {
        return new Promise(t => {
          this.global.getRequestAnimationFrame()(() => {
            t(!1);
          });
        });
      });
    }
    checkForDraw(t) {
      return Gj(this, void 0, void 0, function* () {
        let e = this.rendering;
        return t.restartIncremental && ((e = !1), yield this.forceStop(), this.resetToInit()), e;
      });
    }
    forceStop() {
      return Gj(this, void 0, void 0, function* () {
        this.rendering &&
          ((this.status = Hj.STOP),
          yield new Promise(t => {
            this.hooks.completeDraw.tap('stopCb', () => {
              (this.status = Hj.NORMAL),
                (this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter(t => 'stopCb' !== t.name)),
                t(!1);
            });
          }));
      });
    }
    resetToInit() {
      (this.currFrameStartAt = 0), (this.currentIdx = 0);
    }
    renderGroup(t, e) {
      return Gj(this, void 0, void 0, function* () {
        if (!e.break && !1 !== t.attribute.visibleAll)
          return t.incremental && e.startAtId === t._uid
            ? (yield this._increaseRender(t, e), void (e.break = !0))
            : void (yield new Promise(i => {
                this.renderItem(t, e, {
                  drawingCb: () =>
                    Gj(this, void 0, void 0, function* () {
                      yield cD(t, TA.zIndex, t =>
                        Gj(this, void 0, void 0, function* () {
                          e.break || (t.isContainer && (yield this.renderGroup(t, e)));
                        })
                      ),
                        i(!1);
                    })
                });
              }));
      });
    }
  };
  Nj([tw(dw), Vj('design:type', Object)], Uj.prototype, 'global', void 0),
    (Uj = Nj(
      [
        ZS(),
        Wj(0, ew(cI)),
        Wj(1, tw(wI)),
        Wj(2, tw(Fj)),
        Wj(3, tw(zj)),
        Wj(4, tw(rP)),
        Wj(5, tw(rw)),
        Wj(5, JS(Sj)),
        Vj('design:paramtypes', [Array, Object, Object, Object, Object, Object])
      ],
      Uj
    ));
  var Yj = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let $j = class extends gB {
    constructor() {
      super(...arguments), (this.type = 'rect3d'), (this.numberType = DE);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      var l;
      const h = Zk(t, null == r ? void 0 : r.theme).rect3d,
        {
          fill: c = h.fill,
          stroke: d = h.stroke,
          width: u = h.width,
          height: p = h.height,
          opacity: g = h.opacity,
          fillOpacity: f = h.fillOpacity,
          lineWidth: v = h.lineWidth,
          strokeOpacity: m = h.strokeOpacity,
          visible: y = h.visible
        } = t.attribute,
        _ = null !== (l = this.z) && void 0 !== l ? l : 0,
        b = cP(g, f, u, p, c),
        x = uP(g, m, u, p),
        S = oP(c),
        w = lP(d, v);
      if (!t.valid || !y) return;
      if (!S && !w) return;
      if (!(b || x || a || o)) return;
      const { light: A, camera: k } = s.stage || {},
        M = t.findFace();
      if (!1 !== c) {
        e.setCommonStyle(t, t.attribute, i, n, h);
        let s = c;
        'string' != typeof s && (s = 'black'), this.fill(i, n, _, M, s, e, A, a);
      }
      !1 !== d && (e.setStrokeStyle(t, t.attribute, i, n, h), this.stroke(i, n, _, M, e));
    }
    stroke(t, e, i, n, s) {
      const r = n.vertices;
      n.edges.forEach(n => {
        const a = r[n[0]],
          o = { x: t + a[0], y: e + a[1], z: i + a[2] },
          l = r[n[1]],
          h = { x: t + l[0], y: e + l[1], z: i + l[2] };
        s.beginPath(), s.moveTo(o.x, o.y, o.z), s.lineTo(h.x, h.y, h.z), s.stroke();
      });
    }
    fill(t, e, i, n, s, r, a, o) {
      const l = bT.get(s).value,
        h = n.vertices,
        c = h.map(t => r.view(t[0], t[1], t[2])[2]),
        d = [];
      n.polygons.forEach((t, e) => {
        d.push({ faceIdx: e, polygon: t });
        const { polygon: i, normal: n } = t,
          s = c[i[0]],
          r = c[i[1]],
          a = c[i[2]],
          o = c[i[3]];
        t.ave_z = s + r + a + o;
      }),
        d.sort((t, e) => e.polygon.ave_z - t.polygon.ave_z),
        d.forEach(n => {
          const { polygon: c, normal: d } = n.polygon,
            u = h[c[0]],
            p = h[c[1]],
            g = h[c[2]],
            f = h[c[3]],
            v = { x: t + u[0], y: e + u[1], z: i + u[2] },
            m = { x: t + p[0], y: e + p[1], z: i + p[2] },
            y = { x: t + g[0], y: e + g[1], z: i + g[2] },
            _ = { x: t + f[0], y: e + f[1], z: i + f[2] };
          r.beginPath(),
            r.moveTo(v.x, v.y, v.z),
            r.lineTo(m.x, m.y, m.z),
            r.lineTo(y.x, y.y, y.z),
            r.lineTo(_.x, _.y, _.z),
            r.closePath(),
            o ? o(r, null, null) : ((r.fillStyle = a ? a.computeColor(d, l) : s), r.fill());
        });
    }
    draw(t, e, i) {
      const { context: n } = i;
      if (!n) return;
      n.highPerformanceSave();
      const s = Zk(t).rect,
        r = this.transform(t, s, n),
        { x: a, y: o, z: l, lastModelMatrix: h } = r;
      (this.z = l),
        this.drawShape(t, n, a, o, i),
        (this.z = 0),
        n.modelMatrix !== h && HO.free(n.modelMatrix),
        (n.modelMatrix = h),
        n.highPerformanceRestore();
    }
  };
  $j = Yj([ZS()], $j);
  var Xj = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let Kj = class {
    constructor() {
      this.numberType = LE;
    }
    drawShape(t, e, i, n, s) {
      const r = Zk(t).richtext,
        {
          width: a = r.width,
          height: o = r.height,
          opacity: l = r.opacity,
          fillOpacity: h = r.fillOpacity,
          visible: c = r.visible
        } = t.attribute;
      t.valid && c && hP(l, h, !0) && (e.translate(i, n), t.getFrameCache().draw(e, this.drawIcon));
    }
    drawIcon(t, e, i, n, s) {
      var r;
      const a = Zk(t).richtextIcon,
        {
          width: o = a.width,
          height: l = a.height,
          opacity: h = a.opacity,
          image: c,
          backgroundFill: d = a.backgroundFill,
          backgroundFillOpacity: u = a.backgroundFillOpacity,
          backgroundStroke: p = a.backgroundStroke,
          backgroundStrokeOpacity: g = a.backgroundStrokeOpacity,
          backgroundRadius: f = a.backgroundRadius,
          margin: v
        } = t.attribute,
        { backgroundWidth: m = o, backgroundHeight: y = l } = t.attribute;
      if ((v && ((i += t._marginArray[3]), (n += t._marginArray[0])), t._hovered)) {
        const t = (m - o) / 2,
          s = (y - l) / 2;
        0 === f ? (e.beginPath(), e.rect(i - t, n - s, m, y)) : (e.beginPath(), OB(e, i - t, n - s, m, y, f)),
          d && ((e.globalAlpha = u), (e.fillStyle = d), e.fill()),
          p && ((e.globalAlpha = g), (e.strokeStyle = p), e.stroke());
      }
      const _ = c && (null === (r = null == t ? void 0 : t.resources) || void 0 === r ? void 0 : r.get(c));
      _ && 'success' === _.state && ((e.globalAlpha = h), e.drawImage(_.data, i, n, o, l));
    }
    draw(t, e, i) {
      const { context: n } = i;
      if (!n) return;
      n.highPerformanceSave();
      const s = Zk(t).richtext;
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if (t.transMatrix.onlyTranslate()) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      this.drawShape(t, n, r, a, i), n.highPerformanceRestore();
    }
  };
  Kj = Xj([ZS()], Kj);
  var qj = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let Zj = class {
    constructor() {
      this.numberType = TE;
    }
    drawShape(t, e, i, n, s, r, a, o) {
      s.drawContribution &&
        t.getSubGraphic().forEach(t => {
          const l = s.drawContribution.getRenderContribution(t);
          l && l.drawShape && l.drawShape(t, e, i, n, s, r, a, o);
        });
    }
    draw(t, e, i, n) {
      const { context: s } = i;
      if (!s) return;
      if ((s.highPerformanceSave(), !i.drawContribution)) return;
      const r = Zk(t),
        a = t.getSubGraphic();
      a.length &&
        a.forEach(t => {
          i.drawContribution.renderItem(t, i, { theme: r });
        }),
        s.highPerformanceRestore();
    }
  };
  Zj = qj([ZS()], Zj);
  var Jj = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let Qj = class extends gB {
    constructor() {
      super(...arguments), (this.numberType = AE);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      var l;
      const h = Zk(t, null == r ? void 0 : r.theme).arc,
        {
          fill: c = h.fill,
          background: d,
          stroke: u = h.stroke,
          opacity: p = h.opacity,
          fillOpacity: g = h.fillOpacity,
          lineWidth: f = h.lineWidth,
          strokeOpacity: v = h.strokeOpacity,
          visible: m = h.visible
        } = t.attribute,
        y = hP(p, g, c),
        _ = dP(p, v),
        b = oP(c, d),
        x = lP(u, f),
        S = null !== (l = this.z) && void 0 !== l ? l : 0;
      if (!t.valid || !m) return;
      if (!b && !x) return;
      if (!(y || _ || a || o || d)) return;
      const { outerRadius: w = h.outerRadius, innerRadius: A = h.innerRadius, height: k = 10 } = t.attribute,
        M = bT.get(c).value,
        { light: T } = s.stage || {},
        C = s.hack_pieFace,
        E = { top: S, bottom: S + k },
        P = { top: [0, 1, 0], bottom: [0, -1, 0], outside: [1, 0, -1], inside: [1, 0, -1] };
      'bottom' === C || 'top' === C
        ? (e.beginPath(),
          (function (t, e, i, n, s, r, a) {
            const { startAngle: o, endAngle: l } = t.getParsedAngle(),
              h = Pt(l - o),
              c = l > o;
            let d = !1;
            if (r < a) {
              const t = r;
              (r = a), (a = t);
            }
            if (r <= kt) e.moveTo(i, n, s);
            else if (h >= Et - kt)
              e.moveTo(i + r * Ot(o), n + r * Dt(o), s),
                e.arc(i, n, r, o, l, !c, s),
                a > kt && (e.moveTo(i + a * Ot(l), n + a * Dt(l), s), e.arc(i, n, a, l, o, c, s));
            else {
              const {
                  outerDeltaAngle: h,
                  innerDeltaAngle: u,
                  outerStartAngle: p,
                  outerEndAngle: g,
                  innerEndAngle: f,
                  innerStartAngle: v
                } = t.getParsePadAngle(o, l),
                m = r * Ot(p),
                y = r * Dt(p),
                _ = a * Ot(f),
                b = a * Dt(f);
              h < 0.001 ? (d = !0) : (e.moveTo(i + m, n + y, s), e.arc(i, n, r, p, g, !c, s)),
                !(a > kt) || u < 0.001
                  ? (e.lineTo(i + _, n + b, s), (d = !0))
                  : (e.lineTo(i + _, n + b, s), e.arc(i, n, a, f, v, c, s));
            }
            e.closePath();
          })(t, e, i, n, E[C], w, A),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, h),
          b &&
            (a
              ? a(e, t.attribute, h)
              : y &&
                (e.setCommonStyle(t, t.attribute, i, n, h), (e.fillStyle = T ? T.computeColor(P[C], M) : c), e.fill())),
          x && (o ? o(e, t.attribute, h) : _ && (e.setStrokeStyle(t, t.attribute, i, n, h), e.stroke())))
        : ('outside' !== C && 'inside' !== C) ||
          ('inside' === C && (e.save(), e.beginPath(), e.arc(i, n, A, 0, Et, !0, E.top), e.clip()),
          e.beginPath(),
          (function (t, e, i, n, s, r, a, o) {
            const { startAngle: l, endAngle: h } = t.getParsedAngle(),
              c = Pt(h - l),
              d = h > l;
            let u = !1;
            if (a <= kt) e.moveTo(i, n, s);
            else if (c >= Et - kt)
              e.moveTo(i + a * Ot(l), n + a * Dt(l), s),
                e.arc(i, n, a, l, h, !d, s),
                e.lineTo(i + a * Ot(h), n + a * Dt(h), r),
                e.arc(i, n, a, h, l, d, r);
            else {
              const { innerouterDeltaAngle: t, innerouterStartAngle: c, innerouterEndAngle: p } = o(l, h),
                g = a * Ot(c),
                f = a * Dt(c),
                v = a * Ot(p),
                m = a * Dt(p);
              t < 0.001
                ? (u = !0)
                : (e.moveTo(i + g, n + f, s),
                  e.arc(i, n, a, c, p, !d, s),
                  e.lineTo(i + v, n + m, r),
                  e.arc(i, n, a, p, c, d, r));
            }
            e.closePath();
          })(t, e, i, n, E.top, E.bottom, 'outside' === C ? w : A, (e, i) => {
            const {
              outerDeltaAngle: n,
              innerDeltaAngle: s,
              outerStartAngle: r,
              outerEndAngle: a,
              innerEndAngle: o,
              innerStartAngle: l
            } = t.getParsePadAngle(e, i);
            return 'outside' === C
              ? { innerouterDeltaAngle: n, innerouterEndAngle: a, innerouterStartAngle: r }
              : { innerouterDeltaAngle: s, innerouterEndAngle: o, innerouterStartAngle: l };
          }),
          e.setShadowStyle && e.setShadowStyle(t, t.attribute, h),
          b &&
            (a
              ? a(e, t.attribute, h)
              : y &&
                (e.setCommonStyle(t, t.attribute, i, n, h), (e.fillStyle = T ? T.computeColor(P[C], M) : c), e.fill())),
          x && (o ? o(e, t.attribute, h) : _ && (e.setStrokeStyle(t, t.attribute, i, n, h), e.stroke())),
          'inside' === C && e.restore());
    }
    draw(t, e, i, n) {
      const { context: s } = i;
      if (!s) return;
      const r = Zk(t, null == n ? void 0 : n.theme).arc;
      s.save();
      const a = this.transform(t, r, s),
        { x: o, y: l, z: h, lastModelMatrix: c } = a;
      (this.z = h),
        pP(t, s, o, l, 0, n) ||
          (this.drawShape(t, s, o, l, i, n),
          (this.z = 0),
          s.modelMatrix !== c && HO.free(s.modelMatrix),
          (s.modelMatrix = c)),
        s.restore();
    }
  };
  Qj = Jj([ZS()], Qj);
  var tz = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let ez = class extends gB {
    constructor() {
      super(...arguments), (this.type = 'pyramid3d'), (this.numberType = BE);
    }
    drawShape(t, e, i, n, s, r, a, o) {
      var l;
      const h = Zk(t, null == r ? void 0 : r.theme).polygon,
        {
          fill: c = h.fill,
          stroke: d = h.stroke,
          opacity: u = h.opacity,
          fillOpacity: p = h.fillOpacity,
          lineWidth: g = h.lineWidth,
          strokeOpacity: f = h.strokeOpacity,
          visible: v = h.visible,
          points: m,
          face: y = [!0, !0, !0, !0, !0, !0]
        } = t.attribute,
        _ = null !== (l = this.z) && void 0 !== l ? l : 0,
        b = hP(u, p, c),
        x = dP(u, f),
        S = oP(c),
        w = lP(d, g);
      if (!t.valid || !v || 4 !== m.length) return;
      if (!S && !w) return;
      if (!(b || x || a || o)) return;
      const { light: A, camera: k } = s.stage || {},
        M = t.findFace();
      if (!1 !== c) {
        e.setCommonStyle(t, t.attribute, i, n, h);
        let s = c;
        'string' != typeof s && (s = 'black'), this.fill(i, n, _, M, y, s, e, A, k, t, h, a);
      }
      !1 !== d && (e.setStrokeStyle(t, t.attribute, i, n, h), this.stroke(i, n, _, M, e));
    }
    stroke(t, e, i, n, s) {
      const r = n.vertices;
      n.edges.forEach(n => {
        const a = r[n[0]],
          o = r[n[1]],
          l = { x: t + a[0], y: e + a[1], z: i + a[2] },
          h = { x: t + o[0], y: e + o[1], z: i + o[2] };
        s.beginPath(), s.moveTo(l.x, l.y, l.z), s.lineTo(h.x, h.y, h.z), s.stroke();
      });
    }
    fill(t, e, i, n, s, r, a, o, l, h, c, d) {
      const u = bT.get(r).value,
        p = n.vertices,
        g = p.map(t => a.view(t[0], t[1], t[2])[2]),
        f = [];
      n.polygons.forEach((t, e) => {
        if (!s[e]) return;
        f.push({ faceIdx: e, polygon: t });
        const { polygon: i, normal: n } = t,
          r = g[i[0]],
          a = g[i[1]],
          o = g[i[2]],
          l = g[i[3]];
        t.ave_z = r + a + o + l;
      }),
        f.sort((t, e) => e.polygon.ave_z - t.polygon.ave_z),
        f.forEach(n => {
          const { polygon: s, normal: l } = n.polygon,
            g = p[s[0]],
            f = p[s[1]],
            v = p[s[2]],
            m = p[s[3]],
            y = { x: t + g[0], y: e + g[1], z: i + g[2] },
            _ = { x: t + f[0], y: e + f[1], z: i + f[2] },
            b = { x: t + v[0], y: e + v[1], z: i + v[2] },
            x = { x: t + m[0], y: e + m[1], z: i + m[2] };
          a.beginPath(),
            a.moveTo(y.x, y.y, y.z),
            a.lineTo(_.x, _.y, _.z),
            a.lineTo(b.x, b.y, b.z),
            a.lineTo(x.x, x.y, x.z),
            a.closePath(),
            d ? d(a, h.attribute, c) : ((a.fillStyle = o ? o.computeColor(l, u) : r), a.fill());
        });
    }
    draw(t, e, i) {
      const { context: n } = i;
      if (!n) return;
      n.highPerformanceSave();
      const s = Zk(t).polygon,
        r = this.transform(t, s, n),
        { x: a, y: o, z: l, lastModelMatrix: h } = r;
      (this.z = l),
        this.drawShape(t, n, a, o, i),
        (this.z = 0),
        n.modelMatrix !== h && HO.free(n.modelMatrix),
        (n.modelMatrix = h),
        n.highPerformanceRestore();
    }
  };
  ez = tz([ZS()], ez);
  var iz = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let nz = class extends RI {
    constructor() {
      super(...arguments), (this.time = Lw.beforeFillStroke);
    }
  };
  nz = iz([ZS()], nz);
  let sz = class extends BI {
    constructor() {
      super(...arguments), (this.time = Lw.afterFillStroke);
    }
  };
  sz = iz([ZS()], sz);
  var rz = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let az = class extends RI {
    constructor() {
      super(...arguments), (this.time = Lw.beforeFillStroke);
    }
  };
  az = rz([ZS()], az);
  let oz = class extends BI {
    constructor() {
      super(...arguments), (this.time = Lw.afterFillStroke);
    }
  };
  oz = rz([ZS()], oz);
  var lz = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let hz = class extends RI {
    constructor() {
      super(...arguments), (this.time = Lw.beforeFillStroke);
    }
  };
  hz = lz([ZS()], hz);
  let cz = class extends BI {
    constructor() {
      super(...arguments), (this.time = Lw.afterFillStroke);
    }
    drawShape(t, e, i, n, s, r, a, o, l, h, c, d, u) {
      var p, g, f, v;
      this.textureMap || this.initTextureMap(e, t.stage);
      const { attribute: m = t.attribute } = u || {},
        {
          texture: y = null !== (p = t.attribute.texture) && void 0 !== p ? p : VM(l, 'texture'),
          textureColor: _ = null !== (g = t.attribute.textureColor) && void 0 !== g ? g : VM(l, 'textureColor'),
          textureSize: b = null !== (f = t.attribute.textureSize) && void 0 !== f ? f : VM(l, 'textureSize'),
          texturePadding: x = null !== (v = t.attribute.texturePadding) && void 0 !== v ? v : VM(l, 'texturePadding')
        } = m;
      if (!y) return;
      let S = this.textureMap.get(y);
      if (!S)
        switch (y) {
          case 'circle':
            S = this.createCirclePattern(b, x, _, e);
            break;
          case 'diamond':
            S = this.createDiamondPattern(b, x, _, e);
            break;
          case 'rect':
            S = this.createRectPattern(b, x, _, e);
            break;
          case 'vertical-line':
            S = this.createVerticalLinePattern(b, x, _, e);
            break;
          case 'horizontal-line':
            S = this.createHorizontalLinePattern(b, x, _, e);
            break;
          case 'bias-lr':
            S = this.createBiasLRLinePattern(b, x, _, e);
            break;
          case 'bias-rl':
            S = this.createBiasRLLinePattern(b, x, _, e);
            break;
          case 'grid':
            S = this.createGridPattern(b, x, _, e);
        }
      S &&
        (e.highPerformanceSave(),
        e.setCommonStyle(t, t.attribute, i, n, l),
        (e.fillStyle = S),
        e.fill(),
        e.highPerformanceRestore());
    }
  };
  cz = lz([ZS()], cz);
  var dz = new YS(t => {
    t(Ej).toSelf(),
      t(AI).toService(Ej),
      t(Uj).toSelf(),
      t(rI).toService(Uj),
      t(Rj).toSelf(),
      t(wI).toService(Rj),
      t(jP).toSelf().inSingletonScope(),
      t(hI).to(jP),
      t(cI).to(jP),
      t(zI).toSelf().inSingletonScope(),
      t(HI).toSelf().inSingletonScope(),
      t(NI).toSelf().inSingletonScope(),
      t(SP).toService(zI),
      t(SP).toService(HI),
      t(SP).toService(NI),
      ow(t, SP),
      t(LB).toSelf().inSingletonScope(),
      t(fI).to(LB),
      t(cI).to(LB),
      t($j).toSelf().inSingletonScope(),
      t(vI).toService($j),
      t(cI).toService(vI),
      t($I).toSelf().inSingletonScope(),
      t(XI).toSelf().inSingletonScope(),
      t(KI).toSelf().inSingletonScope(),
      t(qI).toSelf().inSingletonScope(),
      t(ZI).toSelf().inSingletonScope(),
      t(TP).toService($I),
      t(TP).toService(XI),
      t(TP).toService(KI),
      t(TP).toService(qI),
      t(TP).toService(ZI),
      ow(t, TP),
      t(GB).toSelf().inSingletonScope(),
      t(yI).to(GB),
      t(cI).to(GB),
      ow(t, EP),
      t(PB).toSelf().inSingletonScope(),
      t(pI).to(PB),
      t(cI).to(PB),
      t(az).toSelf().inSingletonScope(),
      t(oz).toSelf().inSingletonScope(),
      t(kP).toService(az),
      t(kP).toService(oz),
      ow(t, kP),
      t(HB).toSelf().inSingletonScope(),
      t(mI).to(HB),
      t(cI).to(HB),
      t(QI).toSelf().inSingletonScope(),
      t(tD).toSelf().inSingletonScope(),
      t(eD).toSelf().inSingletonScope(),
      t(CP).toService(QI),
      t(CP).toService(tD),
      t(CP).toService(eD),
      ow(t, CP),
      t(IP).toSelf().inSingletonScope(),
      t(aI).to(IP),
      t(cI).to(IP),
      t(Qj).toSelf().inSingletonScope(),
      t(oI).toService(Qj),
      t(cI).toService(oI),
      t(DI).toSelf().inSingletonScope(),
      t(LI).toSelf().inSingletonScope(),
      t(FI).toSelf().inSingletonScope(),
      t(bP).toService(DI),
      t(bP).toService(LI),
      t(bP).toService(FI),
      ow(t, bP),
      t(yB).toSelf().inSingletonScope(),
      t(uI).to(yB),
      t(cI).to(yB),
      t(Fj).toSelf().inSingletonScope(),
      t(zj).toSelf().inSingletonScope(),
      t(MB).toSelf().inSingletonScope(),
      t(lI).to(MB),
      t(cI).to(MB),
      t(hz).toSelf().inSingletonScope(),
      t(cz).toSelf().inSingletonScope(),
      t(xP).toService(hz),
      t(xP).toService(cz),
      ow(t, xP),
      t(Dj).toSelf().inSingletonScope(),
      t(dI).to(Dj),
      t(cI).to(Dj),
      t(WI).toSelf().inSingletonScope(),
      t(wP).toService(WI),
      ow(t, wP),
      t(QB).toSelf().inSingletonScope(),
      t(gI).to(QB),
      t(cI).to(QB),
      t(nz).toSelf().inSingletonScope(),
      t(sz).toSelf().inSingletonScope(),
      t(MP).toService(nz),
      t(MP).toService(sz),
      ow(t, MP),
      t(Zj).toSelf().inSingletonScope(),
      t(xI).toService(Zj),
      t(cI).toService(xI),
      t(sI).toSelf().inSingletonScope(),
      t(SI).toService(sI),
      t(cI).toService(SI),
      t(UI).toSelf().inSingletonScope(),
      t(AP).toService(UI),
      ow(t, AP),
      t(Kj).toSelf().inSingletonScope(),
      t(_I).toService(Kj),
      t(cI).toService(_I),
      t(ez).toSelf().inSingletonScope(),
      t(bI).toService(ez),
      t(cI).toService(bI),
      t(OI).toSelf().inSingletonScope(),
      t(EP).toService(OI),
      t(bP).toService(OI),
      t(kP).toService(OI),
      t(CP).toService(OI),
      t(TP).toService(OI),
      t(AP).toService(OI),
      t(SP).toService(OI),
      t(xP).toService(OI),
      t(MP).toService(OI),
      ow(t, PP),
      ow(t, cI),
      t(Aj).toSelf().inSingletonScope(),
      t(Sj).toService(Aj),
      t(kj).toSelf().inSingletonScope(),
      t(Sj).toService(kj),
      ow(t, Sj);
  });
  var uz = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    pz = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    gz = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let fz = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'circle'), (this.numberType = ME);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).circle;
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if ((n.highPerformanceSave(), t.transMatrix.onlyTranslate())) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      let o = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          r,
          a,
          {},
          null,
          (t, i, n) => !!o || ((o = t.isPointInPath(e.x, e.y)), o),
          (t, i, s) => {
            if (o) return !0;
            const r = i.lineWidth || s.lineWidth;
            return (n.lineWidth = kI(n, r, n.dpr)), (o = t.isPointInStroke(e.x, e.y)), o;
          }
        ),
        n.highPerformanceRestore(),
        o
      );
    }
  };
  fz = uz([ZS(), gz(0, tw(hI)), pz('design:paramtypes', [Object])], fz);
  var vz = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    mz = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    yz = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  const _z = new Kt();
  let bz = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'rect'), (this.numberType = IE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).rect,
        { cornerRadius: r = s.cornerRadius } = t.attribute;
      let { x: a = s.x, y: o = s.y } = t.attribute;
      n.highPerformanceSave();
      let l = !0;
      if (t.transMatrix.onlyTranslate()) {
        const e = t.getOffsetXY(s);
        (a += e.x), (o += e.y), n.setTransformForCurrent();
      } else (a = 0), (o = 0), (l = !1), n.transformFromMatrix(t.transMatrix, !0);
      let h = !0;
      if (!l || (y(r, !0) && 0 !== r) || (f(r) && r.some(t => 0 !== t)))
        (h = !1),
          this.canvasRenderer.drawShape(
            t,
            n,
            a,
            o,
            {},
            null,
            (t, i, n) => !!h || ((h = t.isPointInPath(e.x, e.y)), h),
            (t, i, s) => {
              if (h) return !0;
              const r = i.lineWidth || s.lineWidth;
              return (n.lineWidth = kI(n, r, n.dpr)), (h = t.isPointInStroke(e.x, e.y)), h;
            }
          );
      else if (h) {
        const { fill: i = s.fill, stroke: n = s.stroke, lineWidth: r = s.lineWidth } = t.attribute;
        if (i) h = !0;
        else if (n) {
          const i = t.AABBBounds;
          _z.setValue(i.x1, i.y1, i.x2, i.y2), _z.expand(-r / 2), (h = !_z.containsPoint(e));
        }
      }
      return n.highPerformanceRestore(), h;
    }
  };
  bz = vz([ZS(), yz(0, tw(fI)), mz('design:paramtypes', [Object])], bz);
  var xz = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    Sz = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    wz = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let Az = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'arc'), (this.numberType = wE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).arc;
      n.highPerformanceSave();
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if (t.transMatrix.onlyTranslate()) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      let o = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          r,
          a,
          {},
          null,
          (t, i, n) => !!o || ((o = t.isPointInPath(e.x, e.y)), o),
          (t, i, s) => {
            if (o) return !0;
            const r = i.lineWidth || s.lineWidth;
            return (n.lineWidth = kI(n, r, n.dpr)), (o = t.isPointInStroke(e.x, e.y)), o;
          }
        ),
        n.highPerformanceRestore(),
        o
      );
    }
  };
  Az = xz([ZS(), wz(0, tw(aI)), Sz('design:paramtypes', [Object])], Az);
  var kz = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    Mz = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    Tz = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let Cz = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'area'), (this.numberType = kE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).area;
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if ((n.highPerformanceSave(), t.transMatrix.onlyTranslate())) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      let o = !1;
      return (
        this.canvasRenderer.drawShape(t, n, r, a, {}, null, t => !!o || ((o = t.isPointInPath(e.x, e.y)), o)),
        n.highPerformanceRestore(),
        o
      );
    }
  };
  Cz = kz([ZS(), Tz(0, tw(lI)), Mz('design:paramtypes', [Object])], Cz);
  var Ez = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let Pz = class {
    constructor() {
      (this.type = 'image'), (this.numberType = EE);
    }
    contains(t, e, i) {
      const { pickContext: n } = null != i ? i : {};
      return !!n && !!t.AABBBounds.containsPoint(e);
    }
  };
  Pz = Ez([ZS()], Pz);
  var Rz = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let Oz = class extends gB {};
  Oz = Rz([ZS()], Oz);
  var Bz = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    Iz = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    Dz = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let Lz = class extends Oz {
    constructor(t) {
      super(), (this.canvasRenderer = t), (this.type = 'line'), (this.numberType = PE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      n.highPerformanceSave();
      const s = Zk(t).line,
        r = this.transform(t, s, n),
        { x: a, y: o, z: l, lastModelMatrix: h } = r;
      let c = e;
      if (n.camera) {
        c = e.clone();
        const i = t.parent.globalTransMatrix;
        (c.x = i.a * e.x + i.c * e.y + i.e), (c.y = i.b * e.x + i.d * e.y + i.f);
      }
      this.canvasRenderer.z = l;
      let d = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          a,
          o,
          {},
          null,
          t => !!d || ((d = t.isPointInPath(c.x, c.y)), d),
          (t, e, i) => {
            if (d) return !0;
            const s = e.lineWidth || i.lineWidth;
            return (n.lineWidth = kI(n, s, n.dpr)), (d = t.isPointInStroke(c.x, c.y)), d;
          }
        ),
        (this.canvasRenderer.z = 0),
        n.modelMatrix !== h && HO.free(n.modelMatrix),
        (n.modelMatrix = h),
        n.highPerformanceRestore(),
        d
      );
    }
  };
  Lz = Bz([ZS(), Dz(0, tw(uI)), Iz('design:paramtypes', [Object])], Lz);
  var Fz = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    jz = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    zz = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let Hz = class extends Oz {
    constructor(t) {
      super(), (this.canvasRenderer = t), (this.type = 'path'), (this.numberType = RE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).path;
      n.highPerformanceSave();
      const r = this.transform(t, s, n),
        { x: a, y: o, z: l, lastModelMatrix: h } = r;
      let c = e;
      if (n.camera) {
        c = e.clone();
        const i = t.parent.globalTransMatrix;
        (c.x = i.a * e.x + i.c * e.y + i.e), (c.y = i.b * e.x + i.d * e.y + i.f);
      }
      this.canvasRenderer.z = l;
      let d = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          a,
          o,
          {},
          null,
          (t, e, i) => !!d || ((d = t.isPointInPath(c.x, c.y)), d),
          (t, e, i) => {
            if (d) return !0;
            const s = e.lineWidth || i.lineWidth;
            return (n.lineWidth = kI(n, s, n.dpr)), (d = t.isPointInStroke(c.x, c.y)), d;
          }
        ),
        (this.canvasRenderer.z = 0),
        n.modelMatrix !== h && HO.free(n.modelMatrix),
        (n.modelMatrix = h),
        n.highPerformanceRestore(),
        d
      );
    }
  };
  Hz = Fz([ZS(), zz(0, tw(pI)), jz('design:paramtypes', [Object])], Hz);
  var Nz = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    Vz = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    Wz = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  iB({});
  let Gz = class extends Oz {
    constructor(t) {
      super(), (this.canvasRenderer = t), (this.type = 'symbol'), (this.numberType = FE);
    }
    contains(t, e, i) {
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = t.getParsedPath();
      if (!n.camera) {
        if (!t.AABBBounds.containsPoint(e)) return !1;
        if (s.isSvg || 'imprecise' === t.attribute.pickMode) return !0;
      }
      n.highPerformanceSave();
      const r = Zk(t).symbol,
        a = this.transform(t, r, n),
        { x: o, y: l, z: h, lastModelMatrix: c } = a;
      let d = e;
      if (n.camera) {
        d = e.clone();
        const i = t.parent.globalTransMatrix;
        (d.x = i.a * e.x + i.c * e.y + i.e), (d.y = i.b * e.x + i.d * e.y + i.f);
      }
      this.canvasRenderer.z = h;
      let u = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          o,
          l,
          {},
          null,
          (t, e, i) => !!u || ((u = t.isPointInPath(d.x, d.y)), u),
          (t, e, i) => {
            if (u) return !0;
            const s = e.lineWidth || i.lineWidth;
            return (n.lineWidth = kI(n, s, n.dpr)), (u = t.isPointInStroke(d.x, d.y)), u;
          }
        ),
        (this.canvasRenderer.z = 0),
        n.modelMatrix !== c && HO.free(n.modelMatrix),
        (n.modelMatrix = c),
        n.highPerformanceRestore(),
        u
      );
    }
  };
  Gz = Nz([ZS(), Wz(0, tw(mI)), Vz('design:paramtypes', [Object])], Gz);
  var Uz = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    Yz = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    $z = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let Xz = class extends Oz {
    constructor(t) {
      super(), (this.canvasRenderer = t), (this.type = 'text'), (this.numberType = jE);
    }
    contains(t, e, i) {
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = t.AABBBounds;
      if (!n.camera) return !!s.containsPoint(e);
      n.highPerformanceSave();
      const r = Zk(t).text,
        { keepDirIn3d: a = r.keepDirIn3d } = t.attribute,
        o = !a,
        l = this.transform(t, r, n, o),
        { x: h, y: c, z: d, lastModelMatrix: u } = l;
      this.canvasRenderer.z = d;
      let p = e;
      if (n.camera) {
        p = e.clone();
        const i = t.parent.globalTransMatrix;
        (p.x = i.a * e.x + i.c * e.y + i.e), (p.y = i.b * e.x + i.d * e.y + i.f);
      }
      let g = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          h,
          c,
          {},
          null,
          (e, i, n) => {
            if (g) return !0;
            const {
                fontSize: s = r.fontSize,
                textBaseline: a = r.textBaseline,
                textAlign: o = r.textAlign
              } = t.attribute,
              l = t.AABBBounds,
              u = l.height(),
              f = l.width(),
              v = WP(a, u, s),
              m = VP(o, f);
            return e.rect(m + h, v + c, f, u, d), (g = e.isPointInPath(p.x, p.y)), g;
          },
          (t, e, i) => g
        ),
        (this.canvasRenderer.z = 0),
        n.modelMatrix !== u && HO.free(n.modelMatrix),
        (n.modelMatrix = u),
        n.highPerformanceRestore(),
        g
      );
    }
  };
  Xz = Uz([ZS(), $z(0, tw(yI)), Yz('design:paramtypes', [Object])], Xz);
  var Kz = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    qz = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    Zz = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let Jz = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'polygon'), (this.numberType = OE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.contains(e.x, e.y)) return !1;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).polygon;
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if ((n.highPerformanceSave(), t.transMatrix.onlyTranslate())) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      let o = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          r,
          a,
          {},
          null,
          (t, i, n) => !!o || ((o = t.isPointInPath(e.x, e.y)), o),
          (t, i, s) => {
            if (o) return !0;
            const r = i.lineWidth || s.lineWidth;
            return (n.lineWidth = r), (o = t.isPointInStroke(e.x, e.y)), o;
          }
        ),
        n.highPerformanceRestore(),
        o
      );
    }
  };
  Jz = Kz([ZS(), Zz(0, tw(gI)), qz('design:paramtypes', [Object])], Jz);
  var Qz = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    tH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    eH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  new Kt();
  let iH = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'richtext'), (this.numberType = LE);
    }
    contains(t, e, i) {
      return !!t.AABBBounds.containsPoint(e);
    }
  };
  iH = Qz([ZS(), eH(0, tw(_I)), tH('design:paramtypes', [Object])], iH);
  var nH = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    sH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    rH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let aH = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'glyph'), (this.numberType = TE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = null == i ? void 0 : i.pickerService;
      if (s) {
        let n = !1;
        return (
          t.getSubGraphic().forEach(t => {
            n || (n = !!s.pickItem(t, e, null, i));
          }),
          n
        );
      }
      return !1;
    }
  };
  aH = nH([ZS(), rH(0, tw(xI)), sH('design:paramtypes', [Object])], aH);
  var oH = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    lH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    hH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  new Kt();
  let cH = class extends Oz {
    constructor(t) {
      super(), (this.canvasRenderer = t), (this.type = 'rect3d'), (this.numberType = DE);
    }
    contains(t, e, i) {
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).rect;
      n.highPerformanceSave();
      const r = this.transform(t, s, n),
        { x: a, y: o, z: l, lastModelMatrix: h } = r;
      let c = e;
      if (n.camera) {
        c = e.clone();
        const i = t.parent.globalTransMatrix;
        (c.x = i.a * e.x + i.c * e.y + i.e), (c.y = i.b * e.x + i.d * e.y + i.f);
      }
      this.canvasRenderer.z = l;
      let d = !1;
      return (
        this.canvasRenderer.drawShape(t, n, a, o, i, null, (t, e, i) => !!d || ((d = t.isPointInPath(c.x, c.y)), d)),
        (this.canvasRenderer.z = 0),
        n.modelMatrix !== h && HO.free(n.modelMatrix),
        (n.modelMatrix = h),
        n.highPerformanceRestore(),
        d
      );
    }
  };
  cH = oH([ZS(), hH(0, tw(vI)), lH('design:paramtypes', [Object])], cH);
  var dH = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    uH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    pH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  new Kt();
  let gH = class extends Oz {
    constructor(t) {
      super(), (this.canvasRenderer = t), (this.type = 'pyramid3d'), (this.numberType = BE);
    }
    contains(t, e, i) {
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).polygon;
      n.highPerformanceSave();
      const r = this.transform(t, s, n),
        { x: a, y: o, z: l, lastModelMatrix: h } = r;
      let c = e;
      if (n.camera) {
        c = e.clone();
        const i = t.parent.globalTransMatrix;
        (c.x = i.a * e.x + i.c * e.y + i.e), (c.y = i.b * e.x + i.d * e.y + i.f);
      }
      this.canvasRenderer.z = l;
      let d = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          a,
          o,
          {},
          null,
          (t, e, i) => !!d || ((d = t.isPointInPath(c.x, c.y)), d),
          (t, e, i) => !1
        ),
        (this.canvasRenderer.z = 0),
        n.modelMatrix !== h && HO.free(n.modelMatrix),
        (n.modelMatrix = h),
        n.highPerformanceRestore(),
        d
      );
    }
  };
  gH = dH([ZS(), pH(0, tw(bI)), uH('design:paramtypes', [Object])], gH);
  var fH = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    vH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    mH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  new Kt();
  let yH = class extends Oz {
    constructor(t) {
      super(), (this.canvasRenderer = t), (this.type = 'arc3d'), (this.numberType = AE);
    }
    contains(t, e, i) {
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).arc;
      n.highPerformanceSave();
      const r = this.transform(t, s, n),
        { x: a, y: o, z: l, lastModelMatrix: h } = r;
      let c = e;
      if (n.camera) {
        c = e.clone();
        const i = t.parent.globalTransMatrix;
        (c.x = i.a * e.x + i.c * e.y + i.e), (c.y = i.b * e.x + i.d * e.y + i.f);
      }
      this.canvasRenderer.z = l;
      let d = !1;
      return (
        this.canvasRenderer.drawShape(t, n, a, o, i, null, (t, e, i) => !!d || ((d = t.isPointInPath(c.x, c.y)), d)),
        (this.canvasRenderer.z = 0),
        n.modelMatrix !== h && HO.free(n.modelMatrix),
        (n.modelMatrix = h),
        n.highPerformanceRestore(),
        d
      );
    }
  };
  yH = fH([ZS(), mH(0, tw(oI)), vH('design:paramtypes', [Object])], yH);
  var _H = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let bH = class {
    constructor() {
      (this.type = 'group'), (this.numberType = CE);
    }
    contains(t, e, i) {
      return !1;
    }
  };
  bH = _H([ZS()], bH);
  var xH = new YS((t, e, i, n) => {
      t(fz).toSelf().inSingletonScope(),
        t(ND).toService(fz),
        t(tL).toService(ND),
        t(bz).toSelf().inSingletonScope(),
        t(UD).toService(bz),
        t(tL).toService(UD),
        t(cH).toSelf().inSingletonScope(),
        t(YD).toService(cH),
        t(tL).toService(YD),
        t(Az).toSelf().inSingletonScope(),
        t(jD).toService(Az),
        t(tL).toService(jD),
        t(Cz).toSelf().inSingletonScope(),
        t(HD).toService(Cz),
        t(tL).toService(HD),
        t(Pz).toSelf().inSingletonScope(),
        t(VD).toService(Pz),
        t(tL).toService(VD),
        t(Lz).toSelf().inSingletonScope(),
        t(WD).toService(Lz),
        t(tL).toService(WD),
        t(Hz).toSelf().inSingletonScope(),
        t(GD).toService(Hz),
        t(tL).toService(GD),
        t(Gz).toSelf().inSingletonScope(),
        t($D).toService(Gz),
        t(tL).toService($D),
        t(Xz).toSelf().inSingletonScope(),
        t(XD).toService(Xz),
        t(tL).toService(XD),
        t(Jz).toSelf().inSingletonScope(),
        t(KD).toService(Jz),
        t(tL).toService(KD),
        t(gH).toSelf().inSingletonScope(),
        t(qD).toService(gH),
        t(tL).toService(qD),
        t(yH).toSelf().inSingletonScope(),
        t(zD).toService(yH),
        t(tL).toService(zD),
        t(iH).toSelf().inSingletonScope(),
        t(ZD).toService(iH),
        t(tL).toService(ZD),
        t(aH).toSelf().inSingletonScope(),
        t(JD).toService(aH),
        t(tL).toService(JD),
        t(bH).toSelf().inSingletonScope(),
        t(QD).toService(bH),
        t(tL).toService(QD),
        ow(t, tL);
    }),
    SH = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    wH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    AH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let kH = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'path'), (this.numberType = RE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).path;
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if ((n.highPerformanceSave(), t.transMatrix.onlyTranslate())) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      let o = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          r,
          a,
          {},
          null,
          (t, i, n) => !!o || ((o = t.isPointInPath(e.x, e.y)), o),
          (t, i, s) => {
            if (o) return !0;
            const r = i.lineWidth || s.lineWidth;
            return (n.lineWidth = r), (o = t.isPointInStroke(e.x, e.y)), o;
          }
        ),
        n.highPerformanceRestore(),
        o
      );
    }
  };
  kH = SH([ZS(), AH(0, tw(pI)), wH('design:paramtypes', [Object])], kH);
  var MH = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    TH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    CH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let EH = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'circle'), (this.numberType = ME);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).circle;
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if ((n.highPerformanceSave(), t.transMatrix.onlyTranslate())) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      let o = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          r,
          a,
          {},
          null,
          (t, i, n) => !!o || ((o = t.isPointInPath(e.x, e.y)), o),
          (t, i, s) => {
            if (o) return !0;
            const r = i.lineWidth || s.lineWidth;
            return (n.lineWidth = r), (o = t.isPointInStroke(e.x, e.y)), o;
          }
        ),
        n.highPerformanceRestore(),
        o
      );
    }
  };
  EH = MH([ZS(), CH(0, tw(hI)), TH('design:paramtypes', [Object])], EH);
  var PH = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    RH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    OH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  const BH = new Kt();
  let IH = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'rect'), (this.numberType = IE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).rect,
        { cornerRadius: r = s.cornerRadius } = t.attribute;
      let { x: a = s.x, y: o = s.y } = t.attribute;
      n.highPerformanceSave();
      let l = !0;
      if (t.transMatrix.onlyTranslate()) {
        const e = t.getOffsetXY(s);
        (a += e.x), (o += e.y), n.setTransformForCurrent();
      } else (a = 0), (o = 0), (l = !1), n.transformFromMatrix(t.transMatrix, !0);
      let h = !0;
      if (!l || (y(r, !0) && 0 !== r) || (f(r) && r.some(t => 0 !== t)))
        (h = !1),
          this.canvasRenderer.drawShape(
            t,
            n,
            a,
            o,
            {},
            null,
            (t, i, n) => !!h || ((h = t.isPointInPath(e.x, e.y)), h),
            (t, i, s) => {
              if (h) return !0;
              const r = i.lineWidth || s.lineWidth;
              return (n.lineWidth = r), (h = t.isPointInStroke(e.x, e.y)), h;
            }
          );
      else if (h) {
        const { fill: i = s.fill, stroke: n = s.stroke, lineWidth: r = s.lineWidth } = t.attribute;
        if (i) h = !0;
        else if (n) {
          const i = t.AABBBounds;
          BH.setValue(i.x1, i.y1, i.x2, i.y2), BH.expand(-r / 2), (h = !BH.containsPoint(e));
        }
      }
      return n.highPerformanceRestore(), h;
    }
  };
  IH = PH([ZS(), OH(0, tw(fI)), RH('design:paramtypes', [Object])], IH);
  var DH = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    LH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    FH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let jH = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'arc'), (this.numberType = wE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).arc;
      n.highPerformanceSave();
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if (t.transMatrix.onlyTranslate()) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      let o = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          r,
          a,
          {},
          null,
          (t, i, n) => !!o || ((o = t.isPointInPath(e.x, e.y)), o),
          (t, i, s) => {
            if (o) return !0;
            const r = i.lineWidth || s.lineWidth;
            return (n.lineWidth = r), (o = t.isPointInStroke(e.x, e.y)), o;
          }
        ),
        n.highPerformanceRestore(),
        o
      );
    }
  };
  jH = DH([ZS(), FH(0, tw(aI)), LH('design:paramtypes', [Object])], jH);
  var zH = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    HH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    NH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let VH = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'area'), (this.numberType = kE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).area;
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if ((n.highPerformanceSave(), t.transMatrix.onlyTranslate())) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      let o = !1;
      return (
        this.canvasRenderer.drawShape(t, n, r, a, {}, null, t => !!o || ((o = t.isPointInPath(e.x, e.y)), o)),
        n.highPerformanceRestore(),
        o
      );
    }
  };
  VH = zH([ZS(), NH(0, tw(lI)), HH('design:paramtypes', [Object])], VH);
  var WH = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    GH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    UH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let YH = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'line'), (this.numberType = PE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).line;
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if ((n.highPerformanceSave(), t.transMatrix.onlyTranslate())) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      let o = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          r,
          a,
          {},
          null,
          t => !!o || ((o = t.isPointInPath(e.x, e.y)), o),
          (t, i, s) => {
            if (o) return !0;
            const r = i.lineWidth || s.lineWidth;
            return (n.lineWidth = r), (o = t.isPointInStroke(e.x, e.y)), o;
          }
        ),
        n.highPerformanceRestore(),
        o
      );
    }
  };
  YH = WH([ZS(), UH(0, tw(uI)), GH('design:paramtypes', [Object])], YH);
  var $H = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    XH = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    KH = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let qH = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'symbol'), (this.numberType = FE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).symbol;
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if ((n.highPerformanceSave(), t.transMatrix.onlyTranslate())) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      let o = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          r,
          a,
          {},
          null,
          (t, i, n) => !!o || ((o = t.isPointInPath(e.x, e.y)), o),
          (t, i, s) => {
            if (o) return !0;
            const r = i.lineWidth || s.lineWidth;
            return (n.lineWidth = r), (o = t.isPointInStroke(e.x, e.y)), o;
          }
        ),
        n.highPerformanceRestore(),
        o
      );
    }
  };
  qH = $H([ZS(), KH(0, tw(mI)), XH('design:paramtypes', [Object])], qH);
  var ZH = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let JH = class {
    constructor() {
      (this.type = 'text'), (this.numberType = jE);
    }
    contains(t, e, i) {
      return !!t.AABBBounds.containsPoint(e);
    }
  };
  JH = ZH([ZS()], JH);
  var QH = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    tN = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    eN = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let iN = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'polygon'), (this.numberType = OE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.contains(e.x, e.y)) return !1;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = Zk(t).polygon;
      let { x: r = s.x, y: a = s.y } = t.attribute;
      if ((n.highPerformanceSave(), t.transMatrix.onlyTranslate())) {
        const e = t.getOffsetXY(s);
        (r += e.x), (a += e.y), n.setTransformForCurrent();
      } else (r = 0), (a = 0), n.transformFromMatrix(t.transMatrix, !0);
      let o = !1;
      return (
        this.canvasRenderer.drawShape(
          t,
          n,
          r,
          a,
          {},
          null,
          (t, i, n) => !!o || ((o = t.isPointInPath(e.x, e.y)), o),
          (t, i, s) => {
            if (o) return !0;
            const r = i.lineWidth || s.lineWidth;
            return (n.lineWidth = r), (o = t.isPointInStroke(e.x, e.y)), o;
          }
        ),
        n.highPerformanceRestore(),
        o
      );
    }
  };
  iN = QH([ZS(), eN(0, tw(gI)), tN('design:paramtypes', [Object])], iN);
  var nN = function (t, e, i, n) {
      var s,
        r = arguments.length,
        a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
      if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
      else
        for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
      return r > 3 && a && Object.defineProperty(e, i, a), a;
    },
    sN = function (t, e) {
      if ('object' == typeof Reflect && 'function' == typeof Reflect.metadata) return Reflect.metadata(t, e);
    },
    rN = function (t, e) {
      return function (i, n) {
        e(i, n, t);
      };
    };
  let aN = class {
    constructor(t) {
      (this.canvasRenderer = t), (this.type = 'glyph'), (this.numberType = TE);
    }
    contains(t, e, i) {
      if (!t.AABBBounds.containsPoint(e)) return !1;
      if ('imprecise' === t.attribute.pickMode) return !0;
      const { pickContext: n } = null != i ? i : {};
      if (!n) return !1;
      const s = null == i ? void 0 : i.pickerService;
      if (s) {
        let n = !1;
        return (
          t.getSubGraphic().forEach(t => {
            n || (n = !!s.pickItem(t, e, null, i));
          }),
          n
        );
      }
      return !1;
    }
  };
  aN = nN([ZS(), rN(0, tw(xI)), sN('design:paramtypes', [Object])], aN);
  var oN = new YS(t => {
    t(EH).toSelf().inSingletonScope(),
      t(nL).toService(EH),
      t(dL).toService(nL),
      t(IH).toSelf().inSingletonScope(),
      t(aL).toService(IH),
      t(dL).toService(aL),
      t(jH).toSelf().inSingletonScope(),
      t(eL).toService(jH),
      t(dL).toService(eL),
      t(VH).toSelf().inSingletonScope(),
      t(iL).toService(VH),
      t(dL).toService(iL),
      t(YH).toSelf().inSingletonScope(),
      t(sL).toService(YH),
      t(dL).toService(sL),
      t(kH).toSelf().inSingletonScope(),
      t(rL).toService(kH),
      t(dL).toService(rL),
      t(qH).toSelf().inSingletonScope(),
      t(oL).toService(qH),
      t(dL).toService(oL),
      t(JH).toSelf().inSingletonScope(),
      t(lL).toService(JH),
      t(dL).toService(lL),
      t(iN).toSelf().inSingletonScope(),
      t(hL).toService(iN),
      t(dL).toService(hL),
      t(aN).toSelf().inSingletonScope(),
      t(cL).toService(aN),
      t(aN).toService(cL),
      ow(t, dL);
  });
  var lN = new YS(t => {
      t(rk)
        .toDynamicValue(() => t => new FD(t))
        .whenTargetNamed(FD.env),
        t(ak)
          .toDynamicValue(() => (t, e) => new BD(t, e))
          .whenTargetNamed(BD.env);
    }),
    hN = new YS(t => {
      t(rk)
        .toDynamicValue(() => t => new TF(t))
        .whenTargetNamed(TF.env),
        t(ak)
          .toDynamicValue(() => (t, e) => new wF(t, e))
          .whenTargetNamed(wF.env);
    }),
    cN = new YS(t => {
      t(rk)
        .toDynamicValue(() => t => new mF(t))
        .whenTargetNamed(mF.env),
        t(ak)
          .toDynamicValue(() => (t, e) => new pF(t, e))
          .whenTargetNamed(pF.env);
    }),
    dN = new YS(t => {
      t(rk)
        .toDynamicValue(() => t => new FF(t))
        .whenTargetNamed(FF.env),
        t(ak)
          .toDynamicValue(() => (t, e) => new BF(t, e))
          .whenTargetNamed(BF.env);
    }),
    uN = new YS(t => {
      t(rk)
        .toDynamicValue(() => t => new sj(t))
        .whenTargetNamed(sj.env),
        t(ak)
          .toDynamicValue(() => (t, e) => new tj(t, e))
          .whenTargetNamed(tj.env);
    }),
    pN = new YS(t => {
      t(rk)
        .toDynamicValue(() => t => new XF(t))
        .whenTargetNamed(XF.env),
        t(ak)
          .toDynamicValue(() => (t, e) => new GF(t, e))
          .whenTargetNamed(GF.env);
    });
  sk.load(aP),
    sk.load(ML),
    sk.load(oD),
    sk.load(kL),
    sk.load(BL),
    (function (t) {
      t.load(sF), t.load(cj), t.load(dj), t.load(bj);
    })(sk),
    (function (t) {
      t.load(dz);
    })(sk),
    (function (t) {
      t.load(xH), t.load(oN);
    })(sk),
    (function (t) {
      t.load(lN), t.load(cN), t.load(hN), t.load(dN), t.load(uN), t.load(pN);
    })(sk);
  const gN = sk.get(dw);
  WA.global = gN;
  const fN = sk.get(sP);
  WA.graphicUtil = fN;
  const vN = sk.get(nP);
  WA.transformUtil = vN;
  const mN = sk.get(zE);
  (WA.graphicService = mN), sk.get(AD);
  const yN = sk.get(rP);
  WA.layerService = yN;
  class _N {
    constructor() {
      (this.name = 'AutoRenderPlugin'),
        (this.activeEvent = 'onRegister'),
        (this._uid = Jk.GenAutoIncrementId()),
        (this.key = this.name + this._uid);
    }
    activate(t) {
      (this.pluginService = t),
        WA.graphicService.hooks.onAttributeUpdate.tap(this.key, e => {
          e.glyphHost && (e = e.glyphHost), e.stage === t.stage && null != e.stage && e.stage.renderNextFrame();
        }),
        WA.graphicService.hooks.onSetStage.tap(this.key, e => {
          e.glyphHost && (e = e.glyphHost), e.stage === t.stage && null != e.stage && e.stage.renderNextFrame();
        });
    }
    deactivate(t) {
      (WA.graphicService.hooks.onAttributeUpdate.taps = WA.graphicService.hooks.onAttributeUpdate.taps.filter(
        t => t.name !== this.key
      )),
        (WA.graphicService.hooks.onSetStage.taps = WA.graphicService.hooks.onSetStage.taps.filter(
          t => t.name !== this.key
        ));
    }
  }
  class bN {
    constructor() {
      (this.name = 'ViewTransform3dPlugin'),
        (this.activeEvent = 'onRegister'),
        (this._uid = Jk.GenAutoIncrementId()),
        (this.key = this.name + this._uid),
        (this.onMouseDown = t => {
          this.option3d || (this.option3d = this.pluginService.stage.option3d),
            this.option3d && ((this.mousedown = !0), (this.pageX = t.page.x), (this.pageY = t.page.y));
        }),
        (this.onMouseUp = t => {
          this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = !1);
        }),
        (this.onMouseMove = t => {
          var e, i;
          const n = this.pluginService.stage;
          if ((this.option3d || (this.option3d = n.option3d), this.option3d && this.mousedown))
            if (this.pageX && this.pageY) {
              const s = t.page.x - this.pageX,
                r = t.page.y - this.pageY;
              (this.pageX = t.page.x), (this.pageY = t.page.y);
              const a = s / 100,
                o = r / 100;
              (this.option3d.alpha = (null !== (e = this.option3d.alpha) && void 0 !== e ? e : 0) + a),
                (this.option3d.beta = (null !== (i = this.option3d.beta) && void 0 !== i ? i : 0) + o),
                n.set3dOptions(this.option3d),
                n.renderNextFrame();
            } else (this.pageX = t.page.x), (this.pageY = t.page.y);
        });
    }
    activate(t) {
      this.pluginService = t;
      const e = t.stage;
      (this.option3d = e.option3d),
        e.addEventListener('mousedown', this.onMouseDown),
        e.addEventListener('mouseup', this.onMouseUp),
        e.addEventListener('mousemove', this.onMouseMove);
    }
    deactivate(t) {
      const e = t.stage;
      e.removeEventListener('mousedown', this.onMouseDown),
        e.removeEventListener('mouseup', this.onMouseUp),
        e.removeEventListener('mousemove', this.onMouseMove);
    }
  }
  class xN {
    constructor() {
      (this.name = 'IncrementalAutoRenderPlugin'),
        (this.activeEvent = 'onRegister'),
        (this.nextFrameRenderGroupSet = new Set()),
        (this.willNextFrameRender = !1),
        (this.nextUserParams = {}),
        (this._uid = Jk.GenAutoIncrementId()),
        (this.key = this.name + this._uid);
    }
    activate(t) {
      (this.pluginService = t),
        WA.graphicService.hooks.onAddIncremental.tap(this.key, (e, i, n) => {
          e.glyphHost && (e = e.glyphHost),
            e.stage === t.stage &&
              null != e.stage &&
              ((this.nextUserParams.startAtId = i._uid), this.renderNextFrame(i));
        }),
        WA.graphicService.hooks.onClearIncremental.tap(this.key, (e, i) => {
          e.stage === t.stage &&
            null != e.stage &&
            ((this.nextUserParams.startAtId = e._uid),
            (this.nextUserParams.restartIncremental = !0),
            this.renderNextFrame(e));
        });
    }
    deactivate(t) {
      (WA.graphicService.hooks.onAddIncremental.taps = WA.graphicService.hooks.onAddIncremental.taps.filter(
        t => t.name !== this.key
      )),
        (WA.graphicService.hooks.onClearIncremental.taps = WA.graphicService.hooks.onClearIncremental.taps.filter(
          t => t.name !== this.key
        ));
    }
    renderNextFrame(t) {
      this.nextFrameRenderGroupSet.add(t),
        this.willNextFrameRender ||
          ((this.willNextFrameRender = !0),
          WA.global.getRequestAnimationFrame()(() => {
            this._doRenderInThisFrame(), (this.willNextFrameRender = !1);
          }));
    }
    _doRenderInThisFrame() {
      const t = this.pluginService.stage;
      this.nextFrameRenderGroupSet.size &&
        (this.nextFrameRenderGroupSet.forEach(e => {
          const i = e.layer;
          if (!i || !e.layer.subLayers) return;
          const n = e.layer.subLayers.get(e._uid);
          n &&
            n.drawContribution &&
            n.drawContribution.draw(
              t.renderService,
              Object.assign(
                {
                  x: t.x,
                  y: t.y,
                  width: i.viewWidth,
                  height: i.viewHeight,
                  stage: t,
                  layer: i,
                  clear: 'transparent',
                  renderService: t.renderService,
                  updateBounds: !1,
                  startAtId: e._uid,
                  context: n.layer.getNativeHandler().getContext()
                },
                this.nextUserParams
              )
            );
        }),
        (this.nextUserParams = {}),
        this.nextFrameRenderGroupSet.clear());
    }
  }
  class SN {
    constructor() {
      (this.name = 'HtmlAttributePlugin'),
        (this.activeEvent = 'onRegister'),
        (this._uid = Jk.GenAutoIncrementId()),
        (this.key = this.name + this._uid);
    }
    activate(t) {
      (this.pluginService = t),
        t.stage.hooks.afterRender.tap(this.key, e => {
          e && e === this.pluginService.stage && this.drawHTML(t.stage.renderService);
        });
    }
    deactivate(t) {
      t.stage.hooks.afterRender.taps = t.stage.hooks.afterRender.taps.filter(t => t.name !== this.key);
    }
    drawHTML(t) {
      'browser' === WA.global.env &&
        t.renderTreeRoots
          .sort((t, e) => {
            var i, n;
            return (
              (null !== (i = t.attribute.zIndex) && void 0 !== i ? i : TA.zIndex) -
              (null !== (n = e.attribute.zIndex) && void 0 !== n ? n : TA.zIndex)
            );
          })
          .forEach(t => {
            this.renderGroupHTML(t);
          });
    }
    renderGroupHTML(t) {
      this.renderGraphicHTML(t),
        t.forEachChildren(t => {
          t.isContainer ? this.renderGroupHTML(t) : this.renderGraphicHTML(t);
        });
    }
    renderGraphicHTML(t) {
      const { html: e } = t.attribute;
      if (!e)
        return void (
          t.bindDom &&
          t.bindDom.size &&
          (t.bindDom.forEach(t => {
            t.dom && t.dom.parentElement.removeChild(t.dom);
          }),
          t.bindDom.clear())
        );
      const i = t.stage;
      if (!i) return;
      const { dom: n, container: s, width: r, height: a, style: o, anchorType: l = 'boundsLeftTop' } = e;
      t.bindDom || (t.bindDom = new Map());
      const h = t.bindDom.get(n);
      if (h && (!s || s === h.container)) return;
      let c, d;
      t.bindDom.forEach(t => {
        let { wrapGroup: e } = t;
        WA.global.removeDom(e);
      }),
        (c = 'string' == typeof n ? new DOMParser().parseFromString(n, 'text/xml').firstChild : n);
      const u = s || (!0 === i.params.enableHtmlAttribute ? null : i.params.enableHtmlAttribute);
      d = u ? ('string' == typeof u ? WA.global.getElementById(u) : u) : t.stage.window.getContainer();
      const p = WA.global.createDom({ tagName: 'div', width: r, height: a, style: o, parent: d });
      p && (p.appendChild(c), t.bindDom.set(n, { dom: c, container: s, wrapGroup: p })),
        (p.style.pointerEvents = 'none'),
        p.style.position || ((p.style.position = 'absolute'), (d.style.position = 'relative'));
      let g = 0,
        f = 0;
      if ('position' === l) {
        const e = t.transMatrix;
        (g = e.e), (f = e.f);
      } else {
        const e = t.AABBBounds;
        (g = e.x1), (f = e.y1);
      }
      const v = WA.global.getElementTopLeft(d, !1),
        m = i.window.getTopLeft(!1),
        y = g + m.left - v.left,
        _ = f + m.top - v.top;
      (p.style.left = `${y}px`), (p.style.top = `${_}px`);
    }
  }
  const wN = new Kt();
  class AN {
    constructor() {
      (this.name = 'DirtyBoundsPlugin'),
        (this.activeEvent = 'onRegister'),
        (this._uid = Jk.GenAutoIncrementId()),
        (this.key = this.name + this._uid);
    }
    activate(t) {
      (this.pluginService = t),
        t.stage.hooks.afterRender.tap(this.key, t => {
          t && t === this.pluginService.stage && t.dirtyBounds.clear();
        }),
        WA.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (t, e, i, n) => {
          t.glyphHost && (t = t.glyphHost),
            e &&
              e === this.pluginService.stage &&
              e.renderCount &&
              ((t.isContainer && !t.shouldSelfChangeUpdateAABBBounds()) ||
                (i && (wN.setValue(n.x1, n.y1, n.x2, n.y2), e.dirty(wN, t.parent && t.parent.globalTransMatrix))));
        }),
        WA.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (t, e, i, n, s) => {
          e &&
            e === this.pluginService.stage &&
            e.renderCount &&
            ((t.isContainer && !s) || e.dirty(n.globalAABBBounds));
        }),
        WA.graphicService.hooks.onRemove.tap(this.key, t => {
          const e = t.stage;
          e && e === this.pluginService.stage && e.renderCount && e && e.dirty(t.globalAABBBounds);
        });
    }
    deactivate(t) {
      (WA.graphicService.hooks.beforeUpdateAABBBounds.taps = WA.graphicService.hooks.beforeUpdateAABBBounds.taps.filter(
        t => t.name !== this.key
      )),
        (WA.graphicService.hooks.afterUpdateAABBBounds.taps = WA.graphicService.hooks.afterUpdateAABBBounds.taps.filter(
          t => t.name !== this.key
        )),
        (t.stage.hooks.afterRender.taps = t.stage.hooks.afterRender.taps.filter(t => t.name !== this.key)),
        (WA.graphicService.hooks.onRemove.taps = WA.graphicService.hooks.onRemove.taps.filter(
          t => t.name !== this.key
        ));
    }
  }
  class kN {
    constructor() {
      (this.name = 'FlexLayoutPlugin'),
        (this.activeEvent = 'onRegister'),
        (this.id = Jk.GenAutoIncrementId()),
        (this.key = this.name + this.id),
        (this.tempBounds = new Kt());
    }
    tryLayout(t) {
      const e = t.parent;
      if (!e || !t.needUpdateLayout()) return;
      const i = Zk(e).group,
        { display: n = i.display } = e.attribute;
      if ('flex' !== n) return;
      const {
        flexDirection: s = i.flexDirection,
        flexWrap: r = i.flexWrap,
        justifyContent: a = i.justifyContent,
        alignItems: o = i.alignItems,
        alignContent: l = i.alignContent,
        clip: h = i.clip
      } = e.attribute;
      let c = 0,
        d = 0,
        u = 0;
      if (
        (e.forEachChildren(t => {
          const e = t.AABBBounds;
          'column' === s || 'column-reverse' === s
            ? ((d += e.height()), (c = Math.max(c, e.width())))
            : ((c += e.width()), (d = Math.max(d, e.height()))),
            (u += e.x1),
            (u += e.y1),
            (u += e.x2),
            (u += e.y2);
        }),
        !isFinite(u))
      )
        return;
      const p = e.attribute.width || c,
        g = e.attribute.height || d;
      e.attribute.width || (e.attribute.width = 0),
        e.attribute.height || (e.attribute.height = 0),
        this.tempBounds.copy(e._AABBBounds);
      const f = { main: { len: p, field: 'x' }, cross: { len: g, field: 'y' }, dir: 1 },
        v = f.main,
        m = f.cross;
      'row-reverse' === s
        ? (f.dir = -1)
        : 'column' === s
        ? ((v.len = g), (m.len = p), (v.field = 'y'), (m.field = 'x'))
        : 'column-reverse' === s && ((v.len = g), (m.len = p), (v.field = 'y'), (m.field = 'x'), (f.dir = -1));
      let y = 0,
        _ = 0;
      const b = [];
      e.forEachChildren(t => {
        const e = t.AABBBounds,
          i = 'x' === v.field ? e.width() : e.height(),
          n = 'x' === m.field ? e.width() : e.height();
        b.push({ mainLen: i, crossLen: n }), (y += i), (_ = Math.max(_, n));
      });
      const x = [];
      if (y > v.len && 'wrap' === r) {
        let t = 0,
          e = 0;
        b.forEach((i, n) => {
          let { mainLen: s, crossLen: r } = i;
          t + s > v.len
            ? 0 === t
              ? (x.push({ idx: n, mainLen: t + s, crossLen: r }), (t = 0), (e = 0))
              : (x.push({ idx: n - 1, mainLen: t, crossLen: r }), (t = s), (e = r))
            : ((t += s), (e = Math.max(e, r)));
        }),
          x.push({ idx: b.length - 1, mainLen: t, crossLen: e });
      } else x.push({ idx: b.length - 1, mainLen: y, crossLen: _ });
      const S = e.getChildren();
      let w = 0;
      if (
        (x.forEach(t => {
          this.layoutMain(e, S, a, v, b, w, t), (w = t.idx + 1);
        }),
        (_ = x.reduce((t, e) => t + e.crossLen, 0)),
        1 === x.length)
      )
        if ('flex-end' === o) {
          const t = m.len;
          this.layoutCross(S, o, m, t, b, x[0], 0);
        } else if ('center' === o) {
          const t = m.len / 2;
          this.layoutCross(S, o, m, t, b, x[0], 0);
        } else
          S.forEach(t => {
            t.attribute[m.field] = MN(t, m.field);
          });
      else if ('flex-start' === l) {
        w = 0;
        let t = 0;
        x.forEach((e, i) => {
          this.layoutCross(S, 'flex-start', m, t, b, x[i], w), (w = e.idx + 1), (t += e.crossLen);
        });
      } else if ('center' === l) {
        w = 0;
        let t = Math.max(0, (m.len - _) / 2);
        x.forEach((e, i) => {
          this.layoutCross(S, 'center', m, t + e.crossLen / 2, b, x[i], w), (w = e.idx + 1), (t += e.crossLen);
        });
      } else if ('space-around' === l) {
        w = 0;
        const t = Math.max(0, (m.len - _) / x.length / 2);
        let e = t;
        x.forEach((i, n) => {
          this.layoutCross(S, 'flex-start', m, e, b, x[n], w), (w = i.idx + 1), (e += i.crossLen + 2 * t);
        });
      } else if ('space-between' === l) {
        w = 0;
        const t = Math.max(0, (m.len - _) / (2 * x.length - 2));
        let e = 0;
        x.forEach((i, n) => {
          this.layoutCross(S, 'flex-start', m, e, b, x[n], w), (w = i.idx + 1), (e += i.crossLen + 2 * t);
        });
      }
      S.forEach((t, e) => {
        t.addUpdateBoundTag(), t.addUpdatePositionTag(), t.clearUpdateLayoutTag();
      }),
        e.addUpdateLayoutTag(),
        h || this.tempBounds.equals(e.AABBBounds) || this.tryLayout(e);
    }
    layoutMain(t, e, i, n, s, r, a) {
      if ('flex-start' === i) {
        let t = 0;
        for (let i = r; i <= a.idx; i++) (e[i].attribute[n.field] = t + MN(e[i], n.field)), (t += s[i].mainLen);
      } else if ('flex-end' === i) {
        let t = n.len;
        for (let i = r; i <= a.idx; i++) (t -= s[i].mainLen), (e[i].attribute[n.field] = t + MN(e[i], n.field));
      } else if ('space-around' === i)
        if (a.mainLen >= n.len) {
          let t = 0;
          for (let i = r; i <= a.idx; i++) (e[i].attribute[n.field] = t + MN(e[i], n.field)), (t += s[i].mainLen);
        } else {
          const t = a.idx - r + 1,
            i = (n.len - a.mainLen) / t / 2;
          let o = i;
          for (let t = r; t <= a.idx; t++)
            (e[t].attribute[n.field] = o + MN(e[t], n.field)), (o += s[t].mainLen + 2 * i);
        }
      else if ('space-between' === i)
        if (a.mainLen >= n.len) {
          let t = 0;
          for (let i = r; i <= a.idx; i++) (e[i].attribute[n.field] = t + MN(e[i], n.field)), (t += s[i].mainLen);
        } else {
          const t = a.idx - r + 1,
            i = (n.len - a.mainLen) / (2 * t - 2);
          let o = 0;
          for (let t = r; t <= a.idx; t++)
            (e[t].attribute[n.field] = o + MN(e[t], n.field)), (o += s[t].mainLen + 2 * i);
        }
    }
    layoutCross(t, e, i, n, s, r, a) {
      if ('flex-end' === e)
        for (let e = a; e <= r.idx; e++) t[e].attribute[i.field] = n - s[e].crossLen + MN(t[e], i.field);
      else if ('center' === e)
        for (let e = a; e <= r.idx; e++) t[e].attribute[i.field] = n - s[e].crossLen / 2 + MN(t[e], i.field);
      else for (let e = a; e <= r.idx; e++) t[e].attribute[i.field] = n + MN(t[e], i.field);
    }
    activate(t) {
      (this.pluginService = t),
        mN.hooks.onAttributeUpdate.tap(this.key, t => {
          t.glyphHost && (t = t.glyphHost), this.tryLayout(t);
        }),
        mN.hooks.onSetStage.tap(this.key, t => {
          t.glyphHost && (t = t.glyphHost), this.tryLayout(t);
        });
    }
    deactivate(t) {
      (mN.hooks.onAttributeUpdate.taps = mN.hooks.onAttributeUpdate.taps.filter(t => t.name !== this.key)),
        (mN.hooks.onSetStage.taps = mN.hooks.onSetStage.taps.filter(t => t.name !== this.key));
    }
  }
  function MN(t, e) {
    if (!t.attribute.boundsPadding) return 0;
    if (
      (function (t) {
        return 'number' == typeof t && Number.isFinite(t);
      })(t.attribute.boundsPadding)
    )
      return t.attribute.boundsPadding;
    if (f(t.attribute.boundsPadding) && 1 === t.attribute.boundsPadding.length) return t.attribute.boundsPadding[0];
    const i = DM(t.attribute.boundsPadding);
    return 'x' === e ? i[3] : 'y' === e ? i[0] : 0;
  }
  const TN = new (class {
    set mode(t) {
      this._mode !== t && ((this._mode = t), this.setupTickHandler());
    }
    get mode() {
      return this._mode;
    }
    constructor() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      (this.handleTick = (t, e) => {
        const { once: i = !1 } = null != e ? e : {};
        this.ifCanStop() ? this.stop() : (this._handlerTick(t), i || t.tick(this.interval, this.handleTick));
      }),
        (this._handlerTick = t => {
          const e = this.tickerHandler.getTime();
          let i = 0;
          this.lastFrameTime >= 0 && (i = e - this.lastFrameTime),
            (this.lastFrameTime = e),
            this.status === _M.RUNNING &&
              (this.tickCounts++,
              this.timelines.forEach(t => {
                t.tick(i);
              }));
        }),
        this.init(),
        (this.lastFrameTime = -1),
        (this.tickCounts = 0),
        (this.timelines = t),
        (this.autoStop = !0);
    }
    init() {
      (this.interval = NaN),
        (this.status = _M.INITIAL),
        WA.global.hooks.onSetEnv.tap('window', () => {
          this.initHandler();
        }),
        WA.global.env && this.initHandler();
    }
    addTimeline(t) {
      this.timelines.push(t);
    }
    remTimeline(t) {
      this.timelines = this.timelines.filter(e => e !== t);
    }
    initHandler() {
      if (this._mode) return null;
      const t = [
        { mode: 'raf', cons: yM },
        { mode: 'timeout', cons: mM },
        { mode: 'manual', cons: vM }
      ];
      for (let e = 0; e < t.length; e++)
        if (t[e].cons.Avaliable()) {
          this.mode = t[e].mode;
          break;
        }
      return null;
    }
    setupTickHandler() {
      let t;
      switch (this._mode) {
        case 'raf':
          t = new yM();
          break;
        case 'timeout':
          t = new mM();
          break;
        case 'manual':
          t = new vM();
          break;
        default:
          console.warn('非法的计时器模式'), (t = new yM());
      }
      return !!t.avaliable() && (this.tickerHandler && this.tickerHandler.release(), (this.tickerHandler = t), !0);
    }
    setInterval(t) {
      this.interval = t;
    }
    getInterval() {
      return this.interval;
    }
    setFPS(t) {
      this.setInterval(1e3 / t);
    }
    getFPS() {
      return 1e3 / this.interval;
    }
    tick(t) {
      this.tickerHandler.tick(t, t => {
        this.handleTick(t, { once: !0 });
      });
    }
    tickTo(t) {
      this.tickerHandler.tickTo &&
        this.tickerHandler.tickTo(t, t => {
          this.handleTick(t, { once: !0 });
        });
    }
    pause() {
      return this.status !== _M.INITIAL && ((this.status = _M.PAUSE), !0);
    }
    resume() {
      return this.status !== _M.INITIAL && ((this.status = _M.RUNNING), !0);
    }
    ifCanStop() {
      if (this.autoStop) {
        if (!this.timelines.length) return !0;
        if (0 === this.timelines.reduce((t, e) => t + e.animateCount, 0)) return !0;
      }
      return !1;
    }
    start() {
      let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (this.status === _M.RUNNING) return !1;
      if (!this.tickerHandler) return !1;
      if (!t) {
        if (this.status === _M.PAUSE) return !1;
        if (!this.timelines.length) return !1;
        if (0 === this.timelines.reduce((t, e) => t + e.animateCount, 0)) return !1;
      }
      return (this.status = _M.RUNNING), this.tickerHandler.tick(0, this.handleTick), !0;
    }
    stop() {
      (this.status = _M.INITIAL), this.setupTickHandler(), (this.lastFrameTime = -1);
    }
  })();
  TN.addTimeline(SM), TN.setFPS(60);
  class CN {
    constructor(t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0.8;
      (this.dir = t),
        (this.color = e),
        (this.colorRgb = bT.get(e).value),
        (this.colorRgb[0] /= 255),
        (this.colorRgb[1] /= 255),
        (this.colorRgb[2] /= 255),
        (this.ambient = i);
      const n = Lt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
      this.formatedDir = [t[0] / n, t[1] / n, t[2] / n];
    }
    computeColor(t, e) {
      const i = this.formatedDir,
        n = It(Bt((t[0] * i[0] + t[1] * i[1] + t[2] * i[2]) * (1 - this.ambient / 2), 0) + this.ambient, 1);
      let s;
      s = g(e) ? bT.get(e).value : e;
      const r = this.colorRgb;
      return bT.to.rgb(r[0] * s[0] * n, r[1] * s[1] * n, r[2] * s[2] * n);
    }
  }
  const EN = 'white';
  class PN extends GE {
    set viewBox(t) {
      this._viewBox.setValue(t.x1, t.y1, t.x2, t.y2);
    }
    get viewBox() {
      return this._viewBox;
    }
    get x() {
      return this._viewBox.x1;
    }
    set x(t) {
      this._viewBox.translate(t - this._viewBox.x1, 0);
    }
    get y() {
      return this._viewBox.y1;
    }
    set y(t) {
      this._viewBox.translate(0, t - this._viewBox.y1);
    }
    get width() {
      return this.window.width;
    }
    set width(t) {
      this.resize(t, this.height);
    }
    get viewWidth() {
      return this._viewBox.width();
    }
    set viewWidth(t) {
      this.resizeView(t, this.viewHeight);
    }
    get viewHeight() {
      return this._viewBox.height();
    }
    set viewHeight(t) {
      this.resizeView(this.viewWidth, t);
    }
    get height() {
      return this.window.height;
    }
    set height(t) {
      this.resize(this.width, t);
    }
    get dpr() {
      return this.window.dpr;
    }
    set dpr(t) {
      this.setDpr(t);
    }
    get background() {
      var t;
      return null !== (t = this._background) && void 0 !== t ? t : EN;
    }
    set background(t) {
      this._background = t;
    }
    get defaultLayer() {
      return this.at(0);
    }
    constructor(t) {
      var e;
      super({}),
        (this.beforeRender = t => {
          this._beforeRender && this._beforeRender(t);
        }),
        (this.afterRender = t => {
          this.renderCount++,
            this._afterRender && this._afterRender(t),
            this._afterNextRenderCbs && this._afterNextRenderCbs.forEach(e => e(t)),
            (this._afterNextRenderCbs = null);
        }),
        (this.params = t),
        (this.theme = new Kk()),
        (this.hooks = { beforeRender: new hw(['stage']), afterRender: new hw(['stage']) }),
        (this.global = sk.get(dw)),
        (this.window = sk.get(tP)),
        (this.renderService = sk.get(rD)),
        (this.pickerService = sk.get(_D)),
        (this.pluginService = sk.get(CL)),
        (this.layerService = sk.get(rP)),
        this.pluginService.active(this, t),
        this.window.create({
          width: t.width,
          height: t.height,
          container: t.container,
          dpr: t.dpr || this.global.devicePixelRatio,
          canvasControled: !1 !== t.canvasControled,
          title: t.title || '',
          canvas: t.canvas
        }),
        (this._viewBox = new Kt()),
        t.viewBox
          ? this._viewBox.setValue(t.viewBox.x1, t.viewBox.y1, t.viewBox.x2, t.viewBox.y2)
          : this._viewBox.setValue(0, 0, this.width, this.height),
        (this.renderCount = 0),
        (this._subView = !(this._viewBox.width() === this.width && this._viewBox.height() === this.height)),
        (this._background = null !== (e = t.background) && void 0 !== e ? e : EN),
        this.appendChild(this.layerService.createLayer(this, { main: !0 })),
        (this.nextFrameRenderLayerSet = new Set()),
        (this.willNextFrameRender = !1),
        (this.stage = this),
        (this.renderStyle = t.renderStyle),
        this.global.supportEvent &&
          (this.eventSystem = new dM({
            targetElement: this.window,
            resolution: this.window.dpr || this.global.devicePixelRatio,
            rootNode: this,
            global: this.global,
            viewport: {
              viewBox: this._viewBox,
              get x() {
                return this.viewBox.x1;
              },
              get y() {
                return this.viewBox.y1;
              },
              get width() {
                return this.viewBox.width();
              },
              get height() {
                return this.viewBox.height();
              }
            }
          })),
        t.autoRender && this.enableAutoRender(),
        !1 === t.disableDirtyBounds && this.enableDirtyBounds(),
        t.enableHtmlAttribute && this.enableHtmlAttribute(t.enableHtmlAttribute),
        t.enableLayout && this.enableLayout(),
        this.hooks.beforeRender.tap('constructor', this.beforeRender),
        this.hooks.afterRender.tap('constructor', this.afterRender),
        (this._beforeRender = t.beforeRender),
        (this._afterRender = t.afterRender),
        (this.ticker = t.ticker || TN),
        (this.supportInteractiveLayer = !1 !== t.interactiveLayer),
        (this.timeline = new xM()),
        this.ticker.addTimeline(this.timeline),
        this.timeline.pause(),
        this.optmize(t.optimize);
    }
    optmize(t) {
      this.optmizeRender(null == t ? void 0 : t.skipRenderWithOutRange);
    }
    optmizeRender() {
      (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]) &&
        ((this._skipRender = this.window.isVisible() ? 0 : 1),
        this.window.onVisibleChange(t => {
          t
            ? (this.dirtyBounds && this.dirtyBounds.setValue(0, 0, this._viewBox.width(), this._viewBox.height()),
              this._skipRender > 1 && this.renderNextFrame(),
              (this._skipRender = 0))
            : (this._skipRender = 1);
        }));
    }
    getTimeline() {
      return this.timeline;
    }
    get3dOptions(t) {
      const {
        center: e = { x: this.width / 2, y: this.height / 2, z: 0, dx: 0, dy: 0, dz: 0 },
        light: i = {},
        alpha: n = 0,
        beta: s = 0,
        camera: r,
        fieldRatio: a = 1,
        fieldDepth: o
      } = t;
      return Object.assign(Object.assign({}, t), {
        center: e,
        light: i,
        alpha: n,
        beta: s,
        camera: r,
        fieldRatio: a,
        fieldDepth: o
      });
    }
    set3dOptions(t) {
      var e, i, n, s, r, a;
      this.option3d = t;
      const o = this.get3dOptions(t),
        { light: l, center: h, camera: c, alpha: d, beta: u, fieldRatio: p, fieldDepth: g } = o,
        { dir: f = [1, 1, -1], color: v = 'white', ambient: m } = l,
        y = (null !== (e = h.x) && void 0 !== e ? e : this.width / 2) + (null !== (i = h.dx) && void 0 !== i ? i : 0),
        _ = (null !== (n = h.y) && void 0 !== n ? n : this.height / 2) + (null !== (s = h.dy) && void 0 !== s ? s : 0),
        b = [y, _, (null !== (r = h.z) && void 0 !== r ? r : 0) + (null !== (a = h.dz) && void 0 !== a ? a : 0)];
      let x = 0,
        S = 0,
        w = 0;
      c || ((x = Math.sin(d) + y), (S = Math.sin(u) + _), (w = Math.cos(d) * Math.cos(u) * 1)),
        (this.light = new CN(f, v, m));
      const A = {
        left: 0,
        right: this.width,
        top: 0,
        bottom: this.height,
        fieldRatio: p,
        fieldDepth: g,
        viewParams: { pos: [x, S, w], center: b, up: [0, 1, 0] }
      };
      this.camera ? (this.camera.params = A) : (this.camera = new CD(A)),
        t.enableView3dTransform && this.enableView3dTransform();
    }
    setBeforeRender(t) {
      this._beforeRender = t;
    }
    setAfterRender(t) {
      this._afterRender = t;
    }
    afterNextRender(t) {
      this._afterNextRenderCbs || (this._afterNextRenderCbs = []), this._afterNextRenderCbs.push(t);
    }
    enableView3dTransform() {
      this.view3dTranform || ((this.view3dTranform = !0), this.pluginService.register(new bN()));
    }
    disableView3dTranform() {
      this.view3dTranform &&
        ((this.view3dTranform = !1),
        this.pluginService.findPluginsByName('ViewTransform3dPlugin').forEach(t => {
          t.deactivate(this.pluginService);
        }));
    }
    enableAutoRender() {
      this.autoRender || ((this.autoRender = !0), this.pluginService.register(new _N()));
    }
    disableAutoRender() {
      this.autoRender &&
        ((this.autoRender = !1),
        this.pluginService.findPluginsByName('AutoRenderPlugin').forEach(t => {
          t.deactivate(this.pluginService);
        }));
    }
    enableIncrementalAutoRender() {
      this.increaseAutoRender || ((this.increaseAutoRender = !0), this.pluginService.register(new xN()));
    }
    disableIncrementalAutoRender() {
      this.increaseAutoRender &&
        ((this.increaseAutoRender = !1),
        this.pluginService.findPluginsByName('IncrementalAutoRenderPlugin').forEach(t => {
          t.deactivate(this.pluginService);
        }));
    }
    enableDirtyBounds() {
      if (this.dirtyBounds) return;
      this.dirtyBounds = new Xt();
      let t = this.pluginService.findPluginsByName('DirtyBoundsPlugin')[0];
      t || ((t = new AN()), this.pluginService.register(t)), t.activate(this.pluginService);
    }
    disableDirtyBounds() {
      this.dirtyBounds &&
        ((this.dirtyBounds = null),
        this.pluginService.findPluginsByName('DirtyBoundsPlugin').forEach(t => {
          t.deactivate(this.pluginService);
        }));
    }
    enableLayout() {
      this._enableLayout || ((this._enableLayout = !0), this.pluginService.register(new kN()));
    }
    disableLayout() {
      this._enableLayout &&
        ((this._enableLayout = !1),
        this.pluginService.findPluginsByName('FlexLayoutPlugin').forEach(t => {
          t.deactivate(this.pluginService);
        }));
    }
    enableHtmlAttribute(t) {
      this.htmlAttribute || ((this.htmlAttribute = t), this.pluginService.register(new SN()));
    }
    disableHtmlAttribute() {
      this.htmlAttribute &&
        ((this.htmlAttribute = !1),
        this.pluginService.findPluginsByName('HtmlAttributePlugin').forEach(t => {
          t.deactivate(this.pluginService);
        }));
    }
    tryUpdateAABBBounds() {
      const t = this._viewBox;
      return this._AABBBounds.setValue(t.x1, t.y1, t.x2, t.y2), this._AABBBounds;
    }
    combineLayer(t, e) {
      throw new Error('暂不支持');
    }
    createLayer(t) {
      const e = this.layerService.createLayer(this, { main: !1, canvasId: t });
      return this.appendChild(e), e;
    }
    sortLayer(t) {
      const e = this.children;
      e.sort(t),
        this.removeAllChild(),
        e.forEach(t => {
          this.appendChild(t);
        });
    }
    removeLayer(t) {
      return this.removeChild(this.findChildByUid(t));
    }
    tryInitInteractiveLayer() {
      this.supportInteractiveLayer &&
        !this.interactiveLayer &&
        ((this.interactiveLayer = this.createLayer()),
        (this.interactiveLayer.name = '_builtin_interactive'),
        this.nextFrameRenderLayerSet.add(this.interactiveLayer));
    }
    clearViewBox(t) {
      this.window.clearViewBox(this._viewBox, t);
    }
    render(t, e) {
      this.ticker.start(),
        this.timeline.resume(),
        this._skipRender ||
          ((this.lastRenderparams = e),
          this.hooks.beforeRender.call(this),
          (t || this).forEach((t, i) => {
            t.render(
              {
                renderService: this.renderService,
                background: t === this.defaultLayer ? this.background : void 0,
                updateBounds: !!this.dirtyBounds
              },
              Object.assign({ renderStyle: this.renderStyle }, e)
            );
          }),
          this.combineLayersToWindow(),
          this.nextFrameRenderLayerSet.clear(),
          this.hooks.afterRender.call(this)),
        this._skipRender && this._skipRender++;
    }
    combineLayersToWindow() {
      this.forEach((t, e) => {
        t.combineTo(this.window, {
          clear: 0 === e,
          x: this.x,
          y: this.y,
          width: this.viewWidth,
          height: this.viewHeight,
          renderService: this.renderService,
          background: t === this.defaultLayer ? this.background : void 0,
          updateBounds: !!this.dirtyBounds
        });
      });
    }
    renderNextFrame(t) {
      this.nextFrameRenderLayerSet.size !== this.childrenCount &&
        (t || this).forEach(t => {
          this.nextFrameRenderLayerSet.add(t);
        }),
        this.willNextFrameRender ||
          ((this.willNextFrameRender = !0),
          this.global.getRequestAnimationFrame()(() => {
            this._doRenderInThisFrame(), (this.willNextFrameRender = !1);
          }));
    }
    _doRenderInThisFrame() {
      this.timeline.resume(),
        this.ticker.start(),
        this.nextFrameRenderLayerSet.size &&
          !this._skipRender &&
          (this.hooks.beforeRender.call(this),
          this.forEach(t => {
            this.nextFrameRenderLayerSet.has(t) &&
              t.render(
                {
                  renderService: this.renderService,
                  background: t === this.defaultLayer ? this.background : void 0,
                  updateBounds: !!this.dirtyBounds
                },
                Object.assign({ renderStyle: this.renderStyle }, this.lastRenderparams || {})
              );
          }),
          this.combineLayersToWindow(),
          this.hooks.afterRender.call(this),
          this.nextFrameRenderLayerSet.clear()),
        this._skipRender && this._skipRender++;
    }
    resizeWindow(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      this.window.resize(t, e), i && this.render();
    }
    resize(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      this.window.resize(t, e),
        this.forEachChildren(i => {
          i.resize(t, e);
        }),
        this._subView ||
          this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + t, this.viewBox.y1 + e),
        this.camera && this.option3d && this.set3dOptions(this.option3d),
        i && this.render();
    }
    resizeView(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + t, this.viewBox.y1 + e),
        this.forEachChildren(i => {
          i.resizeView(t, e);
        }),
        this.camera &&
          (this.camera.params = Object.assign(Object.assign({}, this.camera.params), {
            right: this.width,
            bottom: this.height
          })),
        i && this.render();
    }
    setViewBox(t, e, i, n, s) {
      let r = !0;
      'object' == typeof t
        ? (this.viewBox.setValue(t.x1, t.y1, t.x2, t.y2), !1 === e && (r = !1))
        : (this.viewBox.setValue(t, e, t + i, e + n), !1 === s && (r = !1)),
        this.forEachChildren(t => {
          t.resizeView(this.viewBox.width(), this.viewBox.height());
        }),
        r && this.render();
    }
    setDpr(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      this.forEachChildren(e => {
        e.setDpr(t);
      }),
        e && this.render();
    }
    setOrigin(t, e) {
      throw new Error('暂不支持');
    }
    export(t) {
      throw new Error('暂不支持');
    }
    pick(t, e) {
      const i = this.pickerService.pick(this.children, new Ut(t, e), { bounds: this.AABBBounds });
      return !(!(null == i ? void 0 : i.graphic) && !(null == i ? void 0 : i.group)) && i;
    }
    startAnimate(t) {
      throw new Error('暂不支持');
    }
    setToFrame(t) {
      throw new Error('暂不支持');
    }
    release() {
      super.release(),
        this.eventSystem && this.eventSystem.release(),
        this.pluginService.release(),
        this.forEach(t => {
          t.release();
        }),
        this.interactiveLayer && this.interactiveLayer.release(),
        this.window.release();
    }
    setStage(t) {}
    dirty(t, e) {
      e && t.transformWithMatrix(e),
        this.dirtyBounds.empty() && this.dirtyBounds.setValue(t.x1, t.y1, t.x2, t.y2),
        this.dirtyBounds.union(t);
    }
    getLayer(t) {
      return this.children.filter(e => e.name === t)[0];
    }
    renderTo(t, e) {
      this.forEachChildren((i, n) => {
        i.drawTo(
          t,
          Object.assign(Object.assign({}, e), {
            renderService: this.renderService,
            background: i === this.defaultLayer ? this.background : void 0,
            clear: 0 === n,
            updateBounds: !!this.dirtyBounds
          })
        );
      });
    }
    renderToNewWindow() {
      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
        e = arguments.length > 1 ? arguments[1] : void 0;
      const i = sk.get(tP);
      if (t)
        i.create({
          width: this.viewWidth,
          height: this.viewHeight,
          dpr: this.window.dpr,
          canvasControled: !0,
          offscreen: !0,
          title: ''
        });
      else {
        const t = e ? e.width() : Math.min(this.viewWidth, this.window.width - this.x),
          n = e ? e.height() : Math.min(this.viewHeight, this.window.height - this.y);
        i.create({ width: t, height: n, dpr: this.window.dpr, canvasControled: !0, offscreen: !0, title: '' });
      }
      const n = e ? -e.x1 : 0,
        s = e ? -e.y1 : 0;
      return this.renderTo(i, { x: n, y: s, width: e ? e.x2 : i.width, height: e ? e.y2 : i.height }), i;
    }
    toCanvas() {
      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
        e = arguments.length > 1 ? arguments[1] : void 0;
      const i = this.renderToNewWindow(t, e).getNativeHandler();
      return i.nativeCanvas ? i.nativeCanvas : null;
    }
    setCursor(t) {
      (this._cursor = t), this.eventSystem.setCursor(t);
    }
    getCursor() {
      return this._cursor;
    }
  }
  var RN;
  !(function (t) {
    (t[(t.W = 1)] = 'W'), (t[(t.H = 2)] = 'H'), (t[(t.WH = 3)] = 'WH');
  })(RN || (RN = {}));
  const ON = (t, e, i, n) =>
    new $e(
      Object.assign(
        {
          defaultFontParams: Object.assign(
            {
              fontFamily:
                'PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol',
              fontSize: 14
            },
            n
          ),
          getTextBounds: i ? void 0 : dB,
          specialCharSet: '-/: .,@%\'"~' + $e.ALPHABET_CHAR_SET + $e.ALPHABET_CHAR_SET.toUpperCase()
        },
        null != e ? e : {}
      ),
      t
    );
  function BN(t) {
    for (; t < 0; ) t += 2 * Math.PI;
    for (; t >= 2 * Math.PI; ) t -= 2 * Math.PI;
    return t;
  }
  function IN(t) {
    let e = 'center',
      i = 'middle';
    return (
      (e =
        (t = BN(t)) >= Math.PI * (5 / 3) || t <= Math.PI * (1 / 3)
          ? 'left'
          : t >= Math.PI * (2 / 3) && t <= Math.PI * (4 / 3)
          ? 'right'
          : 'center'),
      (i =
        t >= Math.PI * (7 / 6) && t <= Math.PI * (11 / 6)
          ? 'bottom'
          : t >= Math.PI * (1 / 6) && t <= Math.PI * (5 / 6)
          ? 'top'
          : 'middle'),
      { align: e, baseline: i }
    );
  }
  const DN = t => t.map((t, e) => ({ index: e, value: t })),
    LN = function (t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
      const n = new Kt(t).expand(i / 2),
        s = new Kt(e).expand(i / 2);
      return n.intersects(s);
    },
    FN = (t, e) => {
      let i = 0;
      t.x2 < e.x1 ? (i = e.x1 - t.x2) : e.x2 < t.x1 && (i = t.x1 - e.x2);
      let n = 0;
      return t.y2 < e.y1 ? (n = e.y1 - t.y2) : e.y2 < t.y1 && (n = t.y1 - e.y2), [i, n];
    };
  function jN(t, e, i) {
    return i > Math.max(e.x1 - t.x2, t.x1 - e.x2, e.y1 - t.y2, t.y1 - e.y2);
  }
  function zN(t, e) {
    for (let i, n = 1, s = t.length, r = t[0]; n < s; r = i, ++n)
      if (((i = t[n]), jN(r.AABBBounds, i.AABBBounds, e))) return !0;
    return !1;
  }
  const HN = (t, e, i) => {
      var n;
      const { labelStyle: s, axisOrientType: r, labelFlush: a, labelFormatter: o, startAngle: l = 0 } = i,
        h = null !== (n = s.angle) && void 0 !== n ? n : 0,
        c = ['bottom', 'top'].includes(r),
        d = ['left', 'right'].includes(r);
      let u = l;
      c ? (u = 0) : d && (u = qt(-90));
      const p = ON(s),
        g = e.map((i, n) => {
          var r, l;
          const g = o ? o(i) : `${i}`,
            { width: f, height: v } = p.quickMeasure(g),
            m = Math.max(f, 12),
            y = Math.max(v, 12),
            _ = t.scale(i);
          let b,
            x,
            S = Math.cos(u) * _,
            w = -Math.sin(u) * _;
          return (
            (b =
              a && c && 0 === n
                ? 'left'
                : a && c && n === e.length - 1
                ? 'right'
                : null !== (r = s.textAlign) && void 0 !== r
                ? r
                : 'center'),
            'right' === b ? (S -= m) : 'center' === b && (S -= m / 2),
            (x =
              a && d && 0 === n
                ? 'top'
                : a && d && n === e.length - 1
                ? 'bottom'
                : null !== (l = s.textBaseline) && void 0 !== l
                ? l
                : 'middle'),
            'bottom' === x ? (w -= y) : 'middle' === x && (w -= y / 2),
            new Kt().set(S, w, S + m, w + y).rotate(h, S + m / 2, w + y / 2)
          );
        });
      return g;
    },
    NN = {
      parity: function (t) {
        return t.filter((t, e) => e % 2 == 0);
      },
      greedy: function (t, e) {
        let i;
        return t.filter((t, n) => !((n && jN(i.AABBBounds, t.AABBBounds, e)) || ((i = t), 0)));
      }
    },
    VN = (t, e, i, n, s, r) => {
      let a = r,
        o = 0,
        l = 0,
        h = 0,
        c = -1,
        d = Number.MAX_VALUE;
      do {
        let r = !0;
        a++;
        let u = 0;
        do {
          u + a < t.length && LN(e[u], e[u + a], i) && (r = !1), (u += a);
        } while (r && u < t.length);
        if (r) {
          if (!n) {
            h = a;
            break;
          }
          {
            const n = t.length - 1;
            o = 0;
            do {
              if (((u -= a), u !== n && !LN(e[u], e[n], i))) break;
              o++;
            } while (u > 0);
            if (u === n) {
              (h = a), (l = o);
              break;
            }
            {
              const i = Math.floor(t.length / a) - o + 1;
              if (i < c) break;
              {
                c = i;
                const t = s ? 0 : 1,
                  r = FN(e[u], e[n])[t],
                  p = u - a >= 0 ? FN(e[u - a], e[u])[t] : r,
                  g = Math.abs(r - p);
                g < d && ((d = g), (h = a), (l = o));
              }
            }
          }
        }
      } while (a <= t.length);
      return { step: h, delCount: l };
    },
    WN = (t, e) => {
      const { tickCount: i, forceTickCount: n, tickStep: s, getRadius: r, labelOffset: a, labelGap: o = 0 } = e,
        l = null == r ? void 0 : r();
      if (!l) return DN(t.domain());
      let c;
      if (h(s)) c = t.stepTicks(s);
      else if (h(n)) c = t.forceTicks(n);
      else if (h(i)) c = t.ticks(i);
      else if (e.sampling) {
        const i = t.domain(),
          n = t.range(),
          s = ((t, e, i) => {
            var n;
            const { labelStyle: s, getRadius: r, labelOffset: a, labelFormatter: o } = i,
              l = null == r ? void 0 : r(),
              h = null !== (n = s.angle) && void 0 !== n ? n : 0,
              c = ON(s);
            return e.map(e => {
              const i = o ? o(e) : `${e}`,
                { width: n, height: s } = c.quickMeasure(i),
                r = Math.max(n, 12),
                d = Math.max(s, 12),
                u = t.scale(e);
              let p = 0,
                g = 0;
              const f = IN(u),
                { x: v, y: m } = te({ x: 0, y: 0 }, l + a, u);
              return (
                (p = v + ('right' === f.align ? -r : 'center' === f.align ? -r / 2 : 0)),
                (g = m + ('bottom' === f.baseline ? -d : 'middle' === f.baseline ? -d / 2 : 0)),
                new Kt().set(p, g, p + r, g + d).rotate(h, p + r / 2, g + d / 2)
              );
            });
          })(t, i, e),
          r = Math.min(...n),
          h = Math.max(...n),
          d = (Math.abs(h - r) * (l + a)) / i.length,
          { step: u, delCount: p } = GN(
            i,
            s,
            o,
            Math.floor(s.reduce((t, e) => Math.min(t, e.width(), e.height()), Number.MAX_VALUE) / d)
          );
        (c = t.stepTicks(u)), (c = c.slice(0, c.length - p));
      } else c = t.domain();
      return DN(c);
    },
    GN = (t, e, i, n) => {
      let s = n;
      do {
        let n = !0;
        s++;
        let r = 0;
        do {
          r + s < t.length && LN(e[r], e[r + s], i) && (n = !1), (r += s);
        } while (n && r < t.length);
        if (n) break;
      } while (s <= t.length);
      let r = 0;
      if (t.length > 2) {
        let i = t.length - (t.length % s);
        for (i >= t.length && (i -= s); i > 0 && LN(e[0], e[i]); ) r++, (i -= s);
      }
      return { step: s, delCount: r };
    },
    UN = (t, e) => {
      if (Zo(t.type))
        return ((t, e) => {
          if (!Zo(t.type)) return DN(t.domain());
          const i = t.range();
          if (Math.abs(i[i.length - 1] - i[0]) < 2) return DN([t.domain()[0]]);
          const { tickCount: n, forceTickCount: s, tickStep: r, noDecimals: a = !1 } = e;
          let o;
          if (
            ((o = h(r)
              ? t.stepTicks(r)
              : h(s)
              ? t.forceTicks(s)
              : 'd3' === e.tickMode
              ? t.d3Ticks(null != n ? n : 5, { noDecimals: a })
              : t.ticks(null != n ? n : 5, { noDecimals: a })),
            e.sampling &&
              ('cartesian' === e.coordinateType || ('polar' === e.coordinateType && 'radius' === e.axisOrientType)))
          ) {
            const { labelGap: i = 4, labelFlush: n } = e;
            let s = HN(t, o, e).map((t, e) => ({ AABBBounds: t, value: o[e] }));
            for (; s.length >= 3 && zN(s, i); ) s = NN.parity(s);
            const r = s.map(t => t.value);
            r.length < 3 && n && (r.length > 1 && r.pop(), W(r) !== W(o) && r.push(W(o))), (o = r);
          }
          return DN(o);
        })(t, e);
      if (Qo(t.type)) {
        if ('cartesian' === e.coordinateType)
          return ((t, e) => {
            var i;
            const n = t.domain();
            if (!n.length) return [];
            const { tickCount: s, forceTickCount: r, tickStep: a, labelGap: o = 4, axisOrientType: l } = e,
              c = ['bottom', 'top'].includes(l),
              d = t.range(),
              u = t.calculateWholeRangeSize();
            if (u < 2) return e.labelLastVisible ? DN([n[n.length - 1]]) : DN([n[0]]);
            let p;
            if (h(a)) p = t.stepTicks(a);
            else if (h(r)) p = t.forceTicks(r);
            else if (h(s)) p = t.ticks(s);
            else if (e.sampling) {
              let s;
              const r = (null !== (i = e.labelStyle.fontSize) && void 0 !== i ? i : 12) + 2;
              if (n.length <= u / r) s = HN(t, n, e);
              else {
                const i = [n[0], n[Math.floor(n.length / 2)], n[n.length - 1]],
                  r = HN(t, i, e);
                let a = null,
                  o = 0;
                r.forEach((t, e) => {
                  if (!a) return (a = t), void (o = e);
                  c ? a.width() < t.width() && ((a = t), (o = e)) : a.height() < t.height() && ((a = t), (o = e));
                });
                const l = 0 === o ? 0 : 2 === o ? n.length - 1 : Math.floor(n.length / 2),
                  h = t.scale(n[l]);
                s = new Array(n.length);
                for (let e = 0; e < s.length; e++) {
                  s[e] = a.clone();
                  const i = t.scale(n[e]);
                  c ? s[e].translate(i - h, 0) : s[e].translate(0, i - h);
                }
              }
              const a = s.map(t => (c ? t.width() : t.height())),
                l = Math.min(...d),
                h = (Math.max(...d) - l) / n.length,
                g = VN(n, s, o, e.labelLastVisible, c, Math.floor(Math.min(...a) / h));
              (p = t.stepTicks(g.step)),
                e.labelLastVisible && ((p = p.slice(0, p.length - g.delCount)), p.push(n[n.length - 1]));
            } else p = t.domain();
            return DN(p);
          })(t, e);
        if ('polar' === e.coordinateType && 'angle' === e.axisOrientType) return WN(t, e);
      }
      return DN(t.domain());
    };
  function YN(t) {
    return t.radius ? { x: Math.cos(t.angle) * t.radius, y: Math.sin(t.angle) * t.radius } : { x: 0, y: 0 };
  }
  function $N(t, e) {
    const i = e ? +t[0][e] : +t[0];
    if (!_(i)) return So('invalid data'), 0;
    return t.reduce((t, i) => {
      const n = e ? +i[e] : +i;
      return _(n) && n < t && (t = n), t;
    }, i);
  }
  function XN(t, e) {
    const i = e ? +t[0][e] : +t[0];
    if (!_(i)) return So('invalid data'), 0;
    return t.reduce((t, i) => {
      const n = e ? +i[e] : +i;
      return _(n) && n > t && (t = n), t;
    }, i);
  }
  function KN(t, e) {
    return t.reduce((t, i) => {
      const n = e ? +i[e] : +i;
      return _(n) && (t += n), t;
    }, 0);
  }
  function qN(t, e) {
    let i = 0,
      n = 0;
    t.forEach(t => {
      const s = e ? +t[e] : +t;
      _(s) && ((i += s), n++);
    });
    return i / n;
  }
  function ZN(t, e) {
    const i = qN(t, e);
    if (t.length <= 1) return 0;
    const n = t.reduce((t, n) => t + (e ? +n[e] : +n - i) ** 2, 0);
    return n / (t.length - 1);
  }
  function JN(t, e) {
    const i = QN(t),
      n = QN(e),
      s = Math.asin((t.x * e.y - e.x * t.y) / i / n),
      r = Math.acos((t.x * e.x + t.y * e.y) / i / n);
    return s < 0 ? -r : r;
  }
  function QN(t, e = { x: 0, y: 0 }) {
    return Yt.distancePP(t, e);
  }
  function tV(t, e, i) {
    let n = !1;
    if (e && o(e)) for (const s of t) for (const t of s.getSeries(i)) if (((n = !!e.call(null, t)), n)) return n;
    return n;
  }
  function eV(t, e) {
    const i = [];
    for (const n of t) for (const t of n.getSeries(e)) i.push(t);
    return i;
  }
  function iV(t) {
    return function (e) {
      let i;
      return (i = f(t) ? t.reduce((t, e) => (null == t ? void 0 : t[e]), e) : null == e ? void 0 : e[t]), i;
    };
  }
  function nV(t, e) {
    var i;
    const n = h(e) && null !== (i = null == t ? void 0 : t[e]) && void 0 !== i ? i : null == t ? void 0 : t.default;
    if (!n || f(n)) return n;
    if (c(n)) {
      const { dataScheme: i } = n;
      return i
        ? lV(i)
          ? i.map(i =>
              Object.assign(Object.assign({}, i), { scheme: i.scheme.map(i => (oV(i) ? rV(t, i, e) : i)).filter(h) })
            )
          : i.map(i => (oV(i) ? rV(t, i, e) : i)).filter(h)
        : [];
    }
    return [];
  }
  function sV(t, e) {
    var i, n;
    return lV(t)
      ? null !==
          (n =
            null ===
              (i = t.find(t =>
                h(t.isAvailable)
                  ? o(t.isAvailable)
                    ? t.isAvailable(e)
                    : !!t.isAvailable
                  : !h(t.maxDomainLength) || (null == e ? void 0 : e.length) <= t.maxDomainLength
              )) || void 0 === i
              ? void 0
              : i.scheme) && void 0 !== n
        ? n
        : t[t.length - 1].scheme
      : t;
  }
  function rV(t, e, i) {
    var n;
    const s = h(i) && null !== (n = t[i]) && void 0 !== n ? n : t.default;
    if (!s) return;
    let r;
    const { palette: a } = s;
    if (c(a)) {
      for (const t of V(e.key)) if (((r = a[t]), h(r))) break;
      r || (r = e.default);
    }
    if (!r) return;
    if ((!h(e.a) && !h(e.l)) || !g(r)) return r;
    let o = new xo(r);
    if (h(e.l)) {
      const { r: t, g: i, b: n } = o.color,
        { h: s, s: r } = se(t, i, n),
        a = ne(s, r, e.l),
        l = new xo(`rgb(${a.r}, ${a.g}, ${a.b})`);
      l.setOpacity(o.color.opacity), (o = l);
    }
    return h(e.a) && o.setOpacity(e.a), o.toRGBA();
  }
  const aV = (t, e, i) => {
    if (oV(t) && e) {
      const n = rV(e, t, i);
      if (n) return n;
    }
    return t;
  };
  function oV(t) {
    return c(t) && 'palette' === t.type && !!t.key;
  }
  function lV(t) {
    return !!f(t) && t.every(t => h(t.scheme));
  }
  class hV extends il {
    range(t) {
      return t ? ((this._range = t), this._resetRange(), this) : super.range();
    }
    domain(t) {
      return t ? (super.domain(t), this._resetRange(), this) : super.domain();
    }
    _resetRange() {
      if (!lV(this._range)) return void super.range(this._range);
      const t = sV(this._range, this._domain);
      super.range(t);
    }
  }
  const cV = { linear: Vl, band: xl, point: Ul, ordinal: il, threshold: Zl, colorOrdinal: hV };
  function dV(t) {
    const e = cV[t];
    return e ? new e() : null;
  }
  function uV(t, e) {
    if (!e) return t;
    const i = e.range(),
      n = Math.min(i[0], i[i.length - 1]),
      s = Math.max(i[0], i[i.length - 1]);
    return Math.min(Math.max(n, t), s);
  }
  function pV(t) {
    return h(null == t ? void 0 : t.field) && h(null == t ? void 0 : t.scale);
  }
  function gV(t) {
    switch (t) {
      case 'left':
      case 'right':
      case 'top':
      case 'bottom':
        return !0;
      default:
        return !1;
    }
  }
  function fV(t, e) {
    const { x: i, y: n, width: s, height: r } = e,
      { x: a, y: o } = t;
    return a < i + s && o < n + r && o > n && a > i;
  }
  function vV(t) {
    return !!g(t) && !!t.endsWith('%') && Oo(t.substring(0, t.length - 1));
  }
  function mV(t, e, i) {
    var n, s;
    return y(t)
      ? t
      : vV(t)
      ? (Number(t.substring(0, t.length - 1)) * e) / 100
      : o(t)
      ? t(i)
      : c(t)
      ? e * (null !== (n = t.percent) && void 0 !== n ? n : 0) + (null !== (s = t.offset) && void 0 !== s ? s : 0)
      : 0;
  }
  function yV(t, e, i) {
    var n, s, r, a;
    const o = { top: 0, bottom: 0, left: 0, right: 0 };
    if (Object.values(t).every(t => y(t)))
      return (
        (o.top = null !== (n = t.top) && void 0 !== n ? n : 0),
        (o.right = null !== (s = t.right) && void 0 !== s ? s : 0),
        (o.bottom = null !== (r = t.bottom) && void 0 !== r ? r : 0),
        (o.left = null !== (a = t.left) && void 0 !== a ? a : 0),
        o
      );
    return (
      [
        { orients: ['left', 'right'], size: e.width },
        { orients: ['top', 'bottom'], size: e.height }
      ].forEach(e => {
        e.orients.forEach(n => {
          o[n] = mV(t[n], e.size, i);
        });
      }),
      o
    );
  }
  function _V(t) {
    let e = {};
    return f(t)
      ? (l(t[0]) || (e.top = e.left = e.bottom = e.right = t[0]),
        l(t[1]) || (e.left = e.right = t[1]),
        l(t[2]) || (e.bottom = t[2]),
        l(t[3]) || (e.left = t[3]),
        e)
      : y(t) || vV(t) || o(t) || (c((i = t)) && ('percent' in i || 'offset' in i))
      ? ((e.top = e.left = e.bottom = e.right = t), e)
      : c(t)
      ? ((e = Object.assign({}, t)), e)
      : e;
    var i;
  }
  function bV(t, e, i) {
    return i ? { x: t.x + e.x, y: t.y + e.y } : t;
  }
  const xV = (t, e) => {
    const i = Number(t),
      n = t.toString();
    return isNaN(i) && '%' === n[n.length - 1] ? e * (Number(n.slice(0, n.length - 1)) / 100) : i;
  };
  const SV = [
      {
        maxDomainLength: 10,
        scheme: [
          '#1664FF',
          '#1AC6FF',
          '#FF8A00',
          '#3CC780',
          '#7442D4',
          '#FFC400',
          '#304D77',
          '#B48DEB',
          '#009488',
          '#FF7DDA'
        ]
      },
      {
        scheme: [
          '#1664FF',
          '#B2CFFF',
          '#1AC6FF',
          '#94EFFF',
          '#FF8A00',
          '#FFCE7A',
          '#3CC780',
          '#B9EDCD',
          '#7442D4',
          '#DDC5FA',
          '#FFC400',
          '#FAE878',
          '#304D77',
          '#8B959E',
          '#B48DEB',
          '#EFE3FF',
          '#009488',
          '#59BAA8',
          '#FF7DDA',
          '#FFCFEE'
        ]
      }
    ],
    wV = {
      default: {
        dataScheme: SV,
        palette: {
          backgroundColor: '#ffffff',
          borderColor: '#e3e5e8',
          shadowColor: '#21252c',
          primaryFontColor: '#21252c',
          secondaryFontColor: '#606773',
          axisFontColor: '#89909d',
          disableFontColor: '#bcc1cb',
          labelReverseFontColor: '#ffffff',
          axisGridColor: '#f1f2f5',
          axisDomainColor: '#D9DDE4',
          axisLabelFontColor: '#89909d',
          dataZoomHandlerStrokeColor: '#AEB5BE',
          dataZoomHandlerFillColor: '#ffffff',
          dataZoomBackgroundColor: '#f1f3f4',
          dataZoomChartColor: '#c9ced8',
          dataZoomSelectedColor: '#0040ff',
          scrollBarSliderColor: '#000000',
          tooltipBackgroundColor: '#ffffff',
          titleFontColor: '#21252c',
          labelFontColor: '#89909d'
        }
      }
    },
    AV =
      'PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol',
    kV = 14,
    MV = 32,
    TV = 20,
    CV = 16,
    EV = '150%',
    PV = 14,
    RV = '150%',
    OV = 12,
    BV = '130%',
    IV = 10,
    DV = 4,
    LV = 0.2,
    FV = {
      dot: { style: { size: 10, fillOpacity: 1 } },
      symbol: { style: { size: 10 } },
      title: { style: { textAlign: 'left', textBaseline: 'middle', fontSize: OV, lineHeight: BV, fontFamily: AV } },
      subTitle: { style: { textAlign: 'left', textBaseline: 'top', fontSize: OV, lineHeight: BV, fontFamily: AV } }
    },
    jV = {
      transform: { style: { fill: '#f5f5f5' } },
      label: { style: { fill: 'white', textBaseline: 'middle', lineWidth: 2 } },
      outerLabel: {
        style: { fontSize: PV, lineHeight: RV, fontFamily: AV, fill: '#707070' },
        line: { style: { stroke: { type: 'palette', key: 'axisDomainColor' } } }
      },
      transformLabel: {
        style: { fontSize: PV, lineHeight: RV, fontFamily: AV, fill: '#707070', textBaseline: 'middle' }
      }
    },
    zV = {
      transform3d: { style: { fill: '#f5f5f5' } },
      label: { style: { fill: 'white', textBaseline: 'middle', lineWidth: 2 } },
      outerLabel: {
        style: { fontSize: PV, lineHeight: RV, fontFamily: AV, fill: '#707070' },
        line: { style: { stroke: { type: 'palette', key: 'axisDomainColor' } } }
      },
      transformLabel: {
        style: { fontSize: PV, lineHeight: RV, fontFamily: AV, fill: '#707070', textBaseline: 'middle' }
      }
    },
    HV =
      'M1 0 C1 0.55228 0.55228 1 0 1 C-0.552285 1 -1 0.55228 -1 0 C-1 -0.552285 -0.552285 -1 0 -1 C0.55228 -1 1 -0.552285 1 0Z',
    NV = {
      pointer: {
        type: 'path',
        width: 0.4,
        height: 0.4,
        style: {
          path: 'M-0.020059 -0.978425 C-0.018029 -0.9888053 -0.013378 -1 0 -1 C0.01342 -1 0.01812 -0.989146 0.0201 -0.978425 C0.02161 -0.9702819 0.0692 -0.459505 0.09486 -0.184807 C0.10298 -0.097849 0.1089 -0.034548 0.11047 -0.018339 C0.11698 0.04908 0.07373 0.11111 0.00002 0.11111 C-0.07369 0.11111 -0.117184 0.04991 -0.110423 -0.018339 C-0.103662 -0.086591 -0.022089 -0.9680447 -0.020059 -0.978425Z'
        }
      },
      pin: { width: 0.025, height: 0.025, style: { path: HV, fill: '#888' } },
      pinBackground: { width: 0.06, height: 0.06, style: { path: HV, fill: '#ddd' } }
    },
    VV = {
      defaultFillColor: '#f3f3f3',
      area: { style: { lineWidth: 0.5, strokeOpacity: 1, stroke: 'black', fillOpacity: 1 } },
      label: {
        interactive: !1,
        style: {
          fontSize: IV,
          lineHeight: '120%',
          textBaseline: 'middle',
          fill: { type: 'palette', key: 'secondaryFontColor', default: '#89909d' },
          stroke: 'white'
        }
      }
    },
    WV = {
      seriesFieldName: { total: 'total', increase: 'increase', decrease: 'decrease' },
      leaderLine: { style: { stroke: 'black', lineWidth: 1, lineDash: [4, 4] } },
      stackLabel: {
        visible: !0,
        offset: 12,
        position: 'withChange',
        style: { fill: 'black', fontSize: PV, lineHeight: RV, fontFamily: AV }
      },
      label: { visible: !1, offset: 12, position: 'inside' }
    },
    GV = {
      gapWidth: 1,
      nodePadding: [5],
      nonLeaf: { visible: !1, style: { fillOpacity: 0.5 } },
      label: {
        style: {
          fill: 'white',
          textBaseline: 'middle',
          textAlign: 'center',
          fontSize: OV,
          lineHeight: BV,
          fontFamily: AV
        }
      },
      nonLeafLabel: {
        padding: 2 * OV,
        style: {
          fill: 'black',
          stroke: 'white',
          lineWidth: 2,
          fontSize: OV,
          lineHeight: BV,
          fontFamily: AV,
          textBaseline: 'middle',
          textAlign: 'center'
        }
      }
    },
    UV = '__VCHART',
    YV = 500,
    $V = 500,
    XV = `${UV}_LABEL_LIMIT`,
    KV = `${UV}_LABEL_ALIGN`,
    qV = `${UV}_LABEL_TEXT`,
    ZV = `${UV}_LABEL_VISIBLE`,
    JV = `${UV}_LABEL_X`,
    QV = `${UV}_LABEL_Y`,
    tW = `${UV}_ARC_RATIO`,
    eW = `${UV}_ARC_START_ANGLE`,
    iW = `${UV}_ARC_END_ANGLE`,
    nW = `${UV}_ARC_K`,
    sW = `${UV}_ARC_LABEL_POINT_BX`,
    rW = `${UV}_ARC_LABEL_POINT_BY`,
    aW = `${UV}_ARC_LABEL_POINT_CX`,
    oW = `${UV}_ARC_LABEL_POINT_CY`,
    lW = `${UV}_ARC_MIDDLE_ANGLE`,
    hW = `${UV}_ARC_QUADRANT`,
    cW = `${UV}_ARC_RADIAN`,
    dW = -Math.PI / 2,
    uW = (3 * Math.PI) / 2,
    pW = -90,
    gW = 270,
    fW = 0.6,
    vW = {},
    mW = [],
    yW = (t, e, i) => {
      (vW[t] = Object.assign(e, { type: t })), i || mW.push(t);
    },
    _W = () => {
      mW.slice().forEach(t => {
        (t => {
          delete vW[t];
          const e = mW.indexOf(t);
          e >= 0 && mW.splice(e, 1);
        })(t);
      });
    },
    bW = (t, e, i, n, s, r) => {
      const a = [i[0] >= r ? 1 : 0, i[1] >= r ? 1 : 0, i[2] >= r ? 1 : 0, i[3] >= r ? 1 : 0],
        o = [];
      a[0] !== a[1] &&
        o.push({
          id: `${t}-${e - 1}-${t}-${e}`,
          currentCell: e * s + t,
          nextCell: (e - 1) * s + t,
          point: { x: t + (r - i[0]) / (i[1] - i[0]), y: e },
          siblingPoint: null
        }),
        a[1] !== a[2] &&
          o.push({
            id: `${t}-${e}-${t + 1}-${e}`,
            currentCell: e * s + t,
            nextCell: e * s + t + 1,
            point: { x: t + 1, y: e + (r - i[1]) / (i[2] - i[1]) },
            siblingPoint: null
          }),
        a[2] !== a[3] &&
          o.push({
            id: `${t}-${e}-${t}-${e + 1}`,
            currentCell: e * s + t,
            nextCell: (e + 1) * s + t,
            point: { x: t + (r - i[3]) / (i[2] - i[3]), y: e + 1 },
            siblingPoint: null
          }),
        a[3] !== a[0] &&
          o.push({
            id: `${t - 1}-${e}-${t}-${e}`,
            currentCell: e * s + t,
            nextCell: e * s + t - 1,
            point: { x: t, y: e + (r - i[0]) / (i[3] - i[0]) },
            siblingPoint: null
          });
      const l = (8 & a[0]) + (4 & a[1]) + (2 & a[2]) + (1 & a[3]);
      return (
        6 === l || 9 === l
          ? ((o[0].siblingPoint = o[1]),
            (o[1].siblingPoint = o[0]),
            (o[2].siblingPoint = o[3]),
            (o[3].siblingPoint = o[2]))
          : 2 === o.length && ((o[0].siblingPoint = o[1]), (o[1].siblingPoint = o[0])),
        o
      );
    },
    xW = (t, e) => {
      const i = t.siblingPoint,
        n = SW(t, e);
      return 'loop' === n.result ? n.points : SW(i, e).points.reverse().concat(n.points);
    },
    SW = (t, e) => {
      const i = [t];
      let n = t;
      const s = t => t.id === n.id;
      let r = 'break';
      do {
        const t = e[n.nextCell],
          a = null == t ? void 0 : t.find(s);
        if (a) {
          if (((n = a.siblingPoint), i.includes(n))) {
            (r = 'loop'), i.push(n);
            break;
          }
          if (!n) break;
          i.push(n);
        } else n = null;
      } while (n);
      return { points: i, result: r };
    },
    wW = ['x', 'kde'],
    AW = ['x', 'y', 'kde'],
    kW = Math.sqrt(2 * Math.PI),
    MW = Math.sqrt((2 * Math.PI) ** 2),
    TW = function (t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
      const i = 1 === e ? kW : 2 === e ? MW : Math.sqrt((2 * Math.PI) ** e);
      return Math.exp(-(t ** 2) / 2) / i;
    },
    CW = (t, e, i) => {
      const n = e.length;
      return (
        e.reduce((e, n) => {
          const s = Math.abs(t.x - n.x);
          return e + TW(s / i, 1);
        }, 0) /
        (n * i)
      );
    },
    EW = (t, e, i) => {
      const n = e.length;
      return (
        e.reduce((e, n) => {
          const s = Yt.distancePP(t, n);
          return e + TW(s / i ** 2, 1);
        }, 0) /
        (n * i ** 2)
      );
    },
    PW = (t, e) => {
      const i = Ze.getInstance();
      let n = t.as;
      const { fields: s, from: r, key: a, values: o } = t,
        h = jo(a),
        c = (r || []).reduce((t, e) => ((t[h(e)] = e), t), {}),
        d = l(t.default) ? null : t.default,
        u = s.map(t => jo(t));
      if (o) {
        s.length > 1 && !n && i.error('Multi-field lookup requires explicit "as" parameter.'),
          n && n.length !== s.length * o.length && i.error('The "as" parameter has too few output field names.'),
          l(n) && (n = o);
        const t = o.map(t => jo(t));
        return e.map(e =>
          u.reduce((i, s, r) => {
            const a = c[s(e)],
              h = o.length;
            return (l(a) ? t.map(t => d) : t.map(t => t(a))).reduce((t, e, i) => ((t[n[r * h + i]] = e), t), i);
          }, e)
        );
      }
      return (
        n || i.error('Missing output field names.'),
        e.map(t =>
          u.reduce((e, i, s) => {
            const r = c[i(t)];
            return (e[n[s]] = l(r) ? d : r), e;
          }, t)
        )
      );
    };
  function RW(t, e) {
    return t
      ? t.map((t, i) => {
          var n, s;
          return null !== (n = e[i]) && void 0 !== n ? n : g(t) ? t : l((s = t)) ? null : s.fname;
        })
      : null;
  }
  function OW(t) {
    return (t = (function (t) {
      for (; t < 0; ) t += 2 * Math.PI;
      for (; t >= 2 * Math.PI; ) t -= 2 * Math.PI;
      return t;
    })(t)) > 0 && t <= Math.PI / 2
      ? 2
      : t > Math.PI / 2 && t <= Math.PI
      ? 3
      : t > Math.PI && t <= (3 * Math.PI) / 2
      ? 4
      : 1;
  }
  function BW(t, e) {
    return V(t).reduce((t, i) => {
      const n = g(i) ? e.getGrammarById(i) : i;
      return n && t.push(n), t;
    }, []);
  }
  function IW(t, e) {
    if (l(t)) return [];
    if (!o((i = t)) && (null == i ? void 0 : i.signal)) {
      const i = t.signal;
      if (g(i)) return V(e.getGrammarById(i));
      if ('signal' === (null == i ? void 0 : i.grammarType)) return [i];
    } else if (
      (function (t) {
        return !o(t) && !!(null == t ? void 0 : t.callback);
      })(t)
    )
      return BW(t.dependency, e);
    var i;
    return [];
  }
  function DW(t) {
    return o(t) || (null == t ? void 0 : t.signal) || !!(null == t ? void 0 : t.callback);
  }
  function LW(t, e, i, n) {
    if (l(t)) return t;
    if (o(t)) return n ? t.call(null, i, n, e) : t.call(null, i, e);
    if (t.signal) {
      const i = t.signal;
      return g(i) ? (null == e ? void 0 : e[i]) : i.output();
    }
    return t.callback ? (n ? t.callback.call(null, i, n, e) : t.callback.call(null, i, e)) : t;
  }
  function FW(t, e) {
    if (l(t)) return t;
    if (o(t)) return t.call(null, e);
    if (t.signal) {
      const i = t.signal;
      return g(i) ? (null == e ? void 0 : e[i]) : i.output();
    }
    return t.callback ? t.callback.call(null, e) : t;
  }
  function jW(t, e) {
    return zW(t) ? t.output() : e[t];
  }
  const zW = t => t && !l(t.grammarType),
    HW = t => (o(t) ? t : e => e[t]),
    NW = t => (g(t) && ue.parseColorString(t) ? t : null);
  var VW, WW, GW, UW, YW, $W, XW, KW, qW, ZW, JW, QW, tG, eG;
  !(function (t) {
    (t.enter = 'enter'), (t.update = 'update'), (t.exit = 'exit'), (t.group = 'group');
  })(VW || (VW = {})),
    (function (t) {
      (t.enter = 'enter'), (t.update = 'update'), (t.exit = 'exit'), (t.unChange = 'unChange');
    })(WW || (WW = {})),
    (function (t) {
      (t.arc = 'arc'),
        (t.arc3d = 'arc3d'),
        (t.area = 'area'),
        (t.image = 'image'),
        (t.line = 'line'),
        (t.path = 'path'),
        (t.rect = 'rect'),
        (t.rect3d = 'rect3d'),
        (t.rule = 'rule'),
        (t.shape = 'shape'),
        (t.symbol = 'symbol'),
        (t.text = 'text'),
        (t.richtext = 'richtext'),
        (t.polygon = 'polygon'),
        (t.pyramid3d = 'pyramid3d'),
        (t.circle = 'circle'),
        (t.cell = 'cell'),
        (t.interval = 'interval'),
        (t.group = 'group'),
        (t.glyph = 'glyph'),
        (t.component = 'component'),
        (t.largeRects = 'largeRects'),
        (t.largeSymbols = 'largeSymbols');
    })(GW || (GW = {})),
    (function (t) {
      (t.axis = 'axis'),
        (t.grid = 'grid'),
        (t.crosshair = 'crosshair'),
        (t.legend = 'legend'),
        (t.slider = 'slider'),
        (t.label = 'label'),
        (t.datazoom = 'datazoom'),
        (t.player = 'player'),
        (t.tooltip = 'tooltip'),
        (t.dimensionTooltip = 'dimensionTooltip'),
        (t.title = 'title');
    })(UW || (UW = {})),
    (function (t) {
      (t[(t.player = 1)] = 'player'),
        (t[(t.slider = 2)] = 'slider'),
        (t[(t.datazoom = 3)] = 'datazoom'),
        (t[(t.legend = 4)] = 'legend');
    })(YW || (YW = {})),
    (function (t) {
      (t.lineAxis = 'lineAxis'), (t.circleAxis = 'circleAxis');
    })($W || ($W = {})),
    (function (t) {
      (t.lineAxisGrid = 'lineAxisGrid'), (t.circleAxisGrid = 'circleAxisGrid');
    })(XW || (XW = {})),
    (function (t) {
      (t.discreteLegend = 'discreteLegend'), (t.colorLegend = 'colorLegend'), (t.sizeLegend = 'sizeLegend');
    })(KW || (KW = {})),
    (function (t) {
      (t.lineCrosshair = 'lineCrosshair'),
        (t.rectCrosshair = 'rectCrosshair'),
        (t.sectorCrosshair = 'sectorCrosshair'),
        (t.circleCrosshair = 'circleCrosshair'),
        (t.polygonCrosshair = 'polygonCrosshair'),
        (t.ringCrosshair = 'ringCrosshair');
    })(qW || (qW = {})),
    (function (t) {
      (t.symbolLabel = 'symbolLabel'),
        (t.rectLabel = 'rectLabel'),
        (t.lineLabel = 'lineLabel'),
        (t.dataLabel = 'dataLabel');
    })(ZW || (ZW = {})),
    (function (t) {
      (t.continuousPlayer = 'continuousPlayer'), (t.discretePlayer = 'discretePlayer');
    })(JW || (JW = {})),
    (function (t) {
      (t.before = 'before'), (t.layouting = 'layouting'), (t.reevaluate = 'reevaluate'), (t.after = 'after');
    })(QW || (QW = {})),
    (function (t) {
      (t.BEFORE_EVALUATE_DATA = 'beforeEvaluateData'),
        (t.AFTER_EVALUATE_DATA = 'afterEvaluateData'),
        (t.BEFORE_EVALUATE_SCALE = 'beforeEvaluateScale'),
        (t.AFTER_EVALUATE_SCALE = 'afterEvaluateScale'),
        (t.BEFORE_PARSE_VIEW = 'beforeParseView'),
        (t.AFTER_PARSE_VIEW = 'afterParseView'),
        (t.BEFORE_TRANSFORM = 'beforeTransform'),
        (t.AFTER_TRANSFORM = 'afterTransform'),
        (t.BEFORE_CREATE_VRENDER_STAGE = 'beforeCreateVRenderStage'),
        (t.AFTER_CREATE_VRENDER_STAGE = 'afterCreateVRenderStage'),
        (t.BEFORE_CREATE_VRENDER_LAYER = 'beforeCreateVRenderLayer'),
        (t.AFTER_CREATE_VRENDER_LAYER = 'afterCreateVRenderLayer'),
        (t.BEFORE_STAGE_RESIZE = 'beforeStageResize'),
        (t.AFTER_STAGE_RESIZE = 'afterStageResize'),
        (t.BEFORE_VRENDER_DRAW = 'beforeVRenderDraw'),
        (t.AFTER_VRENDER_DRAW = 'afterVRenderDraw'),
        (t.BEFORE_MARK_JOIN = 'beforeMarkJoin'),
        (t.AFTER_MARK_JOIN = 'afterMarkJoin'),
        (t.BEFORE_MARK_UPDATE = 'beforeMarkUpdate'),
        (t.AFTER_MARK_UPDATE = 'afterMarkUpdate'),
        (t.BEFORE_MARK_STATE = 'beforeMarkState'),
        (t.AFTER_MARK_STATE = 'afterMarkState'),
        (t.BEFORE_MARK_ENCODE = 'beforeMarkEncode'),
        (t.AFTER_MARK_ENCODE = 'afterMarkEncode'),
        (t.BEFORE_DO_LAYOUT = 'beforeDoLayout'),
        (t.AFTER_DO_LAYOUT = 'afterDoLayout'),
        (t.BEFORE_MARK_LAYOUT_END = 'beforeMarkLayoutEnd'),
        (t.AFTER_MARK_LAYOUT_END = 'afterMarkLayoutEnd'),
        (t.BEFORE_DO_RENDER = 'beforeDoRender'),
        (t.AFTER_DO_RENDER = 'afterDoRender'),
        (t.BEFORE_MARK_RENDER_END = 'beforeMarkRenderEnd'),
        (t.AFTER_MARK_RENDER_END = 'afterMarkRenderEnd'),
        (t.BEFORE_CREATE_VRENDER_MARK = 'beforeCreateVRenderMark'),
        (t.AFTER_CREATE_VRENDER_MARK = 'afterCreateVRenderMark'),
        (t.BEFORE_ADD_VRENDER_MARK = 'beforeAddVRenderMark'),
        (t.AFTER_ADD_VRENDER_MARK = 'afterAddVRenderMark'),
        (t.AFTER_VRENDER_NEXT_RENDER = 'afterVRenderNextRender'),
        (t.BEFORE_ELEMENT_UPDATE_DATA = 'beforeElementUpdateData'),
        (t.AFTER_ELEMENT_UPDATE_DATA = 'afterElementUpdateData'),
        (t.BEFORE_ELEMENT_STATE = 'beforeElementState'),
        (t.AFTER_ELEMENT_STATE = 'afterElementState'),
        (t.BEFORE_ELEMENT_ENCODE = 'beforeElementEncode'),
        (t.AFTER_ELEMENT_ENCODE = 'afterElementEncode'),
        (t.ANIMATION_START = 'animationStart'),
        (t.ANIMATION_END = 'animationEnd'),
        (t.ELEMENT_ANIMATION_START = 'elementAnimationStart'),
        (t.ELEMENT_ANIMATION_END = 'elementAnimationEnd'),
        (t.ALL_ANIMATION_START = 'allAnimationStart'),
        (t.ALL_ANIMATION_END = 'allAnimationEnd');
    })(tG || (tG = {})),
    (function (t) {
      (t.signal = 'signal'), (t.data = 'data'), (t.scale = 'scale'), (t.coordinate = 'coordinate'), (t.mark = 'mark');
    })(eG || (eG = {}));
  const iG = '__vgrammar_scene_item__',
    nG = [GW.line, GW.area],
    sG = [GW.arc3d, GW.rect3d, GW.pyramid3d],
    rG = 'key',
    aG = [{}],
    oG = ['key'],
    lG = 'VGRAMMAR_IMMEDIATE_ANIMATION',
    hG = 0,
    cG = 1e3,
    dG = 0,
    uG = !1,
    pG = !1,
    gG = 'quintInOut',
    fG = { stopWhenStateChange: !1, immediatelyApply: !0 };
  function vG(t, e, i) {
    const n = new Map();
    if (!t || 0 === t.length) return { keys: [], data: n };
    if (!e) return n.set(rG, i ? t.slice().sort(i) : t.slice()), { keys: oG, data: n };
    const s = HW(e),
      r = new Set();
    return (
      t.forEach(t => {
        var e;
        const i = s(t),
          a = null !== (e = n.get(i)) && void 0 !== e ? e : [];
        a.push(t), n.set(i, a), r.add(i);
      }),
      i &&
        r.forEach(t => {
          n.get(t).sort(i);
        }),
      { keys: Array.from(r), data: n }
    );
  }
  class mG {
    constructor(t, e, i) {
      this.prevData = vG(null != t ? t : [], null != e ? e : null, i);
    }
    setCurrentData(t) {
      this.currentData = t;
    }
    getCurrentData() {
      return this.currentData;
    }
    doDiff() {
      if (this.callback) {
        const t = new Map(this.prevData.data);
        this.currentData.keys.forEach(e => {
          this.callback(e, this.currentData.data.get(e), t.get(e)), t.delete(e);
        }),
          this.prevData.keys.forEach(e => {
            t.has(e) && this.callback(e, null, t.get(e));
          });
      }
    }
    setCallback(t) {
      this.callback = t;
    }
    updateToCurrent() {
      var t;
      (this.prevData = null !== (t = this.currentData) && void 0 !== t ? t : { keys: [], data: new Map() }),
        (this.currentData = null);
    }
    reset() {
      this.prevData = { keys: [], data: new Map() };
    }
  }
  const yG = {
      sum: t => t.reduce((t, e) => t + e, 0),
      min: t => Math.min.apply(null, t),
      max: t => Math.max.apply(null, t),
      count: t => t.length,
      mean: t => t.reduce((t, e) => t + e, 0) / t.length
    },
    _G = (t, e, i) => {
      let n = 0,
        s = Math.max(Math.ceil((2 * (e - t)) / Math.PI), 2),
        r = (e - t) / s,
        a = 0,
        o = 1,
        l = 0,
        h = 0;
      const c = [];
      let d = t;
      for (; l < i; )
        h < s && (c.push(d + (h % 2 ? Math.floor(h / 2) + Math.floor(s / 2) : h / 2) * r * o), h++),
          l++,
          h === s &&
            ((h = 0),
            (a += 1),
            (o *= -1),
            0 === n ? (n = r / 2) : (n /= 2),
            (d = -1 === o ? e - n : t + n),
            a >= 2 && ((r /= 2), (s *= 2)));
      return c;
    },
    bG = (t, e) =>
      !(!e || !e.length) &&
      e.some(e => Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2) < Math.pow(t.radius + e.radius, 2));
  function xG(t, e, i, n) {
    const s = Math.floor(e.length / t),
      r = [],
      a = e.length;
    let o,
      l,
      h,
      c = 0,
      d = 0;
    r[d++] = c;
    for (let t = 1; t < a - 1; t += s) {
      const u = Math.min(t + s, a - 1),
        p = Math.min(t + 2 * s, a),
        g = (p + u) / 2;
      let f = 0;
      for (let t = u; t < p; t++) {
        const s = i ? e[t].y : e[t][n];
        Number.isNaN(s) || (f += s);
      }
      f /= p - u;
      const v = t,
        m = Math.min(t + s, a),
        y = t - 1,
        _ = i ? e[c].y : e[c][n];
      (o = -1), (h = v);
      for (let t = v; t < m; t++) {
        const s = i ? e[t].y : e[t][n];
        Number.isNaN(s) || ((l = Math.abs((y - g) * (s - _) - (y - t) * (f - _))), l > o && ((o = l), (h = t)));
      }
      (r[d++] = h), (c = h);
    }
    return r[d - 1] !== a - 1 && (r[d++] = a - 1), r.map(t => (i ? e[t].i : t));
  }
  const SG = ':vGrammar_identifier:';
  function wG(t) {
    return !!(null == t ? void 0 : t.scale);
  }
  function AG(t) {
    return !!(null == t ? void 0 : t.field);
  }
  function kG(t, e) {
    if (!t) return [];
    let i = [];
    return t.scale && (i = zW(t.scale) ? [t.scale] : V(e.getScaleById(t.scale))), i.concat(IW(t, e));
  }
  class MG {
    constructor(t, e, i, n) {
      (this.channelEncoder = {}),
        (this.marks = t),
        e && this.registerChannelEncoder(e),
        i && this.registerDefaultEncoder(i),
        this.progressiveChannels && this.registerProgressiveChannels(n);
    }
    getMarks() {
      return this.marks;
    }
    registerChannelEncoder(t, e) {
      return g(t) ? (this.channelEncoder[t] = e) : Object.assign(this.channelEncoder, t), this;
    }
    registerFunctionEncoder(t) {
      return (this.functionEncoder = t), this;
    }
    registerDefaultEncoder(t) {
      return (this.defaultEncoder = t), this;
    }
    registerProgressiveChannels(t) {
      return (this.progressiveChannels = V(t)), this;
    }
    getChannelEncoder() {
      return this.channelEncoder;
    }
    getFunctionEncoder() {
      return this.functionEncoder;
    }
    getDefaultEncoder() {
      return this.defaultEncoder;
    }
    getProgressiveChannels() {
      return this.progressiveChannels;
    }
  }
  const TG = {},
    CG = t => TG[t],
    EG = (t, e, i, n, s) => ((TG[t] = new MG(e, i, n, s)), TG[t]);
  function PG(t) {
    return null === t ? 0 : t;
  }
  function RG(t, e) {
    switch (e) {
      case 'line':
        return t.some(t => ['x', 'y', 'defined'].includes(t));
      case 'area':
        return t.some(t => ['x', 'y', 'x1', 'y1', 'defined'].includes(t));
      case 'largeRects':
        return t.some(t => ['x', 'y', 'width', 'y1'].includes(t));
      case 'largeSymbols':
        return t.some(t => ['x', 'y'].includes(t));
    }
    return !1;
  }
  const OG = ['fillOpacity', 'x', 'y', 'dx', 'dy'],
    BG = (t, e, i) => {
      var n;
      return 'fillOpacity' === e
        ? ((t.fillOpacity = null !== (n = i.fillOpacity) && void 0 !== n ? n : 1), ['fillOpacity'])
        : 'x' === e
        ? ((t.x = PG(i.x)), ['x'])
        : 'y' === e
        ? ((t.y = PG(i.y)), ['y'])
        : 'dx' === e
        ? ((t.dx = PG(i.dx)), ['dx'])
        : 'dy' === e
        ? ((t.dy = PG(i.dy)), ['dy'])
        : [];
    };
  const IG = {
    [GW.largeRects]: [
      {
        channels: ['x', 'y', 'y1', 'x1', 'width', 'height'],
        transform: (t, e, i) => {
          (t.x = 0), (t.y = 0);
        }
      }
    ],
    [GW.largeSymbols]: [
      {
        channels: ['x', 'y', 'size'],
        transform: (t, e, i) => {
          (t.x = 0), (t.y = 0);
        }
      }
    ],
    [GW.area]: [
      {
        channels: ['x', 'y', 'x1', 'y1'],
        transform: (t, e, i) => {
          (t.x = 0), (t.y = 0), (t.x1 = 0), (t.y1 = 0);
        }
      }
    ],
    [GW.line]: [
      {
        channels: ['x', 'y', 'defined', 'enableSegments'],
        transform: (t, e, i) => {
          (t.x = 0), (t.y = 0);
        }
      }
    ],
    [GW.rect]: [
      {
        channels: ['x', 'y', 'x1', 'y1', 'width', 'height'],
        transform: (t, e, i) => {
          var n, s, r, a, o, l, h, c;
          _(e.width) || (!_(e.x1) && _(i.width))
            ? ((t.x = Math.min(
                null !== (n = i.x) && void 0 !== n ? n : 0,
                null !== (s = i.x1) && void 0 !== s ? s : 1 / 0
              )),
              (t.width = i.width))
            : _(e.x1) || (!_(e.width) && _(i.x1))
            ? ((t.x = Math.min(i.x, i.x1)), (t.width = Math.abs(i.x1 - i.x)))
            : ((t.x = Math.min(
                null !== (r = i.x) && void 0 !== r ? r : 0,
                null !== (a = i.x1) && void 0 !== a ? a : 1 / 0
              )),
              (t.width = i.width)),
            _(e.height) || (!_(e.y1) && _(i.height))
              ? ((t.y = Math.min(
                  null !== (o = i.y) && void 0 !== o ? o : 0,
                  null !== (l = i.y1) && void 0 !== l ? l : 1 / 0
                )),
                (t.height = i.height))
              : _(e.y1) || (!_(e.height) && _(i.y1))
              ? ((t.y = Math.min(i.y, i.y1)), (t.height = Math.abs(i.y1 - i.y)))
              : ((t.y = Math.min(
                  null !== (h = i.y) && void 0 !== h ? h : 0,
                  null !== (c = i.y1) && void 0 !== c ? c : 1 / 0
                )),
                (t.height = i.height));
        },
        storedAttrs: 'sizeAttrs'
      }
    ],
    rect3d: [
      {
        channels: ['x', 'y', 'z', 'x1', 'y1', 'width', 'height', 'length'],
        transform: (t, e, i) => {
          var n, s, r, a, o, l, h, c, d, u, p, g;
          _(e.width) || (!_(e.x1) && _(i.width))
            ? ((t.x = Math.min(
                null !== (n = i.x) && void 0 !== n ? n : 0,
                null !== (s = i.x1) && void 0 !== s ? s : 1 / 0
              )),
              (t.width = i.width))
            : _(e.x1) || (!_(e.width) && _(i.x1))
            ? ((t.x = Math.min(i.x, i.x1)), (t.width = Math.abs(i.x1 - i.x)))
            : ((t.x = Math.min(
                null !== (r = i.x) && void 0 !== r ? r : 0,
                null !== (a = i.x1) && void 0 !== a ? a : 1 / 0
              )),
              (t.width = i.width)),
            _(e.height) || (!_(e.y1) && _(i.height))
              ? ((t.y = Math.min(
                  null !== (o = i.y) && void 0 !== o ? o : 0,
                  null !== (l = i.y1) && void 0 !== l ? l : 1 / 0
                )),
                (t.height = i.height))
              : _(e.y1) || (!_(e.height) && _(i.y1))
              ? ((t.y = Math.min(i.y, i.y1)), (t.height = Math.abs(i.y1 - i.y)))
              : ((t.y = Math.min(
                  null !== (h = i.y) && void 0 !== h ? h : 0,
                  null !== (c = i.y1) && void 0 !== c ? c : 1 / 0
                )),
                (t.height = i.height)),
            _(e.length) || (!_(e.z1) && _(i.length))
              ? ((t.z = Math.min(
                  null !== (d = i.z) && void 0 !== d ? d : 0,
                  null !== (u = i.z1) && void 0 !== u ? u : 1 / 0
                )),
                (t.length = i.length))
              : _(e.z1) || (!_(e.length) && _(i.z1))
              ? ((t.z = Math.min(i.z, i.z1)), (t.length = Math.abs(i.z1 - i.z)))
              : ((t.z = Math.min(
                  null !== (p = i.z) && void 0 !== p ? p : 0,
                  null !== (g = i.z1) && void 0 !== g ? g : 1 / 0
                )),
                (t.length = i.length));
        },
        storedAttrs: 'sizeAttrs'
      }
    ],
    [GW.text]: [
      {
        channels: ['text', 'limit', 'autoLimit', 'maxLineWidth'],
        transform: (t, e, i) => {
          var n, s;
          const r = null !== (n = i.limit) && void 0 !== n ? n : 1 / 0,
            a = null !== (s = i.autoLimit) && void 0 !== s ? s : 1 / 0,
            o = Math.min(r, a);
          Array.isArray(i.text), (t.maxLineWidth = o === 1 / 0 ? i.maxLineWidth : o), (t.text = i.text);
        },
        storedAttrs: 'limitAttrs'
      }
    ],
    [GW.rule]: [
      {
        channels: ['x', 'y', 'x1', 'y1'],
        transform: (t, e, i) => {
          const n = (function (t) {
            const { x: e, y: i, x1: n, y1: s } = t;
            return _(e) && _(i) && _(n) && _(s)
              ? [
                  { x: e, y: i },
                  { x: n, y: s }
                ]
              : [];
          })(i);
          (t.points = n), (t.x = 0), (t.y = 0);
        },
        storedAttrs: 'pointAttrs'
      }
    ],
    [GW.symbol]: [
      {
        channels: ['shape', 'symbolType'],
        transform: (t, e, i) => {
          var n;
          t.symbolType = null !== (n = e.shape) && void 0 !== n ? n : e.symbolType;
        }
      },
      {
        channels: ['image', 'fill', 'background'],
        transform: (t, e, i) => {
          e.image
            ? ((t.background = e.image), (t.fill = !1))
            : i.image
            ? ((t.background = i.image), (t.fill = !1))
            : ((t.fill = i.fill), (t.background = i.background));
        },
        storedAttrs: 'imageAttrs'
      }
    ]
  };
  const DG = (t, e, i, n) => {
      const s = {},
        r = Object.keys(e),
        a = g(t) ? IG[t] : t;
      if (null == a ? void 0 : a.length) {
        const t = [];
        r.forEach(r => {
          let o = !1;
          a.forEach((a, l) => {
            if (a.channels.includes(r)) {
              if (!t[l])
                if (a.storedAttrs) {
                  const t = (function (t, e, i, n, s, r) {
                    var a;
                    const o = null !== (a = s.getGraphicAttribute(t, !1, r)) && void 0 !== a ? a : {},
                      l = {};
                    return (
                      e.forEach(t => {
                        var e;
                        l[t] = null !== (e = n[t]) && void 0 !== e ? e : o[t];
                      }),
                      (i[t] = l),
                      l
                    );
                  })(a.storedAttrs, a.channels, s, e, i, n);
                  a.transform(s, e, t);
                } else a.transform(s, e, null);
              (t[l] = !0), (o = !0);
            }
          }),
            o || (OG.includes(r) ? BG(s, r, e) : (s[r] = e[r]));
        });
      } else
        r.forEach(t => {
          OG.includes(t) ? BG(s, t, e) : (s[t] = e[t]);
        });
      return s;
    },
    LG = (t, e, i) =>
      !(!l(t) || !l(e)) ||
      (!l(t) &&
        !l(e) &&
        ('lineDash' === i
          ? ((t, e) => t.length === e.length && t.join('-') === e.join('-'))(t, e)
          : 'stroke' === i || 'fill' === i
          ? ((t, e) => {
              if (t === e) return !0;
              if (typeof t != typeof e) return !1;
              if (g(t)) return !1;
              if (t.gradient !== e.gradient) return !1;
              const i = Object.keys(t),
                n = Object.keys(e);
              return (
                i.length === n.length &&
                i.every(i =>
                  'stops' === i
                    ? ((t, e) => {
                        var i, n;
                        if (t === e) return !0;
                        const s = null !== (i = t && t.length) && void 0 !== i ? i : 0;
                        return (
                          s === (null !== (n = e && e.length) && void 0 !== n ? n : 0) &&
                          0 !== s &&
                          t.every(
                            (t, i) => (!t && !e[i]) || (t && e[i] && t.color === e[i].color && t.offset === e[i].offset)
                          )
                        );
                      })(t[i], e[i])
                    : t[i] === e[i]
                )
              );
            })(t, e)
          : t === e)),
    FG = ['stroke', 'strokeOpacity', 'lineDash', 'lineDashOffset', 'lineCap', 'lineJoin', 'lineWidth', 'miterLimit'],
    jG = ['fill', 'fillOpacity', 'background', 'texture', 'texturePadding', 'textureSize', 'textureColor'].concat(FG);
  function zG(t, e) {
    if (['x', 'y', 'dx', 'dy'].includes(e)) return !0;
    switch (t) {
      case GW.arc:
        return ['innerRadius', 'outerRadius', 'startAngle', 'endAngle'].includes(e);
      case GW.group:
      case GW.rect:
      case GW.image:
        return ['width', 'height', 'y1'].includes(e);
      case GW.path:
      case GW.shape:
        return ['path', 'customPath'].includes(e);
      case GW.line:
        return 'defined' === e;
      case GW.area:
        return ['x1', 'y1', 'defined'].includes(e);
      case GW.rule:
        return ['x1', 'y1'].includes(e);
      case GW.symbol:
        return 'size' === e;
      case GW.polygon:
        return 'points' === e;
      case GW.text:
        return 'text' === e;
    }
    return !1;
  }
  function HG(t, e, i, n, s) {
    i &&
      (DW(i)
        ? e.forEach(e => {
            const s = LW(i, n, e.datum, t);
            Object.assign(e.nextAttrs, s);
          })
        : Object.keys(i).forEach(r => {
            var a, o;
            const h = i[r],
              c = s && !zG(t.mark.markType, r) ? [e[0]] : e;
            if (wG(h)) {
              const t = jW(h.scale, n),
                e = null !== (a = null == h ? void 0 : h.offset) && void 0 !== a ? a : 0,
                i = !l(h.band) && t.bandwidth ? t.bandwidth() * h.band : null,
                s = g(null == h ? void 0 : h.field),
                d = s ? jo(h.field) : null;
              let u = s
                ? null
                : l(null == h ? void 0 : h.value)
                ? 0
                : null === (o = t.scale) || void 0 === o
                ? void 0
                : o.call(t, h.value);
              c.forEach(n => {
                var a;
                s && (u = null === (a = t.scale) || void 0 === a ? void 0 : a.call(t, d(n.datum))),
                  (n.nextAttrs[r] = y(u) || y(i) ? u + e + i : u);
              });
            } else if (AG(h)) {
              const t = jo(h.field);
              c.forEach(e => {
                e.nextAttrs[r] = t(e.datum);
              });
            } else
              c.forEach(e => {
                e.nextAttrs[r] = LW(h, n, e.datum, t);
              });
          }));
  }
  function NG(t, e, i, n) {
    if (!t) return null;
    if (DW(t)) return LW(t, n, e, i);
    const s = {};
    return (
      Object.keys(t).forEach(r => {
        var a, o, h;
        const c = t[r];
        if (wG(c)) {
          const t = jW(c.scale, n),
            i = null !== (a = null == c ? void 0 : c.offset) && void 0 !== a ? a : 0,
            d = !l(c.band) && t.bandwidth ? t.bandwidth() * c.band : null,
            u = g(null == c ? void 0 : c.field),
            p = u ? jo(c.field) : null,
            f = u
              ? null === (o = t.scale) || void 0 === o
                ? void 0
                : o.call(t, p(e))
              : l(null == c ? void 0 : c.value)
              ? 0
              : null === (h = t.scale) || void 0 === h
              ? void 0
              : h.call(t, c.value);
          s[r] = y(f) || y(d) ? f + i + d : f;
        } else if (AG(c)) {
          const t = jo(c.field);
          s[r] = t(e);
        } else s[r] = LW(c, n, e, i);
      }),
      s
    );
  }
  function VG(t) {
    return t && (t.type === qo.Band || t.type === qo.Point);
  }
  function WG(t) {
    if (t) return t.type === qo.Band ? t.bandwidth() : t.type === qo.Point ? t.step() : void 0;
  }
  const GG = (t, e, i) => {
      var n, s, r, a;
      const o = e[0].mark,
        h = null === (n = o.getScalesByChannel()) || void 0 === n ? void 0 : n[i],
        c = null !== (s = t.random) && void 0 !== s ? s : Math.random,
        d = Math.min(null !== (r = 'x' === i ? t.widthRatio : t.heightRatio) && void 0 !== r ? r : 0.4, 0.5),
        u = null !== (a = 'x' === i ? t.bandWidth : t.bandHeight) && void 0 !== a ? a : WG(h);
      if (l(u)) {
        let t = Go(e, t => t.getItemAttribute(i));
        if (l(t[0]) || l(t[1]) || t[0] === t[1]) {
          const e = o.view.getViewBox();
          t = 'x' === i ? [e.x1, e.x2] : [e.y1, e.y2];
        }
        const n = e.length;
        e.forEach((e, s) => {
          e.setItemAttributes({ [i]: t[0] + (t[1] - t[0]) * c(s, n) });
        });
      } else {
        const t = e.length;
        e.forEach((e, n) => {
          const s = e.getItemAttribute(i),
            r = [s - d * u, s + d * u];
          e.setItemAttributes({ [i]: r[0] + (r[1] - r[0]) * c(n, t) });
        });
      }
    },
    UG = {
      bin: {
        transform: (t, e) => {
          if (!e || 0 === e.length) return e;
          const { extent: i, step: n } = t,
            s = h(t.bins) ? Math.max(t.bins, 1) : 10,
            r = i[1] - i[0],
            a = h(n) ? n : r / s;
          return e.map(e => {
            var n, s, r, o;
            const l = Object.assign({}, e),
              h = e[t.field],
              c = Math.floor((h - i[0]) / a),
              d = i[0] + c * a,
              u = Math.min(i[1], i[0] + (c + 1) * a);
            return (
              (l[null !== (s = null === (n = t.as) || void 0 === n ? void 0 : n[0]) && void 0 !== s ? s : 'binStart'] =
                d),
              (l[null !== (o = null === (r = t.as) || void 0 === r ? void 0 : r[1]) && void 0 !== o ? o : 'binEnd'] =
                u),
              l
            );
          });
        },
        markPhase: 'beforeJoin'
      },
      contour: {
        transform: (t, e) => {
          var i;
          if (!e || 0 === e.length) return e;
          const n = t.row,
            s = t.column,
            r = n - 1,
            a = s - 1,
            o = e.map(e => e[t.field]),
            l = [Math.min.apply(null, o), Math.max.apply(null, o)],
            c = null !== (i = t.thresholds) && void 0 !== i ? i : [];
          if (!h(t.thresholds) && _(t.levels)) {
            const e = (l[1] - l[0]) / t.levels;
            for (let i = 1; i < t.levels; i++) c.push(l[0] + i * e);
          }
          const d = [];
          for (let t = 1; t < n; t++)
            for (let e = 1; e < s; e++) {
              const i = o[(t - 1) * s + e - 1],
                n = o[(t - 1) * s + e],
                r = o[t * s + e],
                a = o[t * s + e - 1];
              d.push([i, n, r, a]);
            }
          const u = [];
          return (
            c.forEach(e => {
              var i, o;
              const l = [],
                h = [];
              for (let t = 0; t < r; t++)
                for (let i = 0; i < a; i++) {
                  const n = d[t * a + i],
                    s = bW(i, t, n, 0, a, e);
                  l.push(...s), h.push(s);
                }
              let c = l.slice();
              do {
                const r = xW(c[0], h);
                if ((c.splice(0, 1), r.length)) {
                  const a = r.map(t => t.id);
                  c = c.filter(t => !a.includes(t.id));
                  const l = {
                    [null !== (i = t.asThreshold) && void 0 !== i ? i : 'threshold']: e,
                    [null !== (o = t.asPoints) && void 0 !== o ? o : 'points']: r.map(t => ({
                      x: t.point.x / n,
                      y: t.point.y / s
                    }))
                  };
                  u.push(l);
                }
              } while (c.length > 0);
            }),
            u
          );
        },
        markPhase: 'beforeJoin'
      },
      sort: {
        transform: (t, e) => {
          const i = t.sort;
          if (i && e) {
            const t = o(i) ? i : Wo(i.field, i.order);
            e.sort((e, i) => t(e, i));
          }
          return e;
        },
        markPhase: 'beforeJoin'
      },
      filter: { transform: (t, e, i) => e.filter(e => t.callback(e, i)), markPhase: 'beforeJoin' },
      join: { transform: PW, markPhase: 'beforeJoin' },
      kde: {
        transform: (t, e) => {
          var i, n, s, r, a, o, l, h, c, d, u, p, g, f, v, m, _, b, x, S, w;
          if (!e || 0 === e.length) return e;
          const A = null !== (i = t.dimension) && void 0 !== i ? i : '1d',
            k = V(t.field),
            M = V(null !== (n = t.bins) && void 0 !== n ? n : 256),
            T = V(t.as);
          if ('1d' === A) {
            const i = e.map(t => ({ x: t[k[0]] })),
              n =
                null !== (s = t.bandwidth) && void 0 !== s
                  ? s
                  : (function (t) {
                      const e = t.length,
                        i = t.reduce((t, e) => t + e.x, 0) / e,
                        n = Math.sqrt(t.reduce((t, e) => t + (e.x - i) ** 2, 0) / e),
                        s = t.sort((t, e) => t.x - e.x).map(t => t.x),
                        r = Z(s, 0.25),
                        a = Z(s, 0.75) - r;
                      return 0.9 * Math.min(n, a / 1.34) * e ** -0.2;
                    })(i),
              d = i.reduce((t, e) => Math.min(t, e.x), i[0].x),
              u = i.reduce((t, e) => Math.max(t, e.x), i[0].x),
              p = null !== (a = null === (r = t.extent) || void 0 === r ? void 0 : r[0]) && void 0 !== a ? a : d,
              g = null !== (l = null === (o = t.extent) || void 0 === o ? void 0 : o[1]) && void 0 !== l ? l : u,
              f = [
                y(p) ? p : null !== (h = p.x) && void 0 !== h ? h : d,
                y(g) ? g : null !== (c = g.x) && void 0 !== c ? c : u
              ],
              v = (f[1] - f[0]) / M[0],
              m = new Array(M[0]).fill(0).map((t, e) => {
                var s, r;
                const a = Math.min(f[0] + v * (e + 0.5), f[1]);
                return {
                  [null !== (s = T[0]) && void 0 !== s ? s : wW[0]]: a,
                  [null !== (r = T[1]) && void 0 !== r ? r : wW[0]]: CW({ x: a }, i, n)
                };
              });
            return m;
          }
          if ('2d' === A) {
            const i = e.map(t => ({ x: t[k[0]], y: t[k[1]] })),
              n =
                t.bandwidth ||
                (function (t) {
                  let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                  return t.length ** (-1 / (e + 4));
                })(i, 2),
              s = i.reduce((t, e) => ({ x: Math.min(t.x, e.x), y: Math.min(t.y, e.y) }), i[0]),
              r = i.reduce((t, e) => ({ x: Math.max(t.x, e.x), y: Math.max(t.y, e.y) }), i[0]),
              a = null !== (u = null === (d = t.extent) || void 0 === d ? void 0 : d[0]) && void 0 !== u ? u : s,
              o = null !== (g = null === (p = t.extent) || void 0 === p ? void 0 : p[1]) && void 0 !== g ? g : r,
              l = [
                y(a)
                  ? { x: a, y: a }
                  : {
                      x: null !== (f = a.x) && void 0 !== f ? f : s.x,
                      y: null !== (v = a.y) && void 0 !== v ? v : s.y
                    },
                y(o)
                  ? { x: o, y: o }
                  : { x: null !== (m = o.x) && void 0 !== m ? m : r.x, y: null !== (_ = o.y) && void 0 !== _ ? _ : r.y }
              ],
              h = M[0],
              c = null !== (b = M[1]) && void 0 !== b ? b : M[0],
              A = (l[1].x - l[0].x) / h,
              C = (l[1].y - l[0].y) / c,
              E = [];
            for (let t = 0; t < c; t++)
              for (let e = 0; e < h; e++) {
                const s = Math.min(l[0].x + A * (e + 0.5), l[1].x),
                  r = Math.min(l[0].y + C * (t + 0.5), l[1].y);
                E.push({
                  [null !== (x = T[0]) && void 0 !== x ? x : AW[0]]: s,
                  [null !== (S = T[1]) && void 0 !== S ? S : AW[1]]: r,
                  [null !== (w = T[2]) && void 0 !== w ? w : AW[2]]: EW({ x: s, y: r }, i, n)
                });
              }
            return E;
          }
          return [];
        },
        markPhase: 'beforeJoin'
      },
      map: {
        transform: (t, e, i) => {
          const n = t.callback,
            s = t.as;
          if (!t.all)
            return (
              e.forEach(t => {
                const e = n(t, i);
                if (!l(s)) {
                  if (l(t)) return;
                  t[s] = e;
                }
                return e;
              }),
              e
            );
          const r = n(e, i);
          return l(s) || l(e) ? r : ((e[s] = r), e);
        },
        markPhase: 'beforeJoin'
      },
      lookup: { transform: PW, markPhase: 'beforeJoin' },
      pick: {
        transform: (t, e) => {
          const { fields: i = [] } = t,
            n = RW(i, t.as || []),
            s = i.map(t => (g(t) ? jo(t) : t));
          return s.length
            ? e.map((t, e) =>
                (function (t, e, i) {
                  return e.reduce((e, n, s) => ((e[i[s]] = n(t)), e), {});
                })(t, s, n)
              )
            : e.map((t, e) => ({}));
        },
        markPhase: 'beforeJoin'
      },
      range: {
        transform: t => {
          const { start: e, stop: i, step: n = 1, as: s = 'data' } = t;
          return X(e, i, n).map(t => ({ [s]: t }));
        },
        markPhase: 'beforeJoin'
      },
      stack: {
        transform: (t, e) => {
          var i;
          const n = null !== (i = t.offset) && void 0 !== i ? i : 'diverging',
            s = ((t, e) => {
              var i;
              const n = new Map(),
                s = new Map(),
                r = null !== (i = t.offset) && void 0 !== i ? i : 'diverging';
              return e.map(e => {
                var i;
                const a = e[t.dimensionField],
                  o = 'diverging' === r ? e[t.stackField] : Math.abs(e[t.stackField]),
                  l = o >= 0 ? n : s,
                  h = null !== (i = l.get(a)) && void 0 !== i ? i : 0,
                  c = o + h;
                return l.set(a, c), { dimension: a, value: o, stack: c, prevStack: h, datum: e };
              });
            })(t, 'negative' === t.order ? e.slice().reverse() : e);
          'silhouette' === n
            ? ((t, e) => {
                if (!e || 0 === e.length) return e;
                const i = vG(e, jo('dimension'));
                i.keys.forEach(t => {
                  const e = i.data.get(t);
                  if (!e || e.length <= 0) return 0;
                  const n = -e.reduce((t, e) => t + e.value, 0) / 2;
                  e.forEach(t => {
                    (t.stack = t.stack + n), (t.prevStack = t.prevStack + n);
                  });
                });
              })(0, s)
            : 'wiggle' === n &&
              ((t, e) => {
                if (!e || 0 === e.length) return e;
                const i = vG(e, jo('dimension'));
                i.keys.forEach(t => {
                  const e = i.data.get(t);
                  if (!e || e.length <= 0) return 0;
                  const n = e.length,
                    s = (-1 / (n + 1)) * e.reduce((t, e, i) => e.value * (n - i + 1), 0);
                  e.forEach(t => {
                    (t.stack = t.stack + s), (t.prevStack = t.prevStack + s);
                  });
                });
              })(0, s);
          const r = ((t, e) => {
            if (!(t.asPercentStack || t.asPrevPercentStack || t.asPercent || t.asSum))
              return e.map(e => {
                var i;
                const { stack: n, prevStack: s, datum: r } = e,
                  a = Object.assign({}, r);
                return (
                  (a[null !== (i = t.asStack) && void 0 !== i ? i : t.stackField] = n),
                  t.asPrevStack && (a[t.asPrevStack] = s),
                  a
                );
              });
            const i = new Map(),
              n = new Map();
            return (
              e.forEach(t => {
                var e;
                const { dimension: s, value: r } = t,
                  a = r >= 0 ? i : n;
                a.set(s, (null !== (e = a.get(s)) && void 0 !== e ? e : 0) + r);
              }),
              e.map(e => {
                var s, r;
                const { dimension: a, value: o, stack: l, prevStack: h, datum: c } = e,
                  d = Object.assign({}, c),
                  u = null !== (s = (o >= 0 ? i : n).get(a)) && void 0 !== s ? s : 0;
                return (
                  (d[null !== (r = t.asStack) && void 0 !== r ? r : t.stackField] = l),
                  t.asPrevStack && (d[t.asPrevStack] = h),
                  t.asSum && (d[t.asSum] = u),
                  t.asPercent && (d[t.asPercent] = 0 === u ? 0 : o / u),
                  t.asPercentStack && (d[t.asPercentStack] = 0 === u ? 0 : l / u),
                  t.asPrevPercentStack && (d[t.asPrevPercentStack] = 0 === u ? 0 : h / u),
                  d
                );
              })
            );
          })(t, s);
          return 'negative' === t.order ? r.reverse() : r;
        },
        markPhase: 'beforeJoin'
      },
      funnel: {
        transform: (t, e) => {
          var i, n;
          const {
              field: s,
              asTransformRatio: r,
              asReachRatio: a,
              asHeightRatio: o,
              asValueRatio: l,
              asNextValueRatio: h,
              asLastValueRatio: c,
              asLastValue: d,
              asCurrentValue: u,
              asNextValue: p,
              heightVisual: g = !1,
              isCone: f = !0,
              range: v
            } = t,
            m = e.reduce((t, e) => Math.max(t, Number.parseFloat(e[s]) || -1 / 0), -1 / 0),
            y = e.reduce((t, e) => Math.min(t, Number.parseFloat(e[s]) || 1 / 0), 1 / 0),
            b = [
              null !== (i = null == v ? void 0 : v.min) && void 0 !== i ? i : y,
              null !== (n = null == v ? void 0 : v.max) && void 0 !== n ? n : m
            ],
            x = e.map((t, i) => {
              var n, v;
              const m = Object.assign({}, t),
                y = Number.parseFloat(m[s]),
                x = Number.parseFloat(null === (n = e[i - 1]) || void 0 === n ? void 0 : n[s]),
                S = Number.parseFloat(null === (v = e[i + 1]) || void 0 === v ? void 0 : v[s]),
                w = _(S * y) ? S / y : null,
                A = _(y * y) ? y / x : null;
              return (
                d && (m[d] = x),
                p && (m[p] = S),
                r && (m[r] = w),
                a && (m[a] = 0 === i ? 1 : A),
                o && (m[o] = !0 === g ? w : 1 / e.length),
                l && (m[l] = y / b[1]),
                h && (m[h] = i === e.length - 1 ? (f ? 0 : m[l]) : S / b[1]),
                c && (m[c] = 0 === i ? 1 : x / b[1]),
                u && (m[u] = y),
                m
              );
            });
          return x;
        },
        markPhase: 'beforeJoin'
      },
      pie: {
        transform: (t, e) => {
          var i, n;
          if (!e || 0 === e.length) return e;
          const s = t.field,
            r = null !== (i = t.startAngle) && void 0 !== i ? i : 0,
            a = null !== (n = t.endAngle) && void 0 !== n ? n : 2 * Math.PI,
            { asStartAngle: o, asEndAngle: l, asMiddleAngle: h, asRadian: c, asRatio: d, asQuadrant: u, asK: p } = t,
            g = e.reduce((t, e) => Number.parseFloat(e[s]) + t, 0),
            f = e.reduce((t, e) => Math.max(t, Number.parseFloat(e[s])), -1 / 0),
            v = a - r;
          let m = r;
          const y = e.map(t => {
            const e = Object.assign({}, t),
              i = Number.parseFloat(e[s]) / g,
              n = i * v;
            return (
              d && (e[d] = i),
              o && (e[o] = m),
              l && (e[l] = m + n),
              h && (e[h] = m + n / 2),
              c && (e[c] = n),
              u && (e[u] = OW(m + n / 2)),
              p && (e[p] = Number.parseFloat(e[s]) / f),
              (m = e[l]),
              e
            );
          });
          return (y[y.length - 1][l] = a), y;
        },
        markPhase: 'beforeJoin'
      },
      circularRelation: {
        transform: (t, e) => {
          var i, n, s, r, a, o, h, c, d, u, p, g, f, v, m;
          if (!e || 0 === e.length) return [];
          const _ = (t =>
              'width' in t
                ? { x0: 0, x1: t.width, y0: 0, y1: t.height, width: t.width, height: t.height }
                : {
                    x0: Math.min(t.x0, t.x1),
                    x1: Math.max(t.x0, t.x1),
                    y0: Math.min(t.y0, t.y1),
                    y1: Math.max(t.y0, t.y1),
                    width: Math.abs(t.x1 - t.x0),
                    height: Math.abs(t.y1 - t.y0)
                  })(t),
            b = null !== (i = t.startAngle) && void 0 !== i ? i : 0,
            x = null !== (n = t.endAngle) && void 0 !== n ? n : 2 * Math.PI,
            S = Math.max(_.width / 2, _.height / 2),
            w = Yo(null !== (s = t.innerRadius) && void 0 !== s ? s : 0, S),
            A = Yo(t.outerRadius, S),
            k = [
              y(null === (r = t.center) || void 0 === r ? void 0 : r[0])
                ? t.center[0]
                : _.x0 +
                  Yo(
                    null !== (o = null === (a = t.center) || void 0 === a ? void 0 : a[0]) && void 0 !== o ? o : '50%',
                    _.width
                  ),
              y(null === (h = t.center) || void 0 === h ? void 0 : h[1])
                ? t.center[1]
                : _.y0 +
                  Yo(
                    null !== (d = null === (c = t.center) || void 0 === c ? void 0 : c[1]) && void 0 !== d ? d : '50%',
                    _.height
                  )
            ],
            M = jo(t.field),
            T = e.map(M),
            [C, E] = Go(T),
            P = C === E ? t => (w + A) / 2 : t => w + ((A - w) * (t - C)) / (E - C),
            R = l(t.radiusField) ? M : jo(t.radiusField),
            O =
              null !== (p = null === (u = null == t ? void 0 : t.radiusRange) || void 0 === u ? void 0 : u[1]) &&
              void 0 !== p
                ? p
                : 5;
          let B = t => O;
          if (R) {
            const [i, n] = R !== M ? Go(e.map(R)) : [C, E],
              s = null !== (f = null === (g = t.radiusRange) || void 0 === g ? void 0 : g[0]) && void 0 !== f ? f : 5,
              r = null !== (m = null === (v = t.radiusRange) || void 0 === v ? void 0 : v[1]) && void 0 !== m ? m : 5;
            i !== n && (B = t => s + ((r - s) * (R(t) - i)) / (n - i));
          }
          const I = Math.min(b, x),
            D = Math.max(b, x),
            L = _G(I, D, e.length),
            F = [],
            j = (D - I) / 60;
          return (
            e.forEach((t, e) => {
              const i = P(T[e]),
                n = B(t);
              let s,
                r,
                a = L[e];
              for (
                let t = 0;
                t < 60 &&
                ((s = k[0] + i * Math.cos(a)),
                (r = k[1] + i * Math.sin(a)),
                bG({ x: s, y: r, radius: n }, F) || s - n < _.x0 || s + n > _.x1 || r - n < _.y0 || r + n > _.y1);
                t++
              )
                t < 59 && ((a += j), a > D ? (a = I) : a < I && (a = D));
              F.push({ x: s, y: r, radius: n, datum: t });
            }),
            F
          );
        },
        markPhase: 'beforeJoin'
      },
      fold: {
        transform: (t, e) => {
          if (!e || !e.length) return [];
          const { fields: i, asKey: n = 'key', asValue: s = 'value', retains: r } = t,
            a = [];
          for (let t = 0, o = e.length; t < o; t++) {
            const o = e[t];
            i.forEach(t => {
              const e = {};
              if (r)
                r.forEach(t => {
                  e[t] = o[t];
                });
              else for (const t in o) -1 === i.indexOf(t) && (e[t] = o[t]);
              (e[n] = t), (e[s] = o[t]), a.push(e);
            });
          }
          return a;
        },
        markPhase: 'beforeJoin'
      },
      unfold: {
        transform: (t, e) => {
          var i;
          if (!e || !e.length) return [];
          const n = [],
            s = {},
            r = t.keyField,
            a = t.valueField,
            o = yG[null !== (i = t.aggregateType) && void 0 !== i ? i : 'sum'];
          if (t.groupBy) {
            const i = V(t.groupBy);
            e.forEach(t => {
              if (!t) return;
              const e = {},
                n = [];
              i.forEach(i => {
                (e[i] = t[i]), n.push(t[i]);
              });
              const o = n.join('~');
              s[o]
                ? s[o].values[t[r]]
                  ? s[o].values[t[r]].push(t[a])
                  : (s[o].values[t[r]] = [t[a]])
                : (s[o] = { datum: e, values: { [t[r]]: [t[a]] } });
            });
          } else
            (s[0] = { datum: {}, values: {} }),
              e.forEach(t => {
                t && (s[0].values[t[r]] ? s[0].values[t[r]].push(t[a]) : (s[0].values[t[r]] = [t[a]]));
              });
          return (
            Object.keys(s).forEach(t => {
              const e = s[t].datum,
                i = s[t].values;
              Object.keys(i).forEach(t => {
                const n = i[t];
                e[t] = o(n);
              }),
                n.push(e);
            }),
            n
          );
        },
        markPhase: 'beforeJoin'
      },
      lttbsample: {
        transform: (t, e) => {
          let i = t.size;
          const n = t.factor || 1;
          if ((Array.isArray(i) && (i = Math.floor(i[1] - i[0])), (i *= n), i <= 0)) return [];
          if (e.length <= i) return e;
          if (t.skipfirst) return e.slice(0, 1);
          const { yfield: s, groupBy: r } = t;
          if (e.length) {
            const t = {};
            if (r) {
              for (let i = 0, n = e.length; i < n; i++) {
                const n = e[i],
                  a = n[r];
                t[a] || (t[a] = []), t[a].push({ y: n[s], i: i });
              }
              let n = [];
              return (
                Object.keys(t).forEach(e => {
                  const s = t[e];
                  if (s.length <= i) {
                    const t = s.map(t => t.i);
                    n = n.concat(t);
                  } else {
                    const t = xG(i, s, !0);
                    n = n.concat(t);
                  }
                }),
                n.sort((t, e) => t - e),
                n.map(t => e[t])
              );
            }
            return xG(i, e, !1, s).map(t => e[t]);
          }
          return [];
        },
        markPhase: 'afterEncode'
      },
      markoverlap: {
        transform: (t, e) => {
          if (!e || 0 === e.length) return;
          let { radius: i } = t;
          l(i) && 'symbol' === e[0].mark.markType && (i = !0);
          const { direction: n, delta: s, deltaMul: r = 1, groupBy: a } = t,
            o = t => {
              !(function (t) {
                t.forEach(t => {
                  t.setGraphicAttribute('visible', !0);
                });
              })(t);
              const e = t.slice().sort((t, e) => t.getGraphicAttribute('x') - e.getGraphicAttribute('x'));
              0 === n
                ? (function (t, e, i, n) {
                    if (n) {
                      const n = -1 / 0;
                      let s = -1 / 0,
                        r = 0,
                        a = 0;
                      const o = l(e);
                      let h = e;
                      t.forEach(t => {
                        const e = t.getGraphicAttribute('size') / 2,
                          l = t.getGraphicAttribute('x'),
                          c = t.getGraphicAttribute('y');
                        o && (h = (e + r) * i),
                          (a = (n - l) ** 2 + (s - c) ** 2),
                          a < (h + r + e) ** 2
                            ? t.getGraphicAttribute('forceShow') || t.setGraphicAttribute('visible', !1)
                            : (s = c),
                          (r = e);
                      });
                    }
                  })(e, s, r, i)
                : 1 === n
                ? (function (t, e, i, n) {
                    if (n) {
                      let n = -1 / 0,
                        s = 0;
                      const r = l(e);
                      let a = e;
                      t.forEach(t => {
                        const e = t.getGraphicAttribute('size') / 2,
                          o = t.getGraphicAttribute('x');
                        r && (a = (e + s) * i),
                          Math.abs(o - n) < a + s + e
                            ? t.getGraphicAttribute('forceShow') || t.setGraphicAttribute('visible', !1)
                            : (n = o),
                          (s = e);
                      });
                    }
                  })(e, s, r, i)
                : (function (t, e, i, n) {
                    if (n) {
                      let n = -1 / 0,
                        s = 0;
                      const r = l(e);
                      let a = e;
                      t.forEach(t => {
                        const e = t.getGraphicAttribute('size') / 2,
                          o = t.getGraphicAttribute('y');
                        r && (a = (e + s) * i),
                          Math.abs(o - n) < a + s + e
                            ? t.getGraphicAttribute('forceShow') || t.setGraphicAttribute('visible', !1)
                            : (n = o),
                          (s = e);
                      });
                    }
                  })(e, s, r, i);
            };
          if (a) {
            const t = e.reduce((t, e) => {
              const i = e.getDatum()[a];
              return t[i] ? t[i].push(e) : (t[i] = [e]), t;
            }, {});
            Object.keys(t).forEach(e => {
              o(t[e]);
            });
          } else o(e);
          return e;
        },
        markPhase: 'afterEncode'
      },
      identifier: {
        transform: (t, e, i, n) => {
          l(n[SG]) && (n[SG] = 0);
          let s = n[SG];
          const r = t.as;
          return (
            e.forEach(t => {
              t && l(t[r]) && ((s += 1), (t[r] = s));
            }),
            (n[SG] = s),
            s
          );
        },
        markPhase: 'beforeJoin'
      },
      dodge: {
        transform: (t, e) => {
          var i, n, s;
          if (!e || 0 === e.length || !(null === (i = e[0]) || void 0 === i ? void 0 : i.mark)) return e;
          const r = e[0].mark,
            a = r.getScales(),
            o = Object.values(a).find(VG);
          if (!o) return e;
          const h = r.getScalesByChannel(),
            c = WG(o),
            d = l(t.dodgeChannel)
              ? h.y === o || h.y1 === o || (h.x && !VG(h.x)) || (h.x1 && !VG(h.x1))
                ? 'y'
                : 'x'
              : t.dodgeChannel;
          if (c > 0) {
            const i = null !== (n = t.innerGap) && void 0 !== n ? n : 0,
              a = null !== (s = t.categoryGap) && void 0 !== s ? s : '20%';
            let o = t => t.groupKey;
            if (!l(t.dodgeBy)) {
              const e = Do(V(t.dodgeBy));
              o = t => e(t.getDatum());
            }
            const h = [];
            e.forEach(t => {
              const e = o(t);
              h.includes(e) || h.push(e);
            });
            const u = h.length;
            if (u < 1) return e;
            const p = Yo(a, c);
            let g = p >= c ? c : c - p;
            const f = Yo(i, g);
            let v = (g - Math.max(u - 1, 0) * f) / u;
            v > t.maxWidth
              ? ((g -= (v - t.maxWidth) * u), (v = t.maxWidth))
              : v < t.minWidth && t.minWidth <= c / u && ((g += (t.minWidth - v) * u), (v = t.minWidth));
            const m = {};
            h.forEach((t, e) => {
              m[t] = -g / 2 + e * (v + f);
            });
            const y = r.markType;
            'rect' === y || 'interval' === y || 'arc' === y
              ? e.forEach(t => {
                  const e = o(t),
                    i = m[e],
                    n = t.getItemAttribute();
                  if ('x' === d) {
                    const e = {
                      x:
                        (l(n.width) && !l(n.x1) ? Math.min(n.x, n.x1) : n.x) +
                        (l(n.width) ? (l(n.x1) ? c : Math.abs(n.x1 - n.x)) : n.width) / 2 +
                        i
                    };
                    l(n.width) ? (e.x1 = e.x + v) : (e.width = v), t.setItemAttributes(e);
                  } else if ('y' === d) {
                    const e = {
                      y:
                        (l(n.height) && !l(n.y1) ? Math.min(n.y, n.y1) : n.y) +
                        (l(n.height) ? (l(n.y1) ? c : Math.abs(n.y1 - n.y)) : n.height) / 2 +
                        i
                    };
                    l(n.height) ? (e.y1 = e.y + v) : (e.height = v), t.setItemAttributes(e);
                  }
                })
              : e.forEach(t => {
                  const e = o(t),
                    i = m[e];
                  if ('x' === d) {
                    const e = t.getItemAttribute('x') + c / 2 + i + v / 2;
                    t.setItemAttributes({ x: e }), 'rule' === y && t.setItemAttributes({ x1: e });
                  } else if ('y' === d) {
                    const e = t.getItemAttribute('y') + c / 2 + i + v / 2;
                    t.setItemAttributes({ y: e }), 'rule' === y && t.setItemAttributes({ y1: e });
                  }
                });
          }
          return e;
        },
        markPhase: 'afterEncodeItems'
      },
      jitter: {
        transform: (t, e) => {
          var i;
          return e && 0 !== e.length && (null === (i = e[0]) || void 0 === i ? void 0 : i.mark)
            ? (GG(t, e, 'x'), GG(t, e, 'y'), e)
            : e;
        },
        markPhase: 'afterEncodeItems'
      },
      jitterX: {
        transform: (t, e) => {
          var i;
          return e && 0 !== e.length && (null === (i = e[0]) || void 0 === i ? void 0 : i.mark) ? GG(t, e, 'x') : e;
        },
        markPhase: 'afterEncodeItems'
      },
      jitterY: {
        transform: (t, e) => {
          var i;
          return e && 0 !== e.length && (null === (i = e[0]) || void 0 === i ? void 0 : i.mark) ? GG(t, e, 'y') : e;
        },
        markPhase: 'afterEncodeItems'
      },
      symmetry: {
        transform: (t, e) => {
          var i, n;
          return e && 0 !== e.length && (null === (i = e[0]) || void 0 === i ? void 0 : i.mark)
            ? ((t, e, i) => {
                const n = `${e}1`,
                  s = t.some(t => !l(t.getItemAttribute(n))),
                  r = s
                    ? t.map(t => (t.getItemAttribute(n) + t.getItemAttribute(e)) / 2)
                    : t.map(t => t.getItemAttribute(e)),
                  a = 'min' === i ? Math.min.apply(null, r) : Math.max.apply(null, r);
                return (
                  _(a) &&
                    t.forEach((t, i) => {
                      const o = a - r[i];
                      s
                        ? t.setItemAttributes({ [n]: t.getItemAttribute(n) + o, [e]: t.getItemAttribute(e) + o })
                        : t.setItemAttributes({ [e]: t.getItemAttribute(e) + o });
                    }),
                  t
                );
              })(e, null !== (n = t.channel) && void 0 !== n ? n : 'y', t.align)
            : e;
        },
        markPhase: 'afterEncodeItems'
      }
    },
    YG = {},
    $G = t => YG[t],
    XG = (t, e) => {
      YG[t] = { creator: e };
    };
  class KG extends GE {
    constructor(t) {
      super(t),
        (this.attribute = t),
        this.onSetStage(() => {
          this.render();
        });
    }
    render() {
      var t;
      const e = this.createOrUpdateChild('large-path', {}, 'path'),
        i = this.attribute.points,
        n = null !== (t = e.attribute.path) && void 0 !== t ? t : new mA();
      let s, r, a, o;
      n.clear();
      for (let t = 0, e = i.length; t < e; t += 4)
        (s = i[t]), (r = i[t + 1]), (a = i[t + 2]), (o = i[t + 3]), n.rect(s, r, a, o);
      const l = Object.assign({}, this.attribute, { path: n, points: null });
      (this.attribute = {}), e.setAttributes(l);
    }
  }
  class qG extends GE {
    constructor(t) {
      super(t),
        (this.attribute = t),
        this.onSetStage(() => {
          this.render();
        });
    }
    render() {
      var t, e;
      const i = this.createOrUpdateChild('large-path', {}, 'path'),
        n = this.attribute.points,
        s = null !== (t = this.attribute.size) && void 0 !== t ? t : jA.size,
        r = null !== (e = i.attribute.path) && void 0 !== e ? e : new mA();
      let a, o;
      r.clear();
      const l = y(s) ? s : Bt(s[0], s[1]);
      for (let t = 0, e = n.length; t < e; t += 4)
        (a = n[t]), (o = n[t + 1]), r.arc(a, o, l / 2, 0, 2 * Math.PI), r.closePath();
      const h = Object.assign({}, this.attribute, { path: r, points: null, size: null });
      (this.attribute = {}), i.setAttributes(h);
    }
  }
  const ZG = {
    circle: JO,
    arc: qO,
    arc3d: function (t) {
      return new mO(t);
    },
    pyramid3d: function (t) {
      return new bO(t);
    },
    area: ZO,
    group: QO,
    image: aB,
    rect3d: nB,
    line: tB,
    path: eB,
    rect: iB,
    rule: tB,
    shape: eB,
    symbol: rB,
    text: sB,
    richtext: lB,
    polygon: oB,
    cell: rB,
    interval: iB
  };
  function JG(t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if ((t.emit(tG.BEFORE_CREATE_VRENDER_MARK), e === GW.largeRects)) return new KG(i);
    if (e === GW.largeSymbols) return new qG(i);
    const n = ZG[e] ? ZG[e](i) : $G(e) ? $G(e).creator(i) : null;
    return t.emit(tG.AFTER_CREATE_VRENDER_MARK), n;
  }
  function QG(t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    t.emit(tG.BEFORE_CREATE_VRENDER_MARK);
    const n = new eO(i),
      s = e.getMarks(),
      r = Object.keys(s).map(t => {
        const e = ZG[s[t]]();
        return (e.name = t), e;
      });
    return n.setSubGraphic(r), t.emit(tG.AFTER_CREATE_VRENDER_MARK), n;
  }
  const tU = t => {
    t && ((t[iG] = null), t.release(), t.parent && t.parent.removeChild(t));
  };
  let eU = class {
    constructor(t) {
      (this.data = null),
        (this.states = []),
        (this.diffState = WW.enter),
        (this.isReserved = !1),
        (this.runtimeStatesEncoder = null),
        (this.items = []),
        (this.getStateAttrs = (t, e) => {
          var i, n, s;
          const r = !l(null === (i = this.runtimeStatesEncoder) || void 0 === i ? void 0 : i[t]),
            a = r
              ? this.runtimeStatesEncoder[t]
              : null === (n = this.mark.getSpec().encode) || void 0 === n
              ? void 0
              : n[t];
          if (!a) return {};
          if (o(a)) return a(this.getDatum(), this, t, e);
          if (!r && (null === (s = this.graphicItem.states) || void 0 === s ? void 0 : s[t]))
            return this.graphicItem.states[t];
          const h = this.items.map(t => Object.assign({}, t, { nextAttrs: {} }));
          HG(this, h, a, this.mark.parameters());
          const c = this.transformElementItems(h, this.mark.markType);
          return (
            this.graphicItem.states
              ? this.graphicItem.states[t] || (this.graphicItem.states[t] = c)
              : (this.graphicItem.states = { [t]: c }),
            c
          );
        }),
        (this.mark = t);
    }
    initGraphicItem() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      if (this.graphicItem) return;
      const e = Object.assign({}, t);
      (this.graphicItem = this.mark.addGraphicItem(e, this.groupKey)),
        (this.graphicItem[iG] = this),
        (this.graphicItem.onBeforeAttributeUpdate = t =>
          this.mark ? DG(this.mark.getAttributeTransforms(), t, this) : t),
        this.graphicItem.setAttributes(this.graphicItem.attribute),
        this.clearGraphicAttributes(),
        this.mark.needAnimate() &&
          (this.setPrevGraphicAttributes({}), this.setNextGraphicAttributes(t), this.setFinalGraphicAttributes(t));
    }
    updateGraphicItem(t) {
      var e;
      if (!this.graphicItem) return;
      l(t.clip) || this.graphicItem.setAttribute('clip', t.clip),
        l(t.interactive) || this.graphicItem.setAttribute('pickable', t.interactive),
        l(t.zIndex) || this.graphicItem.setAttribute('zIndex', t.zIndex),
        this.diffState === WW.exit
          ? (this.graphicItem.releaseStatus = 'willRelease')
          : (this.graphicItem.releaseStatus = void 0);
      const i = this.mark.getSpec();
      (null === (e = i.animation) || void 0 === e ? void 0 : e.state) &&
        (this.graphicItem.stateAnimateConfig = i.animation.state);
    }
    getGraphicItem() {
      return this.graphicItem;
    }
    getBounds() {
      var t;
      return null === (t = this.graphicItem) || void 0 === t ? void 0 : t.AABBBounds;
    }
    getStates() {
      return this.states.slice();
    }
    updateData(t, e, i) {
      var n;
      this.mark.emit(tG.BEFORE_ELEMENT_UPDATE_DATA, { groupKey: t, data: e, key: i }, this), (this.data = e);
      const s = HW(i);
      return (
        (this.items = e.map(t => ({ datum: t, key: s(t), view: this.mark.view, nextAttrs: {} }))),
        (this.groupKey = t),
        (this.key = this.mark.isCollectionMark() ? t : null === (n = this.items) || void 0 === n ? void 0 : n[0].key),
        this.mark.emit(tG.AFTER_ELEMENT_UPDATE_DATA, { groupKey: t, data: e, key: i }, this),
        this.items
      );
    }
    state(t, e) {
      var i;
      const n = this.mark.isCollectionMark(),
        s = this.states,
        r = V(LW(t, e, this.getDatum(), this)),
        a = null === (i = this.mark.getSpec()) || void 0 === i ? void 0 : i.stateSort;
      a && a.sort(a);
      const o = r.length !== s.length || r.some((t, e) => t !== s[e]);
      (this.states = r), !n && o && this.diffState === WW.unChange && (this.diffState = WW.update);
    }
    encodeGraphic(t) {
      var e, i;
      this.coordinateTransformEncode(this.items),
        !l(null == t ? void 0 : t.enableSegments) &&
          (null === (i = null === (e = this.items) || void 0 === e ? void 0 : e[0]) || void 0 === i
            ? void 0
            : i.nextAttrs) &&
          (this.items[0].nextAttrs.enableSegments = t.enableSegments);
      const n = this.transformElementItems(this.items, this.mark.markType);
      t && Object.assign(n, t),
        this.graphicItem
          ? (this.graphicItem.clearStates(),
            (this.graphicItem.states = {}),
            (this.graphicItem.stateProxy = null),
            this.applyGraphicAttributes(n))
          : this.initGraphicItem(n),
        (this.diffState !== WW.enter && this.diffState !== WW.update) ||
          !this.states.length ||
          this.useStates(this.states),
        this.mark.markType === GW.shape && (this.graphicItem.datum = this.items[0].datum),
        this.items.forEach(t => {
          t.nextAttrs = {};
        }),
        this._setCutomizedShape();
    }
    _setCutomizedShape() {
      var t;
      if (!this.graphicItem) return;
      const e = null === (t = this.mark.getSpec()) || void 0 === t ? void 0 : t.setCustomizedShape;
      e && (this.graphicItem.pathProxy = t => e(this.data, t, new mA()));
    }
    encodeItems(t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
        n = arguments.length > 3 ? arguments[3] : void 0;
      const s = this.mark.isCollectionMark(),
        r = e[VW.update],
        a = e[VW.enter],
        o = e[VW.exit],
        l = this.mark.isLargeMode();
      this.diffState === WW.enter
        ? (a && HG(this, t, a, n, l), r && HG(this, t, r, n, l))
        : this.diffState === WW.update
        ? (((s && a) || i) && HG(this, t, a, n, l), r && HG(this, t, r, n, l))
        : this.diffState === WW.exit && o && (i && HG(this, t, a, n, l), HG(this, t, o, n, l));
    }
    coordinateTransformEncode(t) {
      if (!this.mark.coord || 'arc' === this.mark.markType || !0 === this.mark.disableCoordinateTransform) return;
      const e = this.mark.coord.output();
      t.forEach(t => {
        const i = t.nextAttrs,
          n = e.convert(i);
        Object.assign(i, n);
      });
    }
    clearStates(t) {
      var e;
      const i = a(t) ? t : !!(null === (e = this.mark.getSpec().animation) || void 0 === e ? void 0 : e.state);
      (this.states = []),
        this.graphicItem && this.graphicItem.clearStates(i),
        this.runtimeStatesEncoder && (this.runtimeStatesEncoder = {});
    }
    _updateRuntimeStates(t, e) {
      this.runtimeStatesEncoder || (this.runtimeStatesEncoder = {}), (this.runtimeStatesEncoder[t] = e);
    }
    hasState(t) {
      return this.states && this.states.includes(t);
    }
    addState(t, e) {
      var i;
      const n = V(t).reduce((t, e) => (t.includes(e) || t.push(e), t), this.states.slice()),
        s = e && g(t) && !z(e, null === (i = this.runtimeStatesEncoder) || void 0 === i ? void 0 : i[t]);
      s && this._updateRuntimeStates(t, e),
        n.length !== this.states.length
          ? this.useStates(n)
          : s && this.graphicItem && (this.graphicItem.clearStates(), this.useStates(n));
    }
    removeState(t) {
      const e = V(t),
        i = this.states.filter(t => !e.includes(t));
      i.length !== this.states.length &&
        (this.runtimeStatesEncoder &&
          e.forEach(t => {
            this.runtimeStatesEncoder[t] = null;
          }),
        this.useStates(i));
    }
    useStates(t, e) {
      var i, n;
      if (!this.graphicItem) return;
      this.mark.emit(tG.BEFORE_ELEMENT_STATE, { states: t }, this), (this.states = t.slice());
      const s = null === (i = this.mark.getSpec()) || void 0 === i ? void 0 : i.stateSort;
      s && this.states.sort(s);
      const r = a(e) ? e : !!(null === (n = this.mark.getSpec().animation) || void 0 === n ? void 0 : n.state);
      (this.graphicItem.stateProxy = this.getStateAttrs),
        this.graphicItem.useStates(this.states, r),
        this.mark.emit(tG.AFTER_ELEMENT_STATE, { states: t }, this);
    }
    diffAttributes(t) {
      const e = {},
        i = this.getFinalGraphicAttributes();
      for (const n in t) (Uo(n, i, t) && P(i, n)) || (e[n] = t[n]);
      return e;
    }
    transformElementItems(t, e, i) {
      var n, s, r, a, o;
      const h = t[0];
      if (!h.nextAttrs || 0 === Object.keys(h.nextAttrs).length) return {};
      let c = null == h ? void 0 : h.nextAttrs;
      if (
        t &&
        t.length &&
        l(null === (n = h.nextAttrs) || void 0 === n ? void 0 : n.points) &&
        (!0 === i || RG(Object.keys(h.nextAttrs), this.mark.markType)) &&
        (function (t) {
          return [GW.line, GW.area, GW.largeRects, GW.largeSymbols].includes(t);
        })(e)
      ) {
        const i = this.getGraphicAttribute('points', !1),
          n = this.getGraphicAttribute('segments', !1),
          d =
            null !== (s = h.nextAttrs.enableSegments) && void 0 !== s
              ? s
              : this.getGraphicAttribute('enableSegments', !1),
          u = t.map(t => t.nextAttrs),
          p = this.mark.isProgressive();
        if (((c = Object.assign({}, c)), delete c.x, delete c.y, e === GW.line || e === GW.area)) {
          const s = (function (t, e, i, n) {
            return !t || !t.length || (1 === t.length && e)
              ? []
              : t.some(t => RG(Object.keys(t.nextAttrs), 'line'))
              ? t.map((t, e) => {
                  var s, r, a, o, l, h, c, d, u, p;
                  const g = t.nextAttrs,
                    f = PG(
                      null !== (s = g.x) && void 0 !== s
                        ? s
                        : null === (r = null == i ? void 0 : i[e]) || void 0 === r
                        ? void 0
                        : r.x
                    ),
                    v = PG(
                      null !== (a = g.y) && void 0 !== a
                        ? a
                        : null === (o = null == i ? void 0 : i[e]) || void 0 === o
                        ? void 0
                        : o.y
                    ),
                    m =
                      null !== (l = g.defined) && void 0 !== l
                        ? l
                        : null === (h = null == i ? void 0 : i[e]) || void 0 === h
                        ? void 0
                        : h.defined,
                    y = { x: f, y: v, context: t.key };
                  if (n) {
                    const t = PG(
                        null !== (c = g.x1) && void 0 !== c
                          ? c
                          : null === (d = null == i ? void 0 : i[e]) || void 0 === d
                          ? void 0
                          : d.x1
                      ),
                      n = PG(
                        null !== (u = g.y1) && void 0 !== u
                          ? u
                          : null === (p = null == i ? void 0 : i[e]) || void 0 === p
                          ? void 0
                          : p.y1
                      );
                    (y.x1 = t), (y.y1 = n);
                  }
                  return !1 === m && (y.defined = !1), y;
                })
              : null != i
              ? i
              : [];
          })(t, !0, i, e === GW.area);
          if (d && !p) {
            const t =
                s && 0 !== s.length
                  ? s
                  : (function (t) {
                      return t ? t.reduce((t, e) => t.concat(e.points), []) : null;
                    })(n),
              e = (function (t, e, i) {
                var n;
                if (!t || t.length <= 1) return null;
                const s =
                    'area' === (null === (n = null == i ? void 0 : i.mark) || void 0 === n ? void 0 : n.markType)
                      ? jG
                      : FG,
                  r = [];
                let a = null;
                return (
                  t.forEach((t, e) => {
                    (a && s.every(e => LG(a[e], t[e], e))) ||
                      (r.length && (r[r.length - 1].endIndex = e), (a = t), r.push({ attrs: a, startIndex: e }));
                  }),
                  r.length >= 2
                    ? r.map(t => {
                        const n = DG(GW.line, t.attrs, i);
                        return (n.points = e.slice(t.startIndex, l(t.endIndex) ? e.length : t.endIndex)), n;
                      })
                    : null
                );
              })(u, t, this);
            e ? ((c.segments = e), (c.points = null)) : ((c.segments = null), (c.points = t));
          } else
            p
              ? (c.segments = (
                  null !==
                    (o =
                      null === (a = null === (r = this.graphicItem) || void 0 === r ? void 0 : r.attribute) ||
                      void 0 === a
                        ? void 0
                        : a.segments) && void 0 !== o
                    ? o
                    : []
                ).concat([{ points: s }]))
              : ((c.points = s), (c.segments = null));
        } else
          e === GW.largeRects
            ? (c.points = (function (t, e, i) {
                if (!t || !t.length || (1 === t.length && e)) return [];
                const n = new Float32Array(4 * t.length);
                return (
                  t.forEach((t, e) => {
                    var s, r, a, o;
                    const l = t.nextAttrs,
                      h = PG(null !== (s = l.x) && void 0 !== s ? s : null == i ? void 0 : i[4 * e]),
                      c = PG(null !== (r = l.y) && void 0 !== r ? r : null == i ? void 0 : i[4 * e + 1]),
                      d = PG(null !== (a = l.width) && void 0 !== a ? a : null == i ? void 0 : i[4 * e + 2]),
                      u = PG(null !== (o = l.y1) && void 0 !== o ? o : null == i ? void 0 : i[4 * e + 3]);
                    (n[4 * e] = h), (n[4 * e + 1] = c), (n[4 * e + 2] = d), (n[4 * e + 3] = u - c);
                  }),
                  n
                );
              })(t, !0, i))
            : e === GW.largeSymbols &&
              (c.points = (function (t, e, i) {
                if (!t || !t.length || (1 === t.length && e)) return [];
                const n = new Float32Array(2 * t.length);
                return (
                  t.forEach((t, e) => {
                    var s, r;
                    const a = t.nextAttrs,
                      o = PG(null !== (s = a.x) && void 0 !== s ? s : null == i ? void 0 : i[2 * e]),
                      l = PG(null !== (r = a.y) && void 0 !== r ? r : null == i ? void 0 : i[2 * e + 1]);
                    (n[2 * e] = o), (n[2 * e + 1] = l);
                  }),
                  n
                );
              })(t, !0, i));
      }
      return c;
    }
    applyGraphicAttributes(t) {
      if (!T(t))
        if (this.mark.needAnimate()) {
          const e = this.diffAttributes(t),
            i = this.getPrevGraphicAttributes(),
            n = this.getFinalGraphicAttributes();
          Object.keys(e).forEach(t => {
            (i[t] = this.getGraphicAttribute(t)), (n[t] = e[t]);
          }),
            this.setNextGraphicAttributes(e),
            this.setPrevGraphicAttributes(i),
            this.setFinalGraphicAttributes(n);
          const s = this.mark.animate
              .getElementAnimators(this)
              .reduce((t, e) => Object.assign(t, e.getEndAttributes()), {}),
            r = Object.assign({}, s, n);
          this.graphicItem.setAttributes(r);
        } else this.graphicItem.setAttributes(t);
    }
    getGraphicAttribute(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      var i;
      if (!this.graphicItem) return;
      if (e) {
        let e;
        const i = this.getPrevGraphicAttributes();
        if (!l((e = C(i, t)))) return e;
      }
      const n = this.mark.getAttributeTransforms();
      let s = [t];
      if (n && n.length) {
        const e = n.find(e => e.storedAttrs && e.channels.includes(t));
        e && (s = [e.storedAttrs, t]);
      }
      return C(null === (i = this.graphicItem) || void 0 === i ? void 0 : i.attribute, s);
    }
    setGraphicAttribute(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      if (!this.graphicItem) return;
      const n = this.getFinalGraphicAttributes(),
        s = this.getPrevGraphicAttributes();
      i && n && (n[t] = e),
        s && !P(s, t) && (s[t] = this.graphicItem.attribute[t]),
        this.graphicItem.setAttribute(t, e);
    }
    setGraphicAttributes(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      if (!this.graphicItem) return;
      const i = this.getFinalGraphicAttributes(),
        n = this.getPrevGraphicAttributes();
      Object.keys(t).forEach(s => {
        i && e && (i[s] = t[s]), n && !P(n, s) && (n[s] = this.graphicItem.attribute[s]);
      }),
        this.graphicItem.setAttributes(t);
    }
    getFinalGraphicAttributes() {
      return this.graphicItem.finalAttrs;
    }
    setFinalGraphicAttributes(t) {
      this.graphicItem.finalAttrs = t;
    }
    getPrevGraphicAttributes() {
      return this.graphicItem.prevAttrs;
    }
    setPrevGraphicAttributes(t) {
      this.graphicItem.prevAttrs = t;
    }
    getNextGraphicAttributes() {
      return this.graphicItem.nextAttrs;
    }
    setNextGraphicAttributes(t) {
      this.graphicItem.nextAttrs = t;
    }
    clearChangedGraphicAttributes() {
      this.graphicItem && (this.setPrevGraphicAttributes({}), this.setNextGraphicAttributes({}));
    }
    clearGraphicAttributes() {
      this.graphicItem &&
        (this.setPrevGraphicAttributes({}), this.setNextGraphicAttributes({}), this.setFinalGraphicAttributes({}));
    }
    remove() {
      this.graphicItem && (tU(this.graphicItem), (this.graphicItem = null));
    }
    release() {
      var t, e;
      this.graphicItem &&
        (null === (e = null === (t = this.graphicItem.animates) || void 0 === t ? void 0 : t.forEach) ||
          void 0 === e ||
          e.call(t, t => t.stop())),
        (this.mark = null),
        (this.data = null),
        this.graphicItem && (tU(this.graphicItem), (this.graphicItem[iG] = null), (this.graphicItem = null)),
        (this.items = null);
    }
    getItemAttribute(t) {
      var e, i;
      if (null === (e = this.items) || void 0 === e ? void 0 : e.length)
        return this.mark.isCollectionMark()
          ? l(t)
            ? this.items.map(t => t.nextAttrs)
            : this.items.map(e => {
                var i;
                return null === (i = e.nextAttrs) || void 0 === i ? void 0 : i[t];
              })
          : l(t)
          ? this.items[0].nextAttrs
          : null === (i = this.items[0].nextAttrs) || void 0 === i
          ? void 0
          : i[t];
    }
    setItemAttributes(t) {
      var e;
      (null === (e = this.items) || void 0 === e ? void 0 : e.length) &&
        (this.mark.isCollectionMark()
          ? f(t) &&
            this.items.forEach((e, i) => {
              Object.assign(e.nextAttrs, t[i]);
            })
          : Object.assign(this.items[0].nextAttrs, t));
    }
    getItem() {
      var t, e;
      return this.mark.isCollectionMark()
        ? null !== (t = this.items) && void 0 !== t
          ? t
          : []
        : null === (e = this.items) || void 0 === e
        ? void 0
        : e[0];
    }
    getDatum() {
      var t, e;
      return this.mark.isCollectionMark()
        ? null !== (t = this.data) && void 0 !== t
          ? t
          : []
        : null === (e = this.data) || void 0 === e
        ? void 0
        : e[0];
    }
  };
  const iU = (t, e, i) => {
      const n = t.getGraphicAttribute('points', !1),
        s = { x: 0, y: 0 };
      return (
        n.forEach(t => {
          (s.x += t.x), (s.y += t.y);
        }),
        (s.x /= n.length),
        (s.y /= n.length),
        (null == e ? void 0 : e.center) && (_(e.center.x) && (s.x = e.center.x), _(e.center.y) && (s.y = e.center.y)),
        n.map(() => Object.assign(s))
      );
    },
    nU = (t, e, i) =>
      t.getGraphicAttribute('points', !1).map(t => {
        if ('negative' === (null == e ? void 0 : e.orient)) {
          const e = i.group ? i.group.getBounds().width() : i.width;
          return { x: e, y: t.y, x1: e, y1: t.y1, defined: !1 !== t.defined };
        }
        return { x: 0, y: t.y, x1: 0, y1: t.y1, defined: !1 !== t.defined };
      }),
    sU = (t, e, i) =>
      t.getGraphicAttribute('points', !1).map(t => {
        if ('negative' === (null == e ? void 0 : e.orient)) {
          const e = i.group ? i.group.getBounds().height() : i.height;
          return { x: t.x, y: e, x1: t.x1, y1: e, defined: !1 !== t.defined };
        }
        return { x: t.x, y: 0, x1: t.x1, y1: 0, defined: !1 !== t.defined };
      });
  const rU = ['visible', 'path', 'text', 'lineWidth', 'textBaseline', 'textAlign'],
    aU = {
      clipIn: (t, e, i) => {
        var n;
        const s = t.getGraphicAttribute('clipRangeByDimension', !1),
          r = null !== (n = t.getGraphicAttribute('clipRange', !1)) && void 0 !== n ? n : 1;
        return (null == e ? void 0 : e.clipDimension)
          ? {
              from: { clipRange: 0, clipRangeByDimension: e.clipDimension },
              to: { clipRange: r, clipRangeByDimension: s }
            }
          : { from: { clipRange: 0 }, to: { clipRange: r } };
      },
      clipOut: (t, e, i) => {
        var n;
        const s = t.getGraphicAttribute('clipRangeByDimension', !0),
          r = null !== (n = t.getGraphicAttribute('clipRange', !0)) && void 0 !== n ? n : 1;
        return (null == e ? void 0 : e.clipDimension)
          ? {
              from: { clipRange: r, clipRangeByDimension: e.clipDimension },
              to: { clipRange: 0, clipRangeByDimension: s }
            }
          : { from: { clipRange: r }, to: { clipRange: 0 } };
      },
      fadeIn: (t, e, i) => {
        var n, s, r;
        return {
          from: { opacity: 0, fillOpacity: 0, strokeOpacity: 0 },
          to: {
            opacity: null !== (n = t.getGraphicAttribute('opacity', !1)) && void 0 !== n ? n : 1,
            fillOpacity: null !== (s = t.getGraphicAttribute('fillOpacity', !1)) && void 0 !== s ? s : 1,
            strokeOpacity: null !== (r = t.getGraphicAttribute('strokeOpacity', !1)) && void 0 !== r ? r : 1
          }
        };
      },
      fadeOut: (t, e, i) => {
        var n, s, r;
        return {
          from: {
            opacity: null !== (n = t.getGraphicAttribute('opacity', !0)) && void 0 !== n ? n : 1,
            fillOpacity: null !== (s = t.getGraphicAttribute('fillOpacity', !0)) && void 0 !== s ? s : 1,
            strokeOpacity: null !== (r = t.getGraphicAttribute('strokeOpacity', !0)) && void 0 !== r ? r : 1
          },
          to: { opacity: 0, fillOpacity: 0, strokeOpacity: 0 }
        };
      },
      moveIn: (t, e, i) => {
        var n, s, r, a, o;
        const l = null !== (n = null == e ? void 0 : e.offset) && void 0 !== n ? n : 0,
          h = i.group ? i.group.getBounds() : null,
          c = null !== (s = null == h ? void 0 : h.width()) && void 0 !== s ? s : i.width,
          d = null !== (r = null == h ? void 0 : h.height()) && void 0 !== r ? r : i.height,
          u = ('negative' === (null == e ? void 0 : e.orient) ? c : 0) + l,
          p = ('negative' === (null == e ? void 0 : e.orient) ? d : 0) + l,
          g = _(null === (a = null == e ? void 0 : e.point) || void 0 === a ? void 0 : a.x) ? e.point.x : u,
          f = _(null === (o = null == e ? void 0 : e.point) || void 0 === o ? void 0 : o.y) ? e.point.y : p;
        switch (null == e ? void 0 : e.direction) {
          case 'x':
            return { from: { x: g }, to: { x: t.getGraphicAttribute('x', !1) } };
          case 'y':
            return { from: { y: f }, to: { y: t.getGraphicAttribute('y', !1) } };
          default:
            return {
              from: { x: g, y: f },
              to: { x: t.getGraphicAttribute('x', !1), y: t.getGraphicAttribute('y', !1) }
            };
        }
      },
      moveOut: (t, e, i) => {
        var n, s, r, a, o;
        const l = null !== (n = null == e ? void 0 : e.offset) && void 0 !== n ? n : 0,
          h = i.group ? i.group.getBounds() : null,
          c = null !== (s = null == h ? void 0 : h.width()) && void 0 !== s ? s : i.width,
          d = null !== (r = null == h ? void 0 : h.height()) && void 0 !== r ? r : i.height,
          u = ('negative' === (null == e ? void 0 : e.orient) ? c : 0) + l,
          p = ('negative' === (null == e ? void 0 : e.orient) ? d : 0) + l,
          g = _(null === (a = null == e ? void 0 : e.point) || void 0 === a ? void 0 : a.x) ? e.point.x : u,
          f = _(null === (o = null == e ? void 0 : e.point) || void 0 === o ? void 0 : o.y) ? e.point.y : p;
        switch (null == e ? void 0 : e.direction) {
          case 'x':
            return { from: { x: t.getGraphicAttribute('x', !0) }, to: { x: g } };
          case 'y':
            return { from: { y: t.getGraphicAttribute('y', !0) }, to: { y: f } };
          default:
            return {
              from: { x: t.getGraphicAttribute('x', !0), y: t.getGraphicAttribute('y', !0) },
              to: { x: g, y: f }
            };
        }
      },
      scaleIn: (t, e, i) => {
        var n, s, r, a;
        switch (null == e ? void 0 : e.direction) {
          case 'x':
            return {
              from: { scaleX: 0 },
              to: { scaleX: null !== (n = t.getGraphicAttribute('scaleX', !1)) && void 0 !== n ? n : 1 }
            };
          case 'y':
            return {
              from: { scaleY: 0 },
              to: { scaleY: null !== (s = t.getGraphicAttribute('scaleY', !1)) && void 0 !== s ? s : 1 }
            };
          default:
            return {
              from: { scaleX: 0, scaleY: 0 },
              to: {
                scaleX: null !== (r = t.getGraphicAttribute('scaleX', !1)) && void 0 !== r ? r : 1,
                scaleY: null !== (a = t.getGraphicAttribute('scaleY', !1)) && void 0 !== a ? a : 1
              }
            };
        }
      },
      scaleOut: (t, e, i) => {
        var n, s, r, a;
        switch (null == e ? void 0 : e.direction) {
          case 'x':
            return {
              from: { scaleX: null !== (n = t.getGraphicAttribute('scaleX', !0)) && void 0 !== n ? n : 1 },
              to: { scaleX: 0 }
            };
          case 'y':
            return {
              from: { scaleY: null !== (s = t.getGraphicAttribute('scaleY', !0)) && void 0 !== s ? s : 1 },
              to: { scaleY: 0 }
            };
          default:
            return {
              from: {
                scaleX: null !== (r = t.getGraphicAttribute('scaleX', !0)) && void 0 !== r ? r : 1,
                scaleY: null !== (a = t.getGraphicAttribute('scaleY', !0)) && void 0 !== a ? a : 1
              },
              to: { scaleX: 0, scaleY: 0 }
            };
        }
      },
      rotateIn: (t, e, i) => {
        var n;
        const s = null !== (n = t.getGraphicAttribute('angle', !1)) && void 0 !== n ? n : 0;
        let r = 0;
        return (
          (r = ot(s / (2 * Math.PI), 0)
            ? Math.round(s / (2 * Math.PI)) * Math.PI * 2
            : _(null == e ? void 0 : e.angle)
            ? e.angle
            : 'anticlockwise' === (null == e ? void 0 : e.orient)
            ? Math.ceil(s / (2 * Math.PI)) * Math.PI * 2
            : Math.floor(s / (2 * Math.PI)) * Math.PI * 2),
          { from: { angle: r }, to: { angle: s } }
        );
      },
      rotateOut: (t, e, i) => {
        var n;
        const s = null !== (n = t.getGraphicAttribute('angle', !0)) && void 0 !== n ? n : 0;
        let r = 0;
        return (
          (r = ot(s / (2 * Math.PI), 0)
            ? Math.round(s / (2 * Math.PI)) * Math.PI * 2
            : _(null == e ? void 0 : e.angle)
            ? e.angle
            : 'anticlockwise' === (null == e ? void 0 : e.orient)
            ? Math.ceil(s / (2 * Math.PI)) * Math.PI * 2
            : Math.floor(s / (2 * Math.PI)) * Math.PI * 2),
          { from: { angle: s }, to: { angle: r } }
        );
      },
      growCenterIn: (t, e, i) => {
        const n = t.getGraphicAttribute('x', !1),
          s = t.getGraphicAttribute('x1', !1),
          r = t.getGraphicAttribute('y', !1),
          a = t.getGraphicAttribute('y1', !1),
          o = t.getGraphicAttribute('width', !1),
          h = t.getGraphicAttribute('height', !1),
          c = t.getGraphicItem().attribute.x,
          d = t.getGraphicItem().attribute.y,
          u = t.getGraphicItem().attribute.width,
          p = t.getGraphicItem().attribute.height;
        switch (null == e ? void 0 : e.direction) {
          case 'x':
            return {
              from: { x: c + u / 2, x1: l(s) ? void 0 : c + u / 2, width: l(o) ? void 0 : 0 },
              to: { x: n, x1: s, width: o }
            };
          case 'y':
            return {
              from: { y: d + p / 2, y1: l(a) ? void 0 : d + p / 2, height: l(h) ? void 0 : 0 },
              to: { y: r, y1: a, height: h }
            };
          default:
            return {
              from: {
                x: c + u / 2,
                y: d + p / 2,
                x1: l(s) ? void 0 : c + u / 2,
                y1: l(a) ? void 0 : d + p / 2,
                width: l(o) ? void 0 : 0,
                height: l(h) ? void 0 : 0
              },
              to: { x: n, y: r, x1: s, y1: a, width: o, height: h }
            };
        }
      },
      growCenterOut: (t, e, i) => {
        const n = t.getGraphicAttribute('x1', !1),
          s = t.getGraphicAttribute('y1', !1),
          r = t.getGraphicAttribute('width', !1),
          a = t.getGraphicAttribute('height', !1),
          o = t.getGraphicItem().attribute.x,
          h = t.getGraphicItem().attribute.width,
          c = t.getGraphicItem().attribute.y,
          d = t.getGraphicItem().attribute.height;
        switch (null == e ? void 0 : e.direction) {
          case 'x':
            return { to: { x: o + h / 2, x1: l(n) ? void 0 : o + h / 2, width: l(r) ? void 0 : 0 } };
          case 'y':
            return { to: { y: c + d / 2, y1: l(s) ? void 0 : c + d / 2, height: l(a) ? void 0 : 0 } };
          default:
            return {
              to: {
                x: o + h / 2,
                y: c + d / 2,
                x1: l(n) ? void 0 : o + h / 2,
                y1: l(s) ? void 0 : c + d / 2,
                width: l(r) ? void 0 : 0,
                height: l(a) ? void 0 : 0
              }
            };
        }
      },
      growWidthIn: (t, e, i) => {
        var n;
        return !1 !== (null !== (n = null == e ? void 0 : e.overall) && void 0 !== n && n)
          ? (function (t, e, i) {
              const n = t.getGraphicAttribute('x', !1),
                s = t.getGraphicAttribute('x1', !1),
                r = t.getGraphicAttribute('width', !1);
              let a;
              if ('negative' === (null == e ? void 0 : e.orient)) {
                const t = i.group ? i.group.getBounds().width() : i.width;
                a = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : t;
              } else a = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : 0;
              return { from: { x: a, x1: l(s) ? void 0 : a, width: l(r) ? void 0 : 0 }, to: { x: n, x1: s, width: r } };
            })(t, e, i)
          : (function (t, e, i) {
              const n = t.getGraphicAttribute('x', !1),
                s = t.getGraphicAttribute('x1', !1),
                r = t.getGraphicAttribute('width', !1),
                a = t.getGraphicItem().attribute.x,
                o = a + t.getGraphicItem().attribute.width;
              return 'negative' === (null == e ? void 0 : e.orient)
                ? { from: { x: o, x1: l(s) ? void 0 : o, width: l(r) ? void 0 : 0 }, to: { x: n, x1: s, width: r } }
                : { from: { x: a, x1: l(s) ? void 0 : a, width: l(r) ? void 0 : 0 }, to: { x: n, x1: s, width: r } };
            })(t, e);
      },
      growWidthOut: (t, e, i) => {
        var n;
        return !1 !== (null !== (n = null == e ? void 0 : e.overall) && void 0 !== n && n)
          ? (function (t, e, i) {
              const n = t.getGraphicAttribute('x1', !1),
                s = t.getGraphicAttribute('width', !1);
              let r;
              if ('negative' === (null == e ? void 0 : e.orient)) {
                const t = i.group ? i.group.getBounds().width() : i.width;
                r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : t;
              } else r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : 0;
              return { to: { x: r, x1: l(n) ? void 0 : r, width: l(s) ? void 0 : 0 } };
            })(t, e, i)
          : (function (t, e, i) {
              const n = t.getGraphicAttribute('x1', !1),
                s = t.getGraphicAttribute('width', !1),
                r = t.getGraphicItem().attribute.x,
                a = r + t.getGraphicItem().attribute.width;
              return 'negative' === (null == e ? void 0 : e.orient)
                ? { to: { x: a, x1: l(n) ? void 0 : a, width: l(s) ? void 0 : 0 } }
                : { to: { x: r, x1: l(n) ? void 0 : r, width: l(s) ? void 0 : 0 } };
            })(t, e);
      },
      growHeightIn: (t, e, i) => {
        var n;
        return !1 !== (null !== (n = null == e ? void 0 : e.overall) && void 0 !== n && n)
          ? (function (t, e, i) {
              const n = t.getGraphicAttribute('y', !1),
                s = t.getGraphicAttribute('y1', !1),
                r = t.getGraphicAttribute('height', !1);
              let a;
              if ('negative' === (null == e ? void 0 : e.orient)) {
                const t = i.group ? i.group.getBounds().height() : i.height;
                a = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : t;
              } else a = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : 0;
              return {
                from: { y: a, y1: l(s) ? void 0 : a, height: l(r) ? void 0 : 0 },
                to: { y: n, y1: s, height: r }
              };
            })(t, e, i)
          : (function (t, e, i) {
              const n = t.getGraphicAttribute('y', !1),
                s = t.getGraphicAttribute('y1', !1),
                r = t.getGraphicAttribute('height', !1),
                a = t.getGraphicItem().attribute.y,
                o = a + t.getGraphicItem().attribute.height;
              return 'negative' === (null == e ? void 0 : e.orient)
                ? { from: { y: o, y1: l(s) ? void 0 : o, height: l(r) ? void 0 : 0 }, to: { y: n, y1: s, height: r } }
                : { from: { y: a, y1: l(s) ? void 0 : a, height: l(r) ? void 0 : 0 }, to: { y: n, y1: s, height: r } };
            })(t, e);
      },
      growHeightOut: (t, e, i) => {
        var n;
        return !1 !== (null !== (n = null == e ? void 0 : e.overall) && void 0 !== n && n)
          ? (function (t, e, i) {
              const n = t.getGraphicAttribute('y1', !1),
                s = t.getGraphicAttribute('height', !1);
              let r;
              if ('negative' === (null == e ? void 0 : e.orient)) {
                const t = i.group ? i.group.getBounds().height() : i.height;
                r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : t;
              } else r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : 0;
              return { to: { y: r, y1: l(n) ? void 0 : r, height: l(s) ? void 0 : 0 } };
            })(t, e, i)
          : (function (t, e, i) {
              const n = t.getGraphicAttribute('y1', !1),
                s = t.getGraphicAttribute('height', !1),
                r = t.getGraphicItem().attribute.y,
                a = r + t.getGraphicItem().attribute.height;
              return 'negative' === (null == e ? void 0 : e.orient)
                ? { to: { y: a, y1: l(n) ? void 0 : a, height: l(s) ? void 0 : 0 } }
                : { to: { y: r, y1: l(n) ? void 0 : r, height: l(s) ? void 0 : 0 } };
            })(t, e);
      },
      growAngleIn: (t, e, i) => {
        var n;
        return !1 !== (null !== (n = null == e ? void 0 : e.overall) && void 0 !== n && n)
          ? ((t, e, i) => {
              if ('anticlockwise' === (null == e ? void 0 : e.orient)) {
                const i = y(null == e ? void 0 : e.overall) ? e.overall : 2 * Math.PI;
                return {
                  from: { startAngle: i, endAngle: i },
                  to: {
                    startAngle: t.getGraphicAttribute('startAngle', !1),
                    endAngle: t.getGraphicAttribute('endAngle', !1)
                  }
                };
              }
              const n = y(null == e ? void 0 : e.overall) ? e.overall : 0;
              return {
                from: { startAngle: n, endAngle: n },
                to: {
                  startAngle: t.getGraphicAttribute('startAngle', !1),
                  endAngle: t.getGraphicAttribute('endAngle', !1)
                }
              };
            })(t, e)
          : ((t, e, i) =>
              'anticlockwise' === (null == e ? void 0 : e.orient)
                ? {
                    from: { startAngle: t.getGraphicAttribute('endAngle', !1) },
                    to: { startAngle: t.getGraphicAttribute('startAngle', !1) }
                  }
                : {
                    from: { endAngle: t.getGraphicAttribute('startAngle', !1) },
                    to: { endAngle: t.getGraphicAttribute('endAngle', !1) }
                  })(t, e);
      },
      growAngleOut: (t, e, i) => {
        var n;
        return !1 !== (null !== (n = null == e ? void 0 : e.overall) && void 0 !== n && n)
          ? ((t, e, i) => {
              if ('anticlockwise' === (null == e ? void 0 : e.orient)) {
                const i = y(null == e ? void 0 : e.overall) ? e.overall : 2 * Math.PI;
                return {
                  from: {
                    startAngle: t.getGraphicAttribute('startAngle', !0),
                    endAngle: t.getGraphicAttribute('endAngle', !0)
                  },
                  to: { startAngle: i, endAngle: i }
                };
              }
              const n = y(null == e ? void 0 : e.overall) ? e.overall : 0;
              return {
                from: {
                  startAngle: t.getGraphicAttribute('startAngle', !0),
                  endAngle: t.getGraphicAttribute('endAngle', !0)
                },
                to: { startAngle: n, endAngle: n }
              };
            })(t, e)
          : ((t, e, i) =>
              'anticlockwise' === (null == e ? void 0 : e.orient)
                ? {
                    from: { startAngle: t.getGraphicAttribute('startAngle', !0) },
                    to: { startAngle: t.getGraphicAttribute('endAngle', !1) }
                  }
                : {
                    from: { endAngle: t.getGraphicAttribute('endAngle', !0) },
                    to: { endAngle: t.getGraphicAttribute('startAngle', !1) }
                  })(t, e);
      },
      growRadiusIn: (t, e, i) => {
        var n;
        return !1 !== (null !== (n = null == e ? void 0 : e.overall) && void 0 !== n && n)
          ? ((t, e, i) => {
              const n = y(null == e ? void 0 : e.overall) ? e.overall : 0;
              return {
                from: { innerRadius: n, outerRadius: n },
                to: {
                  innerRadius: t.getGraphicAttribute('innerRadius', !1),
                  outerRadius: t.getGraphicAttribute('outerRadius', !1)
                }
              };
            })(t, e)
          : ((t, e, i) =>
              'inside' === (null == e ? void 0 : e.orient)
                ? {
                    from: { innerRadius: t.getGraphicAttribute('outerRadius', !1) },
                    to: { innerRadius: t.getGraphicAttribute('innerRadius', !1) }
                  }
                : {
                    from: { outerRadius: t.getGraphicAttribute('innerRadius', !1) },
                    to: { outerRadius: t.getGraphicAttribute('outerRadius', !1) }
                  })(t, e);
      },
      growRadiusOut: (t, e, i) => {
        var n;
        return !1 !== (null !== (n = null == e ? void 0 : e.overall) && void 0 !== n && n)
          ? ((t, e, i) => {
              const n = y(null == e ? void 0 : e.overall) ? e.overall : 0;
              return {
                from: {
                  innerRadius: t.getGraphicAttribute('innerRadius', !0),
                  outerRadius: t.getGraphicAttribute('outerRadius', !0)
                },
                to: { innerRadius: n, outerRadius: n }
              };
            })(t, e)
          : ((t, e, i) =>
              'inside' === (null == e ? void 0 : e.orient)
                ? {
                    from: { innerRadius: t.getGraphicAttribute('innerRadius', !0) },
                    to: { innerRadius: t.getGraphicAttribute('outerRadius', !1) }
                  }
                : {
                    from: { outerRadius: t.getGraphicAttribute('outerRadius', !0) },
                    to: { outerRadius: t.getGraphicAttribute('innerRadius', !1) }
                  })(t, e);
      },
      growPointsIn: (t, e, i) => ({ from: { points: iU(t, e) }, to: { points: t.getGraphicAttribute('points', !1) } }),
      growPointsOut: (t, e, i) => ({ from: { points: t.getGraphicAttribute('points', !0) }, to: { points: iU(t, e) } }),
      growPointsXIn: (t, e, i) => ({
        from: { points: nU(t, e, i) },
        to: { points: t.getGraphicAttribute('points', !1) }
      }),
      growPointsXOut: (t, e, i) => ({
        from: { points: t.getGraphicAttribute('points', !0) },
        to: { points: nU(t, e, i) }
      }),
      growPointsYIn: (t, e, i) => ({
        from: { points: sU(t, e, i) },
        to: { points: t.getGraphicAttribute('points', !1) }
      }),
      growPointsYOut: (t, e, i) => ({
        from: { points: t.getGraphicAttribute('points', !0) },
        to: { points: sU(t, e, i) }
      }),
      growIntervalIn: (t, e, i) => {
        var n, s;
        const r =
            null === (s = null === (n = t.mark) || void 0 === n ? void 0 : n.coord) || void 0 === s
              ? void 0
              : s.output(),
          a = r.isTransposed(),
          o = 'polar' === r.type,
          l = { orient: 'negative', direction: a && !o ? 'x' : 'y' };
        return !0 !== (null == e ? void 0 : e.overall)
          ? (function (t, e, i) {
              if ('x' === (null == e ? void 0 : e.direction)) {
                const i = t.getGraphicAttribute('x', !1),
                  n = t.getGraphicAttribute('x1', !1);
                return 'negative' === (null == e ? void 0 : e.orient)
                  ? { from: { x: n, x1: n }, to: { x: i, x1: n } }
                  : { from: { x: i, x1: i }, to: { x: i, y1: n } };
              }
              const n = t.getGraphicAttribute('y', !1),
                s = t.getGraphicAttribute('y1', !1);
              return 'negative' === (null == e ? void 0 : e.orient)
                ? { from: { y: s, y1: s }, to: { y: n, y1: s } }
                : { from: { y: n, y1: n }, to: { y: n, y1: s } };
            })(t, l)
          : (function (t, e, i) {
              if ('x' === (null == e ? void 0 : e.direction)) {
                const n = t.getGraphicAttribute('x', !1),
                  s = t.getGraphicAttribute('x1', !1);
                let r;
                if ('negative' === (null == e ? void 0 : e.orient)) {
                  const t = i.group ? i.group.getBounds().width() : i.width;
                  r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : t;
                } else r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : 0;
                return { from: { x: r, x1: r }, to: { x: n, y1: s } };
              }
              const n = t.getGraphicAttribute('y', !1),
                s = t.getGraphicAttribute('y1', !1);
              let r;
              if ('negative' === (null == e ? void 0 : e.orient)) {
                const t = i.group ? i.group.getBounds().height() : i.height;
                r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : t;
              } else r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : 0;
              return { from: { y: r, y1: r }, to: { y: n, y1: s } };
            })(t, l, i);
      },
      growIntervalOut: (t, e, i) => {
        var n, s;
        const r =
            null === (s = null === (n = t.mark) || void 0 === n ? void 0 : n.coord) || void 0 === s
              ? void 0
              : s.output(),
          a = r.isTransposed(),
          o = 'polar' === r.type,
          l = { orient: 'negative', direction: a && !o ? 'x' : 'y' };
        return !0 !== (null == e ? void 0 : e.overall)
          ? (function (t, e, i) {
              if ('x' === e.direction) {
                const i = t.getGraphicAttribute('x', !1),
                  n = t.getGraphicAttribute('x1', !1),
                  s = t.getGraphicAttribute('x', !0),
                  r = t.getGraphicAttribute('x1', !0);
                return 'negative' === (null == e ? void 0 : e.orient)
                  ? { from: { x: s, x1: r }, to: { x: n, x1: n } }
                  : { from: { x: s, x1: r }, to: { x: i, x1: i } };
              }
              const n = t.getGraphicAttribute('y', !1),
                s = t.getGraphicAttribute('y1', !1),
                r = t.getGraphicAttribute('y', !0),
                a = t.getGraphicAttribute('y1', !0);
              return 'negative' === (null == e ? void 0 : e.orient)
                ? { from: { y: r, y1: a }, to: { y: s, y1: s } }
                : { from: { y: r, y1: a }, to: { y: n, y1: n } };
            })(t, l)
          : (function (t, e, i) {
              if ('x' === (null == e ? void 0 : e.direction)) {
                const n = t.getGraphicAttribute('x', !0),
                  s = t.getGraphicAttribute('x1', !0);
                let r;
                if ('negative' === (null == e ? void 0 : e.orient)) {
                  const t = i.group ? i.group.getBounds().width() : i.height;
                  r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : t;
                } else r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : 0;
                return { from: { x: n, x1: s }, to: { x: r, x1: r } };
              }
              const n = t.getGraphicAttribute('y', !0),
                s = t.getGraphicAttribute('y1', !0);
              let r;
              if ('negative' === (null == e ? void 0 : e.orient)) {
                const t = i.group ? i.group.getBounds().height() : i.height;
                r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : t;
              } else r = y(null == e ? void 0 : e.overall) ? (null == e ? void 0 : e.overall) : 0;
              return { from: { y: n, y1: s }, to: { y: r, y1: r } };
            })(t, l, i);
      },
      update: (t, e, i) => {
        const n = Object.assign({}, t.getPrevGraphicAttributes()),
          s = Object.assign({}, t.getNextGraphicAttributes());
        return (
          rU.forEach(t => {
            delete n[t], delete s[t];
          }),
          V(null == e ? void 0 : e.excludeChannels).forEach(t => {
            delete n[t], delete s[t];
          }),
          Object.keys(s).forEach(t => {
            Uo(t, n, s) && (delete n[t], delete s[t]);
          }),
          { from: n, to: s }
        );
      }
    },
    oU = Object.assign({}, aU),
    lU = t => oU[t],
    hU = (t, e) => {
      oU[t] = e;
    },
    cU = t => (e, i, n) => {
      var s, r, a;
      const o =
          null !==
            (a =
              null !== (s = e.getGraphicAttribute('direction', !1)) && void 0 !== s
                ? s
                : null === (r = e.mark.getGlyphConfig()) || void 0 === r
                ? void 0
                : r.direction) && void 0 !== a
            ? a
            : 'vertical',
        l = t(e, o, i);
      if (!_(l)) return {};
      const h = e.getGraphicAttribute('x', !1),
        c = e.getGraphicAttribute('y', !1),
        d = e.getGraphicAttribute('min', !1),
        u = e.getGraphicAttribute('max', !1),
        p = e.getGraphicAttribute('q1', !1),
        g = e.getGraphicAttribute('q3', !1),
        f = e.getGraphicAttribute('median', !1),
        v = { from: { x: h, y: c }, to: { x: h, y: c } };
      return (
        _(d) && ((v.from.min = l), (v.to.min = d)),
        _(u) && ((v.from.max = l), (v.to.max = u)),
        _(p) && ((v.from.q1 = l), (v.to.q1 = p)),
        _(g) && ((v.from.q3 = l), (v.to.q3 = g)),
        _(f) && ((v.from.median = l), (v.to.median = f)),
        v
      );
    },
    dU = t => (e, i, n) => {
      var s, r, a;
      const o =
          null !==
            (a =
              null !== (s = e.getGraphicAttribute('direction', !1)) && void 0 !== s
                ? s
                : null === (r = e.mark.getGlyphConfig()) || void 0 === r
                ? void 0
                : r.direction) && void 0 !== a
            ? a
            : 'vertical',
        l = t(e, o, i);
      if (!_(l)) return {};
      const h = e.getGraphicAttribute('x', !0),
        c = e.getGraphicAttribute('y', !0),
        d = e.getGraphicAttribute('min', !0),
        u = e.getGraphicAttribute('max', !0),
        p = e.getGraphicAttribute('q1', !0),
        g = e.getGraphicAttribute('q3', !0),
        f = e.getGraphicAttribute('median', !0),
        v = { from: { x: h, y: c }, to: { x: h, y: c } };
      return (
        _(d) && ((v.to.min = l), (v.from.min = d)),
        _(u) && ((v.to.max = l), (v.from.max = u)),
        _(p) && ((v.to.q1 = l), (v.from.q1 = p)),
        _(g) && ((v.to.q3 = l), (v.from.q3 = g)),
        _(f) && ((v.to.median = l), (v.from.median = f)),
        v
      );
    },
    uU = (t, e, i) => {
      var n, s, r, a, o, l, h, c, d, u, p, g;
      if (_(null == i ? void 0 : i.center)) return i.center;
      let f, v, m, y, b;
      if ('horizontal' === e) {
        (f =
          null === (s = null === (n = t.getGraphicAttribute('points', !1, 'median')) || void 0 === n ? void 0 : n[0]) ||
          void 0 === s
            ? void 0
            : s.x),
          (v =
            null === (a = null === (r = t.getGraphicAttribute('points', !1, 'max')) || void 0 === r ? void 0 : r[0]) ||
            void 0 === a
              ? void 0
              : a.x),
          (m =
            null === (l = null === (o = t.getGraphicAttribute('points', !1, 'min')) || void 0 === o ? void 0 : o[0]) ||
            void 0 === l
              ? void 0
              : l.x);
        const e = t.getGraphicAttribute('width', !1, 'box'),
          i = t.getGraphicAttribute('x', !1, 'box');
        (y = i), (b = i + e);
      } else {
        (f =
          null === (c = null === (h = t.getGraphicAttribute('points', !1, 'median')) || void 0 === h ? void 0 : h[0]) ||
          void 0 === c
            ? void 0
            : c.y),
          (v =
            null === (u = null === (d = t.getGraphicAttribute('points', !1, 'max')) || void 0 === d ? void 0 : d[0]) ||
            void 0 === u
              ? void 0
              : u.y),
          (m =
            null === (g = null === (p = t.getGraphicAttribute('points', !1, 'min')) || void 0 === p ? void 0 : p[0]) ||
            void 0 === g
              ? void 0
              : g.y);
        const e = t.getGraphicAttribute('height', !1, 'box'),
          i = t.getGraphicAttribute('y', !1, 'box');
        (y = i), (b = i + e);
      }
      return _(f) ? f : _(y) && _(b) ? (y + b) / 2 : _(v) && _(m) ? (v + m) / 2 : _(m) ? m : _(v) ? v : NaN;
    },
    pU = (t, e, i, n) => {
      var s, r, a, o, l, h, c, d;
      const u = { shaft: {}, box: {}, max: {}, min: {}, median: {} },
        p = null !== (s = t.x) && void 0 !== s ? s : i.getGraphicAttribute('x', !1),
        g = null !== (r = t.y) && void 0 !== r ? r : i.getGraphicAttribute('y', !1),
        f = null !== (a = t.width) && void 0 !== a ? a : i.getGraphicAttribute('width', !1),
        v = null !== (o = t.height) && void 0 !== o ? o : i.getGraphicAttribute('height', !1),
        m = null !== (l = t.boxWidth) && void 0 !== l ? l : i.getGraphicAttribute('boxWidth', !1),
        y = null !== (h = t.boxHeight) && void 0 !== h ? h : i.getGraphicAttribute('boxHeight', !1),
        b = null !== (c = t.ruleWidth) && void 0 !== c ? c : i.getGraphicAttribute('ruleWidth', !1),
        x = null !== (d = t.ruleHeight) && void 0 !== d ? d : i.getGraphicAttribute('ruleHeight', !1);
      return (
        'horizontal' === (null == n ? void 0 : n.direction)
          ? (_(y)
              ? (Object.assign(u.box, { y: g - y / 2, y1: g + y / 2 }),
                Object.assign(u.median, { y: g - y / 2, y1: g + y / 2 }))
              : (Object.assign(u.box, { y: g - v / 2, y1: g + v / 2 }),
                Object.assign(u.median, { y: g - v / 2, y1: g + v / 2 })),
            _(x)
              ? (Object.assign(u.max, { y: g - x / 2, y1: g + x / 2 }),
                Object.assign(u.min, { y: g - x / 2, y1: g + x / 2 }))
              : (Object.assign(u.max, { y: g - v / 2, y1: g + v / 2 }),
                Object.assign(u.min, { y: g - v / 2, y1: g + v / 2 })))
          : (_(m)
              ? (Object.assign(u.box, { x: p - m / 2, x1: p + m / 2 }),
                Object.assign(u.median, { x: p - m / 2, x1: p + m / 2 }))
              : (Object.assign(u.box, { x: p - f / 2, x1: p + f / 2 }),
                Object.assign(u.median, { x: p - f / 2, x1: p + f / 2 })),
            _(b)
              ? (Object.assign(u.max, { x: p - b / 2, x1: p + b / 2 }),
                Object.assign(u.min, { x: p - b / 2, x1: p + b / 2 }))
              : (Object.assign(u.max, { x: p - f / 2, x1: p + f / 2 }),
                Object.assign(u.min, { x: p - f / 2, x1: p + f / 2 }))),
        u
      );
    },
    gU = cU(uU),
    fU = dU(uU);
  const vU = (t, e, i) => {
      var n, s, r, a;
      if (_(null == i ? void 0 : i.center)) return i.center;
      let o, l, h, c, d;
      if ('horizontal' === e) {
        o =
          null === (s = null === (n = t.getGraphicAttribute('points', !1, 'median')) || void 0 === n ? void 0 : n[0]) ||
          void 0 === s
            ? void 0
            : s.x;
        const e = t.getGraphicAttribute('width', !1, 'minMaxBox'),
          i = t.getGraphicAttribute('x', !1, 'minMaxBox');
        (h = i), (l = i + e);
        const r = t.getGraphicAttribute('width', !1, 'q1q3Box'),
          a = t.getGraphicAttribute('x', !1, 'q1q3Box');
        (c = a), (d = a + r);
      } else {
        o =
          null === (a = null === (r = t.getGraphicAttribute('points', !1, 'median')) || void 0 === r ? void 0 : r[0]) ||
          void 0 === a
            ? void 0
            : a.y;
        const e = t.getGraphicAttribute('height', !1, 'minMaxBox'),
          i = t.getGraphicAttribute('y', !1, 'minMaxBox');
        (h = i), (l = i + e);
        const n = t.getGraphicAttribute('height', !1, 'q1q3Box'),
          s = t.getGraphicAttribute('y', !1, 'q1q3Box');
        (c = s), (d = s + n);
      }
      return _(o) ? o : _(c) && _(d) ? (c + d) / 2 : _(l) && _(h) ? (l + h) / 2 : _(h) ? h : _(l) ? l : NaN;
    },
    mU = (t, e, i, n) => {
      var s, r, a, o, l, h, c, d;
      const u = { minMaxBox: {}, q1q3Box: {}, median: {} },
        p = null !== (s = t.x) && void 0 !== s ? s : i.getGraphicAttribute('x', !1),
        g = null !== (r = t.y) && void 0 !== r ? r : i.getGraphicAttribute('y', !1),
        f = null !== (a = t.width) && void 0 !== a ? a : i.getGraphicAttribute('width', !1),
        v = null !== (o = t.minMaxWidth) && void 0 !== o ? o : i.getGraphicAttribute('minMaxWidth', !1),
        m = null !== (l = t.q1q3Width) && void 0 !== l ? l : i.getGraphicAttribute('q1q3Width', !1),
        y = null !== (h = t.height) && void 0 !== h ? h : i.getGraphicAttribute('height', !1),
        b = null !== (c = t.minMaxHeight) && void 0 !== c ? c : i.getGraphicAttribute('minMaxHeight', !1),
        x = null !== (d = t.q1q3Height) && void 0 !== d ? d : i.getGraphicAttribute('q1q3Height', !1);
      return (
        'horizontal' === (null == n ? void 0 : n.direction)
          ? (_(b)
              ? Object.assign(u.minMaxBox, { y: g - b / 2, y1: g + b / 2 })
              : Object.assign(u.minMaxBox, { y: g - y / 2, y1: g + y / 2 }),
            _(x)
              ? (Object.assign(u.q1q3Box, { y: g - x / 2, y1: g + x / 2 }),
                Object.assign(u.median, { y: g - x / 2, y1: g + x / 2 }))
              : (Object.assign(u.q1q3Box, { y: g - y / 2, y1: g + y / 2 }),
                Object.assign(u.median, { y: g - y / 2, y1: g + y / 2 })))
          : (_(v)
              ? Object.assign(u.minMaxBox, { x: p - v / 2, x1: p + v / 2 })
              : Object.assign(u.minMaxBox, { x: p - f / 2, x1: p + f / 2 }),
            _(m)
              ? (Object.assign(u.q1q3Box, { x: p - m / 2, x1: p + m / 2 }),
                Object.assign(u.median, { x: p - m / 2, x1: p + m / 2 }))
              : (Object.assign(u.q1q3Box, { x: p - f / 2, x1: p + f / 2 }),
                Object.assign(u.median, { x: p - f / 2, x1: p + f / 2 }))),
        u
      );
    },
    yU = cU(vU),
    _U = dU(vU);
  const bU = (t, e) => {
      var i;
      const n = null !== (i = t.curvature) && void 0 !== i ? i : 0.5,
        s = 'number' == typeof e ? t.thickness * e : t.thickness;
      let r = t.x0,
        a = t.x1,
        o = t.y0,
        l = t.y1,
        h = r + n * (a - r),
        c = a + n * (r - a),
        d = t => t;
      !1 !== t.round &&
        ((r = Math.round(r)),
        (a = Math.round(a)),
        (o = Math.round(o)),
        (l = Math.round(l)),
        (h = Math.round(h)),
        (c = Math.round(c)),
        (d = Math.round)),
        'line' === t.pathType || t.pathType,
        'center' === t.align
          ? ((o = d(t.y0 - s / 2)), (l = d(t.y1 - s / 2)))
          : 'end' === t.align
          ? ((o = d(t.y0 + t.thickness / 2 - s)), (l = d(t.y1 + t.thickness / 2 - s)))
          : ((o = d(t.y0 - t.thickness / 2)), (l = d(t.y1 - t.thickness / 2)));
      const u = d(o + s),
        p = d(l + s),
        g = Math.abs(a - r) > 1e-6,
        f = t.endArrow && g ? `L${a},${d(l - s / 2)}L${d(a + s)},${d((l + p) / 2)}L${a},${d(p + s / 2)}` : '',
        v = t.startArrow && g ? `L${r},${d(u + s / 2)}L${d(r - s)},${d((o + u) / 2)}L${r},${d(o - s / 2)}` : '';
      return 'line' === t.pathType
        ? `M${r},${o}L${a},${l}${f}L${a},${p}L${r},${u}${v}Z`
        : 'polyline' === t.pathType
        ? `M${r},${o}L${h},${o}L${h},${l}L${a},${l}\n    ${f}L${a},${p}L${h},${p}L${h},${u}L${r},${u}${v}Z`
        : `M${r},${o}C${h},${o},${c},${l},${a},${l}\n  ${f}L${a},${p}C${c},${p},${h},${u},${r},${u}${v}Z`;
    },
    xU = (t, e) => {
      var i;
      const n = null !== (i = t.curvature) && void 0 !== i ? i : 0.5,
        s = 'number' == typeof e ? t.thickness * e : t.thickness;
      let r = t.y0,
        a = t.y1,
        o = t.x0,
        l = t.x1,
        h = r + n * (a - r),
        c = a + n * (r - a),
        d = t => t;
      !1 !== t.round &&
        ((d = Math.round),
        (r = Math.round(r)),
        (a = Math.round(a)),
        (o = Math.round(o)),
        (l = Math.round(l)),
        (h = Math.round(h)),
        (c = Math.round(c))),
        'line' === t.pathType || t.pathType,
        'center' === t.align
          ? ((o = d(t.x0 - s / 2)), (l = d(t.x1 - s / 2)))
          : 'end' === t.align
          ? ((o = d(t.x0 + t.thickness / 2 - s)), (l = d(t.x1 + t.thickness / 2 - s)))
          : ((o = d(t.x0 - t.thickness / 2)), (l = d(t.x1 - t.thickness / 2)));
      const u = d(o + s),
        p = d(l + s),
        g = Math.abs(a - r) > 1e-6,
        f = t.endArrow && g ? `L${d(l - s / 2)},${a}L${d((l + p) / 2)},${d(a + s)}L${d(p + s / 2)},${a}` : '',
        v = t.startArrow && g ? `L${d(u + s / 2)},${r}L${d((u + o) / 2)},${d(r - s)}L${d(o - s / 2)},${r}` : '';
      return 'line' === t.pathType
        ? `M${o},${r}L${l},${a}${f}L${p},${a}L${u},${r}${v}Z`
        : 'polyline' === t.pathType
        ? `M${o},${r}L${o},${h}L${l},${h}L${l},${a}\n    ${f}L${p},${a}L${p},${h}L${u},${h}L${u},${r}${v}Z`
        : `M${o},${r}C${o},${h},${l},${c},${l},${a}\n  ${f}L${p},${a}C${p},${c},${u},${h},${u},${r}${v}Z`;
    },
    SU = (t, e, i, n) => {
      var s;
      const r = null !== (s = t.direction) && void 0 !== s ? s : null == n ? void 0 : n.direction,
        a = ['vertical', 'TB', 'BT'].includes(r) ? xU : bU,
        o = 'number' == typeof t.ratio && t.ratio >= 0 && t.ratio <= 1,
        l = Object.keys(t);
      return ['x0', 'y0', 'x1', 'y1'].every(t => l.includes(t))
        ? { back: { path: o ? a(t, 1) : '' }, front: { path: a(t, o ? t.ratio : 1) } }
        : {};
    },
    wU = (t, e, i) => {
      const n = {
        x0: t.getGraphicAttribute('x0', !1),
        x1: t.getGraphicAttribute('x1', !1),
        y0: t.getGraphicAttribute('y0', !1),
        y1: t.getGraphicAttribute('y1', !1),
        thickness: t.getGraphicAttribute('thickness', !1),
        round: t.getGraphicAttribute('round', !1),
        align: t.getGraphicAttribute('align', !1),
        pathType: t.getGraphicAttribute('pathType', !1),
        endArrow: t.getGraphicAttribute('endArrow', !1),
        startArrow: t.getGraphicAttribute('startArrow', !1)
      };
      return (
        Object.keys(n).forEach(t => {
          l(n[t]) && delete n[t];
        }),
        { from: Object.assign({}, n, { x1: n.x0, y1: n.y0 }), to: n }
      );
    },
    AU = (t, e, i) => {
      const n = {
        x0: t.getGraphicAttribute('x0', !0),
        x1: t.getGraphicAttribute('x1', !0),
        y0: t.getGraphicAttribute('y0', !0),
        y1: t.getGraphicAttribute('y1', !0),
        thickness: t.getGraphicAttribute('thickness', !0),
        round: t.getGraphicAttribute('round', !0),
        align: t.getGraphicAttribute('align', !0),
        pathType: t.getGraphicAttribute('pathType', !0),
        endArrow: t.getGraphicAttribute('endArrow', !0),
        startArrow: t.getGraphicAttribute('startArrow', !0)
      };
      return (
        Object.keys(n).forEach(t => {
          l(n[t]) && delete n[t];
        }),
        { from: n, to: Object.assign({}, n, { x1: n.x0, y1: n.y0 }) }
      );
    },
    kU = (t, e, i) => {
      const n = {
        thickness: t.getGraphicAttribute('thickness', !1),
        round: t.getGraphicAttribute('round', !1),
        align: t.getGraphicAttribute('align', !1),
        pathType: t.getGraphicAttribute('pathType', !1),
        endArrow: t.getGraphicAttribute('endArrow', !1),
        startArrow: t.getGraphicAttribute('startArrow', !1)
      };
      return (
        Object.keys(n).forEach(t => {
          l(n[t]) && delete n[t];
        }),
        {
          from: Object.assign(
            Object.assign(
              {
                x0: t.getGraphicAttribute('x0', !0),
                x1: t.getGraphicAttribute('x1', !0),
                y0: t.getGraphicAttribute('y0', !0),
                y1: t.getGraphicAttribute('y1', !0)
              },
              n
            ),
            n
          ),
          to: Object.assign(
            {
              x0: t.getGraphicAttribute('x0', !1),
              x1: t.getGraphicAttribute('x1', !1),
              y0: t.getGraphicAttribute('y0', !1),
              y1: t.getGraphicAttribute('y1', !1)
            },
            n
          )
        }
      );
    },
    MU = (t, e) => {
      if (!t) return null;
      if (null == t ? void 0 : t.from) {
        const i = t.from;
        Object.keys(i).forEach(t => {
          l(i[t]) && delete i[t];
        });
        const n = RG(Object.keys(i), e.mark.markType) && !h(i.segments);
        if (n) {
          const s = e.items.map(t => Object.assign({}, t, { nextAttrs: i }));
          t.from = e.transformElementItems(s, e.mark.markType, n);
        }
      }
      if (null == t ? void 0 : t.to) {
        const i = t.to;
        Object.keys(i).forEach(t => {
          l(i[t]) && delete i[t];
        });
        const n = RG(Object.keys(i), e.mark.markType) && !h(i.segments);
        if (n) {
          const s = e.items.map(t => Object.assign({}, t, { nextAttrs: i }));
          t.to = e.transformElementItems(s, e.mark.markType, n);
        }
      }
      return t;
    };
  const TU = (t, e, i, n, s) => (o(i) ? i(t.getDatum(), t, s) : i);
  class CU extends wM {
    constructor(t, e, i, n, s) {
      super(t, e, i, n, s),
        (this._interpolator = null == s ? void 0 : s.interpolator),
        (this._element = null == s ? void 0 : s.element);
    }
    onBind() {
      var t, e;
      (this.from = null !== (t = this.from) && void 0 !== t ? t : {}),
        (this.to = null !== (e = this.to) && void 0 !== e ? e : {});
    }
    getEndProps() {
      return this.to;
    }
    onUpdate(t, e, i) {
      this._interpolator &&
        this._element &&
        this._interpolator.call(
          this,
          e,
          this.from,
          this.to,
          i,
          this._element.getDatum(),
          this._element,
          this.params.parameters
        );
    }
  }
  class EU extends wM {
    getEndProps() {
      return this.to;
    }
    onBind() {
      var t, e;
      (this.from = null !== (t = this.from) && void 0 !== t ? t : {}),
        (this.to = null !== (e = this.to) && void 0 !== e ? e : {});
    }
    onStart() {
      const t = Object.assign({}, this.from),
        e = Object.assign({}, this.to);
      Object.keys(e).forEach(e => {
        l(t[e]) && (t[e] = this.target.getComputedAttribute(e));
      }),
        this.target.setAttributes(t, !1, { type: Pw.ANIMATE_UPDATE, animationState: { ratio: 0, end: !1 } }),
        (this._fromAttribute = t),
        (this._toAttribute = e);
    }
    onEnd() {
      this.target.setAttributes(this._toAttribute, !1, { type: Pw.ANIMATE_END });
    }
    onUpdate(t, e, i) {
      this.target.stepInterpolate(
        this.subAnimate,
        this.subAnimate.animate,
        i,
        this.step,
        e,
        t,
        this._toAttribute,
        this._fromAttribute
      );
    }
  }
  kM.mode |= Ow.SET_ATTR_IMMEDIATELY;
  let PU = 0;
  const RU = t => !l(t) && t.prototype instanceof wM;
  class OU {
    constructor(t, e, i) {
      (this.id = PU++),
        (this.isAnimating = !1),
        (this.runnings = []),
        (this.element = t),
        (this.animationOptions = i),
        (this.unit = e);
    }
    callback(t) {
      return (this.callbackFunction = t), this;
    }
    animate(t, e) {
      return (
        (this.isAnimating = !0), this.animateElement(t, e), 0 === this.runnings.length && this.animationEnd(), this
      );
    }
    stop() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'end',
        e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      return this.runnings.forEach(e => e.stop(t)), this.animationEnd(e), this;
    }
    pause() {
      return this.runnings.forEach(t => t.pause()), this;
    }
    resume() {
      return this.runnings.forEach(t => t.resume()), this;
    }
    startAt(t) {
      return (
        this.runnings.forEach(e => {
          const i = this.unit.initialDelay;
          e.startAt(i + t);
        }),
        this
      );
    }
    getTotalAnimationTime() {
      var t;
      const e = this.unit.initialDelay + this.unit.loopDuration * this.unit.loopCount;
      return null !== (t = this.unit.totalTime) && void 0 !== t ? t : e;
    }
    getEndAttributes() {
      return this.runnings.reduce((t, e) => Object.assign(t, e.getEndProps()), {});
    }
    animationEnd() {
      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      var e;
      (this.isAnimating = !1),
        (this.runnings = null),
        t && (null === (e = this.callbackFunction) || void 0 === e || e.call(null));
    }
    animateElement(t, e) {
      const i = this.element.getGraphicItem().animate();
      this.runnings.push(i),
        i.startAt(this.unit.initialDelay),
        i.wait(this.unit.loopDelay),
        this.unit.timeSlices.forEach(n => {
          this.animateTimeSlice(i, n, t, e);
        }),
        i.wait(this.unit.loopDelayAfter),
        i.loop(this.unit.loopCount - 1),
        _(this.unit.totalTime) &&
          setTimeout(() => {
            i && i.stop('end');
          }, this.unit.totalTime),
        i.onEnd(() => {
          (this.runnings = this.runnings.filter(t => t !== i)), 0 === this.runnings.length && this.animationEnd();
        });
    }
    animateTimeSlice(t, e, i, n) {
      const s = e.delay,
        r = e.duration,
        a = e.effects;
      if ((s > 0 && t.wait(s), a.length < 0)) t.wait(r);
      else {
        const e = a
          .map((t, e) => {
            var s;
            const a =
                null !==
                  (s = t.type
                    ? (function (t, e, i, n) {
                        const s = o(e.options) ? e.options.call(null, t.getDatum(), t, n) : e.options;
                        if (!e.type || !lU(e.type)) return null;
                        const r = lU(e.type)(t, s, i);
                        return MU(r, t);
                      })(this.element, t, i, n)
                    : (function (t, e, i, n) {
                        const s = e.channel;
                        let r = null;
                        return (
                          f(s)
                            ? (r = s.reduce(
                                (e, i) => (
                                  (e.from[i] = t.getGraphicAttribute(i, !0)),
                                  (e.to[i] = t.getGraphicAttribute(i, !1)),
                                  e
                                ),
                                { from: {}, to: {} }
                              ))
                            : c(s) &&
                              (r = Object.keys(s).reduce(
                                (e, i) => {
                                  var r, a;
                                  const o = !l(null === (r = s[i]) || void 0 === r ? void 0 : r.from),
                                    h = !l(null === (a = s[i]) || void 0 === a ? void 0 : a.to);
                                  return (
                                    (o || h) &&
                                      ((e.from[i] = o ? TU(t, 0, s[i].from, 0, n) : void 0),
                                      (e.to[i] = h ? TU(t, 0, s[i].to, 0, n) : t.getGraphicAttribute(i, !1))),
                                    e
                                  );
                                },
                                { from: {}, to: {} }
                              )),
                          MU(r, t)
                        );
                      })(this.element, t, 0, n)) && void 0 !== s
                  ? s
                  : {},
              h = (null == a ? void 0 : a.custom) || (null == t ? void 0 : t.custom),
              d = (null == a ? void 0 : a.customParameters) || (null == t ? void 0 : t.customParameters);
            a.from &&
              Object.keys(a.from).length &&
              this.unit &&
              this.animationOptions.timeline.controlOptions.immediatelyApply &&
              'component' !== this.element.mark.markType &&
              this.element.getGraphicItem().setAttributes(a.from);
            const u = RU(h);
            return l(h) || RU(h)
              ? u
                ? new h(a.from, a.to, r, t.easing, d)
                : a.to
                ? new EU(a.from, a.to, r, t.easing)
                : void 0
              : new CU(a.from, a.to, r, t.easing, { interpolator: h, element: this.element, parameters: d });
          })
          .filter(t => !l(t));
        1 === e.length ? t.play(e[0]) : t.play(new QM(r, e));
      }
    }
  }
  function BU(t) {
    let e = [];
    return (
      Object.keys(t).forEach(i => {
        e = e.concat(IU(i, t[i]));
      }),
      e
    );
  }
  function IU(t, e) {
    const i = [];
    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return (
      V(e).forEach(e => {
        var s;
        const r = (function (t) {
          var e, i, n, s, r, a, o, h, c, d, u;
          if (l(t.timeSlices)) {
            const l = t;
            return {
              startTime: null !== (e = l.startTime) && void 0 !== e ? e : hG,
              totalTime: l.totalTime,
              oneByOne: null !== (i = l.oneByOne) && void 0 !== i ? i : pG,
              loop: null !== (n = l.loop) && void 0 !== n ? n : uG,
              controlOptions: D({}, fG, null !== (s = l.controlOptions) && void 0 !== s ? s : {}),
              timeSlices: [
                {
                  duration: null !== (r = l.duration) && void 0 !== r ? r : cG,
                  delay: null !== (a = l.delay) && void 0 !== a ? a : dG,
                  effects: [
                    {
                      type: l.type,
                      channel: l.channel,
                      custom: l.custom,
                      easing: null !== (o = l.easing) && void 0 !== o ? o : gG,
                      customParameters: l.customParameters,
                      options: l.options
                    }
                  ]
                }
              ]
            };
          }
          const p = V(t.timeSlices).filter(t => t.effects && V(t.effects).filter(t => t.channel || t.type).length);
          if (p.length)
            return {
              startTime: null !== (h = t.startTime) && void 0 !== h ? h : hG,
              totalTime: t.totalTime,
              oneByOne: null !== (c = t.oneByOne) && void 0 !== c ? c : pG,
              loop: null !== (d = t.loop) && void 0 !== d ? d : uG,
              controlOptions: D({}, fG, null !== (u = t.controlOptions) && void 0 !== u ? u : {}),
              timeSlices: p.map(t => {
                var e;
                return {
                  duration: t.duration,
                  delay: null !== (e = t.delay) && void 0 !== e ? e : dG,
                  effects: V(t.effects)
                    .filter(t => t.channel || t.type)
                    .map(t => {
                      var e;
                      return {
                        type: t.type,
                        channel: t.channel,
                        custom: t.custom,
                        easing: null !== (e = t.easing) && void 0 !== e ? e : gG,
                        customParameters: t.customParameters,
                        options: t.options
                      };
                    })
                };
              }),
              partitioner: t.partitioner,
              sort: t.sort
            };
        })(e);
        r &&
          (i.push({
            state: t,
            id: null !== (s = r.id) && void 0 !== s ? s : `${t}-${n}`,
            timeline: r,
            originConfig: e
          }),
          (n += 1));
      }),
      i
    );
  }
  function DU(t, e, i) {
    return o(t) ? t.call(null, e.getDatum(), e, i) : t;
  }
  class LU {
    constructor(t) {
      (this.parallelArrangers = [this]),
        (this.totalTime = 0),
        (this.startTime = 0),
        (this.endTime = 0),
        (this.animators = t.filter(t => !l(t))),
        (this.totalTime = this.animators.reduce((t, e) => Math.max(t, e.getTotalAnimationTime()), 0));
    }
    parallel(t) {
      const e = Array.from(new Set(this.parallelArrangers.concat(t.parallelArrangers)));
      return (
        e.forEach(t => {
          t.parallelArrangers = e;
        }),
        this.arrangeTime(),
        this
      );
    }
    after(t) {
      return (this.afterArranger = t), this.arrangeTime(), this;
    }
    arrangeTime() {
      const t = this.parallelArrangers.reduce((t, e) => Math.max(t, e.totalTime), this.totalTime),
        e = this.parallelArrangers.reduce((t, e) => {
          var i, n;
          return Math.max(
            t,
            null !== (n = null === (i = e.afterArranger) || void 0 === i ? void 0 : i.endTime) && void 0 !== n ? n : 0
          );
        }, 0);
      this.parallelArrangers.forEach(i => {
        (i.startTime = e),
          (i.endTime = e + t),
          i.animators.forEach(t => {
            t.startAt(e);
          });
      });
    }
  }
  class FU {
    constructor(t, e) {
      (this.state = null),
        (this.immediateConfigs = []),
        (this.isEnabled = !0),
        (this.disabledStates = []),
        (this.animators = new Map()),
        (this.elementRecorder = new WeakMap()),
        (this.timelineCount = {}),
        (this.mark = t),
        (this.configs = BU(null != e ? e : {}));
    }
    updateConfig(t) {
      this.configs = BU(null != t ? t : {});
    }
    updateState(t) {
      this.state = t;
    }
    animate() {
      if (!this.isEnabled || !this.configs || !this.configs.length) return;
      const t = this.mark.getAllElements(),
        e = this.mark.parameters();
      return (
        t.forEach(t => {
          var e;
          t.isReserved && t.diffState !== WW.exit && (t.isReserved = !1);
          const i = null === (e = this.elementRecorder.get(t)) || void 0 === e ? void 0 : e.prevState;
          this.configs.some(e => i !== t.diffState && e.state === i && e.timeline.controlOptions.stopWhenStateChange) &&
            this.clearElementAnimation(t, !1);
        }),
        this.configs.forEach(i => {
          this.animateByTimeline(i, t, e);
        }),
        this.mark.cleanExitElements(),
        this
      );
    }
    runAnimationByState(t) {
      if (!this.isEnabled) return;
      const e = this.configs.filter(e => e.state === t),
        i = this.mark.getAllElements(),
        n = this.mark.parameters(),
        s = e.reduce((t, e) => t.concat(this.animateByTimeline(e, i, n, !0)), []);
      return new LU(s);
    }
    stopAnimationByState(t) {
      const e = this.animators.get(t);
      return e && e.forEach(t => t.stop()), this;
    }
    pauseAnimationByState(t) {
      const e = this.animators.get(t);
      return e && e.forEach(t => t.pause()), this;
    }
    resumeAnimationByState(t) {
      const e = this.animators.get(t);
      return e && e.forEach(t => t.resume()), this;
    }
    run(t) {
      if (!this.isEnabled) return;
      const e = IU(lG, t, this.immediateConfigs.length);
      this.immediateConfigs = this.immediateConfigs.concat(e);
      const i = this.mark.getAllElements(),
        n = this.mark.parameters(),
        s = e.reduce((t, e) => t.concat(this.animateByTimeline(e, i, n, !0)), []);
      return new LU(s);
    }
    stop() {
      return (
        this.animators.forEach(t => {
          t.forEach(t => t.stop());
        }),
        this
      );
    }
    pause() {
      return this.animators.forEach(t => t.forEach(t => t.pause())), this;
    }
    resume() {
      return this.animators.forEach(t => t.forEach(t => t.resume())), this;
    }
    reverse() {
      return this;
    }
    restart() {
      return this;
    }
    record() {
      return this;
    }
    recordEnd() {
      return this;
    }
    isAnimating() {
      let t = !1;
      return (
        this.animators.forEach(e => {
          t = t || e.some(t => t.isAnimating);
        }),
        t
      );
    }
    isElementAnimating(t) {
      var e;
      const i = null === (e = this.elementRecorder.get(t)) || void 0 === e ? void 0 : e.count;
      return l(i) || Object.values(i).every(t => 0 === t);
    }
    getAnimatorCount() {
      let t = 0;
      return this.animators.forEach(e => (t += e.length)), t;
    }
    getAllAnimators() {
      const t = [];
      return (
        this.animators.forEach(e => {
          t.push(...e);
        }),
        t
      );
    }
    getElementAnimators(t, e) {
      var i;
      const n = V(t);
      let s = [];
      return (
        e
          ? (s = null !== (i = this.animators.get(e)) && void 0 !== i ? i : [])
          : this.animators.forEach(t => {
              s = s.concat(t);
            }),
        s.filter(t => n.includes(t.element))
      );
    }
    enable() {
      return (this.isEnabled = !0), this;
    }
    disable() {
      return (this.isEnabled = !1), this.stop(), this.animators.clear(), this;
    }
    enableAnimationState(t) {
      const e = V(t);
      return (this.disabledStates = this.disabledStates.filter(t => !e.includes(t))), this;
    }
    disableAnimationState(t) {
      const e = V(t);
      return (this.disabledStates = this.disabledStates.concat(e)), this;
    }
    release() {
      this.stop(),
        this.animators.clear(),
        (this.configs = null),
        (this.animators = null),
        (this.elementRecorder = null),
        (this.timelineCount = null);
    }
    animateByTimeline(t, e, i) {
      let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
      const s = [],
        r = e.filter(e => {
          const s = !(e.isReserved && e.diffState === WW.exit),
            r = this.getAnimationState(e),
            a = !this.disabledStates.includes(r),
            o = n || r === t.state,
            l = !t.timeline.partitioner || t.timeline.partitioner(e.getDatum(), e, i);
          return s && a && o && l;
        });
      return (
        r.length &&
          (l(this.timelineCount[t.id]) && (this.timelineCount[t.id] = 0),
          t.timeline.sort && r.sort((e, n) => t.timeline.sort(e.getDatum(), n.getDatum(), e, n, i)),
          r.forEach((e, n) => {
            var a;
            const o = {
                width: this.mark.view.width(),
                height: this.mark.view.height(),
                group: null !== (a = this.mark.group) && void 0 !== a ? a : null,
                mark: this.mark,
                view: this.mark.view,
                elementCount: r.length,
                elementIndex: n
              },
              l = Object.assign({ VGRAMMAR_ANIMATION_PARAMETERS: o }, i),
              h = this.getAnimationUnit(t.timeline, e, n, r.length, l);
            s.push(this.animateElement(t, h, e, o, l));
          })),
        s
      );
    }
    animateElement(t, e, i, n, s) {
      var r, a, o;
      const l = new OU(i, e, t);
      if ((l.animate(n, s), !l.isAnimating)) return;
      i.diffState === WW.exit && (i.isReserved = !0);
      const h = 0 === this.timelineCount[t.id];
      this.timelineCount[t.id] += 1;
      const c = null !== (r = this.elementRecorder.get(i)) && void 0 !== r ? r : { prevState: t.state, count: {} };
      (c.prevState = t.state),
        (c.count[t.state] = (null !== (a = c.count[t.state]) && void 0 !== a ? a : 0) + 1),
        this.elementRecorder.set(i, c),
        this.animators.set(t.state, (null !== (o = this.animators.get(t.state)) && void 0 !== o ? o : []).concat(l)),
        l.callback(() => {
          this.handleAnimatorEnd(l);
        });
      const d = { mark: this.mark, animationState: t.state, animationConfig: t.originConfig };
      return h && this.mark.emit(tG.ANIMATION_START, d), this.mark.emit(tG.ELEMENT_ANIMATION_START, d, i), l;
    }
    getAnimationState(t) {
      const e = LW(this.state, this.mark.parameters(), t.getDatum(), t);
      return null != e ? e : t.diffState;
    }
    getAnimationUnit(t, e, i, n, s) {
      const r = [],
        a = DU(t.startTime, e, s),
        o = DU(t.totalTime, e, s),
        l = DU(t.oneByOne, e, s),
        h = DU(t.loop, e, s);
      let c = 0;
      t.timeSlices.forEach(t => {
        var i;
        const a = DU(t.delay, e, s),
          l = null !== (i = DU(t.duration, e, s)) && void 0 !== i ? i : o / n,
          h = V(t.effects).map(t => Object.assign({}, t, { customParameters: DU(t.customParameters, e, s) }));
        r.push({ effects: h, duration: l, delay: a }), (c += a + l);
      });
      const d = y(l) ? l : !0 === l ? c : 0;
      return {
        initialDelay: a,
        loopCount: y(h) ? h : !0 === h ? 1 / 0 : 1,
        loopDelay: d * i,
        loopDelayAfter: d * (n - i - 1),
        loopAnimateDuration: c,
        loopDuration: c + d * (n - 1),
        totalTime: o,
        timeSlices: r
      };
    }
    clearElementAnimation(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      this.animators.forEach(i => {
        i.forEach(i => {
          i.element === t &&
            (i.animationOptions.state === WW.exit ? i.stop('start', !1) : i.stop('end', !1),
            this.handleAnimatorEnd(i, e));
        });
      }),
        this.elementRecorder.delete(t);
    }
    clearAllElements() {
      const t = this.mark.getAllElements();
      t &&
        t.forEach((e, i) => {
          this.clearElement(e, i === t.length - 1);
        });
    }
    clearElement(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      this.clearElementAnimation(t),
        t.getGraphicItem() &&
          (t.clearGraphicAttributes(),
          t.diffState === WW.exit && (t.isReserved = !1),
          e && this.mark.cleanExitElements());
    }
    handleAnimatorEnd(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      const i = t.element,
        n = t.animationOptions,
        s = n.state,
        r = s === lG,
        a = this.elementRecorder.get(i).count;
      (a[s] -= 1),
        this.animators.set(
          s,
          this.animators.get(s).filter(e => e !== t)
        ),
        0 === this.animators.get(s).length && this.animators.delete(s),
        (this.timelineCount[n.id] -= 1);
      const o = 0 === this.timelineCount[n.id],
        l = r
          ? this.immediateConfigs.find(t => t.id === n.id).originConfig
          : this.configs.find(t => t.id === n.id).originConfig;
      o &&
        (delete this.timelineCount[n.id],
        r && (this.immediateConfigs = this.immediateConfigs.filter(t => t.id !== n.id))),
        e &&
          (0 === Object.keys(this.timelineCount).length
            ? this.clearAllElements()
            : s === WW.exit && 0 === a[WW.exit] && this.clearElement(i));
      const h = { mark: this.mark, animationState: s, animationConfig: l };
      o && this.mark.emit(tG.ANIMATION_END, h), this.mark.emit(tG.ELEMENT_ANIMATION_END, h, i);
    }
  }
  const jU = (t, e) =>
      zW(t) ? t.output() : t && c(t) ? (o(t.callback) ? i => t.callback(i, e) : o(t.value) ? t.value(e) : t) : t,
    zU = (t, e) =>
      t
        ? c(t)
          ? Object.keys(t).reduce((i, n) => {
              const s = t[n];
              return (i[n] = jU(s, e)), i;
            }, {})
          : t.map(t => jU(t, e))
        : t;
  var HU = function (t, e, i, n) {
    return new (i || (i = Promise))(function (s, r) {
      function a(t) {
        try {
          l(n.next(t));
        } catch (t) {
          r(t);
        }
      }
      function o(t) {
        try {
          l(n.throw(t));
        } catch (t) {
          r(t);
        }
      }
      function l(t) {
        var e;
        t.done
          ? s(t.value)
          : ((e = t.value),
            e instanceof i
              ? e
              : new i(function (t) {
                  t(e);
                })).then(a, o);
      }
      l((n = n.apply(t, e || [])).next());
    });
  };
  let NU = -1;
  class VU extends s {
    constructor(t) {
      super(),
        (this.spec = {}),
        (this.references = new Map()),
        (this.targets = []),
        (this.transforms = []),
        (this.view = t),
        (this.uid = ++NU);
    }
    parse(t) {
      return this.id(t.id), this.name(t.name), this.depend(t.dependency), this;
    }
    depend(t) {
      var e;
      if (null === (e = this.spec) || void 0 === e ? void 0 : e.dependency) {
        const t = V(this.spec.dependency).map(t => (g(t) ? this.view.getGrammarById(t) : t));
        this.detach(t);
      }
      this.spec.dependency = t;
      const i = V(t).map(t => (g(t) ? this.view.getGrammarById(t) : t));
      return this.attach(i), this.commit(), this;
    }
    addEventListener(t, e, i) {
      let n = e;
      return (
        (i && !1 === i.trap) || ((n = e), (n.raw = e)), i && i.target && (n.target = i.target), this.on(t, n), this
      );
    }
    removeEventListener(t, e) {
      return e ? this.off(t, e) : this.off(t), this;
    }
    emit(t) {
      for (var e, i, n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) s[r - 1] = arguments[r];
      return (
        null === (i = null === (e = this.view) || void 0 === e ? void 0 : e.emit) || void 0 === i || i.call(e, t, ...s),
        super.emit(t, ...s)
      );
    }
    emitGrammarEvent(t) {
      for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) i[n - 1] = arguments[n];
      return super.emit(t, ...i);
    }
    evaluateTransform(t, e, i) {
      return HU(this, void 0, void 0, function* () {
        if (!t || !t.length) return e;
        let n = e,
          s = 0;
        const r = t.length;
        for (; s < r; ) {
          const e = t[s];
          this.emit(tG.BEFORE_TRANSFORM, e.type),
            (n = e.transform(e.isRawOptions ? e.options : zU(e.options, i), n, i, this.view)),
            (null == n ? void 0 : n.then) && (n = yield n),
            s++,
            this.emit(tG.AFTER_TRANSFORM, e.type);
        }
        return n;
      });
    }
    evaluateTransformSync(t, e, i) {
      if (!t || !t.length) return e;
      let n = e,
        s = 0;
      const r = t.length;
      for (; s < r; ) {
        const e = t[s];
        this.emit(tG.BEFORE_TRANSFORM, e.type),
          (n = e.transform(e.isRawOptions ? e.options : zU(e.options, i), n, i, this.view)),
          s++,
          this.emit(tG.AFTER_TRANSFORM, e.type);
      }
      return n;
    }
    set(t) {
      return !1;
    }
    id(t) {
      return arguments.length
        ? (this.view.grammars.unrecord(this), (this._id = t), this.view.grammars.record(this), this)
        : this._id;
    }
    name(t) {
      return arguments.length ? ((this._name = t), this) : this._name;
    }
    attach(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
      return (
        V(t)
          .filter(t => !l(t))
          .forEach(i => {
            var n;
            l(t) ||
              (i.targets.includes(this) || i.targets.push(this),
              this.references.set(i, (null !== (n = this.references.get(i)) && void 0 !== n ? n : 0) + e));
          }),
        this
      );
    }
    detach(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
      return (
        V(t)
          .filter(t => !l(t))
          .forEach(t => {
            const i = this.references.get(t) - e;
            i > 0
              ? this.references.set(t, i - 1)
              : (this.references.delete(t),
                t.targets.includes(this) && (t.targets = t.targets.filter(t => t !== this)));
          }),
        this
      );
    }
    detachAll() {
      this.references.forEach((t, e) => {
        this.detach(e, t);
      });
    }
    link(t) {
      this.grammarSource = t;
    }
    run() {
      var t;
      const e = null === (t = this.grammarSource) || void 0 === t ? void 0 : t.output(),
        i = this.parameters();
      return this.evaluate(e, i);
    }
    runSync() {
      var t;
      const e = null === (t = this.grammarSource) || void 0 === t ? void 0 : t.output(),
        i = this.parameters();
      return this.evaluateSync ? this.evaluateSync(e, i) : this.evaluate(e, i);
    }
    commit() {
      this.view.commit(this);
    }
    parameters() {
      const t = {};
      return (
        this.references.forEach((e, i) => {
          h(i.id()) && (t[i.id()] = i.output());
        }),
        t
      );
    }
    getSpec() {
      return this.spec;
    }
    reuse(t) {
      return this;
    }
    clear() {
      (this.spec = null), (this.view = null);
    }
    release() {
      this.clear();
    }
    setFunctionSpec(t, e) {
      return (
        l(this.spec[e]) || this.detach(IW(this.spec[e], this.view)),
        (this.spec[e] = t),
        this.attach(IW(t, this.view)),
        this.commit(),
        this
      );
    }
  }
  const WU = (t, e, i) => {
      var n, s;
      if ('callback' === t && o(e)) return { references: [], value: { callback: e, dependency: [] } };
      if (!l(e.data)) {
        const t = i.getDataById(e.data);
        return { references: [t], value: t };
      }
      if (!l(e.customized)) {
        const t = i.getCustomizedById(e.customized);
        return { references: [t], value: t };
      }
      if (!l(e.scale)) {
        const t = i.getScaleById(e.scale);
        return { references: [t], value: t };
      }
      if ((s = e) && (s.signal || s.callback)) {
        const t = IW(e, i);
        return {
          references: t,
          value: e.callback
            ? { value: e.callback, dependency: t }
            : null !== (n = null == t ? void 0 : t[0]) && void 0 !== n
            ? n
            : e
        };
      }
      return { value: e };
    },
    GU = (t, e) => {
      const i = ((n = t.type), vW[n]);
      var n;
      if (!i) return;
      const s = {};
      let r = [];
      return (
        Object.keys(t).forEach(i => {
          var n;
          if ('type' === i) return;
          const a = t[i];
          if ('dependency' === i) return void ((null == a ? void 0 : a.length) && (r = r.concat(BW(a, e))));
          const o = ((t, e, i) => {
            if (l(e)) return { value: e };
            if (f(e)) {
              const n = e.map(e => WU(t, e, i));
              return {
                references: n.reduce((t, e) => (e.references && t.concat(e.references), t), []),
                value: n.map(t => t.value)
              };
            }
            return WU(t, e, i);
          })(i, a, e);
          o &&
            ((null === (n = o.references) || void 0 === n ? void 0 : n.length) && (r = r.concat(o.references)),
            (s[i] = o.value));
        }),
        {
          markPhase: i.markPhase,
          transform: i.transform,
          canProgressive: i.canProgressive,
          type: i.type,
          options: s,
          references: r
        }
      );
    },
    UU = (t, e) => {
      if (null == t ? void 0 : t.length) {
        const i = [];
        let n = [];
        return (
          t.forEach(t => {
            var s;
            const r = GU(t, e);
            r &&
              ((null === (s = r.references) || void 0 === s ? void 0 : s.length) && (n = n.concat(r.references)),
              i.push(r));
          }),
          { transforms: i, refs: n }
        );
      }
      return null;
    };
  class YU extends eU {
    constructor(t) {
      super(t),
        (this.getStateAttrs = (t, e) => {
          var i, n, s;
          const r = !l(null === (i = this.runtimeStatesEncoder) || void 0 === i ? void 0 : i[t]),
            a = r
              ? this.runtimeStatesEncoder[t]
              : null === (n = this.mark.getSpec().encode) || void 0 === n
              ? void 0
              : n[t],
            h = {};
          if (!a) return h;
          if (o(a)) return (h.attributes = a(this.getDatum(), this, t, e)), h;
          if (!r && (null === (s = this.graphicItem.glyphStates) || void 0 === s ? void 0 : s[t]))
            return this.graphicItem.glyphStates[t];
          if (a) {
            const e = this.items[0],
              i = [Object.assign({}, e, { nextAttrs: {} })];
            return (
              HG(this, i, a, this.mark.parameters()),
              this.coordinateTransformEncode(i),
              (h.attributes = i[0].nextAttrs),
              this.graphicItem.glyphStates
                ? this.graphicItem.glyphStates[t] || (this.graphicItem.glyphStates[t] = h)
                : (this.graphicItem.glyphStates = { [t]: h }),
              h
            );
          }
          return h;
        }),
        (this.glyphMeta = this.mark.getGlyphMeta());
    }
    getGlyphGraphicItems() {
      return this.glyphGraphicItems;
    }
    initGraphicItem() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      if (this.graphicItem) return;
      const e = Object.assign({}, t);
      (this.graphicItem = this.mark.addGraphicItem(e, this.groupKey)),
        (this.graphicItem[iG] = this),
        (this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(!1));
      const i = this.glyphMeta.getMarks();
      (this.glyphGraphicItems = {}),
        this.graphicItem.getSubGraphic().forEach(t => {
          const e = i[t.name];
          (this.glyphGraphicItems[t.name] = t),
            (t.onBeforeAttributeUpdate = i => (this.mark ? DG(e, i, this, t.name) : i));
        }),
        this.clearGraphicAttributes();
    }
    useStates(t, e) {
      var i;
      if (!this.graphicItem) return;
      this.mark.emit(tG.BEFORE_ELEMENT_STATE, { states: t }, this), (this.states = t.slice());
      const n = a(e) ? e : !!(null === (i = this.mark.getSpec().animation) || void 0 === i ? void 0 : i.state);
      (this.graphicItem.glyphStateProxy = this.getStateAttrs),
        this.graphicItem.useStates(this.states, n),
        this.mark.emit(tG.AFTER_ELEMENT_STATE, { states: t }, this);
    }
    encodeGraphic() {
      this.coordinateTransformEncode(this.items);
      const t = this.transformElementItems(this.items, this.mark.markType);
      this.graphicItem || this.initGraphicItem(),
        this.diffState === WW.enter
          ? ((this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(!0)),
            this.applyGraphicAttributes(t),
            (this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(!1)))
          : this.applyGraphicAttributes(t),
        (this.diffState !== WW.enter && this.diffState !== WW.update) ||
          !this.states.length ||
          (Object.values(this.glyphGraphicItems).forEach(t => {
            t.states = {};
          }),
          this.useStates(this.states)),
        this.items.map(t => {
          t.nextAttrs = {};
        });
    }
    encodeCustom(t) {
      var e;
      let i = {};
      const n = this.glyphMeta.getChannelEncoder(),
        s = this.glyphMeta.getFunctionEncoder();
      if (
        (s &&
          (i = s.call(
            null,
            Object.assign({}, null === (e = this.graphicItem) || void 0 === e ? void 0 : e.attribute, t),
            this.getDatum(),
            this,
            this.mark.getGlyphConfig()
          )),
        n)
      ) {
        let e;
        Object.keys(n).forEach(s => {
          var r;
          if (!l(t[s])) {
            e || (e = Object.assign({}, null === (r = this.graphicItem) || void 0 === r ? void 0 : r.attribute, t));
            const a = n[s].call(null, s, t[s], e, this.getDatum(), this, this.mark.getGlyphConfig());
            Object.keys(null != a ? a : {}).forEach(t => {
              var e;
              i[t] = Object.assign(null !== (e = i[t]) && void 0 !== e ? e : {}, a[t]);
            });
          }
        });
      }
      return i;
    }
    encodeDefault() {
      const t = {};
      if (this.diffState === WW.enter && this.glyphMeta.getDefaultEncoder()) {
        const e = this.glyphMeta.getDefaultEncoder().call(null, this.getDatum(), this, this.mark.getGlyphConfig());
        Object.assign(t, e);
      }
      return t;
    }
    _onGlyphAttributeUpdate() {
      let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      return e => {
        if (!this.mark) return e;
        const i = this.glyphMeta.getMarks(),
          n = DG(this.mark.getAttributeTransforms(), e, this),
          s = t ? this.encodeDefault() : null,
          r = this.encodeCustom(e);
        return (
          Object.keys(i).forEach(n => {
            const a = i[n],
              o = this.glyphGraphicItems[n],
              l = null == r ? void 0 : r[n],
              h = Object.assign({}, l);
            if (t) {
              const t = null == s ? void 0 : s[n];
              Object.keys(null != t ? t : {}).forEach(e => {
                P(this.items[0].nextAttrs, e) || P(h, e) || (h[e] = t[e]);
              });
            }
            const c = Object.assign(
                {},
                (function (t, e) {
                  var i;
                  return (null !== (i = IG[t]) && void 0 !== i ? i : []).reduce(
                    (t, i) => (
                      i.channels.forEach(i => {
                        P(e, i) && (t[i] = e[i]);
                      }),
                      t
                    ),
                    {}
                  );
                })(a, e),
                h
              ),
              d = this._generateGlyphItems(a, this.items, c);
            this.coordinateTransformEncode(d);
            const u = this.transformElementItems(d, a);
            this.applyGlyphGraphicAttributes(u, n, o), a === GW.shape && (o.datum = d[0].datum);
          }),
          n
        );
      };
    }
    _generateGlyphItems(t, e, i) {
      var n;
      const s = null === (n = e[0]) || void 0 === n ? void 0 : n.nextAttrs,
        r = e.map(t => Object.assign({}, t, { nextAttrs: i }));
      return (
        nG.includes(t) &&
          s.enableSegments &&
          r.forEach((t, n) => {
            t.nextAttrs = Object.assign({}, e[n].nextAttrs, i);
          }),
        r
      );
    }
    getGraphicAttribute(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
        i = arguments.length > 2 ? arguments[2] : void 0;
      if (!this.graphicItem) return;
      const n = this.getPrevGraphicAttributes(i);
      return e && P(n, t) ? n[t] : (i ? this.glyphGraphicItems[i] : this.graphicItem).attribute[t];
    }
    setGraphicAttribute(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
        n = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.graphicItem) return;
      const s = n ? this.glyphGraphicItems[n] : this.graphicItem,
        r = this.getFinalGraphicAttributes(n),
        a = this.getPrevGraphicAttributes(n);
      i && (r[t] = e), P(a, t) || (a[t] = s.attribute[t]), s.setAttribute(t, e);
    }
    setGraphicAttributes(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
        i = arguments.length > 2 ? arguments[2] : void 0;
      if (!this.graphicItem) return;
      const n = i ? this.glyphGraphicItems[i] : this.graphicItem,
        s = this.getFinalGraphicAttributes(i),
        r = this.getPrevGraphicAttributes(i);
      Object.keys(t).forEach(i => {
        e && (s[i] = t[i]), P(r, i) || (r[i] = n.attribute[i]);
      }),
        n.setAttributes(t);
    }
    diffAttributes(t, e) {
      const i = {},
        n = this.getFinalGraphicAttributes(e);
      for (const e in t) Uo(e, n, t) || (i[e] = t[e]);
      return i;
    }
    applyGlyphGraphicAttributes(t, e, i) {
      if (this.mark.needAnimate()) {
        const n = this.diffAttributes(t, e),
          s = this.getPrevGraphicAttributes(e),
          r = this.getFinalGraphicAttributes(e);
        Object.keys(n).forEach(t => {
          (s[t] = i.attribute[t]), (r[t] = n[t]);
        }),
          this.setNextGraphicAttributes(n, e),
          this.setPrevGraphicAttributes(s, e),
          this.setFinalGraphicAttributes(r, e),
          i.setAttributes(n);
      } else i.setAttributes(t);
    }
    getFinalGraphicAttributes(t) {
      return (t ? this.glyphGraphicItems[t] : this.graphicItem).finalAttrs;
    }
    setFinalGraphicAttributes(t, e) {
      (e ? this.glyphGraphicItems[e] : this.graphicItem).finalAttrs = t;
    }
    getPrevGraphicAttributes(t) {
      return (t ? this.glyphGraphicItems[t] : this.graphicItem).prevAttrs;
    }
    setPrevGraphicAttributes(t, e) {
      (e ? this.glyphGraphicItems[e] : this.graphicItem).prevAttrs = t;
    }
    getNextGraphicAttributes(t) {
      return (t ? this.glyphGraphicItems[t] : this.graphicItem).nextAttrs;
    }
    setNextGraphicAttributes(t, e) {
      (e ? this.glyphGraphicItems[e] : this.graphicItem).nextAttrs = t;
    }
    clearChangedGraphicAttributes() {
      this.setPrevGraphicAttributes({}),
        this.setNextGraphicAttributes({}),
        Object.keys(this.glyphGraphicItems).forEach(t => {
          this.setPrevGraphicAttributes({}, t), this.setNextGraphicAttributes({}, t);
        });
    }
    clearGraphicAttributes() {
      this.setPrevGraphicAttributes({}),
        this.setNextGraphicAttributes({}),
        this.setFinalGraphicAttributes({}),
        Object.keys(this.glyphGraphicItems).forEach(t => {
          this.setPrevGraphicAttributes({}, t),
            this.setNextGraphicAttributes({}, t),
            this.setFinalGraphicAttributes({}, t);
        });
    }
    remove() {
      (this.glyphGraphicItems = null), super.remove();
    }
    release() {
      this.glyphGraphicItems &&
        (Object.values(this.glyphGraphicItems).forEach(t => {
          t[iG] = null;
        }),
        (this.glyphGraphicItems = null)),
        super.release();
    }
  }
  const $U = t => (t.markType === GW.glyph ? new YU(t) : new eU(t));
  function XU(t) {
    return l(t.offsetX)
      ? l(t.x)
        ? t.changedTouches && t.changedTouches.length
          ? (function (t) {
              return { canvasX: t.changedTouches[0].x, canvasY: t.changedTouches[0].y };
            })(t)
          : { canvasX: 0, canvasY: 0 }
        : (function (t) {
            return { canvasX: t.x, canvasY: t.y };
          })(t)
      : (function (t) {
          return { canvasX: t.offsetX, canvasY: t.offsetY };
        })(t);
  }
  function KU(t, e) {
    let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    return (
      _(e.canvasX) && Object.defineProperty(t, 'canvasX', { value: e.canvasX, writable: !0 }),
      _(e.canvasY) && Object.defineProperty(t, 'canvasY', { value: e.canvasY, writable: !0 }),
      i && _(e.clientX) && Object.defineProperty(t, 'clientX', { value: e.clientX, writable: !0 }),
      i && _(e.clientY) && Object.defineProperty(t, 'clientY', { value: e.clientY, writable: !0 }),
      [e.canvasX, e.canvasY]
    );
  }
  const qU = 'window',
    ZU = 'view',
    JU = { trap: !1 },
    QU = 'default',
    tY = 'width',
    eY = 'height',
    iY = 'viewWidth',
    nY = 'viewHeight',
    sY = 'padding',
    rY = 'viewBox',
    aY = 'autoFit';
  function oY(t, e, i, n, s) {
    if (s === qU) {
      !(function (t) {
        ['touches', 'changedTouches', 'targetTouches'].forEach(e => {
          t[e] &&
            t[e].length &&
            Array.from(t[e]).forEach(t => {
              KU(t, XU(t), !1);
            });
        });
        const e = XU(t);
        KU(t, e);
      })(e.changedTouches ? e.changedTouches[0] : e);
    }
    return (e.element = i), (e.vGrammarType = n), e;
  }
  var lY = function (t, e, i, n) {
    return new (i || (i = Promise))(function (s, r) {
      function a(t) {
        try {
          l(n.next(t));
        } catch (t) {
          r(t);
        }
      }
      function o(t) {
        try {
          l(n.throw(t));
        } catch (t) {
          r(t);
        }
      }
      function l(t) {
        var e;
        t.done
          ? s(t.value)
          : ((e = t.value),
            e instanceof i
              ? e
              : new i(function (t) {
                  t(e);
                })).then(a, o);
      }
      l((n = n.apply(t, e || [])).next());
    });
  };
  class hY extends VU {
    constructor(t, e, i) {
      super(t),
        (this.grammarType = 'mark'),
        (this.elements = []),
        (this.elementMap = new Map()),
        (this.isUpdated = !0),
        (this._isReentered = !1),
        (this.animate = new FU(this, {})),
        (this.differ = new mG([])),
        (this.evaluateSync = (t, e) => {
          var i;
          return (
            this.evaluateMainTasks(t, e),
            (null === (i = this.renderContext) || void 0 === i ? void 0 : i.progressive) ||
              this.evaluateTransformSync(this._getTransformsAfterEncode(), this.elements, e),
            this
          );
        }),
        (this.markType = e),
        (this.spec.type = e),
        (this.spec.encode = { update: {} }),
        (this.spec.group = i),
        i && ((this.group = i), this.attach(i), i.appendChild(this));
    }
    parse(t) {
      var e, i, n;
      if ((super.parse(t), this.spec.group)) {
        const t = g(this.spec.group) ? this.view.getMarkById(this.spec.group) : this.spec.group;
        this.detach(t);
      }
      const s = g(t.group) ? this.view.getMarkById(t.group) : t.group;
      return (
        this.attach(s),
        this.join(null === (e = t.from) || void 0 === e ? void 0 : e.data, t.key, t.sort, t.groupBy, t.groupSort),
        this.coordinate(t.coordinate),
        this.state(t.state, this.spec.stateSort),
        Object.keys(null !== (i = this.spec.encode) && void 0 !== i ? i : {}).forEach(t => {
          this.encodeState(t, {});
        }),
        Object.keys(null !== (n = t.encode) && void 0 !== n ? n : {}).forEach(e => {
          this.encodeState(e, t.encode[e]);
        }),
        this.animation(t.animation),
        this.animationState(t.animationState),
        this.morph(t.morph, t.morphKey, t.morphElementKey),
        this.layout(t.layout),
        this.configure(t),
        this.transform(t.transform),
        this.parseAddition(t),
        (this.spec = t),
        (this.markType = t.type),
        this.commit(),
        this
      );
    }
    parameters() {
      var t;
      return null !== (t = this._finalParameters) && void 0 !== t ? t : super.parameters();
    }
    parseAddition(t) {
      return this;
    }
    reuse(t) {
      if (t.grammarType !== this.grammarType) return this;
      const e = t;
      return (
        (this.markType = e.markType),
        (this.coord = e.coord),
        (this.elementMap = e.elementMap),
        (this.elements = e.elements),
        this.elementMap.forEach(t => (t.mark = this)),
        (this.differ = e.differ),
        (this.animate = e.animate),
        (this.animate.mark = this),
        (this.context = e.context),
        (this.graphicItem = e.graphicItem),
        (this.graphicIndex = e.graphicIndex),
        (this.graphicParent = e.graphicParent),
        (this.needClear = e.needClear),
        (this.isUpdated = e.isUpdated),
        this
      );
    }
    needLayout() {
      return !l(this.spec.layout);
    }
    handleLayoutEnd() {
      var t, e;
      (null === (e = null === (t = this.spec) || void 0 === t ? void 0 : t.layout) || void 0 === e
        ? void 0
        : e.skipBeforeLayouted) && this.run();
    }
    handleRenderEnd() {
      this.needClear &&
        (this.cleanExitElements(),
        this.elementMap.forEach(t => {
          t.diffState === WW.exit ? t.clearGraphicAttributes() : t.clearChangedGraphicAttributes();
        }),
        this.differ.updateToCurrent(),
        (this.needClear = !1));
    }
    evaluateMainTasks(t, e) {
      var i;
      if (this.needSkipBeforeLayout() && this.view.getLayoutState() === QW.before) return this;
      const n = null === (i = this.view.renderer) || void 0 === i ? void 0 : i.stage();
      this.init(n, e);
      const s = this.evaluateTransformSync(this._getTransformsBeforeJoin(), null != t ? t : aG, e);
      let r = (null == s ? void 0 : s.progressive) ? t : s;
      return (
        this.evaluateGroup(r),
        (this.renderContext = this.parseRenderContext(r, e)),
        this.renderContext.progressive
          ? (this.differ.reset(), this.elementMap.clear(), this.evaluateProgressive())
          : ((null == s ? void 0 : s.progressive) &&
              ((this.renderContext.parameters = e),
              (this.renderContext.beforeTransformProgressive = s.progressive),
              (r = s.progressive.output())),
            this.emit(tG.BEFORE_MARK_JOIN),
            this.evaluateJoin(r),
            this.emit(tG.AFTER_MARK_JOIN),
            this.emit(tG.BEFORE_MARK_STATE),
            this.evaluateState(this.elements, this.spec.state, e),
            this.emit(tG.AFTER_MARK_STATE),
            this.emit(tG.BEFORE_MARK_ENCODE),
            this.evaluateEncode(this.elements, this._getEncoders(), e),
            this.emit(tG.AFTER_MARK_ENCODE)),
        this.emit(tG.BEFORE_MARK_UPDATE),
        this.update(this.spec),
        this.emit(tG.AFTER_MARK_UPDATE),
        this
      );
    }
    evaluateGroup(t) {
      var e;
      if (this.markType === GW.group) return;
      const i = vG(
          null != t ? t : aG,
          HW(null !== (e = this.spec.groupBy) && void 0 !== e ? e : () => rG),
          this.spec.groupSort
        ),
        n = i.keys;
      (this._groupKeys = n), this.differ.setCurrentData(i);
    }
    _getTransformsAfterEncodeItems() {
      return this.transforms && this.transforms.filter(t => 'afterEncodeItems' === t.markPhase);
    }
    _getTransformsAfterEncode() {
      return this.transforms && this.transforms.filter(t => l(t.markPhase) || 'afterEncode' === t.markPhase);
    }
    _getTransformsBeforeJoin() {
      return this.transforms ? this.transforms.filter(t => 'beforeJoin' === t.markPhase) : [];
    }
    evaluate(t, e) {
      var i;
      return lY(this, void 0, void 0, function* () {
        return (
          this.evaluateMainTasks(t, e),
          (null === (i = this.renderContext) || void 0 === i ? void 0 : i.progressive) ||
            (yield this.evaluateTransform(this._getTransformsAfterEncode(), this.elements, e)),
          this
        );
      });
    }
    output() {
      return this;
    }
    join(t, e, i, n, s) {
      return (
        this.grammarSource && (this.detach(this.grammarSource), (this.grammarSource = null)),
        (this.spec.from = null),
        l(t) ||
          (g(t) ? (this.grammarSource = this.view.getDataById(t)) : (this.grammarSource = t),
          (this.spec.from = { data: t }),
          this.attach(this.grammarSource)),
        (this.spec.key = e),
        (this.spec.sort = i),
        (this.spec.groupBy = n),
        (this.spec.groupSort = s),
        this.commit(),
        this
      );
    }
    coordinate(t) {
      return (
        g(t) ? (this.coord = this.view.getCoordinateById(t)) : (this.coord = t),
        this.attach(this.coord),
        this.commit(),
        this
      );
    }
    state(t, e) {
      return (this.spec.stateSort = e), this.setFunctionSpec(t, 'state');
    }
    encode(t, e) {
      return this.encodeState(WW.update, t, e);
    }
    encodeState(t, e, i) {
      if ((t === WW.enter && (this._isReentered = !0), this.spec.encode[t])) {
        const i = this.spec.encode[t];
        DW(i)
          ? this.detach(kG(i, this.view))
          : g(e)
          ? this.detach(kG(this.spec.encode[t][e], this.view))
          : Object.keys(e).forEach(e => {
              this.detach(kG(this.spec.encode[t][e], this.view));
            });
      } else this.spec.encode[t] = {};
      return (
        g(e)
          ? ((this.spec.encode[t][e] = i), this.attach(kG(i, this.view)))
          : DW(e)
          ? ((this.spec.encode[t] = e), this.attach(kG(e, this.view)))
          : (Object.assign(this.spec.encode[t], e),
            e &&
              Object.values(e).forEach(t => {
                this.attach(kG(t, this.view));
              })),
        this.commit(),
        this
      );
    }
    _getEncoders() {
      var t;
      return null !== (t = this.spec.encode) && void 0 !== t ? t : {};
    }
    animation(t) {
      return (this.spec.animation = t), this;
    }
    animationState(t) {
      return this.setFunctionSpec(t, 'animationState');
    }
    layout(t) {
      return (this.spec.layout = t), this.commit(), this;
    }
    morph(t, e, i) {
      return (this.spec.morph = t), (this.spec.morphKey = e), (this.spec.morphElementKey = i), this;
    }
    transform(t) {
      const e = UU(this.spec.transform, this.view);
      e && (this.detach(e.refs), (this.transforms = []));
      const i = UU(t, this.view);
      return (
        i && (this.attach(i.refs), (this.transforms = i.transforms)), (this.spec.transform = t), this.commit(), this
      );
    }
    configure(t) {
      const e = [
        'clip',
        'zIndex',
        'interactive',
        'context',
        'setCustomizedShape',
        'large',
        'largeThreshold',
        'progressiveStep',
        'progressiveThreshold',
        'support3d',
        'morph',
        'morphKey',
        'morphElementKey',
        'attributeTransforms'
      ];
      return null === t
        ? (e.forEach(t => {
            l(this.spec[t]) || (this.spec[t] = void 0);
          }),
          this)
        : (e.forEach(e => {
            l(t[e]) || (this.spec[e] = t[e]);
          }),
          this);
    }
    isCollectionMark() {
      return nG.includes(this.markType);
    }
    needAnimate() {
      var t;
      return !(null === (t = this.renderContext) || void 0 === t ? void 0 : t.progressive) && !l(this.spec.animation);
    }
    getAllElements() {
      const t = this.elements.slice();
      return (
        this.elementMap.forEach(e => {
          e.diffState !== WW.exit || t.includes(e) || t.push(e);
        }),
        this.spec.sort && t.sort((t, e) => this.spec.sort(t.getDatum(), e.getDatum())),
        t
      );
    }
    getScales() {
      const t = {};
      return (
        this.references.forEach((e, i) => {
          i.grammarType === eG.scale && (t[i.id()] = i.output());
        }),
        t
      );
    }
    getScalesByChannel() {
      const t = this.spec.encode;
      if (!t) return {};
      const e = {},
        i = this.parameters();
      return (
        Object.keys(t).forEach(n => {
          const s = t[n];
          s &&
            !DW(s) &&
            Object.keys(s).forEach(t => {
              wG(s[t]) && (e[t] = jW(s[t].scale, i));
            });
        }),
        e
      );
    }
    getFieldsByChannel() {
      const t = this.spec.encode;
      if (!t) return {};
      const e = {};
      return (
        Object.keys(t).forEach(i => {
          const n = t[i];
          DW(n) ||
            Object.keys(n).forEach(t => {
              AG(n[t]) && (e[t] = n[t].field);
            });
        }),
        e
      );
    }
    init(t, e) {
      var i, n, s, r;
      if (
        (this._delegateEvent ||
          ((this._delegateEvent = (t, e) => {
            var i;
            const n = null === (i = t.target) || void 0 === i ? void 0 : i[iG];
            if ((null == n ? void 0 : n.mark) === this) {
              const i = oY(this.view, t, n, e, ZU);
              this.emitGrammarEvent(e, i, n);
            }
          }),
          this.initEvent()),
        this.animate ||
          ((this.animate = new FU(this, this.spec.animation)),
          this.needAnimate() && this.animate.updateState(this.spec.animationState)),
        !this.group)
      ) {
        const t = jW(this.spec.group, e);
        (this.group = t),
          t && (this.emit(tG.BEFORE_ADD_VRENDER_MARK), t.appendChild(this), this.emit(tG.AFTER_ADD_VRENDER_MARK));
      }
      const a = this.group ? this.group.getGroupGraphicItem() : t.defaultLayer,
        o =
          null !==
            (s =
              null === (n = null === (i = this.group) || void 0 === i ? void 0 : i.children) || void 0 === n
                ? void 0
                : n.indexOf(this)) && void 0 !== s
            ? s
            : 0;
      if (this.markType !== GW.group) {
        if (!this.graphicItem) {
          const t = JG(this, GW.group, {
            pickable: !1,
            zIndex: null !== (r = this.spec.zIndex) && void 0 !== r ? r : 0
          });
          (this.spec.support3d || sG.includes(this.markType)) && t.setMode('3d'),
            (t.name = `${this.id() || this.markType}`),
            (this.graphicItem = t);
        }
        (this.graphicParent = this.graphicItem),
          !a || (this.graphicIndex === o && this.graphicItem.parent === a) || a.insertIntoKeepIdx(this.graphicItem, o);
      } else this.graphicParent = a;
      this.graphicIndex = o;
    }
    update(t) {
      (this.context = this.spec.context),
        (this.isUpdated = !0),
        this.renderContext.progressive ||
          (t.animation && this.animate.updateConfig(t.animation), this.animate.updateState(t.animationState)),
        this.markType !== GW.group
          ? (l(t.zIndex) || this.graphicItem.setAttribute('zIndex', t.zIndex),
            l(t.clip) || this.graphicItem.setAttribute('clip', t.clip),
            this.elementMap.forEach(e => {
              e.updateGraphicItem({ interactive: t.interactive });
            }))
          : this.elementMap.forEach(e => {
              e.updateGraphicItem({ clip: t.clip, zIndex: t.zIndex, interactive: t.interactive });
            });
    }
    evaluateJoin(t) {
      var e, i, n, s;
      this.needClear = !0;
      const r = HW(
          null !==
            (n =
              null !== (e = this.spec.key) && void 0 !== e
                ? e
                : null === (i = this.grammarSource) || void 0 === i
                ? void 0
                : i.getDataIDKey()) && void 0 !== n
            ? n
            : () => rG
        ),
        a = HW(null !== (s = this.spec.groupBy) && void 0 !== s ? s : () => rG),
        o = this.spec.sort,
        h = this.isCollectionMark(),
        c = new Set(this.elements.filter(t => t.diffState === WW.enter)),
        d = [];
      this.differ.setCallback((t, e, i) => {
        const n = t;
        let s;
        if (l(e)) (s = this.elementMap.get(n)), s && (s.diffState = WW.exit);
        else if (l(i)) {
          (s = this.elementMap.has(n) ? this.elementMap.get(n) : $U(this)),
            s.diffState === WW.exit &&
              ((s.diffState = WW.enter), this.animate.getElementAnimators(s, WW.exit).forEach(t => t.stop('start'))),
            (s.diffState = WW.enter);
          const i = h ? t : a(e[0]);
          s.updateData(i, e, r, this.view), this.elementMap.set(n, s), d.push(s);
        } else if (((s = this.elementMap.get(n)), s)) {
          s.diffState = WW.update;
          const i = h ? t : a(e[0]);
          s.updateData(i, e, r, this.view), d.push(s);
        }
        c.delete(s);
      });
      const u = null != t ? t : aG;
      h || this.differ.setCurrentData(vG(u, t => `${a(t)}-${r(t)}`, void 0)),
        this.differ.doDiff(),
        c.forEach(t => {
          this.elementMap.delete(h ? t.groupKey : `${t.groupKey}-${t.key}`), t.remove(), t.release();
        }),
        (this.elements = d),
        o && this.elements.sort((t, e) => o(t.getDatum(), e.getDatum()));
    }
    evaluateState(t, e, i) {
      e &&
        t.forEach(t => {
          t.state(e, i);
        });
    }
    evaluateGroupEncode(t, e, i) {
      var n;
      if (this.markType === GW.group) {
        const t = this.elements[0],
          s = {};
        return (
          HG(t, [Object.assign({}, null === (n = t.items) || void 0 === n ? void 0 : n[0], { nextAttrs: s })], e, i), s
        );
      }
      if (!this._groupKeys || !e) return;
      const s = {};
      return (
        this._groupKeys.forEach(n => {
          var r;
          const a = t.find(t => t.groupKey === n);
          if (!a) return;
          const o = {};
          HG(a, [Object.assign({}, null === (r = a.items) || void 0 === r ? void 0 : r[0], { nextAttrs: o })], e, i),
            (s[n] = o);
        }),
        s
      );
    }
    evaluateEncode(t, e, i) {
      if (e) {
        this.emit(tG.BEFORE_ELEMENT_ENCODE, { encoders: e, parameters: i }, this);
        const n = this.evaluateGroupEncode(t, e[VW.group], i);
        t.forEach(t => {
          this.markType === GW.group && n
            ? t.items.forEach(t => {
                t.nextAttrs = Object.assign(t.nextAttrs, n);
              })
            : (null == n ? void 0 : n[t.groupKey]) &&
              !this.isCollectionMark() &&
              t.items.forEach(e => {
                e.nextAttrs = Object.assign(e.nextAttrs, n[t.groupKey]);
              }),
            t.encodeItems(t.items, e, this._isReentered, i);
        }),
          (this._isReentered = !1),
          this.evaluateTransformSync(this._getTransformsAfterEncodeItems(), t, i),
          t.forEach(t => {
            t.encodeGraphic(this.isCollectionMark() ? (null == n ? void 0 : n[t.groupKey]) : null);
          }),
          this.emit(tG.AFTER_ELEMENT_ENCODE, { encoders: e, parameters: i }, this);
      } else
        t.forEach(t => {
          t.initGraphicItem();
        });
    }
    addGraphicItem(t, e, i) {
      var n;
      const s = null != i ? i : JG(this, this.markType, t);
      if ((this.emit(tG.BEFORE_ADD_VRENDER_MARK), this.markType === GW.group))
        (s.name = `${this.id() || this.markType}`), this.graphicParent.insertIntoKeepIdx(s, this.graphicIndex);
      else if (null === (n = this.renderContext) || void 0 === n ? void 0 : n.progressive) {
        let t;
        if (this._groupKeys) {
          const i = this._groupKeys.indexOf(e);
          i >= 0 && (t = this.graphicParent.getChildAt(i));
        } else t = this.graphicParent.at(0);
        this.isCollectionMark() ? ((s.incremental = 1), t.appendChild(s)) : t.incrementalAppendChild(s);
      } else this.graphicParent.appendChild(s);
      return this.emit(tG.AFTER_ADD_VRENDER_MARK), s;
    }
    parseRenderContext(t, e) {
      const i =
          this.markType !== GW.group &&
          this.spec.progressiveStep > 0 &&
          this.spec.progressiveThreshold > 0 &&
          this.spec.progressiveStep < this.spec.progressiveThreshold,
        n = this.spec.large && this.spec.largeThreshold > 0 && t.length >= this.spec.largeThreshold;
      if (i) {
        const i = this.differ.getCurrentData();
        return i && i.keys && i.keys.some(t => i.data.get(t).length > this.spec.progressiveThreshold)
          ? {
              large: n,
              parameters: e,
              progressive: {
                data: t,
                step: this.spec.progressiveStep,
                currentIndex: 0,
                totalStep: i.keys.reduce(
                  (t, e) => Math.max(Math.ceil(i.data.get(e).length / this.spec.progressiveStep), t),
                  1
                ),
                groupedData: i.data
              }
            }
          : { large: n };
      }
      return { large: n };
    }
    isProgressive() {
      return (
        this.renderContext && (!!this.renderContext.progressive || !!this.renderContext.beforeTransformProgressive)
      );
    }
    isDoingProgressive() {
      return (
        this.renderContext &&
        ((this.renderContext.progressive &&
          this.renderContext.progressive.currentIndex < this.renderContext.progressive.totalStep) ||
          (this.renderContext.beforeTransformProgressive && this.renderContext.beforeTransformProgressive.unfinished()))
      );
    }
    clearProgressive() {
      var t, e;
      (null === (t = this.renderContext) || void 0 === t ? void 0 : t.progressive) &&
        ((this.elements = []),
        this.graphicParent.children.forEach(t => {
          t.incrementalClearChild();
        }),
        this.graphicParent.removeAllChild()),
        (null === (e = this.renderContext) || void 0 === e ? void 0 : e.beforeTransformProgressive) &&
          this.renderContext.beforeTransformProgressive.release(),
        (this.renderContext = null);
    }
    restartProgressive() {
      var t;
      (null === (t = this.renderContext) || void 0 === t ? void 0 : t.progressive) &&
        (this.renderContext.progressive.currentIndex = 0);
    }
    evaluateJoinProgressive() {
      var t, e, i;
      const n = this.renderContext.progressive.currentIndex,
        s = HW(
          null !==
            (i =
              null !== (t = this.spec.key) && void 0 !== t
                ? t
                : null === (e = this.grammarSource) || void 0 === e
                ? void 0
                : e.getDataIDKey()) && void 0 !== i
            ? i
            : () => rG
        ),
        r = [];
      if (this.isCollectionMark())
        return (
          this._groupKeys.forEach((t, e) => {
            const i = this.renderContext.progressive.groupedData.get(t),
              a = this.renderContext.progressive.step,
              o = i.slice(n * a, (n + 1) * a);
            if (0 === n) {
              const e = $U(this);
              (e.diffState = WW.enter), e.updateData(t, o, s, this.view), r.push(e);
            } else {
              const i = this.elements[e];
              i.updateData(t, o, s, this.view), r.push(i);
            }
          }),
          r
        );
      const a = {};
      return (
        this._groupKeys.forEach(t => {
          const e = this.renderContext.progressive.groupedData.get(t),
            i = this.renderContext.progressive.step,
            o = e.slice(n * i, (n + 1) * i),
            l = [];
          o.forEach(e => {
            const i = $U(this);
            (i.diffState = WW.enter), i.updateData(t, [e], s, this.view), l.push(i), r.push(i);
          }),
            (a[t] = l);
        }),
        { groupElements: a, elements: r }
      );
    }
    evaluateEncodeProgressive(t, e, i) {
      if (!e)
        return void t.forEach(t => {
          t.initGraphicItem();
        });
      const n = Object.keys(e).reduce(
          (t, i) => (
            !e[i] ||
              (i !== VW.enter && i !== VW.exit && i !== VW.update) ||
              (t[i] = (function (t, e, i) {
                if (DW(e)) return { themeEncoder: {}, positionEncoder: e };
                const n = {},
                  s = {};
                if (t === GW.glyph && CG(i)) {
                  const t = CG(i),
                    r = t.getProgressiveChannels();
                  if (r)
                    Object.keys(e).forEach(t => {
                      r.includes(t) ? (s[t] = e[t]) : (n[t] = e[t]);
                    });
                  else {
                    const i = Array.from(new Set(Object.values(t.getMarks())));
                    Object.keys(e).forEach(t => {
                      i.some(e => zG(e, t)) ? (s[t] = e[t]) : (n[t] = e[t]);
                    });
                  }
                } else
                  Object.keys(e).forEach(i => {
                    zG(t, i) ? (s[i] = e[i]) : (n[i] = e[i]);
                  });
                return { positionEncoder: s, themeEncoder: n };
              })(this.markType, e[i], this.glyphType).positionEncoder),
            t
          ),
          {}
        ),
        s = this.renderContext.progressive.currentIndex,
        r = this.isCollectionMark();
      this.emit(tG.BEFORE_ELEMENT_ENCODE, { encoders: e, parameters: i }, this);
      const a = this.evaluateGroupEncode(t, e[VW.group], i);
      if (
        (t.forEach((t, o) => {
          const l = s > 0 || (!r && o > 0);
          !l &&
            (null == a ? void 0 : a[t.groupKey]) &&
            t.items.forEach(e => {
              e.nextAttrs = Object.assign(e.nextAttrs, a[t.groupKey]);
            }),
            t.encodeItems(t.items, l ? n : e, this._isReentered, i);
        }),
        (this._isReentered = !1),
        this.evaluateTransformSync(this._getTransformsAfterEncodeItems(), t, i),
        t.forEach(t => {
          t.encodeGraphic();
        }),
        this.emit(tG.AFTER_ELEMENT_ENCODE, { encoders: e, parameters: i }, this),
        0 === s && !r)
      ) {
        const e = t[0].getGraphicItem(),
          i = null == e ? void 0 : e.parent;
        if (i) {
          const t = e.attribute,
            n = {},
            s = {};
          Object.keys(t).forEach(e => {
            ['pickable', 'zIndex'].includes(e) || (zG(this.markType, e) ? (s[e] = t[e]) : (n[e] = t[e]));
          }),
            i.setTheme({ common: n }),
            e.initAttributes(s);
        }
      }
    }
    evaluateProgressive() {
      var t, e, i;
      if (null === (t = this.renderContext) || void 0 === t ? void 0 : t.beforeTransformProgressive) {
        this.renderContext.beforeTransformProgressive.progressiveRun();
        const t = this.renderContext.beforeTransformProgressive.output();
        return (
          this.emit(tG.BEFORE_MARK_JOIN),
          this.evaluateJoin(t),
          this.emit(tG.AFTER_MARK_JOIN),
          this.emit(tG.BEFORE_MARK_STATE),
          this.evaluateState(this.elements, this.spec.state, this.renderContext.parameters),
          this.emit(tG.AFTER_MARK_STATE),
          this.emit(tG.BEFORE_MARK_ENCODE),
          this.evaluateEncode(this.elements, this._getEncoders(), this.renderContext.parameters),
          void this.emit(tG.AFTER_MARK_ENCODE)
        );
      }
      if (!(null === (e = this.renderContext) || void 0 === e ? void 0 : e.progressive)) return;
      const n = this.renderContext.parameters;
      this.emit(tG.BEFORE_MARK_JOIN);
      const s = this.evaluateJoinProgressive(),
        r = Array.isArray(s) ? s : s.elements;
      if (
        (this.emit(tG.AFTER_MARK_JOIN),
        0 === this.renderContext.progressive.currentIndex
          ? (this.graphicParent.removeAllChild(),
            this._groupKeys.forEach(t => {
              const e = JG(this, GW.group, { pickable: !1, zIndex: this.spec.zIndex });
              (e.incremental = this.renderContext.progressive.step), this.graphicParent.appendChild(e);
            }),
            (this.elements = r))
          : (this.elements = this.elements.concat(r)),
        this.emit(tG.BEFORE_MARK_STATE),
        this.evaluateState(r, this.spec.state, n),
        this.emit(tG.AFTER_MARK_STATE),
        this.emit(tG.BEFORE_MARK_ENCODE),
        Array.isArray(s))
      )
        this.evaluateEncodeProgressive(r, this._getEncoders(), n);
      else {
        const t = s.groupElements;
        Object.keys(t).forEach(e => {
          this.evaluateEncodeProgressive(t[e], this._getEncoders(), n);
        });
      }
      this.emit(tG.AFTER_MARK_ENCODE);
      const a =
        null === (i = this._getTransformsAfterEncode()) || void 0 === i
          ? void 0
          : i.filter(t => !0 === t.canProgressive);
      (null == a ? void 0 : a.length) && this.evaluateTransformSync(a, this.elements, n),
        (this.renderContext.progressive.currentIndex += 1);
    }
    isLargeMode() {
      return this.renderContext && this.renderContext.large;
    }
    cleanExitElements() {
      this.elementMap.forEach((t, e) => {
        t.diffState !== WW.exit || t.isReserved || (this.elementMap.delete(e), t.remove(), t.release());
      });
    }
    getGroupGraphicItem() {
      var t, e, i;
      return null ===
        (i =
          null === (e = null === (t = this.elements) || void 0 === t ? void 0 : t[0]) || void 0 === e
            ? void 0
            : e.getGraphicItem) || void 0 === i
        ? void 0
        : i.call(e);
    }
    getBounds() {
      var t, e, i, n;
      return this.graphicItem
        ? this.graphicItem.AABBBounds
        : null ===
            (n =
              null ===
                (i =
                  null === (e = null === (t = this.elements) || void 0 === t ? void 0 : t[0]) || void 0 === e
                    ? void 0
                    : e.getGraphicItem) || void 0 === i
                ? void 0
                : i.call(e)) || void 0 === n
        ? void 0
        : n.AABBBounds;
    }
    getMorphConfig() {
      var t;
      return {
        morph: null !== (t = this.spec.morph) && void 0 !== t && t,
        morphKey: this.spec.morphKey,
        morphElementKey: this.spec.morphElementKey
      };
    }
    getAttributeTransforms() {
      var t;
      return null !== (t = this.spec.attributeTransforms) && void 0 !== t ? t : IG[this.markType];
    }
    needSkipBeforeLayout() {
      var t, e;
      if (!0 === (null === (t = this.spec.layout) || void 0 === t ? void 0 : t.skipBeforeLayouted)) return !0;
      let i = this.group;
      for (; i; ) {
        if (!0 === (null === (e = i.getSpec().layout) || void 0 === e ? void 0 : e.skipBeforeLayouted)) return !0;
        i = i.group;
      }
      return !1;
    }
    initEvent() {
      this._delegateEvent && this.view.renderer.stage().on('*', this._delegateEvent);
    }
    releaseEvent() {
      if (this._delegateEvent) {
        const t = this.view.renderer.stage();
        t && t.off('*', this._delegateEvent);
      }
    }
    clear() {
      var t;
      super.clear(),
        (this.transforms = null),
        (this.elementMap = null),
        (this.elements = null),
        (this.graphicItem = null),
        (this.animate = null),
        null === (t = this.group) || void 0 === t || t.removeChild(this),
        (this.group = null);
    }
    prepareRelease() {
      this.animate.stop(),
        this.elementMap.forEach(t => (t.diffState = WW.exit)),
        (this._finalParameters = this.parameters());
    }
    release() {
      this.releaseEvent(),
        this.elements.forEach(t => t.release()),
        this.elementMap.clear(),
        (this._finalParameters = null),
        this.animate && this.animate.release(),
        this.graphicItem && tU(this.graphicItem),
        this.detachAll(),
        super.release();
    }
  }
  class cY extends hY {
    constructor(t, e, i, n) {
      super(t, GW.component, i),
        (this._componentDatum = { [rG]: 0 }),
        (this.componentType = e),
        (this.spec.type = 'component'),
        (this.spec.componentType = e),
        (this.mode = n);
    }
    configureComponent(t) {
      return (this.spec.componentConfig = t), this.commit(), this;
    }
    addGraphicItem(t, e, i) {
      const n = null != i ? i : $G(this.componentType).creator(t, this.mode);
      return super.addGraphicItem(t, e, n);
    }
    join(t) {
      return super.join(t, rG);
    }
    encodeState(t, e, i) {
      return super.encodeState(t, e, i), this._updateComponentEncoders(), this;
    }
    _prepareRejoin() {
      this._componentDatum[rG] += 1;
    }
    evaluateJoin(t) {
      return (this.spec.key = rG), super.evaluateJoin([this._componentDatum]);
    }
    _updateComponentEncoders() {
      this._encoders = this.spec.encode;
    }
    _getEncoders() {
      var t;
      return null !== (t = this._encoders) && void 0 !== t ? t : {};
    }
    _filterData(t, e, i, n, s, r) {
      const a = g(t) ? this.view.getDataById(t) : t;
      a && (a.removeDataFilter(this._dataFilter), (this._filterCallback = null), (this._dataFilter = null));
      const o = g(e) ? this.view.getDataById(e) : e;
      return (
        o &&
          ((this._filterCallback = (t, e) => {
            e && e.mark === this && o && ((this._filterValue = n(t)), o.commit(), this.view.runAsync());
          }),
          (this._dataFilter = {
            source: `${this.uid}`,
            rank: i,
            filter: t => {
              if (!this._filterValue) return t;
              const e = s ? t.filter(t => s(t, this._filterValue)) : t;
              return r ? r(e, this._filterValue) : e;
            }
          }),
          o.addDataFilter(this._dataFilter)),
        this
      );
    }
  }
  const dY = [
    'x',
    'y',
    'dx',
    'dy',
    'scaleX',
    'scaleY',
    'angle',
    'anchor',
    'postMatrix',
    'visible',
    'clip',
    'pickable',
    'childrenPickable',
    'zIndex'
  ];
  class uY extends GE {
    constructor(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '2d';
      super(t),
        (this.mode = e),
        this.setTheme({ common: { strokeBoundsBuffer: 0 } }),
        (this.attribute = t),
        this.onSetStage(() => {
          this.render(), this.bindEvents();
        });
    }
    setAttribute(t, e, i) {
      !u(this.attribute[t]) || o(this.attribute[t]) || o(e) ? (this.attribute[t] = e) : D(this.attribute[t], e),
        dY.includes(t) || this.render(),
        (this.valid = this.isValid()),
        this.updateShapeAndBoundsTagSetted() || (!i && !this.needUpdateTag(t))
          ? this.addUpdateBoundTag()
          : this.addUpdateShapeAndBoundsTag(),
        this.addUpdatePositionTag(),
        this.onAttributeUpdate();
    }
    setAttributes(t, e) {
      const i = Object.keys(t);
      this._mergeAttributes(t, i),
        i.every(t => dY.includes(t)) || this.render(),
        (this.valid = this.isValid()),
        this.updateShapeAndBoundsTagSetted() || (!e && !this.needUpdateTags(i))
          ? this.addUpdateBoundTag()
          : this.addUpdateShapeAndBoundsTag(),
        this.addUpdatePositionTag(),
        this.onAttributeUpdate();
    }
    _mergeAttributes(t, e) {
      l(e) && (e = Object.keys(t));
      for (let i = 0; i < e.length; i++) {
        const n = e[i];
        !u(this.attribute[n]) || o(this.attribute[n]) || o(t[n])
          ? (this.attribute[n] = t[n])
          : D(this.attribute[n], t[n]);
      }
    }
    bindEvents() {}
    _getNodeId(t) {
      return `${this.id}-${this.name}-${t}`;
    }
  }
  let pY = class t extends uY {
    constructor(e) {
      super(D({}, t.defaultAttributes, e)),
        (this.name = 'scrollbar'),
        (this._onRailPointerDown = t => {
          var e, i;
          const { viewX: n, viewY: s } = t,
            { direction: r, width: a, height: o, range: l } = this.attribute,
            h = this._sliderSize,
            [c, d] = this._getScrollRange();
          let u;
          if ('vertical' === r) {
            const t = s - this._viewPosition.y,
              e = pt(t - h / 2, c, d);
            (u = t / o), this._slider.setAttribute('y', e, !0);
          } else {
            const t = n - this._viewPosition.x,
              e = pt(t - h / 2, c, d);
            (u = t / a), this._slider.setAttribute('x', e, !0);
          }
          this.setScrollRange([u - (l[1] - l[0]) / 2, u + (l[1] - l[0]) / 2], !1),
            (null === (e = this.stage) || void 0 === e ? void 0 : e.autoRender) ||
              null === (i = this.stage) ||
              void 0 === i ||
              i.renderNextFrame();
        }),
        (this._onSliderPointerDown = t => {
          t.stopPropagation();
          const { direction: e } = this.attribute;
          (this._prePos = 'horizontal' === e ? t.clientX : t.clientY),
            'browser' === gN.env
              ? (gN.addEventListener('pointermove', this._onSliderPointerMove),
                gN.addEventListener('pointerup', this._onSliderPointerUp))
              : (this._slider.addEventListener('pointermove', this._onSliderPointerMove),
                this._slider.addEventListener('pointerup', this._onSliderPointerUp),
                this._slider.addEventListener('pointerupoutside', this._onSliderPointerUp));
        }),
        (this._onSliderPointerMove = t => {
          t.stopPropagation();
          const { direction: e } = this.attribute;
          let i,
            n,
            s = 0;
          const r = this.getScrollRange(),
            { width: a, height: o } = this._getSliderRenderBounds();
          'vertical' === e
            ? ((n = t.clientY), (s = n - this._prePos), (i = s / o))
            : ((n = t.clientX), (s = n - this._prePos), (i = s / a)),
            this.setScrollRange([r[0] + i, r[1] + i], !0),
            (this._prePos = n);
        }),
        (this._onSliderPointerUp = t => {
          t.preventDefault(),
            'browser' === gN.env
              ? (gN.removeEventListener('pointermove', this._onSliderPointerMove),
                gN.removeEventListener('pointerup', this._onSliderPointerUp))
              : (this._slider.removeEventListener('pointermove', this._onSliderPointerMove),
                this._slider.removeEventListener('pointerup', this._onSliderPointerUp),
                this._slider.removeEventListener('pointerupoutside', this._onSliderPointerUp));
        });
    }
    setScrollRange(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      var i, n;
      const { direction: s = 'horizontal', limitRange: r = [0, 1], range: a } = this.attribute,
        o = gt(t, r[0], r[1]);
      if (e) {
        const t = this._getSliderPos(o);
        this._slider &&
          ('horizontal' === s ? this._slider.setAttribute('x', t[0], !0) : this._slider.setAttribute('y', t[0], !0),
          (null === (i = this.stage) || void 0 === i ? void 0 : i.autoRender) ||
            null === (n = this.stage) ||
            void 0 === n ||
            n.renderNextFrame());
      }
      (this.attribute.range = o), this._onChange({ pre: a, value: o });
    }
    getScrollRange() {
      return this.attribute.range;
    }
    bindEvents() {
      this._rail && this._rail.addEventListener('pointerdown', this._onRailPointerDown),
        this._slider && this._slider.addEventListener('pointerdown', this._onSliderPointerDown);
    }
    render() {
      this._reset();
      const {
          direction: t = 'horizontal',
          width: e,
          height: i,
          range: n,
          limitRange: s = [0, 1],
          railStyle: r,
          sliderStyle: a,
          padding: o = 2
        } = this.attribute,
        l = this.createOrUpdateChild('scrollbar-container', {}, 'group'),
        h = l.createOrUpdateChild('scrollbar-rail', Object.assign({ x: 0, y: 0, width: e, height: i }, r), 'rect');
      this._rail = h;
      const c = this._getSliderRenderBounds(),
        d = this._getSliderPos(gt(n, s[0], s[1])),
        u = d[1] - d[0];
      let p;
      (this._sliderSize = u),
        (p =
          'horizontal' === t
            ? { x: d[0], y: c.y1, width: u, height: c.height }
            : { x: c.x1, y: d[0], width: c.width, height: u });
      const g = l.createOrUpdateChild(
        'slider',
        Object.assign(
          Object.assign(Object.assign(Object.assign({}, p), { cornerRadius: this._getDefaultSliderCornerRadius() }), a),
          { boundsPadding: Je(o), pickMode: 'imprecise' }
        ),
        'rect'
      );
      (this._slider = g), (this._container = l);
      const f = this._container.AABBBounds;
      this._viewPosition = { x: f.x1, y: f.y1 };
    }
    _getSliderRenderBounds() {
      if (this._sliderRenderBounds) return this._sliderRenderBounds;
      const { width: t, height: e, padding: i = 2 } = this.attribute,
        [n, s, r, a] = Je(i),
        o = { x1: a, y1: n, x2: t - s, y2: e - r, width: t - (a + s), height: e - (n + r) };
      return (this._sliderRenderBounds = o), o;
    }
    _getDefaultSliderCornerRadius() {
      const { direction: t, round: e } = this.attribute;
      if (e) {
        const { width: e, height: i } = this._getSliderRenderBounds();
        return 'horizontal' === t ? i : e;
      }
      return 0;
    }
    _getSliderPos(t) {
      const { direction: e } = this.attribute,
        { width: i, height: n, x1: s, y1: r } = this._getSliderRenderBounds();
      return 'horizontal' === e ? [i * t[0] + s, i * t[1] + s] : [n * t[0] + r, n * t[1] + r];
    }
    _getScrollRange() {
      if (this._sliderLimitRange) return this._sliderLimitRange;
      const { limitRange: t = [0, 1], direction: e } = this.attribute,
        [i, n] = gt(t, 0, 1),
        { width: s, height: r, x1: a, y1: o } = this._getSliderRenderBounds(),
        l = this._sliderSize;
      return 'horizontal' === e ? gt([a + i * s, a + n * s], a, s - l) : gt([o + i * r, o + n * r], o, r - l);
    }
    _onChange(t) {
      var e;
      const i = new rM('scroll', t);
      (i.manager = null === (e = this.stage) || void 0 === e ? void 0 : e.eventSystem.manager), this.dispatchEvent(i);
    }
    _reset() {
      (this._sliderRenderBounds = null), (this._sliderLimitRange = null);
    }
  };
  function gY(t, e) {
    t.forEachChildren(t => {
      const i = e(t);
      t.isContainer && !i && gY(t, e);
    });
  }
  pY.defaultAttributes = {
    direction: 'horizontal',
    round: !0,
    sliderSize: 20,
    sliderStyle: { fill: 'rgba(0, 0, 0, .5)' },
    railStyle: { fill: 'rgba(0, 0, 0, .0)' },
    padding: 2,
    scrollRange: [0, 1]
  };
  const fY = t => !l(t) && !1 !== t.visible;
  const vY = ['#ffffff', '#000000'];
  function mY(t, e, i, n, s) {
    const r = xY(t),
      a = xY(e);
    return yY(r, a, i, n)
      ? r
      : (function (t, e, i, n, s) {
          const r = [];
          s && (s instanceof Array ? r.push(...s) : r.push(s)), r.push(...vY);
          for (const s of r) if (t !== s && yY(s, e, i, n)) return s;
        })(r, a, i, n, s);
  }
  function yY(t, e, i, n) {
    return n ? _Y(t, e) > n : 'largeText' === i ? _Y(t, e) > 3 : _Y(t, e) > 4.5;
  }
  function _Y(t, e) {
    const i = bY(t),
      n = bY(e);
    return ((i > n ? i : n) + 0.05) / ((i > n ? n : i) + 0.05);
  }
  function bY(t) {
    const e = ge(t),
      i = e[0] / 255,
      n = e[1] / 255,
      s = e[2] / 255;
    let r, a, o;
    return (
      (r = i <= 0.03928 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4)),
      (a = n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4)),
      (o = s <= 0.03928 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4)),
      0.2126 * r + 0.7152 * a + 0.0722 * o
    );
  }
  function xY(t) {
    if (null == t ? void 0 : t.includes('#')) return t;
    const e = new ue(t),
      { r: i, g: n, b: s } = e.color;
    return '#' + fe(i, n, s);
  }
  function SY(t, e, i, n) {
    let s;
    switch (t) {
      case 'base':
        s = e;
        break;
      case 'invertBase':
        s = i;
        break;
      case 'similarBase':
        s = n;
    }
    return s;
  }
  function wY(t, e) {
    return [t[0] * e, t[1] * e];
  }
  function AY(t, e, i) {
    const n = (function (t, e) {
        const [i, n] = t,
          [s, r] = e,
          a = Math.sqrt((i * i + n * n) * (s * s + r * r)),
          o = a && (i * s + n * r) / a;
        return Math.acos(Math.min(Math.max(o, -1), 1));
      })(t, e),
      s =
        (function (t, e) {
          return t[0] * e[1] - e[0] * t[1];
        })(t, e) >= 0;
    return i ? (s ? 2 * Math.PI - n : n) : s ? n : 2 * Math.PI - n;
  }
  const kY = -0.5 * Math.PI,
    MY = 1.5 * Math.PI,
    TY =
      'PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol';
  var CY;
  !(function (t) {
    (t.selected = 'selected'),
      (t.selectedReverse = 'selected_reverse'),
      (t.hover = 'hover'),
      (t.hoverReverse = 'hover_reverse');
  })(CY || (CY = {}));
  const EY = { [CY.selectedReverse]: {}, [CY.selected]: {}, [CY.hover]: {}, [CY.hoverReverse]: {} },
    PY = (t, e, i) =>
      new $e(
        Object.assign(
          {
            defaultFontParams: { fontFamily: TY, fontSize: 11 },
            getTextBounds: i ? void 0 : dB,
            specialCharSet: '-/: .,@%\'"~' + $e.ALPHABET_CHAR_SET + $e.ALPHABET_CHAR_SET.toUpperCase()
          },
          null != e ? e : {}
        ),
        t
      );
  function RY(t, e) {
    var i;
    if (!t) return { width: 0, height: 0 };
    const n = dB({
      text: t,
      fontFamily: e.fontFamily,
      fontSize: e.fontSize || 12,
      fontWeight: e.fontWeight,
      textAlign: null !== (i = e.textAlign) && void 0 !== i ? i : 'center',
      textBaseline: e.textBaseline,
      ellipsis: !!e.ellipsis,
      maxLineWidth: e.maxLineWidth || 1 / 0,
      lineHeight: e.fontSize || 12
    });
    return { width: n.width(), height: n.height() };
  }
  var OY = function (t, e) {
    var i = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
    if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
      var s = 0;
      for (n = Object.getOwnPropertySymbols(t); s < n.length; s++)
        e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (i[n[s]] = t[n[s]]);
    }
    return i;
  };
  class BY extends uY {
    constructor(t) {
      super(D({}, BY.defaultAttributes, t)), (this.name = 'tag');
    }
    render() {
      var t;
      const {
          text: e = '',
          textStyle: i = {},
          shape: n = {},
          panel: s = {},
          space: r = 4,
          minWidth: o,
          maxWidth: c,
          padding: d = 4,
          visible: u,
          state: p
        } = this.attribute,
        g = Je(d),
        f = this.createOrUpdateChild('tag-content', { x: 0, y: 0, zIndex: 1 }, 'group');
      let v,
        m = g[1] + g[3],
        _ = g[0] + g[2],
        b = 0,
        x = 0;
      const { visible: S } = n,
        w = OY(n, ['visible']);
      if (a(S)) {
        const t = (null == w ? void 0 : w.size) || 10,
          e = y(t) ? t : Math.max(t[0], t[1]);
        (v = f.createOrUpdateChild(
          'tag-shape',
          Object.assign(Object.assign({ symbolType: 'circle', size: t, strokeBoundsBuffer: 0 }, w), {
            visible: S,
            x: e / 2,
            y: e / 2
          }),
          'symbol'
        )),
          T(null == p ? void 0 : p.shape) || (v.states = p.shape),
          S && (x = e + r);
      }
      (m += x), (b += x);
      const A = Object.assign(
        Object.assign({ text: e, visible: h(e) && !1 !== u, lineHeight: null == i ? void 0 : i.fontSize }, i),
        { x: b, y: 0 }
      );
      l(A.lineHeight) && (A.lineHeight = A.fontSize);
      const k = f.createOrUpdateChild('tag-text', A, 'text');
      T(null == p ? void 0 : p.text) || (k.states = p.text);
      const M = RY(A.text, i),
        C = M.width,
        E = M.height;
      m += C;
      const P = null !== (t = n.size) && void 0 !== t ? t : 10,
        R = y(P) ? P : Math.max(P[0], P[1]);
      _ += Math.max(E, (null == n ? void 0 : n.visible) ? R : 0);
      const { textAlign: O, textBaseline: B } = i;
      (h(o) || h(c)) &&
        (h(o) && m < o && (m = o), h(c) && m > c && ((m = c), k.setAttribute('maxLineWidth', c - g[1] - g[2])));
      let I = 0,
        D = 0;
      'center' === O
        ? ((I -= m / 2), v && v.setAttribute('x', (v.attribute.x || 0) - C / 2), f.setAttribute('x', -x / 2))
        : 'right' === O || 'end' === O
        ? ((I -= m), v && v.setAttribute('x', (v.attribute.x || 0) - C), f.setAttribute('x', -g[1] - x))
        : ('left' !== O && 'start' !== O) || f.setAttribute('x', g[3]),
        'middle' === B
          ? ((D -= _ / 2), v && v.setAttribute('y', 0))
          : 'bottom' === B
          ? ((D -= _), v && v.setAttribute('y', -E / 2), f.setAttribute('y', -g[2]))
          : 'top' === B && (f.setAttribute('y', g[0]), v && v.setAttribute('y', E / 2));
      const { visible: L } = s,
        F = OY(s, ['visible']);
      if (u && a(L)) {
        const t = this.createOrUpdateChild(
          'tag-panel',
          Object.assign(Object.assign({}, F), { visible: L && !!e, x: I, y: D, width: m, height: _ }),
          'rect'
        );
        T(null == p ? void 0 : p.panel) || (t.states = p.panel);
      }
    }
  }
  BY.defaultAttributes = {
    visible: !0,
    textStyle: { fontSize: 12, fill: '#000', textAlign: 'left', textBaseline: 'top' },
    space: 4,
    padding: 4,
    shape: { fill: '#000' }
  };
  var IY = function (t, e) {
    var i = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
    if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
      var s = 0;
      for (n = Object.getOwnPropertySymbols(t); s < n.length; s++)
        e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (i[n[s]] = t[n[s]]);
    }
    return i;
  };
  const DY = new Kt();
  class LY extends uY {
    constructor(t) {
      super(D({}, LY.defaultAttributes, t)),
        (this.name = 'poptip'),
        (this.positionList = ['top', 'tl', 'tr', 'bottom', 'bl', 'br', 'left', 'lt', 'lb', 'right', 'rt', 'rb']);
    }
    render() {
      var t, e, i, n, s, r, o, l;
      const {
        titleStyle: c = {},
        position: d,
        contentStyle: u = {},
        panel: p = {},
        space: g = 4,
        minWidth: v = 0,
        maxWidth: m = 1 / 0,
        padding: y = 4,
        maxWidthPercent: _,
        visible: b,
        state: x,
        dx: S = 0,
        dy: w = 0
      } = this.attribute;
      let { title: A = '', content: k = '' } = this.attribute;
      (A = this.attribute.titleFormatMethod ? this.attribute.titleFormatMethod(A) : A),
        (k = this.attribute.contentFormatMethod ? this.attribute.contentFormatMethod(k) : k);
      const M = Je(y),
        C = this.createOrUpdateChild('poptip-content', { x: 0, y: 0, zIndex: 1 }, 'group'),
        E = m - M[1] - M[3],
        P = h(A) && !1 !== b,
        R = Object.assign(Object.assign({ text: f(A) ? A : [A], visible: P }, c), {
          x: M[3],
          y: M[0],
          maxLineWidth: E,
          textAlign: 'left',
          textBaseline: 'top'
        }),
        O = C.createOrUpdateChild('poptip-title', R, 'wrapText');
      T(null == x ? void 0 : x.title) || (O.states = x.title);
      const B = O.AABBBounds,
        I = B.height(),
        D = B.width();
      let L = I + g;
      P || (L = 0);
      const F = h(k) && !1 !== b,
        j = Object.assign(Object.assign({ text: f(k) ? k : [k], visible: F }, u), {
          x: M[3],
          y: M[0] + L,
          maxLineWidth: E,
          textAlign: 'left',
          textBaseline: 'top'
        }),
        z = C.createOrUpdateChild('poptip-content', j, 'wrapText');
      T(null == x ? void 0 : x.content) || (z.states = x.content);
      const H = z.AABBBounds,
        N = H.height(),
        V = H.width();
      F && (L += N);
      let W = Bt(D + M[1] + M[3], V + M[1] + M[3]);
      W > m ? (W = m) : W < v && (W = v);
      let G = M[0] + M[2] + L;
      const { visible: U } = p,
        Y = IY(p, ['visible']),
        $ = null !== (t = Y.size) && void 0 !== t ? t : 12,
        X = f($)
          ? [
              $[0] + (null !== (e = Y.space) && void 0 !== e ? e : 0),
              $[1] + (null !== (i = Y.space) && void 0 !== i ? i : 0)
            ]
          : $ + (null !== (n = Y.space) && void 0 !== n ? n : 0),
        K = null !== (s = Y.lineWidth) && void 0 !== s ? s : 1,
        q = this.stage
          ? [
              null !== (r = this.stage.viewWidth) && void 0 !== r ? r : this.stage.width,
              null !== (o = this.stage.viewHeight) && void 0 !== o ? o : this.stage.height
            ]
          : void 0;
      if (q) {
        const t = this.AABBBounds,
          e = null !== (l = this.attribute.x) && void 0 !== l ? l : t.x1,
          i = q[0] - t.x1;
        let n = Math.max(e, i);
        const s = (f($) ? $[0] : 12) + 3;
        if (((n = Math.min(n - s, n * _)), n < W)) {
          W = n;
          const t = M[1] + M[3];
          O.setAttribute('maxLineWidth', n - t),
            z.setAttribute('maxLineWidth', n - t),
            (G = M[0] + M[2]),
            P && (G += O.AABBBounds.height() + g),
            (G += z.AABBBounds.height());
        }
      }
      const Z = 'auto' === d;
      let J,
        Q = -1 / 0;
      for (let t = 0; t < this.positionList.length + 1; t++) {
        const e = Z ? this.positionList[t === this.positionList.length ? J : t] : d,
          { angle: i, offset: n, rectOffset: s } = this.getAngleAndOffset(e, W, G, f(X) ? X : [X, X - K]);
        if (a(U)) {
          const t = (f($) ? $[0] : $) / 4,
            e = C.createOrUpdateChild(
              'poptip-symbol-panel',
              Object.assign(Object.assign({}, Y), {
                visible: U && (F || P),
                x: t,
                y: 0,
                strokeBoundsBuffer: -1,
                boundsPadding: -2,
                anchor: [0, 0],
                symbolType: 'arrow2Left',
                angle: i,
                dx: n[0],
                dy: n[1],
                size: $,
                zIndex: -9
              }),
              'symbol'
            );
          T(null == x ? void 0 : x.panel) || (e.states = x.panel);
          const s = C.createOrUpdateChild(
            'poptip-rect-panel',
            Object.assign(Object.assign({}, Y), {
              visible: U && (F || P),
              x: 0,
              y: 0,
              width: W,
              height: G,
              zIndex: -8
            }),
            'rect'
          );
          T(null == x ? void 0 : x.panel) || (s.states = x.panel);
        }
        if ((C.setAttributes({ x: -n[0] + S, y: -n[1] + w }), !Z || !q)) break;
        {
          DY.setValue(0, 0, W, G).transformWithMatrix(C.globalTransMatrix);
          const e = DY,
            i = new Xt().setValue(0, 0, q[0], q[1]);
          if (
            ((et = i),
            (it = !1),
            (tt = e) && et
              ? ((ye = tt.x1),
                (_e = tt.x2),
                (be = tt.y1),
                (xe = tt.y2),
                (Se = et.x1),
                (we = et.x2),
                (Ae = et.y1),
                (ke = et.y2),
                it &&
                  (ye > _e && ([ye, _e] = [_e, ye]),
                  be > xe && ([be, xe] = [xe, be]),
                  Se > we && ([Se, we] = [we, Se]),
                  Ae > ke && ([Ae, ke] = [ke, Ae])),
                ye > Se && _e < we && be > Ae && xe < ke
                  ? Ee.BBOX1
                  : Se > ye && we < _e && Ae > be && ke < xe
                  ? Ee.BBOX2
                  : Ee.NONE)
              : Ee.NONE)
          )
            break;
          {
            const n = Ce(e, i, !1),
              s = (n.x2 - n.x1) * (n.y2 - n.y1);
            s > Q && ((Q = s), (J = t));
          }
        }
      }
      var tt, et, it;
    }
    getAngleAndOffset(t, e, i, n) {
      const s = n[1] / 2;
      switch (t) {
        case 'tl':
          return { angle: (Mt / 2) * 3, offset: [e / 4, i + s], rectOffset: [-e / 4, -i - n[1]] };
        case 'top':
          return { angle: (Mt / 2) * 3, offset: [e / 2, i + s], rectOffset: [0, -i - n[1]] };
        case 'tr':
          return { angle: (Mt / 2) * 3, offset: [(e / 4) * 3, i + s], rectOffset: [(e / 4) * 3, -i - n[1]] };
        case 'rt':
          return { angle: 0, offset: [-s, i / 5], rectOffset: [(e / 4) * 3, -i - n[1]] };
        case 'right':
          return { angle: 0, offset: [-s, i / 2], rectOffset: [(e / 4) * 3, -i - n[1]] };
        case 'rb':
          return { angle: 0, offset: [-s, (i / 5) * 4], rectOffset: [(e / 4) * 3, -i - n[1]] };
        case 'bl':
          return { angle: Mt / 2, offset: [e / 4, -s], rectOffset: [-e / 4, -i - n[1]] };
        case 'bottom':
          return { angle: Mt / 2, offset: [e / 2, -s], rectOffset: [0, -i - n[1]] };
        case 'br':
          return { angle: Mt / 2, offset: [(e / 4) * 3, -s], rectOffset: [(e / 4) * 3, -i - n[1]] };
        case 'lt':
          return { angle: Mt, offset: [e + s, i / 5], rectOffset: [-e / 4, -i - n[1]] };
        case 'left':
          return { angle: Mt, offset: [e + s, i / 2], rectOffset: [0, -i - n[1]] };
        case 'lb':
          return { angle: Mt, offset: [e + s, (i / 5) * 4], rectOffset: [(e / 4) * 3, -i - n[1]] };
      }
    }
  }
  LY.defaultAttributes = {
    position: 'rt',
    visible: !0,
    title: null,
    content: null,
    titleStyle: { fontSize: 12, fill: '#000', textAlign: 'left', textBaseline: 'top' },
    contentStyle: { fontSize: 12, fill: '#000', textAlign: 'left', textBaseline: 'top' },
    maxWidthPercent: 0.8,
    space: 8,
    padding: 10
  };
  const FY = {
      visible: !0,
      position: 'auto',
      titleStyle: { fontSize: 16, fill: '#08979c' },
      contentStyle: { fontSize: 12, fill: 'green' },
      panel: { visible: !0, fill: '#e6fffb', size: 12, space: 0, stroke: '#87e8de', lineWidth: 1, cornerRadius: 4 }
    },
    jY = { poptip: D({}, FY) };
  var zY = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let HY = class {
    render(t, e, i, n, s, r, a, o, l, h, c, d, u) {
      var p, g;
      if (1 === t._showPoptip) {
        const { visible: e, visibleCb: i } = t.attribute.poptip || {};
        if (!1 === e || (i && !1 === i(t))) return;
        const n = {};
        D(n, LY.defaultAttributes, t.attribute.poptip ? t.attribute.poptip : {}),
          this.poptipComponent ? this.poptipComponent.initAttributes(n) : (this.poptipComponent = new LY(n));
        let s = t.attribute.poptip || {};
        if ('text' === t.type && null == s.title && null == s.content) {
          const e = {};
          (g = s),
            D(e, jY.poptip, g),
            (s = e),
            (s.content = null !== (p = s.content) && void 0 !== p ? p : t.attribute.text);
        }
        const r = t.globalTransMatrix;
        this.poptipComponent.setAttributes(
          Object.assign(Object.assign({ visibleAll: !0, pickable: !1, childrenPickable: !1 }, s), { x: r.e, y: r.f })
        ),
          h.stage.tryInitInteractiveLayer();
        const a = h.stage.getLayer('_builtin_interactive');
        a && a.add(this.poptipComponent);
      } else
        2 === t._showPoptip &&
          ((t._showPoptip = 0), this.poptipComponent && this.poptipComponent.setAttributes({ visibleAll: !1 }));
    }
  };
  HY = zY([ZS()], HY);
  var NY = function (t, e, i, n) {
    var s,
      r = arguments.length,
      a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n;
    if ('object' == typeof Reflect && 'function' == typeof Reflect.decorate) a = Reflect.decorate(t, e, i, n);
    else for (var o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
    return r > 3 && a && Object.defineProperty(e, i, a), a;
  };
  let VY = class {
    constructor() {
      (this.name = 'poptip'),
        (this.activeEvent = 'onRegister'),
        (this._uid = Jk.GenAutoIncrementId()),
        (this.key = this.name + this._uid),
        (this.poptip = t => {
          const e = t.target;
          if (e.isContainer || !e.attribute) return void this.unpoptip(t);
          if (e === this.activeGraphic) return;
          const { poptip: i } = e.attribute;
          i && (e.setAttributes({}), (e._showPoptip = 1)),
            this.activeGraphic && (this.activeGraphic.setAttributes({}), (this.activeGraphic._showPoptip = 2)),
            this.setActiveGraphic(e, !0);
        }),
        (this.unpoptip = t => {
          this.activeGraphic &&
            (this.activeGraphic.setAttributes({}),
            (this.activeGraphic._showPoptip = 2),
            this.setActiveGraphic(null, !0));
        });
    }
    activate(t) {
      this.pluginService = t;
      const { stage: e } = this.pluginService;
      e.addEventListener('pointerover', this.poptip);
    }
    setActiveGraphic(t, e) {
      (this.activeGraphic = t), this.pluginService.stage.renderNextFrame();
    }
    deactivate(t) {
      const { stage: e } = this.pluginService;
      e.removeEventListener('pointerover', this.poptip);
    }
  };
  VY = NY([ZS()], VY);
  let WY = class {
    constructor() {
      (this.name = 'poptipForText'),
        (this.activeEvent = 'onRegister'),
        (this._uid = Jk.GenAutoIncrementId()),
        (this.key = this.name + this._uid),
        (this.poptip = t => {
          const e = t.target;
          if ('text' !== e.type || !e.cliped || e.isContainer || !e.attribute) return void this.unpoptip(t);
          if (e === this.activeGraphic) return;
          const { poptip: i = {} } = e.attribute;
          i && (e.setAttributes({}), (e._showPoptip = 1)),
            this.activeGraphic && (this.activeGraphic.setAttributes({}), (this.activeGraphic._showPoptip = 2)),
            this.setActiveGraphic(e, !0);
        }),
        (this.unpoptip = t => {
          this.activeGraphic &&
            (this.activeGraphic.setAttributes({}),
            (this.activeGraphic._showPoptip = 2),
            this.setActiveGraphic(null, !0));
        });
    }
    activate(t) {
      this.pluginService = t;
      const { stage: e } = this.pluginService;
      e.addEventListener('pointerover', this.poptip);
    }
    setActiveGraphic(t, e) {
      (this.activeGraphic = t), this.pluginService.stage.renderNextFrame();
    }
    deactivate(t) {
      const { stage: e } = this.pluginService;
      e.removeEventListener('pointerover', this.poptip);
    }
  };
  WY = NY([ZS()], WY);
  const GY = new YS((t, e, i, n) => {
    i(HY) || (t(HY).toSelf().inSingletonScope(), t(PP).toService(HY)),
      i(VY) || (t(VY).toSelf(), t(TL).toService(VY)),
      i(WY) || (t(WY).toSelf(), t(TL).toService(WY));
  });
  class UY extends uY {
    constructor() {
      super(...arguments), (this.name = 'crosshair');
    }
    render() {
      this.renderCrosshair(this);
    }
  }
  class YY extends UY {
    constructor(t) {
      super(D({}, YY.defaultAttributes, t));
    }
    renderCrosshair(t) {
      const { start: e, end: i, lineStyle: n } = this.attribute;
      return t.createOrUpdateChild('crosshair-line', Object.assign({ points: [e, i] }, n), 'line');
    }
    setLocation(t) {
      const { start: e, end: i } = t;
      this.setAttributes({ start: e, end: i });
    }
  }
  YY.defaultAttributes = { lineStyle: { stroke: '#b2bacf', lineWidth: 1, lineDash: [2] } };
  class $Y extends UY {
    constructor(t) {
      super(D({}, $Y.defaultAttributes, t));
    }
    renderCrosshair(t) {
      const { start: e, end: i, rectStyle: n } = this.attribute;
      return t.createOrUpdateChild(
        'crosshair-rect',
        Object.assign({ x: e.x, y: e.y, width: i.x - e.x, height: i.y - e.y }, n),
        'rect'
      );
    }
    setLocation(t) {
      const { start: e, end: i } = t;
      this.setAttributes({ start: e, end: i });
    }
  }
  $Y.defaultAttributes = { rectStyle: { fill: '#b2bacf', opacity: 0.2 } };
  class XY extends UY {
    constructor(t) {
      super(D({}, XY.defaultAttributes, t));
    }
    renderCrosshair(t) {
      const { center: e, radius: i, lineStyle: n } = this.attribute;
      return t.createOrUpdateChild(
        'crosshair-circle',
        Object.assign(Object.assign(Object.assign(Object.assign({}, e), { outerRadius: i }), this.attribute), n),
        'arc'
      );
    }
    setLocation(t) {
      const { center: e } = this.attribute,
        i = Yt.distancePP(t, e);
      this.setAttribute('radius', i);
    }
  }
  XY.defaultAttributes = { lineStyle: { stroke: ['#b2bacf', !1, !1, !1], lineWidth: 1, lineDash: [2] } };
  class KY extends UY {
    constructor(t) {
      super(D({}, KY.defaultAttributes, t));
    }
    renderCrosshair(t) {
      const { center: e, radius: i, innerRadius: n = 0, sectorStyle: s } = this.attribute,
        { startAngle: r, endAngle: a } = this.attribute;
      return t.createOrUpdateChild(
        'crosshair-sector',
        Object.assign(
          Object.assign(Object.assign({}, e), { outerRadius: i, innerRadius: n, startAngle: r, endAngle: a }),
          s
        ),
        'arc'
      );
    }
    setLocation(t) {
      const { center: e, startAngle: i = kY, endAngle: n = MY } = this.attribute,
        s = n - i,
        r = Zt(ee(e, t));
      this.setAttributes({ startAngle: r - s / 2, endAngle: r + s / 2 });
    }
  }
  KY.defaultAttributes = { sectorStyle: { fill: '#b2bacf', opacity: 0.2 } };
  class qY extends UY {
    constructor(t) {
      super(D({}, qY.defaultAttributes, t));
    }
    renderCrosshair(t) {
      const { center: e, radius: i, sides: n = 6, lineStyle: s } = this.attribute,
        { startAngle: r, endAngle: a } = this.attribute,
        o = (a - r) % (2 * Math.PI) == 0,
        l = (a - r) / n;
      let h;
      for (let t = 0; t <= n; t++) {
        const s = te(e, i, r + l * t);
        0 === t ? (h = `M${s.x},${s.y}`) : (h += `L${s.x},${s.y}`), t === n && o && (h += 'Z');
      }
      return t.createOrUpdateChild('crosshair-polygon', Object.assign({ path: h }, s), 'path');
    }
    setLocation(t) {
      const { center: e } = this.attribute,
        i = Yt.distancePP(t, e);
      this.setAttribute('radius', i);
    }
  }
  qY.defaultAttributes = { lineStyle: { stroke: '#b2bacf', lineWidth: 1, lineDash: [2] } };
  const ZY = new Uint32Array(33),
    JY = new Uint32Array(33);
  (JY[0] = 0), (ZY[0] = ~JY[0]);
  for (let t = 1; t <= 32; ++t) (JY[t] = (JY[t - 1] << 1) | 1), (ZY[t] = ~JY[t]);
  function QY(t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    const n = Math.max(1, Math.sqrt((t * e) / 1e6)),
      s = ~~((t + 2 * i + n) / n),
      r = ~~((e + 2 * i + n) / n),
      a = t => ~~((t + i) / n);
    return (
      (a.invert = t => t * n - i),
      (a.bitmap = () =>
        (function (t, e) {
          const i = new Uint32Array(~~((t * e + 32) / 32));
          function n(t, e) {
            i[t] |= e;
          }
          function s(t, e) {
            i[t] &= e;
          }
          return {
            array: i,
            get: (e, n) => {
              const s = n * t + e;
              return i[s >>> 5] & (1 << (31 & s));
            },
            set: (e, i) => {
              const s = i * t + e;
              n(s >>> 5, 1 << (31 & s));
            },
            clear: (e, i) => {
              const n = i * t + e;
              s(n >>> 5, ~(1 << (31 & n)));
            },
            getRange: n => {
              let { x1: s, y1: r, x2: a, y2: o } = n;
              if (a < 0 || o < 0 || s > t || r > e) return !0;
              let l,
                h,
                c,
                d,
                u = o;
              for (; u >= r; --u)
                if (((l = u * t + s), (h = u * t + a), (c = l >>> 5), (d = h >>> 5), c === d)) {
                  if (i[c] & ZY[31 & l] & JY[1 + (31 & h)]) return !0;
                } else {
                  if (i[c] & ZY[31 & l]) return !0;
                  if (i[d] & JY[1 + (31 & h)]) return !0;
                  for (let t = c + 1; t < d; ++t) if (i[t]) return !0;
                }
              return !1;
            },
            setRange: i => {
              let s,
                r,
                a,
                o,
                l,
                { x1: h, y1: c, x2: d, y2: u } = i;
              if (!(d < 0 || u < 0 || h > t || c > e))
                for (; c <= u; ++c)
                  if (((s = c * t + h), (r = c * t + d), (a = s >>> 5), (o = r >>> 5), a === o))
                    n(a, ZY[31 & s] & JY[1 + (31 & r)]);
                  else for (n(a, ZY[31 & s]), n(o, JY[1 + (31 & r)]), l = a + 1; l < o; ++l) n(l, 4294967295);
            },
            clearRange: e => {
              let i,
                n,
                r,
                a,
                o,
                { x1: l, y1: h, x2: c, y2: d } = e;
              for (; h <= d; ++h)
                if (((i = h * t + l), (n = h * t + c), (r = i >>> 5), (a = n >>> 5), r === a))
                  s(r, JY[31 & i] | ZY[1 + (31 & n)]);
                else for (s(r, JY[31 & i]), s(a, ZY[1 + (31 & n)]), o = r + 1; o < a; ++o) s(o, 0);
            },
            outOfBounds: i => {
              let { x1: n, y1: s, x2: r, y2: a } = i;
              return n < 0 || s < 0 || a >= e || r >= t;
            },
            toImageData: n => {
              const s = n.createImageData(t, e),
                r = s.data;
              for (let n = 0; n < e; ++n)
                for (let e = 0; e < t; ++e) {
                  const s = n * t + e,
                    a = 4 * s,
                    o = i[s >>> 5] & (1 << (31 & s));
                  (r[a + 0] = 255 * o), (r[a + 1] = 255 * o), (r[a + 2] = 255 * o), (r[a + 3] = 31);
                }
              return s;
            }
          };
        })(s, r)),
      (a.ratio = n),
      (a.padding = i),
      (a.width = t),
      (a.height = e),
      a
    );
  }
  function t$(t, e) {
    if (arguments.length > 2 && void 0 !== arguments[2] && arguments[2]) {
      const { x1: i, x2: n, y1: s, y2: r } = e,
        a = pt(i, 0, t.width),
        o = pt(n, 0, t.width),
        l = pt(s, 0, t.height),
        h = pt(r, 0, t.height);
      return { x1: t(a), x2: t(o), y1: t(l), y2: t(h) };
    }
    return { x1: t(e.x1), x2: t(e.x2), y1: t(e.y1), y2: t(e.y2) };
  }
  function e$(t, e, i) {
    let n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
      s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
      r = i;
    return (
      s > 0 && (r = { x1: i.x1 - s, x2: i.x2 + s, y1: i.y1 - s, y2: i.y2 + s }),
      (r = t$(t, r)),
      !((n && e.outOfBounds(r)) || e.getRange(r))
    );
  }
  function i$(t, e, i) {
    let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [],
      s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
      r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
    for (let a = 0; a < n.length; a++) {
      const o = i.clone();
      if ((o.setAttributes(n[a]), o.update(), e$(t, e, t$(t, o.AABBBounds), s, r)))
        return e.setRange(t$(t, o.AABBBounds, !0)), n[a];
    }
    return !1;
  }
  function n$(t, e, i, n, s, r, a) {
    var l, h;
    const c = null === (l = n.overlap) || void 0 === l ? void 0 : l.clampForce,
      d = null === (h = n.overlap) || void 0 === h ? void 0 : h.overlapPadding;
    if ('bound' === i.type || 'position' === i.type) {
      if (o(a)) {
        const l = (
          (o(i.position) ? i.position(s.attribute) : i.position) || ((u = n.type), 'rect' === u ? r$ : s$)
        ).map(t => a(s.AABBBounds, r, t, n.offset));
        return i$(t, e, s, l, c, d);
      }
      return !1;
    }
    var u;
    if ('moveY' === i.type) {
      const n = (i.offset ? (o(i.offset) ? i.offset(s.attribute) : i.offset) : []).map(t => ({
        x: s.attribute.x,
        y: s.attribute.y + t
      }));
      return i$(t, e, s, n, c, d);
    }
    if ('moveX' === i.type) {
      const n = (i.offset ? (o(i.offset) ? i.offset(s.attribute) : i.offset) : []).map(t => ({
        x: s.attribute.x + t,
        y: s.attribute.y
      }));
      return i$(t, e, s, n, c, d);
    }
    return !1;
  }
  const s$ = ['top', 'bottom', 'right', 'left', 'top-right', 'bottom-right', 'top-left', 'bottom-left'],
    r$ = ['top', 'inside-top', 'inside'];
  function a$(t, e, i) {
    const { x1: n, x2: s, y1: r, y2: a } = t.AABBBounds,
      o = Math.min(n, s),
      l = Math.max(n, s),
      h = Math.min(r, a),
      c = Math.max(r, a);
    let d = 0,
      u = 0;
    return (
      o < 0 && l - o <= e ? (d = -o) : l > e && o - (l - e) >= 0 && (d = e - l),
      h < 0 && c - h <= i ? (u = -h) : c > i && h - (c - i) >= 0 && (u = i - c),
      { dx: d, dy: u }
    );
  }
  const o$ = {
    fadeIn: function () {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      var e, i, n;
      return {
        from: { opacity: 0, fillOpacity: 0, strokeOpacity: 0 },
        to: {
          opacity: null !== (e = t.opacity) && void 0 !== e ? e : 1,
          fillOpacity: null !== (i = t.fillOpacity) && void 0 !== i ? i : 1,
          strokeOpacity: null !== (n = t.strokeOpacity) && void 0 !== n ? n : 1
        }
      };
    },
    fadeOut: function () {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      var e, i, n;
      return {
        from: {
          opacity: null !== (e = t.opacity) && void 0 !== e ? e : 1,
          fillOpacity: null !== (i = t.fillOpacity) && void 0 !== i ? i : 1,
          strokeOpacity: null !== (n = t.strokeOpacity) && void 0 !== n ? n : 1
        },
        to: { opacity: 0, fillOpacity: 0, strokeOpacity: 0 }
      };
    }
  };
  function l$(t, e) {
    var i, n;
    return null !== (n = null === (i = o$[e]) || void 0 === i ? void 0 : i.call(o$, t)) && void 0 !== n
      ? n
      : { from: {}, to: {} };
  }
  const h$ = 'same-time',
    c$ = 300,
    d$ = 'linear';
  class u$ extends uY {
    setBitmap(t) {
      this._bitmap = t;
    }
    setBitmapTool(t) {
      this._bmpTool = t;
    }
    constructor(t) {
      super(D({}, u$.defaultAttributes, t)),
        (this.name = 'label'),
        (this._onHover = t => {
          const e = t.target;
          e === this._lastHover ||
            T(e.states) ||
            (e.addState(CY.hover, !0),
            gY(this, t => {
              t === e || T(t.states) || t.addState(CY.hoverReverse, !0);
            }),
            (this._lastHover = e));
        }),
        (this._onUnHover = t => {
          this._lastHover &&
            (gY(this, t => {
              T(t.states) || (t.removeState(CY.hoverReverse), t.removeState(CY.hover));
            }),
            (this._lastHover = null));
        }),
        (this._onClick = t => {
          const e = t.target;
          if (this._lastSelect === e && e.hasState('selected'))
            return (
              (this._lastSelect = null),
              void gY(this, t => {
                T(t.states) || (t.removeState(CY.selectedReverse), t.removeState(CY.selected));
              })
            );
          T(e.states) ||
            (e.addState(CY.selected, !0),
            gY(this, t => {
              t === e || T(t.states) || t.addState(CY.selectedReverse, !0);
            }),
            (this._lastSelect = e));
        });
    }
    labeling(t, e, i, n) {}
    _labelLine(t) {}
    render() {
      if ((this._prepare(), l(this._idToGraphic))) return;
      const { overlap: t, smartInvert: e, dataFilter: i, customLayoutFunc: n, customOverlapFunc: s } = this.attribute;
      let r,
        a = this.attribute.data;
      o(i) && (a = i(a)),
        (r = o(n) ? n(a, t => this._idToGraphic.get(t.id)) : this._layout(a)),
        o(s) ? (r = s(r, t => this._idToGraphic.get(t.id))) : !1 !== t && (r = this._overlapping(r)),
        !1 !== e && this._smartInvert(r),
        this._renderLabels(r);
    }
    _bindEvent(t) {
      if (!t) return;
      const { hover: e, select: i } = this.attribute;
      e && (t.addEventListener('pointermove', this._onHover), t.addEventListener('pointerout', this._onUnHover)),
        i && t.addEventListener('pointerdown', this._onClick);
    }
    _setStates(t) {
      if (!t) return;
      const e = this.attribute.state;
      e && !T(e) && (t.states = e);
    }
    _createLabelText(t) {
      const e = sB(t);
      return this._bindEvent(e), this._setStates(e), e;
    }
    _prepare() {
      var t;
      const e = [];
      let i;
      if (
        ((i = o(this.attribute.getBaseMarks)
          ? this.attribute.getBaseMarks()
          : (function (t, e) {
              if (!e) return [];
              const i = t.find(t => t.name === e, !0);
              return i ? i.getChildren() : [];
            })(this.getRootNode(), this.attribute.baseMarkGroupName)),
        i.forEach(t => {
          'willRelease' !== t.releaseStatus && e.push(t);
        }),
        null === (t = this._idToGraphic) || void 0 === t || t.clear(),
        (this._baseMarks = e),
        !e || 0 === e.length)
      )
        return;
      const { data: n } = this.attribute;
      if (n && 0 !== n.length) {
        this._idToGraphic || (this._idToGraphic = new Map());
        for (let t = 0; t < e.length; t++) {
          const i = n[t],
            s = e[t];
          i && s && (h(i.id) || (i.id = `vrender-component-${this.name}-${t}`), this._idToGraphic.set(i.id, s));
        }
      }
    }
    _layout() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      const { textStyle: e = {}, position: i, offset: n } = this.attribute,
        s = [];
      for (let r = 0; r < t.length; r++) {
        const a = t[r],
          l = this._idToGraphic.get(a.id),
          h = Object.assign(Object.assign({ fill: l.attribute.fill }, e), a),
          c = this._createLabelText(h),
          d = this.getGraphicBounds(c),
          u = this.getGraphicBounds(l, { x: a.x, y: a.y }),
          p = this.labeling(d, u, o(i) ? i(a) : i, n);
        p && ((h.x = p.x), (h.y = p.y), c.setAttributes(p)), s.push(c);
      }
      return s;
    }
    _overlapping(t) {
      var e, i, n, s;
      if (0 === t.length) return [];
      const r = this.attribute.overlap,
        a = [],
        l = this.getBaseMarkGroup(),
        h =
          null !== (e = r.size) && void 0 !== e
            ? e
            : {
                width: null !== (i = null == l ? void 0 : l.AABBBounds.width()) && void 0 !== i ? i : 0,
                height: null !== (n = null == l ? void 0 : l.AABBBounds.height()) && void 0 !== n ? n : 0
              };
      if (0 === h.width || 0 === h.height) return t;
      const {
          avoidBaseMark: c,
          strategy: d = [],
          hideOnHit: u = !0,
          clampForce: p = !0,
          avoidMarks: f = [],
          overlapPadding: v
        } = r,
        m = this._bmpTool || QY(h.width, h.height),
        y = this._bitmap || m.bitmap(),
        _ = d.some(t => 'bound' === t.type);
      c &&
        (null === (s = this._baseMarks) ||
          void 0 === s ||
          s.forEach(t => {
            t.AABBBounds && y.setRange(t$(m, t.AABBBounds, !0));
          })),
        f.length > 0 &&
          f.forEach(t => {
            g(t)
              ? (function (t, e) {
                  if (!e) return [];
                  const i = t.find(t => t.name === e, !0);
                  return i ? i.findAll(t => 'group' !== t.type, !0) : [];
                })(this.getRootNode(), t).forEach(t => {
                  t.AABBBounds && y.setRange(t$(m, t.AABBBounds, !0));
                })
              : t.AABBBounds && y.setRange(t$(m, t.AABBBounds, !0));
          });
      for (let e = 0; e < t.length; e++) {
        if (!1 === t[e].visible) continue;
        const i = t[e],
          n = this._idToGraphic.get(i.attribute.id);
        if ((i.update(), !Pe(n.AABBBounds, { x1: 0, x2: m.width, y1: 0, y2: m.height }, !0))) continue;
        if (e$(m, y, i.AABBBounds, p, v)) {
          if (!_) {
            y.setRange(t$(m, i.AABBBounds, !0)), a.push(i);
            continue;
          }
          if (
            _ &&
            (null == n ? void 0 : n.AABBBounds) &&
            this._canPlaceInside(i.AABBBounds, null == n ? void 0 : n.AABBBounds)
          ) {
            y.setRange(t$(m, i.AABBBounds, !0)), a.push(i);
            continue;
          }
        }
        let s = !1;
        for (let r = 0; r < d.length; r++)
          if (((s = n$(m, y, d[r], this.attribute, i, this.getGraphicBounds(n, t[e]), this.labeling)), !1 !== s)) {
            i.setAttributes({ x: s.x, y: s.y }), a.push(i);
            break;
          }
        if (!s && p) {
          const { dx: t = 0, dy: e = 0 } = a$(i, m.width, m.height);
          if (
            (0 !== t || 0 !== e) &&
            e$(
              m,
              y,
              { x1: i.AABBBounds.x1 + t, x2: i.AABBBounds.x2 + t, y1: i.AABBBounds.y1 + e, y2: i.AABBBounds.y2 + e },
              void 0,
              v
            )
          ) {
            i.setAttributes({ x: i.attribute.x + t, y: i.attribute.y + e }),
              y.setRange(t$(m, i.AABBBounds, !0)),
              a.push(i);
            continue;
          }
        }
        !s && !u && a.push(i);
      }
      return o(this.onAfterLabelOverlap) && this.onAfterLabelOverlap(y), a;
    }
    getBaseMarkGroup() {
      const { baseMarkGroupName: t } = this.attribute;
      if (t) return this.getRootNode().find(e => e.name === t, !0);
    }
    getGraphicBounds(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return (null == t ? void 0 : t.AABBBounds) || { x1: e.x, x2: e.x, y1: e.y, y2: e.y };
    }
    _renderLabels(t) {
      !1 === this._enableAnimation || !1 === this.attribute.animation
        ? this._renderWithOutAnimation(t)
        : this._renderWithAnimation(t);
    }
    _renderWithAnimation(t) {
      var e, i, n, s, r;
      const a = null !== (e = this.attribute.animation) && void 0 !== e ? e : {},
        o = null !== (i = a.mode) && void 0 !== i ? i : h$,
        l = null !== (n = a.duration) && void 0 !== n ? n : c$,
        h = null !== (s = a.easing) && void 0 !== s ? s : d$,
        c = null !== (r = a.delay) && void 0 !== r ? r : 0,
        d = new Map(),
        u = this._graphicToText || new Map(),
        p = [];
      t.forEach((t, e) => {
        var i, n, s, r, g, f, v;
        const m = this._labelLine(t),
          y = this._idToGraphic.get(t.attribute.id),
          b = (null == u ? void 0 : u.get(y)) ? 'update' : 'enter';
        if ('enter' === b) {
          if ((p.push(t), d.set(y, m ? { text: t, labelLine: m } : { text: t }), y)) {
            const { from: i, to: n } = l$(t.attribute, 'fadeIn');
            this.add(t),
              m && this.add(m),
              y.once('animate-bind', () => {
                t.setAttributes(i);
                const s = this._afterRelatedGraphicAttributeUpdate(t, p, e, y, {
                  mode: o,
                  duration: l,
                  easing: h,
                  to: n,
                  delay: c
                });
                y.on('afterAttributeUpdate', s);
              });
          }
        } else if ('update' === b) {
          const e = u.get(y);
          u.delete(y), d.set(y, e);
          const o = e.text;
          o.animate().to(t.attribute, l, h),
            e.labelLine &&
              e.labelLine.animate().to(
                D({}, e.labelLine.attribute, {
                  visible:
                    null ===
                      (f =
                        null !==
                          (r =
                            (null === (n = null === (i = t.attribute) || void 0 === i ? void 0 : i.line) || void 0 === n
                              ? void 0
                              : n.visible) && (null === (s = t.attribute) || void 0 === s ? void 0 : s.visible)) &&
                        void 0 !== r
                          ? r
                          : null === (g = t.attribute) || void 0 === g
                          ? void 0
                          : g.visible) ||
                    void 0 === f ||
                    f,
                  points: null === (v = t.attribute) || void 0 === v ? void 0 : v.points
                }),
                l,
                h
              ),
            !1 !== a.increaseEffect &&
              o.attribute.text !== t.attribute.text &&
              _(Number(o.attribute.text) * Number(t.attribute.text)) &&
              o.animate().play(new UM({ text: o.attribute.text }, { text: t.attribute.text }, l, h));
        }
      }),
        u.forEach(t => {
          var e;
          null === (e = t.text) ||
            void 0 === e ||
            e
              .animate()
              .to(l$(t.text.attribute, 'fadeOut').to, l, h)
              .onEnd(() => {
                this.removeChild(t.text), (null == t ? void 0 : t.labelLine) && this.removeChild(t.labelLine);
              });
        }),
        (this._graphicToText = d);
    }
    _renderWithOutAnimation(t) {
      const e = new Map(),
        i = this._graphicToText || new Map();
      t.forEach(t => {
        var n;
        const s = this._labelLine(t),
          r = this._idToGraphic.get(t.attribute.id),
          a = (null == i ? void 0 : i.get(r)) ? 'update' : 'enter';
        if ('enter' === a) e.set(r, s ? { text: t, labelLine: s } : { text: t }), this.add(t), s && this.add(s);
        else if ('update' === a) {
          const s = i.get(r);
          i.delete(r),
            e.set(r, s),
            s.text.setAttributes(t.attribute),
            (null == s ? void 0 : s.labelLine) &&
              s.labelLine.setAttributes({ points: null === (n = t.attribute) || void 0 === n ? void 0 : n.points });
        }
      }),
        i.forEach(t => {
          this.removeChild(t.text), (null == t ? void 0 : t.labelLine) && this.removeChild(t.labelLine);
        }),
        (this._graphicToText = e);
    }
    _afterRelatedGraphicAttributeUpdate(t, e, i, n, s) {
      let { mode: r, duration: a, easing: o, to: l, delay: h } = s;
      const c = s => {
        var d;
        const { detail: u } = s;
        if (!u) return {};
        if (
          !u ||
          u.type !== Pw.ANIMATE_UPDATE ||
          !u.animationState ||
          'wait' === (null === (d = u.animationState.step) || void 0 === d ? void 0 : d.type)
        )
          return {};
        if (u.type === Pw.ANIMATE_END) return void t.setAttributes(l);
        const p = () => {
          n && ((n.onAnimateBind = void 0), n.removeEventListener('afterAttributeUpdate', c));
        };
        switch (r) {
          case 'after':
            u.animationState.end && t.animate({ onEnd: p }).wait(h).to(l, a, o);
            break;
          case 'after-all':
            i === e.length - 1 &&
              u.animationState.end &&
              e.forEach(t => {
                t.animate({ onEnd: p }).wait(h).to(l, a, o);
              });
            break;
          default:
            u.animationState.isFirstFrameOfStep && t.animate({ onEnd: p }).wait(h).to(l, a, o);
        }
      };
      return c;
    }
    _smartInvert(t) {
      var e, i, n, s;
      const r = this.attribute.smartInvert || {},
        { textType: a, contrastRatiosThreshold: o, alternativeColors: l } = r,
        h = null !== (e = r.fillStrategy) && void 0 !== e ? e : 'invertBase',
        c = null !== (i = r.strokeStrategy) && void 0 !== i ? i : 'base',
        d = null !== (n = r.brightColor) && void 0 !== n ? n : '#ffffff',
        u = null !== (s = r.darkColor) && void 0 !== s ? s : '#000000';
      if ('null' !== h || 'null' !== c)
        for (let e = 0; e < t.length; e++) {
          const i = t[e];
          if (!i) continue;
          const n = this._idToGraphic.get(i.attribute.id),
            s = this._canPlaceInside(i.AABBBounds, null == n ? void 0 : n.AABBBounds),
            r = n.attribute.fill,
            p = r,
            g = mY(i.attribute.fill, r, a, o, l),
            f = yY(g, d) ? d : u;
          if (s) {
            const t = SY(h, p, g, f);
            if ((t && i.setAttributes({ fill: t }), 0 === i.attribute.lineWidth)) continue;
            const e = SY(c, p, g, f);
            e && i.setAttributes({ stroke: e });
          } else {
            if (0 === i.attribute.lineWidth) continue;
            if (i.attribute.stroke) {
              i.setAttributes({ fill: mY(i.attribute.fill, i.attribute.stroke, a, o, l) });
              continue;
            }
            const t = SY(h, p, g, f);
            t && i.setAttributes({ fill: t });
            const e = SY(c, p, g, f);
            e && i.setAttributes({ stroke: e });
          }
        }
    }
    _canPlaceInside(t, e) {
      return !(!t || !e) && e.encloses(t);
    }
    setLocation(t) {
      this.translateTo(t.x, t.y);
    }
    disableAnimation() {
      this._enableAnimation = !1;
    }
    enableAnimation() {
      this._enableAnimation = !0;
    }
  }
  u$.defaultAttributes = {
    textStyle: { fontSize: 12, textAlign: 'center', textBaseline: 'middle', boundsPadding: [-1, 0, -1, 0] },
    offset: 0,
    pickable: !1
  };
  class p$ extends u$ {
    constructor(t) {
      super(D({}, p$.defaultAttributes, t)), (this.name = 'symbol-label');
    }
    labeling(t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'top',
        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
      if (!t) return;
      const { x1: s, y1: r, x2: a, y2: o } = t,
        l = Math.abs(a - s),
        h = Math.abs(o - r),
        c = (e.x1 + e.x2) / 2,
        d = (e.y1 + e.y2) / 2;
      let u = 0,
        p = 0,
        g = 0,
        f = 0;
      e && ((g = Math.abs(e.x1 - e.x2) / 2), (f = Math.abs(e.y1 - e.y2) / 2));
      const v = { 'top-right': -235, 'top-left': 235, 'bottom-right': 45, 'bottom-left': -45 };
      switch (i) {
        case 'top':
          p = -1;
          break;
        case 'bottom':
          p = 1;
          break;
        case 'left':
          u = -1;
          break;
        case 'right':
          u = 1;
          break;
        case 'bottom-left':
        case 'bottom-right':
        case 'top-left':
        case 'top-right':
          (u = Math.sin(v[i] * (Math.PI / 180))), (p = Math.cos(v[i] * (Math.PI / 180)));
          break;
        case 'center':
          (u = 0), (p = 0);
      }
      return { x: c + u * (n + g) + Math.sign(u) * (l / 2), y: d + p * (n + f) + Math.sign(p) * (h / 2) };
    }
  }
  p$.defaultAttributes = {
    textStyle: {
      fontSize: 12,
      fill: '#000',
      textAlign: 'center',
      textBaseline: 'middle',
      boundsPadding: [-1, 0, -1, 0]
    },
    position: 'top',
    offset: 5,
    pickable: !1
  };
  class g$ extends u$ {
    constructor(t) {
      super(D({}, g$.defaultAttributes, t));
    }
    labeling(t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'top',
        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
      if (!t || !e) return;
      const { x1: s, y1: r, x2: a, y2: o } = t,
        l = Math.abs(a - s),
        h = Math.abs(o - r),
        c = Math.abs(e.x2 - e.x1),
        d = Math.abs(e.y2 - e.y1);
      let u = (e.x1 + e.x2) / 2,
        p = (e.y1 + e.y2) / 2,
        g = 0,
        f = 0;
      switch (i) {
        case 'top':
        case 'inside-top':
          f = -0.5;
          break;
        case 'bottom':
        case 'inside-bottom':
          f = 0.5;
          break;
        case 'left':
        case 'inside-left':
          g = -0.5;
          break;
        case 'right':
        case 'inside-right':
          g = 0.5;
      }
      (u += g * c), (p += f * d);
      let v = 0,
        m = 0;
      const y = i.includes('inside');
      return (
        i.includes('top')
          ? (m = y ? 1 : -1)
          : i.includes('bottom')
          ? (m = y ? -1 : 1)
          : i.includes('left')
          ? (v = y ? 1 : -1)
          : i.includes('right') && (v = y ? -1 : 1),
        { x: u + v * n + (v * l) / 2, y: p + m * n + (m * h) / 2 }
      );
    }
  }
  function f$(t, e, i, n) {
    const s = (function (t) {
      return t.radius ? { x: Math.cos(t.angle) * t.radius, y: Math.sin(t.angle) * t.radius } : { x: 0, y: 0 };
    })({ radius: i, angle: n });
    return { x: t + s.x, y: e + s.y };
  }
  function v$(t) {
    return (t = (function (t) {
      for (; t < 0; ) t += 2 * Math.PI;
      for (; t >= 2 * Math.PI; ) t -= 2 * Math.PI;
      return t;
    })(t)) > 0 && t <= Math.PI / 2
      ? 2
      : t > Math.PI / 2 && t <= Math.PI
      ? 3
      : t > Math.PI && t <= (3 * Math.PI) / 2
      ? 4
      : 1;
  }
  function m$(t) {
    return 3 === t || 4 === t;
  }
  function y$(t, e) {
    const { x1: i, y1: n, x2: s, y2: r } = t,
      { x1: a, y1: o, x2: l, y2: h } = e;
    return !((i <= a && s <= a) || (i >= l && s >= l) || (n <= o && r <= o) || (n >= h && r >= h));
  }
  (g$.tag = 'rect-label'),
    (g$.defaultAttributes = {
      textStyle: {
        fontSize: 12,
        fill: '#000',
        textAlign: 'center',
        textBaseline: 'middle',
        boundsPadding: [-1, 0, -1, 0]
      },
      position: 'top',
      offset: 5,
      pickable: !1
    });
  class _$ {
    constructor(t, e, i, n, s, r, a, o, l) {
      (this.refDatum = t),
        (this.center = e),
        (this.outerCenter = i),
        (this.quadrant = n),
        (this.radian = s),
        (this.middleAngle = r),
        (this.innerRadius = a),
        (this.outerRadius = o),
        (this.circleCenter = l),
        (this.labelVisible = !0),
        (this.labelLimit = 0);
    }
    getLabelBounds() {
      return this.labelPosition && this.labelSize
        ? {
            x1: this.labelPosition.x - this.labelSize.width / 2,
            y1: this.labelPosition.y - this.labelSize.height / 2,
            x2: this.labelPosition.x + this.labelSize.width / 2,
            y2: this.labelPosition.y + this.labelSize.height / 2
          }
        : { x1: 0, x2: 0, y1: 0, y2: 0 };
    }
  }
  class b$ extends u$ {
    constructor(t) {
      super(D({}, b$.defaultAttributes, t)),
        (this.name = 'arc-label'),
        (this._ellipsisWidth = 0),
        (this._arcLeft = new Map()),
        (this._arcRight = new Map());
    }
    _overlapping(t) {
      return t;
    }
    labeling(t, e) {
      if (t && e) return { x: 0, y: 0 };
    }
    _layout() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      const e = super._layout(t),
        i = e.map(t => this.getGraphicBounds(t)),
        n = Object.assign(Object.assign({}, this.attribute.textStyle), { text: '...' }),
        s = this._createLabelText(n),
        r = this.getGraphicBounds(s),
        a = r.x2 - r.x1,
        o = this.layoutArcLabels(
          this.attribute.position,
          this.attribute,
          Array.from(this._idToGraphic.values()),
          t,
          i,
          a
        );
      for (let i = 0; i < t.length; i++) {
        const n = t[i],
          s = o.find(t => t.refDatum.id === n.id),
          r = {
            visible: s.labelVisible,
            x: s.labelPosition.x,
            y: s.labelPosition.y,
            angle: s.angle,
            maxLineWidth: s.labelLimit,
            points:
              (null == s ? void 0 : s.pointA) && (null == s ? void 0 : s.pointB) && (null == s ? void 0 : s.pointC)
                ? [s.pointA, s.pointB, s.pointC]
                : void 0,
            line: null == s ? void 0 : s.labelLine
          };
        e[i].setAttributes(r);
      }
      return e;
    }
    layoutArcLabels(t, e, i, n, s, r) {
      this._arcLeft.clear(), this._arcRight.clear(), (this._ellipsisWidth = r);
      let a = 0;
      i.forEach(t => {
        t.attribute.outerRadius > a && (a = t.attribute.outerRadius);
      }),
        i.forEach((t, i) => {
          var r, o;
          const l = t.attribute,
            h = {
              x: null !== (r = null == l ? void 0 : l.x) && void 0 !== r ? r : 0,
              y: null !== (o = null == l ? void 0 : l.y) && void 0 !== o ? o : 0
            },
            c = n[i],
            d = s[i],
            u = (l.startAngle + l.endAngle) / 2,
            p = l.endAngle - l.startAngle,
            g = v$(l.endAngle - p / 2),
            f = f$(h.x, h.y, l.outerRadius, u),
            v = f$(h.x, h.y, a + e.line.line1MinLength, u),
            m = new _$(c, f, v, g, p, u, l.innerRadius, l.outerRadius, h);
          var y;
          (m.pointA = f$(h.x, h.y, this.computeDatumRadius(2 * h.x, 2 * h.y, l.outerRadius), m.middleAngle)),
            (m.labelSize = { width: d.x2 - d.x1, height: d.y2 - d.y1 }),
            1 === (y = m.quadrant) || 2 === y
              ? this._arcRight.set(m.refDatum, m)
              : m$(m.quadrant) && this._arcLeft.set(m.refDatum, m);
        });
      const o = Array.from(this._arcLeft.values()),
        l = Array.from(this._arcRight.values()),
        h = [];
      return (
        'inside' === t
          ? (h.push(...this._layoutInsideLabels(l, e, i)), h.push(...this._layoutInsideLabels(o, e, i)))
          : (h.push(...this._layoutOutsideLabels(l, e, i)), h.push(...this._layoutOutsideLabels(o, e, i))),
        h
      );
    }
    _layoutInsideLabels(t, e, i) {
      const n = e,
        s = n.spaceWidth;
      return (
        t.forEach(t => {
          var i, r;
          const { labelSize: a, radian: o } = t,
            l = t.innerRadius,
            h = t.outerRadius;
          let c;
          if (
            o <
            (function (t, e) {
              return e > 2 * t ? NaN : 2 * Math.asin(e / 2 / t);
            })(h, a.height)
          )
            c = 0;
          else {
            let t;
            (t = o >= Math.PI ? l : Math.max(l, a.height / 2 / Math.tan(o / 2))), (c = h - t - s);
          }
          !0 !== (null == n ? void 0 : n.rotate) && (c = h - s);
          const d = this._getFormatLabelText(t.refDatum, c);
          t.labelText = d;
          const u = Math.min(c, t.labelSize.width),
            p = this._computeAlign(t, e),
            g = h - s - ('left' === p ? u : 'right' === p ? 0 : u / 2);
          (t.labelPosition = f$(t.circleCenter.x, t.circleCenter.y, g, t.middleAngle)),
            (t.labelLimit = u),
            lt(u, 0) || (t.labelVisible = !1),
            (t.angle =
              null !== (r = null === (i = null == e ? void 0 : e.textStyle) || void 0 === i ? void 0 : i.angle) &&
              void 0 !== r
                ? r
                : t.middleAngle);
        }),
        t
      );
    }
    _layoutOutsideLabels(t, e, i) {
      var n, s, r, a, o;
      const l = null !== (s = null === (n = i[0].attribute) || void 0 === n ? void 0 : n.x) && void 0 !== s ? s : 0,
        h = 2 * (null !== (a = null === (r = i[0].attribute) || void 0 === r ? void 0 : r.y) && void 0 !== a ? a : 0),
        c = e.line.line2MinLength,
        d = e.layout,
        u = e.spaceWidth;
      if (
        (t.forEach(t => {
          const e = m$(t.quadrant) ? -1 : 1;
          t.labelPosition = { x: t.outerCenter.x + e * (t.labelSize.width / 2 + c + u), y: t.outerCenter.y };
        }),
        t.sort((t, e) => t.labelPosition.y - e.labelPosition.y),
        !1 !== e.coverEnable || 'none' === d.strategy)
      ) {
        for (const n of t) {
          const { labelPosition: t, labelSize: s } = n;
          (n.labelLimit = s.width),
            (n.pointB = m$(n.quadrant)
              ? { x: t.x + s.width / 2 + c + u, y: t.y }
              : { x: t.x - s.width / 2 - c - u, y: t.y }),
            this._computeX(n, e, i);
        }
        !1 === e.coverEnable && 'none' === d.strategy && this._coverLabels(t);
      } else {
        const n = h / ((null === (o = e.textStyle) || void 0 === o ? void 0 : o.fontSize) || 16);
        this._adjustY(t, n, e, i);
        const { minY: s, maxY: r } = t.reduce(
            (t, e) => {
              const { y1: i, y2: n } = e.getLabelBounds();
              return (t.minY = Math.max(0, Math.min(i, t.minY))), (t.maxY = Math.min(h, Math.max(n, t.maxY))), t;
            },
            { minY: 1 / 0, maxY: -1 / 0 }
          ),
          a = Math.max(Math.abs(h / 2 - s), Math.abs(r - h / 2)),
          l = this._computeLayoutRadius(a, e, i);
        for (const n of t) this._computePointB(n, l, e, i), this._computeX(n, e, i);
      }
      const p = 2 * l;
      return (
        t.forEach(t => {
          var i, n;
          t.labelVisible && (ht(t.pointB.x, c + u) || lt(t.pointB.x, p - c - u)) && (t.labelVisible = !1),
            (t.angle =
              null !== (n = null === (i = null == e ? void 0 : e.textStyle) || void 0 === i ? void 0 : i.angle) &&
              void 0 !== n
                ? n
                : 0),
            (t.labelLine = Object.assign({}, null == e ? void 0 : e.line));
        }),
        t
      );
    }
    _computeX(t, e, i) {
      var n;
      const s = t.circleCenter,
        r = 2 * s.x;
      s.y;
      let a = 0;
      i.forEach(t => {
        t.attribute.outerRadius > a && (a = t.attribute.outerRadius);
      });
      const o = this.computeLayoutOuterRadius(a, e.width, e.height),
        l = e.line.line1MinLength,
        h = e.line.line2MinLength,
        c = null === (n = e.layout) || void 0 === n ? void 0 : n.align,
        d = e.spaceWidth,
        { labelPosition: u, quadrant: p, pointB: g } = t;
      _(g.x * g.y) || ((t.pointC = { x: NaN, y: NaN }), (u.x = NaN), (t.labelLimit = 0));
      const f = this.computeRadius(o, e.width, e.height),
        v = m$(p) ? -1 : 1;
      let m = 0,
        y = (v > 0 ? r - g.x : g.x) - h - d;
      'labelLine' === c && ((m = (f + l + h) * v + s.x), (y = (v > 0 ? r - m : m) - d));
      const b = this._getFormatLabelText(t.refDatum, y);
      t.labelText = b;
      let x = Math.min(y, t.labelSize.width);
      switch (c) {
        case 'labelLine':
          break;
        case 'edge':
          m = v > 0 ? r - x - d : x + d;
          break;
        default:
          m = g.x + v * h;
      }
      (x = Math.max(this._ellipsisWidth, x)), (t.labelLimit = x), (t.pointC = { x: m, y: u.y });
      const S = 0.5 * (t.labelLimit < t.labelSize.width ? t.labelLimit : t.labelSize.width);
      if ('edge' === c) {
        const t = 0;
        u.x = (v > 0 ? r + t : t) - v * S;
      } else {
        const t = 0;
        u.x = m + t + v * (d + S);
      }
    }
    _computeAlignOffset(t, e, i) {
      switch (t) {
        case 'left':
          return i < 0 ? -e : 0;
        case 'right':
          return i < 0 ? 0 : e;
        default:
          return (e / 2) * i;
      }
    }
    _computeAlign(t, e) {
      var i, n, s, r, a, o;
      const h = e,
        c =
          null !== (n = null === (i = h.textStyle) || void 0 === i ? void 0 : i.textAlign) && void 0 !== n
            ? n
            : null === (s = h.textStyle) || void 0 === s
            ? void 0
            : s.align,
        d =
          null !== (a = null === (r = h.layout) || void 0 === r ? void 0 : r.textAlign) && void 0 !== a
            ? a
            : null === (o = h.layout) || void 0 === o
            ? void 0
            : o.align;
      return 'inside' !== h.position
        ? l(c) || 'auto' === c
          ? 'edge' === d
            ? m$(t.quadrant)
              ? 'left'
              : 'right'
            : m$(t.quadrant)
            ? 'right'
            : 'left'
          : c
        : l(c) || 'auto' === c
        ? 'center'
        : c;
    }
    _getFormatLabelText(t, e) {
      return t.text;
    }
    _adjustY(t, e, i, n) {
      var s, r, a;
      null === (s = n[0].attribute) || void 0 === s || s.x;
      const o =
          2 * (null !== (a = null === (r = n[0].attribute) || void 0 === r ? void 0 : r.y) && void 0 !== a ? a : 0),
        l = i.layout;
      if ('vertical' === l.strategy) {
        let e,
          i = 0;
        const n = t.length;
        if (n <= 0) return;
        for (let s = 0; s < n; s++) {
          const { y1: r } = t[s].getLabelBounds();
          if (((e = r - i), ht(e, 0))) {
            const i = this._shiftY(t, s, n - 1, -e);
            this._shiftY(t, i, 0, e / 2);
          }
          const { y2: a } = t[s].getLabelBounds();
          i = a;
        }
        const { y1: s } = t[0].getLabelBounds();
        (e = s - 0), ht(e, 0) && this._shiftY(t, 0, n - 1, -e);
        for (let e = t.length - 1; e >= 0 && t[e].getLabelBounds().y2 > o; e--) t[e].labelVisible = !1;
      } else if ('none' !== l.strategy) {
        const s = t.map((t, e) => ({ arc: t, originIndex: e, priorityIndex: 0 }));
        s.sort((t, e) => e.arc.radian - t.arc.radian),
          s.forEach((t, e) => {
            (t.priorityIndex = e), (t.arc.labelVisible = !1);
          });
        let r = 1 / 0,
          a = -1 / 0;
        for (let h = 0; h < e && h < t.length; h++) {
          this._storeY(t);
          const e = s[h].arc;
          this._computeYRange(e, i, n), (e.labelVisible = !0);
          const c = e.labelPosition.y,
            { lastIndex: d, nextIndex: u } = this._findNeighborIndex(t, s[h]),
            p = t[d],
            g = t[u];
          if (-1 === d && -1 !== u) {
            const i = g.labelPosition.y;
            c > i
              ? (e.labelPosition.y = i - g.labelSize.height / 2 - e.labelSize.height / 2)
              : this._twoWayShift(t, e, g, u);
          } else if (-1 !== d && -1 === u) {
            const i = p.labelPosition.y;
            c < i
              ? (e.labelPosition.y = i + p.labelSize.height / 2 + e.labelSize.height / 2)
              : this._twoWayShift(t, p, e, s[h].originIndex);
          } else if (-1 !== d && -1 !== u) {
            const i = p.labelPosition.y,
              n = g.labelPosition.y;
            c > n
              ? ((e.labelPosition.y = n - g.labelSize.height / 2 - e.labelSize.height / 2),
                this._twoWayShift(t, p, e, s[h].originIndex))
              : c < i
              ? ((e.labelPosition.y = i + p.labelSize.height / 2 + e.labelSize.height / 2),
                this._twoWayShift(t, e, g, u))
              : (this._twoWayShift(t, p, e, s[h].originIndex), this._twoWayShift(t, e, g, u));
          }
          const f = Math.min(r, s[h].originIndex),
            v = Math.max(a, s[h].originIndex);
          let m;
          if (
            ((m = t[v].getLabelBounds().y2 - o),
            lt(m, 0) && this._shiftY(t, v, 0, -m),
            (m = t[f].getLabelBounds().y1 - 0),
            ht(m, 0) && this._shiftY(t, f, t.length - 1, -m),
            (m = t[v].getLabelBounds().y2 - o),
            lt(m, 0))
          ) {
            (e.labelVisible = !1), this._restoreY(t);
            break;
          }
          l.tangentConstraint && !this._checkYRange(t)
            ? ((e.labelVisible = !1), this._restoreY(t))
            : ((r = f), (a = v));
        }
      }
    }
    _shiftY(t, e, i, n) {
      const s = e < i ? 1 : -1;
      let r = e;
      for (; -1 !== r; ) {
        t[r].labelPosition.y += n;
        const e = this._findNextVisibleIndex(t, r, i, s);
        if (e >= 0 && e < t.length) {
          const { y1: i, y2: n } = t[r].getLabelBounds(),
            { y1: a, y2: o } = t[e].getLabelBounds();
          if ((s > 0 && n < a) || (s < 0 && i > o)) return r;
        }
        r = e;
      }
      return i;
    }
    _findNextVisibleIndex(t, e, i, n) {
      const s = (i - e) * n;
      for (let i = 1; i <= s; i++) {
        const s = e + i * n;
        if (t[s].labelVisible) return s;
      }
      return -1;
    }
    _computePointB(t, e, i, n) {
      const s = i;
      let r = 0;
      n.forEach(t => {
        t.attribute.outerRadius > r && (r = t.attribute.outerRadius);
      });
      const a = this.computeLayoutOuterRadius(r, i.width, i.height),
        o = s.line.line1MinLength;
      if ('none' === s.layout.strategy) t.pointB = { x: t.outerCenter.x, y: t.outerCenter.y };
      else {
        const n = t.circleCenter,
          s = this.computeRadius(a, i.width, i.height),
          { labelPosition: r, quadrant: l } = t,
          h = e - Math.max(s + o, t.outerRadius),
          c = Math.sqrt(e ** 2 - Math.abs(n.y - r.y) ** 2) - h;
        _(c) ? (t.pointB = { x: n.x + c * (m$(l) ? -1 : 1), y: r.y }) : (t.pointB = { x: NaN, y: NaN });
      }
    }
    _storeY(t) {
      for (const e of t) e.labelVisible && (e.lastLabelY = e.labelPosition.y);
    }
    _computeYRange(t, e, i) {
      const n = t.circleCenter,
        s = { width: 2 * n.x, height: 2 * n.y };
      let r = 0;
      i.forEach(t => {
        t.attribute.outerRadius > r && (r = t.attribute.outerRadius);
      });
      const a = this.computeLayoutOuterRadius(r, e.width, e.height),
        o = e.line.line1MinLength,
        { width: l, height: h } = s,
        c = this.computeRadius(a, e.width, e.height),
        d = this._computeLayoutRadius(h / 2, e, i),
        u = Math.abs(t.center.x - l / 2),
        p = t.center.y - h / 2;
      let g, f, v;
      if (ot(l / 2, u)) (g = 0), (f = 1), (v = -p);
      else if (ot(h / 2, p)) (g = 1), (f = 0), (v = -u);
      else {
        const t = -1 / (p / u);
        (g = t), (f = -1), (v = p - t * u);
      }
      const m = (function (t, e, i, n, s, r) {
        if ((0 === t && 0 === e) || r <= 0) return [];
        if (0 === t) {
          const t = -i / e,
            a = r ** 2 - (t - s) ** 2;
          return a < 0
            ? []
            : 0 === a
            ? [{ x: n, y: t }]
            : [
                { x: Math.sqrt(a) + n, y: t },
                { x: -Math.sqrt(a) + n, y: t }
              ];
        }
        if (0 === e) {
          const e = -i / t,
            a = r ** 2 - (e - n) ** 2;
          return a < 0
            ? []
            : 0 === a
            ? [{ x: e, y: s }]
            : [
                { x: e, y: Math.sqrt(a) + s },
                { x: e, y: -Math.sqrt(a) + s }
              ];
        }
        const a = (e / t) ** 2 + 1,
          o = 2 * ((i / t + n) * (e / t) - s),
          l = o ** 2 - 4 * a * ((i / t + n) ** 2 + s ** 2 - r ** 2);
        if (l < 0) return [];
        const h = (-o + Math.sqrt(l)) / (2 * a),
          c = (-o - Math.sqrt(l)) / (2 * a),
          d = -(e * h + i) / t;
        return 0 === l
          ? [{ x: d, y: h }]
          : [
              { x: d, y: h },
              { x: -(e * c + i) / t, y: c }
            ];
      })(g, f, v, o + c - d, 0, d);
      if (m.length < 2) return;
      let y, _;
      m[0].x > m[1].x && m.reverse(),
        m[0].x < 0
          ? ot(m[0].y, m[1].y)
            ? Math.abs(t.middleAngle) < Math.PI / 2
              ? ((y = 0), (_ = m[1].y + h / 2))
              : ((y = m[1].y + h / 2), (_ = h))
            : m[0].y < m[1].y
            ? ((y = 0), (_ = m[1].y + h / 2))
            : ((y = m[1].y + h / 2), (_ = s.height))
          : ((y = Math.min(m[0].y, m[1].y) + h / 2), (_ = Math.max(m[0].y, m[1].y) + h / 2)),
        (t.labelYRange = [y, _]);
    }
    _computeLayoutRadius(t, e, i) {
      const n = e,
        s = n.layoutArcGap,
        r = n.line.line1MinLength;
      let a = 0;
      i.forEach(t => {
        t.attribute.outerRadius > a && (a = t.attribute.outerRadius);
      });
      const o = this.computeLayoutOuterRadius(a, e.width, e.height),
        l = this.computeRadius(o, e.width, e.height) + r,
        h = l - s;
      return Math.max((h ** 2 + t ** 2) / (2 * h), l);
    }
    _findNeighborIndex(t, e) {
      const i = e.originIndex;
      let n = -1,
        s = -1;
      for (let e = i - 1; e >= 0; e--)
        if (t[e].labelVisible) {
          n = e;
          break;
        }
      for (let e = i + 1; e < t.length; e++)
        if (t[e].labelVisible) {
          s = e;
          break;
        }
      return { lastIndex: n, nextIndex: s };
    }
    _twoWayShift(t, e, i, n) {
      const s = i.getLabelBounds().y1 - e.getLabelBounds().y2;
      if (ht(s, 0)) {
        const e = this._shiftY(t, n, t.length - 1, -s);
        this._shiftY(t, e, 0, s / 2);
      }
    }
    _restoreY(t) {
      for (const e of t) e.labelVisible && (e.labelPosition.y = e.lastLabelY);
    }
    _checkYRange(t) {
      for (const e of t) {
        const { labelYRange: t, labelPosition: i } = e;
        if (e.labelVisible && t && (ht(i.y, t[0]) || lt(i.y, t[1]))) return !1;
      }
      return !0;
    }
    _coverLabels(t) {
      if (t.length <= 1) return;
      let e = t[0].getLabelBounds();
      for (let i = 1; i < t.length; i++) {
        const n = t[i].getLabelBounds();
        y$(e, n) ? (t[i].labelVisible = !1) : (e = n);
      }
    }
    _labelLine(t) {
      var e, i, n, s, r, a, o, l, h, c, d, u, p, g, f, v, m, y, _;
      return (null === (e = t.attribute) || void 0 === e ? void 0 : e.points)
        ? tB({
            visible:
              null ===
                (o =
                  null !==
                    (r =
                      (null === (n = null === (i = t.attribute) || void 0 === i ? void 0 : i.line) || void 0 === n
                        ? void 0
                        : n.visible) && (null === (s = t.attribute) || void 0 === s ? void 0 : s.visible)) &&
                  void 0 !== r
                    ? r
                    : null === (a = t.attribute) || void 0 === a
                    ? void 0
                    : a.visible) ||
              void 0 === o ||
              o,
            stroke:
              null !==
                (d =
                  null ===
                    (c =
                      null === (h = null === (l = t.attribute) || void 0 === l ? void 0 : l.line) || void 0 === h
                        ? void 0
                        : h.style) || void 0 === c
                    ? void 0
                    : c.stroke) && void 0 !== d
                ? d
                : null === (u = t.attribute) || void 0 === u
                ? void 0
                : u.fill,
            lineWidth:
              null !==
                (v =
                  null ===
                    (f =
                      null === (g = null === (p = t.attribute) || void 0 === p ? void 0 : p.line) || void 0 === g
                        ? void 0
                        : g.style) || void 0 === f
                    ? void 0
                    : f.lineWidth) && void 0 !== v
                ? v
                : 1,
            points: null === (m = t.attribute) || void 0 === m ? void 0 : m.points,
            curveType: (
              null === (_ = null === (y = t.attribute) || void 0 === y ? void 0 : y.line) || void 0 === _
                ? void 0
                : _.smooth
            )
              ? 'basis'
              : null
          })
        : void 0;
    }
    computeRadius(t, e, i, n) {
      return this.computeLayoutRadius(e || 0, i || 0) * t * (l(n) ? 1 : n);
    }
    computeLayoutRadius(t, e) {
      return Math.min(t / 2, e / 2);
    }
    _canPlaceInside(t, e) {
      return 'inside' === this.attribute.position;
    }
    computeLayoutOuterRadius(t, e, i) {
      return t / (Math.min(e, i) / 2);
    }
    computeDatumRadius(t, e, i) {
      const n = this.computeLayoutOuterRadius(i, t, e);
      return this.computeLayoutRadius(t || 0, e || 0) * n;
    }
  }
  b$.defaultAttributes = {
    coverEnable: !1,
    spaceWidth: 5,
    layoutArcGap: 6,
    textStyle: {
      visible: !0,
      fontSize: 14,
      fontWeight: 'normal',
      fillOpacity: 1,
      textAlign: 'center',
      textBaseline: 'middle'
    },
    position: 'outside',
    offset: 0,
    line: { visible: !0, line1MinLength: 20, line2MinLength: 10 },
    layout: { align: 'arc', strategy: 'priority', tangentConstraint: !0 },
    pickable: !1
  };
  const x$ = { rect: g$, symbol: p$, arc: b$ };
  class S$ extends uY {
    constructor(t) {
      super(D({}, S$.defaultAttributes, t)), (this.name = 'data-label');
    }
    render() {
      const { dataLabels: t, size: e } = this.attribute;
      if (!t || 0 === t.length) return;
      const { width: i = 0, height: n = 0 } = e || {};
      if (!i || !n || !_(n * i)) return;
      this._componentMap || (this._componentMap = new Map());
      const s = QY(i, n),
        r = s.bitmap(),
        a = new Map(),
        o = this._componentMap;
      for (let e = 0; e < t.length; e++) {
        const i = t[e],
          n = x$[i.type] || u$;
        if (n) {
          const { baseMarkGroupName: t } = i;
          let e = this._componentMap.get(t);
          e
            ? (e.setBitmapTool(s), e.setBitmap(r), e.setAttributes(i), a.set(t, e))
            : ((e = new n(i)), e.setBitmap(r), e.setBitmapTool(s), this.add(e), a.set(t, e));
        }
      }
      o.forEach((t, e) => {
        a.get(e) || this.removeChild(t);
      }),
        (this._componentMap = a);
    }
    setLocation(t) {
      this.translateTo(t.x, t.y);
    }
    disableAnimation() {
      this._componentMap.forEach(t => {
        t.disableAnimation();
      });
    }
    enableAnimation() {
      this._componentMap.forEach(t => {
        t.enableAnimation();
      });
    }
  }
  S$.defaultAttributes = { pickable: !1 };
  class w$ extends uY {
    getStartAngle() {
      return this._startAngle;
    }
    getEndAngle() {
      return this._endAngle;
    }
    getMainSegmentPoints() {
      return this._mainSegmentPoints;
    }
    constructor(t) {
      super(D({}, w$.defaultAttributes, t)), (this.name = 'segment');
    }
    render() {
      this.removeAllChild(), this._reset();
      const {
        startSymbol: t,
        endSymbol: e,
        lineStyle: i,
        state: n,
        visible: s = !0,
        multiSegment: r,
        mainSegmentIndex: a
      } = this.attribute;
      if (!s) return;
      this._computeLineAngle();
      const o = this._renderSymbol(t, 'start'),
        l = this._renderSymbol(e, 'end');
      if (((this.startSymbol = o), (this.endSymbol = l), r)) {
        const t = [...this.attribute.points];
        if (_(a)) t[a] = this._clipPoints(t[a]);
        else {
          const e = this._clipPoints($(t));
          (t[0][0] = e[0]), (t[t.length - 1][t[t.length - 1].length - 1] = e[e.length - 1]);
        }
        t.forEach((t, e) => {
          var s, r;
          const a = tB(
            Object.assign(
              Object.assign({ points: t }, f(i) ? (null !== (s = i[e]) && void 0 !== s ? s : i[i.length - 1]) : i),
              { fill: !1 }
            )
          );
          (a.name = `${this.name}-line`),
            (a.id = this._getNodeId('line' + e)),
            T(null == n ? void 0 : n.line) ||
              (a.states = f(n.line)
                ? null !== (r = n.line[e]) && void 0 !== r
                  ? r
                  : n.line[n.line.length - 1]
                : n.line),
            this.add(a);
        });
      } else {
        const t = tB(
          Object.assign(Object.assign({ points: this._clipPoints(this.attribute.points) }, V(i)[0]), { fill: !1 })
        );
        (t.name = `${this.name}-line`),
          (t.id = this._getNodeId('line')),
          T(null == n ? void 0 : n.line) || (t.states = [].concat(n.line)[0]),
          this.add(t);
      }
    }
    _renderSymbol(t, e) {
      const i = this._getMainSegmentPoints();
      if (!i.length) return;
      const { autoRotate: n = !0 } = t;
      let s;
      if (null == t ? void 0 : t.visible) {
        const r = this._startAngle,
          a = this._endAngle,
          { state: o } = this.attribute,
          l = i[0],
          h = i[i.length - 1],
          { refX: c = 0, refY: d = 0, refAngle: u = 0, style: p, symbolType: g, size: f = 12 } = t;
        let v, m;
        'start' === e
          ? ((v = {
              x: l.x + (_(r) ? c * Math.cos(r) + d * Math.cos(r - Math.PI / 2) : 0),
              y: l.y + (_(r) ? c * Math.sin(r) + d * Math.sin(r - Math.PI / 2) : 0)
            }),
            (m = r + Math.PI / 2))
          : ((v = {
              x: h.x + (_(a) ? c * Math.cos(a) + d * Math.cos(a - Math.PI / 2) : 0),
              y: h.y + (_(a) ? c * Math.sin(a) + d * Math.sin(a - Math.PI / 2) : 0)
            }),
            (m = a + Math.PI / 2)),
          (s = rB(
            Object.assign(
              Object.assign(Object.assign({}, v), {
                symbolType: g,
                size: f,
                angle: n ? m + u : 0,
                strokeBoundsBuffer: 0
              }),
              p
            )
          )),
          (s.name = `${this.name}-${e}-symbol`),
          (s.id = this._getNodeId(`${e}-symbol`)),
          T(null == o ? void 0 : o.symbol) || (s.states = o.symbol),
          this.add(s);
      }
      return s;
    }
    _getMainSegmentPoints() {
      if (this._mainSegmentPoints) return this._mainSegmentPoints;
      const { points: t, multiSegment: e, mainSegmentIndex: i } = this.attribute;
      let n;
      return (n = e ? (_(i) ? t[i] : $(t)) : t), (this._mainSegmentPoints = n), n;
    }
    _clipPoints(t) {
      const { startSymbol: e, endSymbol: i } = this.attribute;
      let n = t;
      if (null == e ? void 0 : e.visible) {
        const i = (null == e ? void 0 : e.clip) ? (null == e ? void 0 : e.size) || 10 : 0;
        n = [
          {
            x: t[0].x - (i / 2) * (Math.cos(this._startAngle) || 0),
            y: t[0].y - (i / 2) * (Math.sin(this._startAngle) || 0)
          },
          ...n.slice(1)
        ];
      }
      if (null == i ? void 0 : i.visible) {
        const e = (null == i ? void 0 : i.clip) ? (null == i ? void 0 : i.size) || 10 : 0,
          s = {
            x: t[t.length - 1].x - (e / 2) * (Math.cos(this._endAngle) || 0),
            y: t[t.length - 1].y - (e / 2) * (Math.sin(this._endAngle) || 0)
          };
        n = [...n.slice(0, n.length - 1), s];
      }
      return n;
    }
    _computeLineAngle() {
      const t = this._getMainSegmentPoints();
      if (t.length <= 1) return;
      const e = t[0],
        i = t[1],
        n = t[t.length - 2],
        s = t[t.length - 1],
        r = [e.x - i.x, e.y - i.y],
        a = Math.atan2(r[1], r[0]),
        o = [s.x - n.x, s.y - n.y],
        l = Math.atan2(o[1], o[0]);
      (this._startAngle = a), (this._endAngle = l);
    }
    _reset() {
      (this.startSymbol = null),
        (this.endSymbol = null),
        (this._startAngle = null),
        (this._endAngle = null),
        (this._mainSegmentPoints = null);
    }
  }
  var A$, k$;
  (w$.defaultAttributes = {
    visible: !0,
    lineStyle: { lineWidth: 1, stroke: '#000' },
    startSymbol: {
      visible: !1,
      autoRotate: !0,
      symbolType: 'triangle',
      size: 12,
      refX: 0,
      refY: 0,
      refAngle: 0,
      style: { fill: '#000', zIndex: 1 }
    },
    endSymbol: {
      visible: !1,
      autoRotate: !0,
      symbolType: 'triangle',
      size: 12,
      refX: 0,
      refY: 0,
      refAngle: 0,
      style: { fill: '#000', zIndex: 1 }
    }
  }),
    (function (t) {
      (t.innerView = 'inner-view'),
        (t.axisContainer = 'axis-container'),
        (t.labelContainer = 'axis-label-container'),
        (t.tickContainer = 'axis-tick-container'),
        (t.tick = 'axis-tick'),
        (t.subTick = 'axis-sub-tick'),
        (t.label = 'axis-label'),
        (t.title = 'axis-title'),
        (t.gridContainer = 'axis-grid-container'),
        (t.grid = 'axis-grid'),
        (t.gridRegion = 'axis-grid-region'),
        (t.line = 'axis-line'),
        (t.background = 'axis-background'),
        (t.axisLabelBackground = 'axis-label-background');
    })(A$ || (A$ = {})),
    (function (t) {
      (t.selected = 'selected'),
        (t.selectedReverse = 'selected_reverse'),
        (t.hover = 'hover'),
        (t.hoverReverse = 'hover_reverse');
    })(k$ || (k$ = {}));
  const M$ = { [k$.selectedReverse]: {}, [k$.selected]: {}, [k$.hover]: {}, [k$.hoverReverse]: {} },
    T$ = {
      title: {
        space: 4,
        padding: 0,
        textStyle: { fontSize: 12, fill: '#333333', fontWeight: 'normal', fillOpacity: 1 }
      },
      label: {
        visible: !0,
        inside: !1,
        space: 4,
        padding: 0,
        style: { fontSize: 12, fill: '#333', fontWeight: 'normal', fillOpacity: 1 }
      },
      tick: {
        visible: !0,
        inside: !1,
        alignWithLabel: !0,
        length: 4,
        style: { lineWidth: 1, stroke: '#000', strokeOpacity: 1 }
      },
      subTick: {
        visible: !1,
        inside: !1,
        count: 4,
        length: 2,
        style: { lineWidth: 1, stroke: '#999', strokeOpacity: 1 }
      },
      line: { visible: !0, style: { lineWidth: 1, stroke: '#000', strokeOpacity: 1 } }
    };
  var C$ = function (t, e) {
    var i = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
    if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
      var s = 0;
      for (n = Object.getOwnPropertySymbols(t); s < n.length; s++)
        e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (i[n[s]] = t[n[s]]);
    }
    return i;
  };
  class E$ extends uY {
    constructor() {
      super(...arguments),
        (this.name = 'axis'),
        (this.data = []),
        (this.tickLineItems = []),
        (this.subTickLineItems = []),
        (this.axisLabelLayerSize = {}),
        (this.axisLabelsContainer = null),
        (this._onHover = t => {
          const e = t.target;
          e !== this._lastHover &&
            e.name &&
            !T(e.states) &&
            (e.addState(CY.hover, !0),
            gY(this.axisContainer, t => {
              t !== e && t.name && !T(t.states) && t.addState(CY.hoverReverse, !0);
            }),
            (this._lastHover = e));
        }),
        (this._onUnHover = t => {
          this._lastHover &&
            (gY(this.axisContainer, t => {
              t.name && !T(t.states) && (t.removeState(CY.hoverReverse), t.removeState(CY.hover));
            }),
            (this._lastHover = null));
        }),
        (this._onClick = t => {
          const e = t.target;
          if (this._lastSelect === e && e.hasState(CY.selected))
            return (
              (this._lastSelect = null),
              void gY(this.axisContainer, t => {
                t.name && !T(t.states) && (t.removeState(CY.selectedReverse), t.removeState(CY.selected));
              })
            );
          e.name &&
            !T(e.states) &&
            (e.addState(CY.selected, !0),
            gY(this.axisContainer, t => {
              t !== e && t.name && !T(t.states) && t.addState(CY.selectedReverse, !0);
            }),
            (this._lastSelect = e));
        });
    }
    getInnerView() {
      return this._innerView;
    }
    getPrevInnerView() {
      return this._prevInnerView;
    }
    getBoundsWithoutRender(t) {
      const e = R(this.attribute);
      D(this.attribute, t);
      const i = QO({ x: this.attribute.x, y: this.attribute.y });
      return this.add(i), this._renderInner(i), this.removeChild(i), (this.attribute = e), i.AABBBounds;
    }
    render() {
      this.removeAllChild(),
        (this._prevInnerView = this._innerView),
        (this._innerView = QO({ x: 0, y: 0, pickable: !1 })),
        this.add(this._innerView),
        this._renderInner(this._innerView),
        this._bindEvent();
    }
    _bindEvent() {
      const { hover: t, select: e } = this.attribute;
      t &&
        (this._innerView.addEventListener('pointermove', this._onHover),
        this._innerView.addEventListener('pointerout', this._onUnHover)),
        e && this._innerView.addEventListener('pointerdown', this._onClick);
    }
    _renderInner(t) {
      const { title: e, label: i, tick: n, line: s, items: r } = this.attribute,
        a = QO({ x: 0, y: 0, zIndex: 1 });
      if (
        ((a.name = A$.axisContainer),
        (a.id = this._getNodeId('container')),
        a.setMode(this.mode),
        (this.axisContainer = a),
        t.add(a),
        (null == s ? void 0 : s.visible) && this.renderLine(a),
        r &&
          r.length &&
          ((this.data = this._transformItems(r[0])),
          (null == n ? void 0 : n.visible) && this.renderTicks(a),
          null == i ? void 0 : i.visible))
      ) {
        const t = QO({ x: 0, y: 0, pickable: !1 });
        (t.name = A$.labelContainer),
          (t.id = this._getNodeId('label-container')),
          (this.axisLabelsContainer = t),
          a.add(t),
          r.forEach((e, i) => {
            const n = this.renderLabels(t, e, i),
              s = n.getChildren();
            this.beforeLabelsOverlap(s, e, n, i, r.length),
              this.handleLabelsOverlap(s, e, n, i, r.length),
              this.afterLabelsOverlap(s, e, n, i, r.length);
          });
      }
      (null == e ? void 0 : e.visible) && this.renderTitle(a);
    }
    renderTicks(t) {
      const e = this.getTickLineItems(),
        i = QO({ x: 0, y: 0, pickable: !1 });
      (i.name = A$.tickContainer),
        (i.id = this._getNodeId('tick-container')),
        t.add(i),
        e.forEach((t, n) => {
          var s;
          const r = tB(Object.assign({}, this._getTickLineAttribute('tick', t, n, e)));
          if (
            ((r.name = A$.tick),
            (r.id = this._getNodeId(t.id)),
            T(null === (s = this.attribute.tick) || void 0 === s ? void 0 : s.state))
          )
            r.states = EY;
          else {
            const t = this.data[n],
              e = D({}, EY, this.attribute.tick.state);
            Object.keys(e).forEach(i => {
              o(e[i]) && (e[i] = e[i](t.rawValue, n, t, this.data));
            }),
              (r.states = e);
          }
          i.add(r);
        }),
        (this.tickLineItems = e);
      const { subTick: n } = this.attribute;
      if (null == n ? void 0 : n.visible) {
        const t = this.getSubTickLineItems();
        t.length &&
          t.forEach((t, s) => {
            const r = tB(Object.assign({}, this._getTickLineAttribute('subTick', t, s, e)));
            if (((r.name = A$.subTick), (r.id = this._getNodeId(`${s}`)), T(n.state))) r.states = EY;
            else {
              const i = D({}, EY, n.state);
              Object.keys(i).forEach(n => {
                o(i[n]) && (i[n] = i[n](t.value, s, t, e));
              }),
                (r.states = i);
            }
            i.add(r);
          }),
          (this.subTickLineItems = t);
      }
    }
    renderLabels(t, e, i) {
      const { dataFilter: n } = this.attribute.label;
      n && o(n) && (e = n(e, i));
      const s = this._transformItems(e),
        r = QO({ x: 0, y: 0, pickable: !1 });
      (r.name = `${A$.labelContainer}-layer-${i}`), (r.id = this._getNodeId(`label-container-layer-${i}`)), t.add(r);
      let a = 0,
        l = 0,
        h = 'center',
        c = 'middle';
      return (
        s.forEach((t, e) => {
          var n, d;
          const u = this._getLabelAttribute(t, e, s, i),
            p = sB(u);
          if (
            ((p.name = A$.label),
            (p.id = this._getNodeId(`layer${i}-label-${t.id}`)),
            T(null === (n = this.attribute.label) || void 0 === n ? void 0 : n.state))
          )
            p.states = EY;
          else {
            const n = D({}, EY, this.attribute.label.state);
            Object.keys(n).forEach(r => {
              o(n[r]) && (n[r] = n[r](t, e, s, i));
            }),
              (p.states = n);
          }
          r.add(p);
          const g = null !== (d = u.angle) && void 0 !== d ? d : 0;
          (a = Math.max(a, p.AABBBounds.width())),
            (l = Math.max(l, p.AABBBounds.height())),
            g && ((a = Math.abs(a * Math.cos(g))), (l = Math.abs(l * Math.sin(g)))),
            (h = u.textAlign),
            (c = u.textBaseline);
        }),
        (this.axisLabelLayerSize[i] = { width: a, height: l, textAlign: h, textBaseline: c }),
        r
      );
    }
    renderTitle(t) {
      const e = this.getTitleAttribute(),
        i = new BY(Object.assign({}, e));
      (i.name = A$.title), (i.id = this._getNodeId('title')), t.add(i);
    }
    getVerticalCoord(t, e, i) {
      const n = this.getVerticalVector(e, i, t);
      return { x: t.x + n[0], y: t.y + n[1] };
    }
    getTextAlign(t) {
      let e = 'center';
      return (
        ot(t[0], 0)
          ? ot(t[1], 0)
            ? Object.is(t[1], -0)
              ? (e = 'start')
              : Object.is(t[0], -0) && (e = 'end')
            : (e = 'center')
          : t[0] > 0
          ? (e = 'start')
          : t[0] < 0 && (e = 'end'),
        e
      );
    }
    getTickLineItems() {
      const { tick: t } = this.attribute,
        e = this.data,
        i = [],
        { alignWithLabel: n, inside: s = !1, length: r, dataFilter: a } = t;
      let l = 1;
      return (
        e.length >= 2 && (l = e[1].value - e[0].value),
        (a && o(a) ? a(e) : e).forEach(t => {
          let e = t.point,
            a = t.value;
          if (!n) {
            const i = t.value - l / 2;
            if (this.isInValidValue(i)) return;
            (e = this.getTickCoord(i)), (a = i);
          }
          const o = this.getVerticalCoord(e, r, s);
          if ('3d' === this.mode) {
            const n = this.getVerticalVector(r, s, e);
            let l = 0,
              h = 0;
            Pt(n[0]) > Pt(n[1]) ? (l = (Mt / 2) * (o.x > e.x ? 1 : -1)) : (h = (Mt / 2) * (o.y > e.y ? -1 : 1)),
              i.push({ start: e, end: o, value: a, id: `tick-${t.id}`, anchor: [e.x, e.y], alpha: l, beta: h });
          } else i.push({ start: e, end: o, value: a, id: `tick-${t.id}` });
        }),
        i
      );
    }
    getSubTickLineItems() {
      const { subTick: t } = this.attribute,
        e = [],
        { count: i = 4, inside: n = !1, length: s = 2 } = t,
        r = this.tickLineItems,
        a = r.length;
      if (a >= 2)
        for (let t = 0; t < a - 1; t++) {
          const a = r[t],
            o = r[t + 1];
          for (let t = 0; t < i; t++) {
            const r = (t + 1) / (i + 1),
              l = (1 - r) * a.value + r * o.value,
              h = this.getTickCoord(l),
              c = this.getVerticalCoord(h, s, n);
            e.push({ start: h, end: c, value: l, id: `sub-tick-${l}` });
          }
        }
      return e;
    }
    _getTickLineAttribute(t, e, i, n) {
      let s = C(this.attribute, `${t}.style`);
      const r = this.data[i];
      s = o(s) ? D({}, C(T$, `${t}.style`), 'tick' === t ? s(r.rawValue, i, r, this.data) : s(e.value, i, e, n)) : s;
      const { start: a, end: l, anchor: h, alpha: c, beta: d } = e;
      return Object.assign({ points: [a, l], anchor: h, alpha: c, beta: d }, s);
    }
    _getLabelAttribute(t, e, i, n) {
      var s, r, a, l, h, c;
      const d = this.attribute.label,
        { space: u = 4, inside: p = !1, formatMethod: g } = d,
        f = C$(d, ['space', 'inside', 'formatMethod']);
      let v = u,
        m = 0;
      (null === (s = this.attribute.tick) || void 0 === s ? void 0 : s.visible) &&
        (null === (r = this.attribute.tick) || void 0 === r ? void 0 : r.inside) === p &&
        (m = (null === (a = this.attribute.tick) || void 0 === a ? void 0 : a.length) || 4),
        (null === (l = this.attribute.subTick) || void 0 === l ? void 0 : l.visible) &&
          (null === (h = this.attribute.subTick) || void 0 === h ? void 0 : h.inside) === p &&
          (m = Math.max(m, (null === (c = this.attribute.subTick) || void 0 === c ? void 0 : c.length) || 2)),
        (v += m);
      const y = this.getRelativeVector(t.point);
      n > 0 &&
        (0 === y[1]
          ? (v += (this.axisLabelLayerSize[n - 1].height + C(this.attribute, 'label.space', 4)) * n)
          : (v += (this.axisLabelLayerSize[n - 1].width + C(this.attribute, 'label.space', 4)) * n));
      const _ = this.getVerticalCoord(t.point, v, p),
        b = this.getVerticalVector(v, p, _),
        x = g ? g(`${t.label}`, t, e, i, n) : t.label;
      let { style: S } = f;
      S = o(S) ? D({}, T$.label.style, S(t, e, i, n)) : S;
      return (
        (S = D(this.getLabelAlign(b, p, S.angle), S)),
        o(S.text) && (S.text = S.text({ label: t.label, value: t.rawValue, index: t.index, layer: n })),
        Object.assign(Object.assign(Object.assign({}, _), { text: x, lineHeight: null == S ? void 0 : S.fontSize }), S)
      );
    }
    _transformItems(t) {
      const e = [];
      return (
        t.forEach(t => {
          var i;
          e.push(
            Object.assign(Object.assign({}, t), {
              point: this.getTickCoord(t.value),
              id: null !== (i = t.id) && void 0 !== i ? i : t.label
            })
          );
        }),
        e
      );
    }
  }
  const P$ = {
    parity: function (t) {
      return t.filter((t, e) => (e % 2 ? t.setAttribute('opacity', 0) : 1));
    },
    greedy: function (t, e) {
      let i;
      return t.filter((t, n) => (n && R$(i.AABBBounds, t.AABBBounds, e) ? t.setAttribute('opacity', 0) : ((i = t), 1)));
    }
  };
  function R$(t, e, i) {
    return i > Math.max(e.x1 - t.x2, t.x1 - e.x2, e.y1 - t.y2, t.y1 - e.y2);
  }
  function O$(t, e) {
    for (let i, n = 1, s = t.length, r = t[0].AABBBounds; n < s; r = i, ++n)
      if (R$(r, (i = t[n].AABBBounds), e)) return !0;
  }
  function B$(t) {
    const e = t.AABBBounds;
    return e.width() > 1 && e.height() > 1;
  }
  function I$(t) {
    for (let n = 1; n < t.length; n++)
      if (
        ((e = t[n - 1]),
        (i = t[n]),
        (function (t, e) {
          let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
            n = arguments.length > 3 ? arguments[3] : void 0;
          const s = De(t, i),
            r = De(e, i),
            a = (t, e) => [e.x - t.x, e.y - t.y];
          n &&
            (n.save(),
            (n.fillStyle = 'red'),
            (n.globalAlpha = 0.6),
            s.forEach((t, e) => {
              0 === e ? n.moveTo(t.x, t.y) : n.lineTo(t.x, t.y);
            }),
            n.fill(),
            n.restore(),
            n.save(),
            (n.fillStyle = 'green'),
            (n.globalAlpha = 0.6),
            r.forEach((t, e) => {
              0 === e ? n.moveTo(t.x, t.y) : n.lineTo(t.x, t.y);
            }),
            n.fill(),
            n.restore());
          const o = Ie(t),
            l = Ie(e);
          n && n.fillRect(o.x, o.y, 2, 2), n && n.fillRect(l.x, l.y, 2, 2);
          const h = a(o, l),
            c = a(s[0], s[1]),
            d = a(s[1], s[2]),
            u = a(r[0], r[1]),
            p = a(r[1], r[2]),
            g = i ? t.angle : Be(t.angle);
          let f = i ? t.angle + Tt : Be(90 - t.angle);
          const v = i ? e.angle : Be(e.angle);
          let m = i ? e.angle + Tt : Be(90 - e.angle);
          f > Et && (f -= Et), m > Et && (m -= Et);
          const y = (t, e, i, n) => {
            const s = [Math.cos(e), Math.sin(e)];
            return t + (Re(s, i) + Re(s, n)) / 2 > Re(s, h);
          };
          return (
            y((t.x2 - t.x1) / 2, g, u, p) &&
            y((t.y2 - t.y1) / 2, f, u, p) &&
            y((e.x2 - e.x1) / 2, v, c, d) &&
            y((e.y2 - e.y1) / 2, m, c, d)
          );
        })(e.rotatedBounds, i.rotatedBounds, !0))
      )
        return !0;
    var e, i;
    return !1;
  }
  function D$(t, e) {
    ('bottom' !== t && 'top' !== t) ||
      (function (t, e) {
        e.forEach(e => {
          e.attribute.angle &&
            e.setAttributes(
              Object.assign(Object.assign({}, F$(t, e.attribute.angle)), { angle: L$(e.attribute.angle) })
            );
        });
      })(t, e),
      ('left' !== t && 'right' !== t) ||
        (function (t, e) {
          e.forEach((e, i) => {
            e.attribute.angle &&
              e.setAttributes(
                Object.assign(Object.assign({}, j$(t, e.attribute.angle)), { angle: L$(e.attribute.angle) })
              );
          });
        })(t, e),
      (function (t) {
        t.forEach(t => {
          const e = (function (t) {
              const e = t.AABBBounds;
              return {
                x1: e.x1,
                x2: e.x2,
                y1: e.y1,
                y2: e.y2,
                centerX: t.attribute.x,
                centerY: t.attribute.y,
                angle: t.attribute.angle
              };
            })(t),
            i =
              ((r = e.centerX),
              (a = e.centerY),
              (o = e.angle),
              (l = t.attribute.x),
              (h = t.attribute.y),
              {
                x: (r - l) * Math.cos(o) + (a - h) * Math.sin(o) + l,
                y: (r - l) * Math.sin(o) + (h - a) * Math.cos(o) + h
              }),
            n = i.x - e.centerX,
            s = i.y - e.centerY;
          var r, a, o, l, h;
          (e.x1 += n), (e.x2 += n), (e.y1 += s), (e.y2 += s), (e.centerX += n), (e.centerY += s), (t.rotatedBounds = e);
        });
      })(e);
  }
  function L$() {
    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    if (t < 0) for (; t < 0; ) t += 2 * Math.PI;
    if (t > 0) for (; t >= 2 * Math.PI; ) t -= 2 * Math.PI;
    return t;
  }
  function F$(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
      i = ['center', 'left', 'left', 'left', 'center', 'right', 'right', 'right', 'left'],
      n = ['top', 'top', 'middle', 'bottom', 'bottom', 'bottom', 'middle', 'top', 'top'];
    'top' === t &&
      ((i = ['center', 'right', 'right', 'right', 'center', 'left', 'left', 'left', 'right']),
      (n = ['bottom', 'bottom', 'middle', 'top', 'top', 'top', 'middle', 'bottom', 'bottom']));
    const s = (e = L$(e)) / (0.5 * Math.PI);
    let r;
    return (
      (r = s === Math.floor(s) ? 2 * Math.floor(s) : 2 * Math.floor(s) + 1), { textAlign: i[r], textBaseline: n[r] }
    );
  }
  function j$(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
      i = ['right', 'right', 'center', 'left', 'center', 'left', 'center', 'right', 'right'],
      n = ['middle', 'middle', 'top', 'top', 'middle', 'middle', 'bottom', 'bottom', 'middle'];
    'right' === t &&
      ((i = ['left', 'right', 'right', 'right', 'left', 'left', 'left', 'left', 'right']),
      (n = ['middle', 'bottom', 'middle', 'top', 'top', 'top', 'middle', 'bottom', 'bottom']));
    const s = (e = L$(e)) / (0.5 * Math.PI);
    let r;
    return (
      (r = s === Math.floor(s) ? 2 * Math.floor(s) : 2 * Math.floor(s) + 1), { textAlign: i[r], textBaseline: n[r] }
    );
  }
  class z$ {
    isInValidValue(t) {
      return t < 0 || t > 1;
    }
    getTickCoord(t) {
      const { start: e } = this.attribute,
        i = this.getRelativeVector();
      return { x: e.x + i[0] * t, y: e.y + i[1] * t };
    }
    getRelativeVector(t) {
      const { start: e, end: i } = this.attribute;
      return [i.x - e.x, i.y - e.y];
    }
    getVerticalVector(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      const { verticalFactor: i = 1 } = this.attribute,
        n = (function (t) {
          const [e, i] = t;
          let n = e * e + i * i;
          return n > 0 && (n = 1 / Math.sqrt(n)), [t[0] * n, t[1] * n];
        })(this.getRelativeVector());
      return wY([n[1], -1 * n[0]], t * (e ? 1 : -1) * i);
    }
  }
  var H$ = function (t, e) {
    var i = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
    if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
      var s = 0;
      for (n = Object.getOwnPropertySymbols(t); s < n.length; s++)
        e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (i[n[s]] = t[n[s]]);
    }
    return i;
  };
  class N$ extends E$ {
    constructor(t, e) {
      super(D({}, N$.defaultAttributes, t), e), '3d' === e && this.setMode(e);
    }
    _renderInner(t) {
      var e;
      super._renderInner(t);
      const { panel: i } = this.attribute;
      if (i && i.visible) {
        const t = this.axisContainer,
          n = t.AABBBounds,
          s = iB(Object.assign({ x: n.x1, y: n.y1, width: n.width(), height: n.height() }, i.style));
        (s.name = A$.background),
          (s.id = this._getNodeId('background')),
          (s.states = D({}, M$, null !== (e = i.state) && void 0 !== e ? e : {})),
          t.insertBefore(s, t.firstChild);
      }
    }
    renderLine(t) {
      const { start: e, end: i, line: n } = this.attribute,
        s = n,
        { startSymbol: r, endSymbol: a, style: o, breakRange: l, breakShape: h, breakShapeStyle: c, state: d } = s,
        u = H$(s, ['startSymbol', 'endSymbol', 'style', 'breakRange', 'breakShape', 'breakShapeStyle', 'state']),
        p = Object.assign({ points: [e, i], startSymbol: r, endSymbol: a, lineStyle: o }, u);
      T(d) || (p.state = { line: D({}, M$, d), symbol: D({}, M$, d) });
      const g = new w$(p);
      (g.name = A$.line), (g.id = this._getNodeId('line')), t.add(g);
    }
    getTitleAttribute() {
      var t, e, i, n, s, r, a, o;
      const h = this.attribute.title,
        {
          position: c = 'middle',
          space: d = 4,
          textStyle: u = {},
          autoRotate: p = !0,
          shape: g,
          background: f,
          state: v
        } = h,
        m = H$(h, ['position', 'space', 'textStyle', 'autoRotate', 'shape', 'background', 'state']);
      let y = 0.5;
      'start' === c ? (y = 0) : 'end' === c && (y = 1);
      const { verticalFactor: _ = 1 } = this.attribute,
        b = -1 * _,
        x = this.getTickCoord(y),
        S = this.getRelativeVector();
      let w = 0;
      if (
        (null === (t = this.attribute.label) || void 0 === t ? void 0 : t.visible) &&
        !1 === (null === (e = this.attribute.label) || void 0 === e ? void 0 : e.inside)
      ) {
        const t = +C(this.attribute, 'label.space', 4);
        w += t;
        const e = Object.keys(this.axisLabelLayerSize).length;
        if (0 === S[1]) {
          const i = this.axisLabelsContainer.AABBBounds.height();
          isFinite(i) ? (w += i + (e - 1) * t) : (w = 0);
        } else {
          if (0 === S[0]) {
            const i = this.axisLabelsContainer.AABBBounds.width();
            isFinite(i) ? (w += i + (e - 1) * t) : (w = 0);
          } else
            Object.keys(this.axisLabelLayerSize).forEach((e, i) => {
              w += this.axisLabelLayerSize[e].width + (i > 0 ? t : 0);
            });
          const i = this.axisLabelLayerSize[0].textAlign,
            n = 'start' === i || 'left' === i,
            s = 'center' === i,
            r = S[1] > 0;
          w =
            1 === b
              ? r
                ? n
                  ? w
                  : s
                  ? w / 2
                  : t
                : n
                ? t
                : s
                ? w / 2
                : w
              : r
              ? n
                ? t
                : s
                ? w / 2
                : w
              : n
              ? w
              : s
              ? w / 2
              : t;
        }
      }
      let A = 0;
      (null === (i = this.attribute.tick) || void 0 === i ? void 0 : i.visible) &&
        !1 === (null === (n = this.attribute.tick) || void 0 === n ? void 0 : n.inside) &&
        (A = (null === (s = this.attribute.tick) || void 0 === s ? void 0 : s.length) || 4),
        (null === (r = this.attribute.subTick) || void 0 === r ? void 0 : r.visible) &&
          !1 === (null === (a = this.attribute.subTick) || void 0 === a ? void 0 : a.inside) &&
          (A = Math.max(A, (null === (o = this.attribute.subTick) || void 0 === o ? void 0 : o.length) || 2));
      const k = A + w + d,
        M = this.getVerticalCoord(x, k, !1),
        T = this.getVerticalVector(k, !1, { x: 0, y: 0 });
      let E,
        P,
        { angle: R } = m;
      if (((E = 'start' === c ? 'start' : 'end' === c ? 'end' : 'center'), l(R) && p)) {
        R = AY(S, [1, 0], !0);
        const { verticalFactor: t = 1 } = this.attribute;
        P = 1 == -1 * t ? 'bottom' : 'top';
      } else (E = this.getTextAlign(T)), (P = this.getTextBaseline(T, !1));
      const O = Object.assign(Object.assign(Object.assign({}, M), m), {
        textStyle: Object.assign({ textAlign: E, textBaseline: P }, u),
        state: {
          text: D({}, M$, null == v ? void 0 : v.text),
          shape: D({}, M$, null == v ? void 0 : v.shape),
          panel: D({}, M$, null == v ? void 0 : v.background)
        }
      });
      return (
        (O.angle = R),
        g && g.visible && ((O.shape = Object.assign({ visible: !0 }, g.style)), g.space && (O.space = g.space)),
        f && f.visible && (O.panel = Object.assign({ visible: !0 }, f.style)),
        O
      );
    }
    getTextBaseline(t, e) {
      let i = 'middle';
      const { verticalFactor: n = 1 } = this.attribute,
        s = (e ? 1 : -1) * n;
      return (
        ot(t[1], 0)
          ? (i = !ot(t[0], 0) || Object.is(t[0], -0) || Object.is(t[1], -0) ? 'middle' : 1 === s ? 'bottom' : 'top')
          : t[1] > 0
          ? (i = 'top')
          : t[1] < 0 && (i = 'bottom'),
        i
      );
    }
    getLabelAlign(t, e, i) {
      const n = this.attribute.orient;
      if (_(i)) {
        if ('top' === n || 'bottom' === n) return F$(n, i);
        if ('left' === n || 'right' === n) return j$(n, i);
      }
      return { textAlign: this.getTextAlign(t), textBaseline: this.getTextBaseline(t, e) };
    }
    beforeLabelsOverlap(t, e, i, n, s) {
      const { flush: r = !1 } = this.attribute.label || {};
      if (r && t.length) {
        const { orient: e, start: i, end: n } = this.attribute,
          s = 'bottom' === e || 'top' === e,
          r = t[0],
          a = W(t),
          o = s ? r.attribute.x > a.attribute.x : r.attribute.y < a.attribute.y;
        if (s) {
          const t = Math.abs(i.x - n.x);
          if (o) {
            const e = t,
              i = 0,
              n = r.AABBBounds.x2,
              s = a.AABBBounds.x1;
            n > e && r.setAttributes({ x: e, textAlign: 'right' }),
              s < i && a.setAttributes({ x: i, textAlign: 'left' });
          } else {
            const e = 0,
              i = t,
              n = r.AABBBounds.x1,
              s = a.AABBBounds.x2;
            n < e && r.setAttributes({ x: e, textAlign: 'left' }),
              s > i && a.setAttributes({ x: i, textAlign: 'right' });
          }
        } else {
          const t = Math.abs(i.y - n.y);
          if (o) {
            const e = r.AABBBounds.y1,
              i = a.AABBBounds.y2,
              n = 0,
              s = t;
            e < n && r.setAttributes({ y: n, textBaseline: 'top' }),
              i > s && a.setAttributes({ y: s, textBaseline: 'bottom' });
          } else {
            const e = t,
              i = 0,
              n = r.AABBBounds.y2,
              s = a.AABBBounds.y1;
            n > e && r.setAttributes({ y: e, textBaseline: 'bottom' }),
              s < i && a.setAttributes({ y: i, textBaseline: 'top' });
          }
        }
      }
    }
    handleLabelsOverlap(t, e, i, n, s) {
      if (T(t)) return;
      const { verticalLimitSize: r, label: a, orient: h } = this.attribute,
        c = this._getAxisLabelLimitLength(r, s),
        {
          layoutFunc: d,
          autoRotate: u,
          autoRotateAngle: p,
          autoLimit: g,
          limitEllipsis: f,
          autoHide: v,
          autoHideMethod: m,
          autoHideSeparation: y
        } = a;
      o(d)
        ? d(t, e, n, this)
        : (u &&
            (function (t, e) {
              if (T(t)) return;
              const { orient: i, labelRotateAngle: n = [0, 45, 90] } = e;
              if (0 === n.length || t.some(t => !!t.attribute.angle)) return;
              let s = 0,
                r = 0;
              for (n && n.length > 0 && (r = n.length); s < r; ) {
                const e = n[s++];
                if (
                  (t.forEach(t => {
                    t.attribute.angle = qt(e);
                  }),
                  D$(i, t),
                  !I$(t))
                )
                  break;
              }
            })(t, { labelRotateAngle: p, orient: h }),
          g &&
            _(c) &&
            c > 0 &&
            (function (t, e) {
              const { limitLength: i, ellipsis: n = '...', orient: s } = e;
              !T(t) &&
                _(i) &&
                t.forEach(t => {
                  if (('top' === s || 'bottom' === s) && Math.floor(t.AABBBounds.height()) <= i) return;
                  if (('left' === s || 'right' === s) && Math.floor(t.AABBBounds.width()) <= i) return;
                  let e =
                    0 === t.attribute.angle || l(t.attribute.angle)
                      ? 'top' === s || 'bottom' === s
                        ? null
                        : i
                      : Math.abs(i / Math.sin(t.attribute.angle));
                  _(t.attribute.maxLineWidth) &&
                    (e = _(e) ? Math.min(t.attribute.maxLineWidth, e) : t.attribute.maxLineWidth),
                    t.setAttributes({ maxLineWidth: e, ellipsis: t.attribute.ellipsis || n });
                });
            })(t, { limitLength: c, ellipsis: f, orient: h }),
          v &&
            (function (t, e) {
              if (T(t)) return;
              const i = t.filter(B$);
              if (T(i)) return;
              let n;
              n = (function (t) {
                return t.forEach(t => t.setAttribute('opacity', 1)), t;
              })(i);
              const { method: s = 'parity', separation: r = 0 } = e,
                a = o(s) ? s : P$[s] || P$.parity;
              if (n.length >= 3 && O$(n, r)) {
                do {
                  n = a(n, r);
                } while (n.length >= 3 && O$(n, r));
                n.length < 3 &&
                  !W(i).attribute.opacity &&
                  (n.length > 1 && W(n).setAttribute('opacity', 0), W(i).setAttribute('opacity', 1));
              }
              i.forEach(t => {
                t.setAttribute('visible', !!t.attribute.opacity);
              });
            })(t, { orient: h, method: m, separation: y }));
    }
    afterLabelsOverlap(t, e, i, n, s) {
      const { verticalLimitSize: r, orient: a } = this.attribute,
        o = 'bottom' === a || 'top' === a,
        l = i.AABBBounds;
      let c = o ? l.height() : l.width();
      const { verticalMinSize: d } = this.attribute;
      if (_(d) && (!_(r) || d <= r)) {
        const t = this._getAxisLabelLimitLength(d, s);
        let e, n;
        (c = Math.max(c, t)),
          'left' === a
            ? ((e = l.x2 - c), (n = l.y1))
            : 'right' === a
            ? ((e = l.x1), (n = l.y1))
            : 'top' === a
            ? ((e = l.x1), (n = l.y2 - c))
            : 'bottom' === a && ((e = l.x1), (n = l.y1));
        const r = iB({ x: e, y: n, width: o ? l.width() : c, height: o ? c : l.height(), pickable: !1 });
        (r.name = A$.axisLabelBackground),
          (r.id = this._getNodeId('axis-label-background')),
          i.insertBefore(r, i.firstChild);
      }
      if (h(this.attribute.label.containerAlign)) {
        let e;
        'left' === a
          ? (e = l.x2)
          : 'right' === a
          ? (e = l.x1)
          : 'top' === a
          ? (e = l.y2)
          : 'bottom' === a && (e = l.y1),
          (function (t, e, i, n, s) {
            if ('right' === n || 'left' === n) {
              if ('left' === s) {
                const s = 'right' === n ? 0 : -1;
                t.forEach(t => {
                  t.setAttributes({ x: e + i * s, textAlign: 'left' });
                });
              } else if ('right' === s) {
                const s = 'right' === n ? 1 : 0;
                t.forEach(t => {
                  t.setAttributes({ x: e + i * s, textAlign: 'right' });
                });
              } else if ('center' === s) {
                const s = 'right' === n ? 1 : -1;
                t.forEach(t => {
                  t.setAttributes({ x: e + 0.5 * i * s, textAlign: 'center' });
                });
              }
            } else if ('bottom' === n || 'top' === n)
              if ('top' === s) {
                const s = 'bottom' === n ? 0 : -1;
                t.forEach(t => {
                  t.setAttributes({ y: e + i * s, textBaseline: 'top' });
                });
              } else if ('bottom' === s) {
                const s = 'bottom' === n ? 1 : 0;
                t.forEach(t => {
                  t.setAttributes({ y: e + i * s, textBaseline: 'bottom' });
                });
              } else if ('middle' === s) {
                const s = 'bottom' === n ? 1 : -1;
                t.forEach(t => {
                  t.setAttributes({ y: e + 0.5 * i * s, textBaseline: 'middle' });
                });
              }
          })(t, e, c, a, this.attribute.label.containerAlign);
      }
    }
    _getAxisLabelLimitLength(t, e) {
      var i, n, s;
      const { label: r, title: a, line: o, tick: l } = this.attribute,
        h = null !== (i = r.space) && void 0 !== i ? i : 4;
      let c = t,
        d = 0,
        u = 0;
      const p = (null == o ? void 0 : o.visible) ? (null !== (n = o.style.lineWidth) && void 0 !== n ? n : 1) : 0,
        g = (null == l ? void 0 : l.visible) ? (null !== (s = l.length) && void 0 !== s ? s : 4) : 0;
      if (null == a ? void 0 : a.visible) {
        d = RY(a.text, a.textStyle).height;
        const t = Je(a.padding);
        u = a.space + t[0] + t[2];
      }
      return c && (c = (c - h - u - d - p - g) / e), c;
    }
  }
  (N$.defaultAttributes = T$), N(N$, z$);
  class V$ {
    isInValidValue(t) {
      const { startAngle: e = kY, endAngle: i = MY } = this.attribute;
      return Math.abs(i - e) % (2 * Math.PI) == 0 ? t > 1 : t < 0 || t > 1;
    }
    getTickCoord(t) {
      const {
        startAngle: e = kY,
        endAngle: i = MY,
        center: n,
        radius: s,
        inside: r = !1,
        innerRadius: a = 0
      } = this.attribute;
      return te(n, r && a > 0 ? a : s, e + (i - e) * t);
    }
    getVerticalVector(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
        i = arguments.length > 2 ? arguments[2] : void 0;
      const { inside: n = !1 } = this.attribute,
        { center: s } = this.attribute,
        r = [i.x - s.x, i.y - s.y];
      return wY(
        r,
        ((e ? -1 : 1) * (n ? -1 : 1) * t) /
          (function (t) {
            const [e, i] = t;
            return Math.sqrt(e * e + i * i);
          })(r)
      );
    }
    getRelativeVector(t) {
      const { center: e } = this.attribute;
      return [t.y - e.y, -1 * (t.x - e.x)];
    }
  }
  var W$ = function (t, e) {
    var i = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
    if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
      var s = 0;
      for (n = Object.getOwnPropertySymbols(t); s < n.length; s++)
        e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (i[n[s]] = t[n[s]]);
    }
    return i;
  };
  class G$ extends E$ {
    constructor(t) {
      super(D({}, G$.defaultAttributes, t));
    }
    renderLine(t) {
      const {
        startAngle: e = kY,
        endAngle: i = MY,
        radius: n,
        center: s,
        innerRadius: r = 0,
        line: a,
        inside: o = !1
      } = this.attribute;
      let l = n,
        h = r;
      o && r > 0 && ((l = r), (h = 0));
      const c = JO(
        Object.assign(
          Object.assign(Object.assign({}, s), { startAngle: e, endAngle: i, radius: l, innerRadius: h }),
          null == a ? void 0 : a.style
        )
      );
      (c.name = A$.line),
        (c.id = this._getNodeId('line')),
        T(null == a ? void 0 : a.state) || (c.states = D({}, M$, a.state)),
        t.add(c);
    }
    getTitleAttribute() {
      var t, e, i, n, s, r, a, o;
      const { center: h, radius: c, innerRadius: d = 0 } = this.attribute,
        u = this.attribute.title,
        { space: p = 4, textStyle: g = {}, shape: f, background: v, state: m } = u,
        y = W$(u, ['space', 'textStyle', 'shape', 'background', 'state']);
      let _ = h,
        b = 0;
      (null === (t = this.attribute.label) || void 0 === t ? void 0 : t.visible) &&
        !1 === (null === (e = this.attribute.label) || void 0 === e ? void 0 : e.inside) &&
        (b = C(this.attribute.label, 'style.fontSize', 12) + C(this.attribute.label, 'space', 4));
      let x = 0;
      (null === (i = this.attribute.tick) || void 0 === i ? void 0 : i.visible) &&
        !1 === (null === (n = this.attribute.tick) || void 0 === n ? void 0 : n.inside) &&
        (x = (null === (s = this.attribute.tick) || void 0 === s ? void 0 : s.length) || 4),
        (null === (r = this.attribute.subTick) || void 0 === r ? void 0 : r.visible) &&
          !1 === (null === (a = this.attribute.subTick) || void 0 === a ? void 0 : a.inside) &&
          (x = Math.max(x, (null === (o = this.attribute.subTick) || void 0 === o ? void 0 : o.length) || 2));
      const S = c + x + b + p;
      let w = 'middle',
        { position: A } = this.attribute.title;
      l(A) && (A = 0 === d ? 'end' : 'middle'),
        'start' === A
          ? ((w = 'bottom'), (_ = { x: h.x, y: h.y - S }))
          : 'end' === A && ((w = 'top'), (_ = { x: h.x, y: h.y + S }));
      const k = Object.assign(Object.assign(Object.assign({}, _), y), {
          textStyle: Object.assign({ textBaseline: w, textAlign: 'center' }, g),
          state: {
            text: D({}, M$, null == m ? void 0 : m.text),
            shape: D({}, M$, null == m ? void 0 : m.shape),
            panel: D({}, M$, null == m ? void 0 : m.background)
          }
        }),
        { angle: M } = y;
      return (
        (k.angle = M),
        f && f.visible && ((k.shape = Object.assign({ visible: !0 }, f.style)), f.space && (k.space = f.space)),
        v && v.visible && (k.panel = Object.assign({ visible: !0 }, v.style)),
        k
      );
    }
    getSubTickLineItems() {
      var t, e;
      const { subTick: i } = this.attribute,
        n = [],
        { count: s = 4, inside: r = !1, length: a = 2 } = i,
        o = this.tickLineItems,
        l = o.length;
      if (l >= 2) {
        const i = this.data[1].value - this.data[0].value,
          h =
            null === (e = null === (t = this.attribute) || void 0 === t ? void 0 : t.tick) || void 0 === e
              ? void 0
              : e.alignWithLabel;
        for (let t = 0; t < l; t++) {
          const e = o[t],
            l = o[t + 1];
          for (let t = 0; t < s; t++) {
            const o = (t + 1) / (s + 1),
              c = (1 - o) * e.value + o * (l ? l.value : h ? 1 : e.value + i),
              d = this.getTickCoord(c),
              u = this.getVerticalCoord(d, a, r);
            n.push({ start: d, end: u, value: c });
          }
        }
      }
      return n;
    }
    getTextBaseline(t) {
      let e = 'middle';
      return (
        ot(t[1], 0)
          ? (e = 'middle')
          : t[1] > 0 && t[1] > Math.abs(t[0])
          ? (e = 'top')
          : t[1] < 0 && Math.abs(t[1]) > Math.abs(t[0]) && (e = 'bottom'),
        e
      );
    }
    beforeLabelsOverlap(t, e, i, n, s) {}
    handleLabelsOverlap(t, e, i, n, s) {}
    afterLabelsOverlap(t, e, i, n, s) {}
    getLabelAlign(t, e, i) {
      return { textAlign: this.getTextAlign(t), textBaseline: this.getTextBaseline(t) };
    }
  }
  (G$.defaultAttributes = T$), N(G$, V$);
  class U$ extends wM {
    constructor() {
      super(...arguments), (this.mode = Ow.NORMAL);
    }
    onBind() {
      const t = this.target.getInnerView(),
        e = this.target.getPrevInnerView();
      e &&
        ((this._oldElementMap = (function (t) {
          const e = {};
          return (
            gY(t, t => {
              'group' !== t.type && t.id && (e[t.id] = t);
            }),
            e
          );
        })(e)),
        (this._newElementAttrMap = {}),
        gY(t, t => {
          var e, i, n, s, r, a;
          if ('group' !== t.type && t.id) {
            const o = this._oldElementMap[t.id];
            if (o) {
              if (!z(t.attribute, o.attribute)) {
                const s = R(t.attribute);
                (this._newElementAttrMap[t.id] = {
                  state: 'update',
                  node: t,
                  attrs: Object.assign(Object.assign({}, s), {
                    opacity: null !== (e = s.opacity) && void 0 !== e ? e : 1,
                    fillOpacity: null !== (i = s.fillOpacity) && void 0 !== i ? i : 1,
                    strokeOpacity: null !== (n = s.strokeOpacity) && void 0 !== n ? n : 1
                  })
                }),
                  t.setAttributes(o.attribute);
              }
            } else {
              const e = {
                opacity: null !== (s = t.attribute.opacity) && void 0 !== s ? s : 1,
                fillOpacity: null !== (r = t.attribute.fillOpacity) && void 0 !== r ? r : 1,
                strokeOpacity: null !== (a = t.attribute.strokeOpacity) && void 0 !== a ? a : 1
              };
              (this._newElementAttrMap[t.id] = { state: 'enter', node: t, attrs: e }),
                t.setAttributes({ opacity: 0, fillOpacity: 0, strokeOpacity: 0 });
            }
          }
        }));
    }
    onStart() {
      let t = this.duration,
        e = this.easing;
      Object.keys(this._newElementAttrMap).forEach(i => {
        var n, s, r, a, o, l, h;
        const { node: c, attrs: d, state: u } = this._newElementAttrMap[i];
        'enter' === u &&
          ((t = _(
            null === (s = null === (n = this.params) || void 0 === n ? void 0 : n.enter) || void 0 === s
              ? void 0
              : s.duration
          )
            ? null === (r = this.params) || void 0 === r
              ? void 0
              : r.enter.duration
            : t),
          (e = (
            null === (o = null === (a = this.params) || void 0 === a ? void 0 : a.enter) || void 0 === o
              ? void 0
              : o.easing
          )
            ? null === (h = null === (l = this.params) || void 0 === l ? void 0 : l.enter) || void 0 === h
              ? void 0
              : h.easing
            : e)),
          'path' === c.type
            ? c
                .animate({
                  interpolate: (t, e, i, n, s) =>
                    'path' === t &&
                    ((s.path = (function (t, e) {
                      let i,
                        n,
                        s,
                        r = (xt.lastIndex = St.lastIndex = 0),
                        a = -1;
                      const o = [],
                        l = [];
                      for (t += '', e += ''; (i = xt.exec(t)) && (n = St.exec(e)); )
                        (s = n.index) > r && ((s = e.slice(r, s)), o[a] ? (o[a] += s) : (o[++a] = s)),
                          (i = i[0]) === (n = n[0])
                            ? o[a]
                              ? (o[a] += n)
                              : (o[++a] = n)
                            : ((o[++a] = null), l.push({ i: a, x: _t(i, n) })),
                          (r = St.lastIndex);
                      return (
                        r < e.length && ((s = e.slice(r)), o[a] ? (o[a] += s) : (o[++a] = s)),
                        o.length < 2
                          ? l[0]
                            ? (function (t) {
                                return function (e) {
                                  return t(e) + '';
                                };
                              })(l[0].x)
                            : (function (t) {
                                return function () {
                                  return t;
                                };
                              })(e)
                          : ((e = l.length),
                            function (t) {
                              for (let i, n = 0; n < e; ++n) o[(i = l[n]).i] = i.x(t);
                              return o.join('');
                            })
                      );
                    })(
                      i,
                      n
                    )(e)),
                    !0)
                })
                .to(d, t, e)
            : c.animate().to(d, t, e);
      });
    }
    onUpdate(t, e, i) {}
  }
  class Y$ extends wM {
    constructor(t, e, i, n) {
      super(null, null, i, n);
    }
    getEndProps() {
      return {};
    }
    onBind() {
      this.target.setTheme({ common: { opacity: 0 } });
    }
    onEnd() {
      this.target.setTheme({ common: { opacity: 1 } });
    }
    onUpdate(t, e, i) {
      this.target.setTheme({ common: { opacity: e } });
    }
  }
  function $$(t, e) {
    let i = '';
    return (
      0 === t.length ||
        (t.forEach((t, e) => {
          0 === e ? (i = `M${t.x},${t.y}`) : (i += `L${t.x},${t.y}`);
        }),
        e && (i += 'Z')),
      i
    );
  }
  function X$(t, e, i, n) {
    let s = '';
    if (!t || 0 === e.length) return s;
    const r = e[0],
      a = Yt.distancePP(t, r),
      o = i ? 0 : 1;
    return (
      n
        ? (s += `M${t.x},${t.y - a}A${a},${a},0,0,${o},${t.x},${t.y + a}A${a},${a},0,0,${o},${t.x},${t.y - a}Z`)
        : e.forEach((t, e) => {
            0 === e ? (s = `M${t.x},${t.y}`) : (s += `A${a},${a},0,0,${o},${t.x},${t.y}`);
          }),
      s
    );
  }
  function K$(t, e, i) {
    const { type: n, closed: s } = i,
      r = e.slice(0).reverse();
    let a = '',
      o = '';
    if ('line' === n && i.smoothLink && i.center) {
      const e = t[0],
        n = r[0],
        l = i.center;
      (a = $$(t, !!s)), (o = $$(r, !!s));
      const h = Yt.distancePP(n, l),
        c = Yt.distancePP(e, l);
      (a += `A${h},${h},0,0,1,${n.x},${n.y}L${n.x},${n.y}`), (o += `A${c},${c},0,0,0,${e.x},${e.y}`);
    } else if ('circle' === n) {
      const { center: e } = i;
      (a = X$(e, t, !1, !!s)), (o = X$(e, r, !0, !!s));
    } else ('line' !== n && 'polygon' !== n) || ((a = $$(t, !!s)), (o = $$(r, !!s)));
    return s ? (a += o) : ((o = 'L' + o.substring(1)), (a += o), (a += 'Z')), a;
  }
  class q$ extends uY {
    constructor() {
      super(...arguments), (this.name = 'axis-grid'), (this.data = []);
    }
    getInnerView() {
      return this._innerView;
    }
    getPrevInnerView() {
      return this._prevInnerView;
    }
    render() {
      this.removeAllChild(),
        (this._prevInnerView = this._innerView),
        (this._innerView = QO({ x: 0, y: 0, pickable: !1 })),
        this.add(this._innerView);
      const { items: t, visible: e } = this.attribute;
      t && t.length && !1 !== e && ((this.data = this._transformItems(t)), this._renderGrid(this._innerView));
    }
    getVerticalCoord(t, e, i) {
      const n = this.getVerticalVector(e, i, t);
      return { x: t.x + n[0], y: t.y + n[1] };
    }
    _transformItems(t) {
      const e = [];
      return (
        t.forEach(t => {
          var i;
          e.push(
            Object.assign(Object.assign({}, t), {
              point: this.getTickCoord(t.value),
              id: null !== (i = t.id) && void 0 !== i ? i : t.label
            })
          );
        }),
        e
      );
    }
    _renderGrid(t) {
      const { visible: e } = this.attribute.subGrid || {};
      e && this._renderGridByType(!0, t), this._renderGridByType(!1, t);
    }
    _renderGridByType(t, e) {
      const i = D({}, this.attribute, this.getGridAttribute(t)),
        { type: n, items: s, style: r, closed: a, alternateColor: l, depth: h = 0 } = i,
        c = t ? `${A$.grid}-sub` : `${A$.grid}`;
      if (
        (s.forEach((t, i) => {
          const { id: s, points: l } = t;
          let d = '';
          if ('line' === n || 'polygon' === n) d = $$(l, !!a);
          else if ('circle' === n) {
            const { center: t } = this.attribute;
            d = X$(t, l, !1, !!a);
          }
          const u = eB(Object.assign({ path: d, z: h }, o(r) ? D({}, q$.defaultAttributes.style, r(t, i)) : r));
          (u.name = `${c}-line`), (u.id = this._getNodeId(`${c}-path-${s}`)), e.add(u);
        }),
        h &&
          'line' === n &&
          s.forEach((t, i) => {
            const { id: n, points: s } = t,
              l = [];
            l.push(s[0]);
            const d = s[1].x - s[0].x,
              u = s[1].y - s[0].y,
              p = Math.sqrt(d * d + u * u),
              g = h / p;
            l.push({ x: s[0].x + d * g, y: s[0].y + u * g });
            const f = $$(l, !!a),
              v = Pt(l[0].x - l[1].x),
              m = Pt(l[0].y - l[1].y),
              y = eB(
                Object.assign(
                  {
                    path: f,
                    z: 0,
                    alpha: v > m ? ((s[1].x - s[0].x > 0 ? -1 : 1) * Mt) / 2 : 0,
                    beta: v < m ? -Mt / 2 : 0,
                    anchor3d: v > m ? [l[0].x, 0] : [0, l[0].y]
                  },
                  o(r) ? D({}, q$.defaultAttributes.style, r(t, i)) : r
                )
              );
            (y.name = `${c}-line`), (y.id = this._getNodeId(`${c}-path-${n}`)), e.add(y);
          }),
        s.length > 1 && l)
      ) {
        const t = f(l) ? l : [l, 'transparent'],
          n = e => t[e % t.length];
        for (let t = 0; t < s.length - 1; t++) {
          const [r, a] = [s[t].points, s[t + 1].points],
            o = eB({ path: K$(r, a, i), fill: n(t) });
          (o.name = `${c}-region`), (o.id = this._getNodeId(`${c}-region-${t}`)), e.add(o);
        }
      }
    }
    _getNodeId(t) {
      return `${this.id}-${t}`;
    }
  }
  q$.defaultAttributes = {
    style: { lineWidth: 1, stroke: '#999', strokeOpacity: 1, lineDash: [4, 4] },
    subGrid: { visible: !1, style: { lineWidth: 1, stroke: '#999', strokeOpacity: 1, lineDash: [4, 4] } }
  };
  class Z$ extends q$ {
    constructor(t, e) {
      super(D({}, q$.defaultAttributes, t), e), '3d' === e && this.setMode(e);
    }
    _getGridPoint(t, e) {
      let i;
      if ('line' === t) {
        const { length: t } = this.attribute;
        i = [e, this.getVerticalCoord(e, t, !0)];
      } else if ('circle' === t || 'polygon' === t) {
        const { center: t, sides: n = 6, startAngle: s = kY, endAngle: r = MY } = this.attribute;
        i = (function (t, e, i, n, s) {
          const r = [],
            a = s - n;
          for (let s = 0; s < e; s++) {
            const o = n + (s * a) / e;
            r.push(te(t, i, o));
          }
          return r;
        })(t, n, Yt.distancePP(t, e), s, r);
      }
      return i;
    }
    getGridAttribute(t) {
      const { type: e, alignWithLabel: i = !0 } = this.attribute;
      let n,
        s = 1;
      this.data.length >= 2 && (s = this.data[1].value - this.data[0].value);
      let r = [];
      if (t) {
        n = D({}, this.attribute, this.attribute.subGrid);
        const t = [],
          { count: a = 4 } = this.attribute.subGrid || {};
        if (this.data.length >= 2) {
          const n = [];
          this.data.forEach(t => {
            let e = t.value;
            if (!i) {
              const i = t.value - s / 2;
              if (this.isInValidValue(i)) return;
              e = i;
            }
            n.push({ value: e });
          });
          for (let i = 0; i < n.length - 1; i++) {
            const s = n[i],
              r = n[i + 1];
            t.push({ id: `sub-${i}-0`, points: this._getGridPoint(e, this.getTickCoord(s.value)), datum: {} });
            for (let n = 0; n < a; n++) {
              const o = (n + 1) / (a + 1),
                l = (1 - o) * s.value + o * r.value,
                h = this.getTickCoord(l);
              t.push({ id: `sub-${i}-${n + 1}`, points: this._getGridPoint(e, h), datum: {} });
            }
            i === n.length - 2 &&
              t.push({ id: `sub-${i}-${a + 1}`, points: this._getGridPoint(e, this.getTickCoord(r.value)), datum: {} });
          }
          r = t;
        }
      } else {
        n = this.attribute;
        const t = [];
        this.data.forEach(n => {
          let { point: r } = n;
          if (!i) {
            const t = n.value - s / 2;
            if (this.isInValidValue(t)) return;
            r = this.getTickCoord(t);
          }
          t.push({ id: n.label, datum: n, points: this._getGridPoint(e, r) });
        }),
          (r = t);
      }
      return Object.assign(Object.assign({}, n), { items: r });
    }
  }
  N(Z$, z$);
  var J$,
    Q$ = function (t, e) {
      var i = {};
      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
      if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
        var s = 0;
        for (n = Object.getOwnPropertySymbols(t); s < n.length; s++)
          e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (i[n[s]] = t[n[s]]);
      }
      return i;
    };
  class tX extends q$ {
    constructor(t) {
      super(D({}, q$.defaultAttributes, t));
    }
    getGridAttribute(t) {
      let e,
        i = [];
      const n = this.attribute,
        { radius: s, innerRadius: r = 0, startAngle: a = kY, endAngle: o = MY, center: l, subGrid: h } = n,
        c = Q$(n, ['radius', 'innerRadius', 'startAngle', 'endAngle', 'center', 'subGrid']),
        { alignWithLabel: d = !0 } = c || {},
        u = s - r;
      let p = 1;
      if ((this.data.length >= 2 && (p = this.data[1].value - this.data[0].value), t)) {
        e = D({}, c, h);
        const t = [],
          { count: n = 4 } = h || {},
          s = this.data.length;
        if (s >= 2) {
          const e = [];
          this.data.forEach(t => {
            let i = t.value;
            if (!d) {
              const e = t.value - p / 2;
              if (this.isInValidValue(e)) return;
              i = e;
            }
            e.push({ value: i });
          });
          for (let i = 0; i < s; i++) {
            const s = e[i],
              r = e[i + 1];
            t.push({
              id: `sub-${i}-0`,
              points: [this.getTickCoord(s.value), this.getVerticalCoord(this.getTickCoord(s.value), u, !0)],
              datum: {}
            });
            for (let e = 0; e < n; e++) {
              const a = (e + 1) / (n + 1),
                o = (1 - a) * s.value + a * (r ? r.value : d ? 1 : s.value + p),
                l = this.getTickCoord(o),
                h = this.getVerticalCoord(l, u, !0);
              t.push({ id: `sub-${i}-${e + 1}`, points: [l, h], datum: {} });
            }
          }
          Math.abs(o - a) % (2 * Math.PI) == 0 && t.push(t[0]), (i = t);
        }
      } else {
        e = c;
        const t = [];
        let n;
        (n = Math.abs(o - a) % (2 * Math.PI) == 0 ? [...this.data].concat(this.data[0]) : this.data),
          n.forEach(e => {
            let { point: i } = e;
            if (!d) {
              const t = e.value - p / 2;
              if (this.isInValidValue(t)) return;
              i = this.getTickCoord(t);
            }
            const n = this.getVerticalCoord(i, u, !0);
            t.push({ id: e.id, points: [i, n], datum: e });
          }),
          (i = t);
      }
      return Object.assign(Object.assign({}, e), { items: i, center: l, type: 'line' });
    }
  }
  N(tX, V$),
    (function (t) {
      (t.startHandler = 'startHandler'),
        (t.endHandler = 'endHandler'),
        (t.middleHandler = 'middleHandler'),
        (t.background = 'background');
    })(J$ || (J$ = {}));
  var eX = function (t, e) {
    var i = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
    if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
      var s = 0;
      for (n = Object.getOwnPropertySymbols(t); s < n.length; s++)
        e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (i[n[s]] = t[n[s]]);
    }
    return i;
  };
  let iX = class t extends uY {
    constructor(e) {
      super(D({}, t.defaultAttributes, e)),
        (this.name = 'dataZoom'),
        (this._previewData = []),
        (this._activeState = !1),
        (this._activeCache = { startPos: { x: 0, y: 0 }, lastPos: { x: 0, y: 0 } }),
        (this._layoutCache = { attPos: 'x', attSize: 'width', max: 0 }),
        (this.state = { start: 0, end: 1 }),
        (this._statePointToData = t => t),
        (this._onHandlerPointerDown = (t, e) => {
          'start' === e
            ? ((this._activeTag = J$.startHandler), (this._activeItem = this._startHandler))
            : 'end' === e
            ? ((this._activeTag = J$.endHandler), (this._activeItem = this._endHandler))
            : 'middleRect' === e
            ? ((this._activeTag = J$.middleHandler), (this._activeItem = this._middleHandlerRect))
            : 'middleSymbol' === e
            ? ((this._activeTag = J$.middleHandler), (this._activeItem = this._middleHandlerSymbol))
            : 'background' === e && ((this._activeTag = J$.background), (this._activeItem = this._background)),
            (this._activeState = !0),
            (this._activeCache.startPos = this.eventPosToStagePos(t)),
            (this._activeCache.lastPos = this.eventPosToStagePos(t));
        }),
        (this._onHandlerPointerMove = t => {
          const { start: e, end: i, brushSelect: n } = this.attribute,
            s = this.eventPosToStagePos(t),
            { attPos: r, max: a } = this._layoutCache,
            o = (s[r] - this._activeCache.lastPos[r]) / a;
          this._activeState &&
            (this._activeTag === J$.middleHandler
              ? this.moveZoomWithMiddle((this.state.start + this.state.end) / 2 + o)
              : this._activeTag === J$.startHandler
              ? this.state.start + o > this.state.end
                ? ((this.state.start = this.state.end),
                  (this.state.end = this.state.start + o),
                  (this._activeTag = J$.endHandler))
                : (this.state.start = this.state.start + o)
              : this._activeTag === J$.endHandler &&
                (this.state.end + o < this.state.start
                  ? ((this.state.end = this.state.start),
                    (this.state.start = this.state.end + o),
                    (this._activeTag = J$.startHandler))
                  : (this.state.end = this.state.end + o)),
            (this._activeCache.lastPos = s),
            n && this.renderDragMask()),
            (this.state.start = Math.min(Math.max(this.state.start, 0), 1)),
            (this.state.end = Math.min(Math.max(this.state.end, 0), 1)),
            (e === this.state.start && i === this.state.end) ||
              (this.setAttributes({ start: this.state.start, end: this.state.end }),
              this._updateStateCallback && this._updateStateCallback(this.state.start, this.state.end));
        });
      const {
          start: i,
          end: n,
          size: s,
          orient: r,
          showDetail: a,
          position: l,
          previewData: h,
          previewCallbackX: c,
          previewCallbackY: d,
          previewCallbackX1: u,
          previewCallbackY1: p,
          updateStateCallback: g
        } = this.attribute,
        { width: f, height: v } = s;
      i && (this.state.start = i),
        n && (this.state.end = n),
        (this._isHorizontal = 'top' === r || 'bottom' === r),
        (this._layoutCache.max = this._isHorizontal ? f : v),
        (this._layoutCache.attPos = this._isHorizontal ? 'x' : 'y'),
        (this._layoutCache.attSize = this._isHorizontal ? 'width' : 'height'),
        (this._activeCache.startPos = l),
        (this._activeCache.lastPos = l),
        (this._showText = 'auto' !== a && a),
        h && (this._previewData = h),
        o(c) && (this._previewCallbackX = c),
        o(d) && (this._previewCallbackY = d),
        o(u) && (this._previewCallbackX1 = u),
        o(p) && (this._previewCallbackY1 = p),
        o(g) && (this._updateStateCallback = g);
    }
    bindEvents() {
      const { showDetail: t, brushSelect: e } = this.attribute;
      this._startHandler &&
        this._startHandler.addEventListener('pointerdown', t => this._onHandlerPointerDown(t, 'start')),
        this._endHandler && this._endHandler.addEventListener('pointerdown', t => this._onHandlerPointerDown(t, 'end')),
        this._middleHandlerSymbol &&
          this._middleHandlerSymbol.addEventListener('pointerdown', t => this._onHandlerPointerDown(t, 'middleSymbol')),
        this._middleHandlerRect &&
          this._middleHandlerRect.addEventListener('pointerdown', t => this._onHandlerPointerDown(t, 'middleRect'));
      const i = e ? 'background' : 'middleRect';
      this._selectedBackground &&
        this._selectedBackground.addEventListener('pointerdown', t => this._onHandlerPointerDown(t, i)),
        e &&
          this._background &&
          this._background.addEventListener('pointerdown', t => this._onHandlerPointerDown(t, 'background')),
        e &&
          this._previewGroup &&
          this._previewGroup.addEventListener('pointerdown', t => this._onHandlerPointerDown(t, 'background')),
        this._selectedPreviewGroup &&
          this._selectedPreviewGroup.addEventListener('pointerdown', t => this._onHandlerPointerDown(t, i)),
        'browser' === gN.env &&
          (gN.addEventListener('pointermove', this._onHandlerPointerMove.bind(this)),
          gN.addEventListener('pointerup', this._onHandlerPointerUp.bind(this))),
        this.addEventListener('pointermove', this._onHandlerPointerMove),
        this.addEventListener('pointerup', this._onHandlerPointerUp),
        this.addEventListener('pointerupoutside', this._onHandlerPointerUp),
        'auto' === t &&
          (this.addEventListener('pointerenter', this._onHandlerPointerEnter),
          this.addEventListener('pointerleave', this._onHandlerPointerLeave));
    }
    dragMaskSize() {
      const { position: t } = this.attribute,
        { attPos: e, max: i } = this._layoutCache;
      return this._activeCache.lastPos[e] - t[e] > i
        ? i + t[e] - this._activeCache.startPos[e]
        : this._activeCache.lastPos[e] - t[e] < 0
        ? t[e] - this._activeCache.startPos[e]
        : this._activeCache.lastPos[e] - this._activeCache.startPos[e];
    }
    eventPosToStagePos(t) {
      var e, i, n;
      const s = null === (e = this.stage) || void 0 === e ? void 0 : e.window.getBoundingClientRect();
      return {
        x:
          t.clientX -
          ((null == s ? void 0 : s.left) || 0) -
          ((null === (i = this.stage) || void 0 === i ? void 0 : i.x) || 0),
        y:
          t.clientY -
          ((null == s ? void 0 : s.top) || 0) -
          ((null === (n = this.stage) || void 0 === n ? void 0 : n.y) || 0)
      };
    }
    _onHandlerPointerUp(t) {
      const { start: e, end: i, brushSelect: n } = this.attribute;
      if (this._activeState && this._activeTag === J$.background) {
        const e = this.eventPosToStagePos(t);
        this.backgroundDragZoom(this._activeCache.startPos, e);
      }
      (this._activeState = !1),
        n && this.renderDragMask(),
        (e === this.state.start && i === this.state.end) ||
          (this.setAttributes({ start: this.state.start, end: this.state.end }),
          this._updateStateCallback && this._updateStateCallback(this.state.start, this.state.end));
    }
    _onHandlerPointerEnter(t) {
      (this._showText = !0), this.renderText();
    }
    _onHandlerPointerLeave(t) {
      (this._showText = !1), this.renderText();
    }
    backgroundDragZoom(t, e) {
      const { attPos: i, max: n } = this._layoutCache,
        { position: s } = this.attribute,
        r = t[i] - s[i],
        a = e[i] - s[i],
        o = Math.min(Math.max(Math.min(r, a) / n, 0), 1),
        l = Math.min(Math.max(Math.max(r, a) / n, 0), 1);
      Math.abs(o - l) < 0.01 ? this.moveZoomWithMiddle(o) : ((this.state.start = o), (this.state.end = l));
    }
    moveZoomWithMiddle(t) {
      let e = t - (this.state.start + this.state.end) / 2;
      0 !== e &&
        (e > 0
          ? this.state.end + e > 1 && (e = 1 - this.state.end)
          : e < 0 && this.state.start + e < 0 && (e = -this.state.start),
        (this.state.start = this.state.start + e),
        (this.state.end = this.state.end + e));
    }
    renderDragMask() {
      const { dragMaskStyle: t } = this.attribute,
        { position: e, width: i, height: n } = this.getLayoutAttrFromConfig();
      this._isHorizontal
        ? (this._dragMask = this._container.createOrUpdateChild(
            'dragMask',
            Object.assign(
              {
                x: pt(
                  this.dragMaskSize() < 0 ? this._activeCache.lastPos.x : this._activeCache.startPos.x,
                  e.x,
                  e.x + i
                ),
                y: e.y,
                width: (this._activeState && this._activeTag === J$.background && Math.abs(this.dragMaskSize())) || 0,
                height: n
              },
              t
            ),
            'rect'
          ))
        : (this._dragMask = this._container.createOrUpdateChild(
            'dragMask',
            Object.assign(
              {
                x: e.x,
                y: pt(
                  this.dragMaskSize() < 0 ? this._activeCache.lastPos.y : this._activeCache.startPos.y,
                  e.y,
                  e.y + n
                ),
                width: i,
                height: (this._activeState && this._activeTag === J$.background && Math.abs(this.dragMaskSize())) || 0
              },
              t
            ),
            'rect'
          ));
    }
    renderText() {
      const { startTextStyle: t, endTextStyle: e } = this.attribute,
        { formatMethod: i } = t,
        n = eX(t, ['formatMethod']),
        { formatMethod: s } = e,
        r = eX(e, ['formatMethod']),
        { start: a, end: o } = this.state;
      (this._startValue = this._statePointToData(a)), (this._endValue = this._statePointToData(o));
      const { position: l, width: h, height: c } = this.getLayoutAttrFromConfig();
      this._isHorizontal
        ? ((this._startText = this.maybeAddLabel(
            this._container,
            D({}, n, {
              text: i ? i(this._startValue) : this._startValue,
              x: l.x + a * h,
              y: l.y + c / 2,
              visible: this._showText,
              pickable: !1,
              childrenPickable: !1,
              textStyle: { textAlign: 'right', textBaseline: 'middle' }
            }),
            `data-zoom-start-text-${l}`
          )),
          (this._endText = this.maybeAddLabel(
            this._container,
            D({}, r, {
              text: s ? s(this._endValue) : this._endValue,
              x: l.x + o * h,
              y: l.y + c / 2,
              visible: this._showText,
              pickable: !1,
              childrenPickable: !1,
              textStyle: { textAlign: 'left', textBaseline: 'middle' }
            }),
            `data-zoom-end-text-${l}`
          )))
        : ((this._startText = this.maybeAddLabel(
            this._container,
            D({}, n, {
              text: i ? i(this._startValue) : this._startValue,
              x: l.x + h / 2,
              y: l.y + a * c,
              visible: this._showText,
              pickable: !1,
              childrenPickable: !1,
              textStyle: { textAlign: 'center', textBaseline: 'bottom' }
            }),
            `data-zoom-start-text-${l}`
          )),
          (this._endText = this.maybeAddLabel(
            this._container,
            D({}, r, {
              text: s ? s(this._endValue) : this._endValue,
              x: l.x + h / 2,
              y: l.y + o * c,
              visible: this._showText,
              pickable: !1,
              childrenPickable: !1,
              textStyle: { textAlign: 'center', textBaseline: 'top' }
            }),
            `data-zoom-end-text-${l}`
          )));
    }
    getLayoutAttrFromConfig() {
      var t, e, i, n;
      if (this._layoutAttrFromConfig) return this._layoutAttrFromConfig;
      const {
          position: s,
          size: r,
          orient: a,
          middleHandlerStyle: o,
          startHandlerStyle: l,
          endHandlerStyle: h
        } = this.attribute,
        { width: c, height: d } = r,
        u =
          null !== (e = null === (t = null == o ? void 0 : o.background) || void 0 === t ? void 0 : t.size) &&
          void 0 !== e
            ? e
            : 10;
      let p, g, f;
      (null == o ? void 0 : o.visible)
        ? this._isHorizontal
          ? ((p = c), (g = d - u), (f = { x: s.x, y: s.y + u }))
          : ((p = c - u), (g = d), (f = { x: s.x + ('left' === a ? u : 0), y: s.y }))
        : ((p = c), (g = d), (f = s));
      const v = null !== (i = null == l ? void 0 : l.size) && void 0 !== i ? i : this._isHorizontal ? g : p,
        m = null !== (n = null == h ? void 0 : h.size) && void 0 !== n ? n : this._isHorizontal ? g : p;
      return (
        (null == l ? void 0 : l.visible) &&
          (this._isHorizontal
            ? ((p -= (v + m) / 2), (f = { x: f.x + v / 2, y: f.y }))
            : ((g -= (v + m) / 2), (f = { x: f.x, y: f.y + v }))),
        (this._layoutAttrFromConfig = { position: f, width: p, height: g }),
        this._layoutAttrFromConfig
      );
    }
    render() {
      var t, e, i, n, s, r, a, o, l, h, c, d, u, p, g, f, v, m, y, _, b;
      this._layoutAttrFromConfig = null;
      const {
          orient: x,
          backgroundStyle: S,
          backgroundChartStyle: w,
          selectedBackgroundStyle: A,
          selectedBackgroundChartStyle: k,
          middleHandlerStyle: M,
          startHandlerStyle: T,
          endHandlerStyle: C,
          brushSelect: E
        } = this.attribute,
        { start: P, end: R } = this.state,
        { position: O, width: B, height: I } = this.getLayoutAttrFromConfig(),
        D = this.createOrUpdateChild('dataZoom-container', {}, 'group');
      (this._container = D),
        (this._background = D.createOrUpdateChild(
          'background',
          Object.assign({ x: O.x, y: O.y, width: B, height: I, cursor: E ? 'crosshair' : 'auto' }, S),
          'rect'
        )),
        (null === (t = null == w ? void 0 : w.line) || void 0 === t ? void 0 : t.visible) &&
          this.setPreviewAttributes('line', D),
        (null === (e = null == w ? void 0 : w.area) || void 0 === e ? void 0 : e.visible) &&
          this.setPreviewAttributes('area', D),
        E && this.renderDragMask(),
        this._isHorizontal
          ? (this._selectedBackground = D.createOrUpdateChild(
              'selectedBackground',
              Object.assign(
                { x: O.x + P * B, y: O.y, width: (R - P) * B, height: I, cursor: E ? 'crosshair' : 'move' },
                A
              ),
              'rect'
            ))
          : (this._selectedBackground = D.createOrUpdateChild(
              'selectedBackground',
              Object.assign(
                { x: O.x, y: O.y + P * I, width: B, height: (R - P) * I, cursor: E ? 'crosshair' : 'move' },
                A
              ),
              'rect'
            )),
        (null === (i = null == k ? void 0 : k.line) || void 0 === i ? void 0 : i.visible) &&
          this.setSelectedPreviewAttributes('line', D),
        (null === (n = null == k ? void 0 : k.area) || void 0 === n ? void 0 : n.visible) &&
          this.setSelectedPreviewAttributes('area', D),
        this.renderText(),
        this._isHorizontal
          ? ((this._startHandler = D.createOrUpdateChild(
              'startHandler',
              Object.assign(
                {
                  x: O.x + P * B,
                  y: O.y + I / 2,
                  size: I,
                  angle: 0,
                  symbolType: null !== (s = null == T ? void 0 : T.symbolType) && void 0 !== s ? s : 'square',
                  cursor: 'ew-resize',
                  strokeBoundsBuffer: 0,
                  boundsPadding: 2,
                  pickMode: 'imprecise'
                },
                T
              ),
              'symbol'
            )),
            (this._endHandler = D.createOrUpdateChild(
              'endHandler',
              Object.assign(
                {
                  x: O.x + R * B,
                  y: O.y + I / 2,
                  size: I,
                  angle: 0,
                  symbolType: null !== (r = null == C ? void 0 : C.symbolType) && void 0 !== r ? r : 'square',
                  cursor: 'ew-resize',
                  strokeBoundsBuffer: 0,
                  boundsPadding: 2,
                  pickMode: 'imprecise'
                },
                C
              ),
              'symbol'
            )),
            (null == M ? void 0 : M.visible) &&
              ((this._middleHandlerRect = D.createOrUpdateChild(
                'middleHandlerRect',
                Object.assign(
                  {
                    x: O.x + P * B,
                    y:
                      O.y -
                      ((null === (a = null == M ? void 0 : M.background) || void 0 === a ? void 0 : a.size) || 10),
                    width: (R - P) * B,
                    height: (null === (o = null == M ? void 0 : M.background) || void 0 === o ? void 0 : o.size) || 10
                  },
                  null === (l = null == M ? void 0 : M.background) || void 0 === l ? void 0 : l.style
                ),
                'rect'
              )),
              (this._middleHandlerSymbol = D.createOrUpdateChild(
                'middleHandlerSymbol',
                Object.assign(
                  {
                    x: O.x + ((P + R) / 2) * B,
                    y:
                      O.y -
                      ((null === (h = null == M ? void 0 : M.background) || void 0 === h ? void 0 : h.size) || 10) / 2,
                    strokeBoundsBuffer: 0,
                    angle: 0,
                    symbolType:
                      null !==
                        (d = null === (c = null == M ? void 0 : M.icon) || void 0 === c ? void 0 : c.symbolType) &&
                      void 0 !== d
                        ? d
                        : 'square'
                  },
                  null == M ? void 0 : M.icon
                ),
                'symbol'
              ))))
          : ((this._startHandler = D.createOrUpdateChild(
              'startHandler',
              Object.assign(
                {
                  x: O.x + B / 2,
                  y: O.y + P * I,
                  size: B,
                  angle: (Math.PI / 180) * 90,
                  symbolType: null !== (u = null == T ? void 0 : T.symbolType) && void 0 !== u ? u : 'square',
                  cursor: 'ns-resize',
                  boundsPadding: 2,
                  pickMode: 'imprecise',
                  strokeBoundsBuffer: 0
                },
                T
              ),
              'symbol'
            )),
            (null == M ? void 0 : M.visible) &&
              ((this._middleHandlerRect = D.createOrUpdateChild(
                'middleHandlerRect',
                Object.assign(
                  {
                    x:
                      'left' === x
                        ? O.x -
                          ((null === (p = null == M ? void 0 : M.background) || void 0 === p ? void 0 : p.size) || 10)
                        : O.x + B,
                    y: O.y + P * I,
                    width: (null === (g = null == M ? void 0 : M.background) || void 0 === g ? void 0 : g.size) || 10,
                    height: (R - P) * I
                  },
                  null === (f = null == M ? void 0 : M.background) || void 0 === f ? void 0 : f.style
                ),
                'rect'
              )),
              (this._middleHandlerSymbol = D.createOrUpdateChild(
                'middleHandlerSymbol',
                Object.assign(
                  {
                    x:
                      'left' === x
                        ? O.x -
                          ((null === (v = null == M ? void 0 : M.background) || void 0 === v ? void 0 : v.size) || 10) /
                            2
                        : O.x +
                          B +
                          ((null === (m = null == M ? void 0 : M.background) || void 0 === m ? void 0 : m.size) || 10) /
                            2,
                    y: O.y + ((P + R) / 2) * I,
                    angle: (Math.PI / 180) * 90,
                    symbolType:
                      null !==
                        (_ = null === (y = null == M ? void 0 : M.icon) || void 0 === y ? void 0 : y.symbolType) &&
                      void 0 !== _
                        ? _
                        : 'square',
                    strokeBoundsBuffer: 0
                  },
                  null == M ? void 0 : M.icon
                ),
                'symbol'
              ))),
            (this._endHandler = D.createOrUpdateChild(
              'endHandler',
              Object.assign(
                {
                  x: O.x + B / 2,
                  y: O.y + R * I,
                  size: B,
                  angle: (Math.PI / 180) * 90,
                  symbolType: null !== (b = null == C ? void 0 : C.symbolType) && void 0 !== b ? b : 'square',
                  cursor: 'ns-resize',
                  boundsPadding: 2,
                  pickMode: 'imprecise',
                  strokeBoundsBuffer: 0
                },
                C
              ),
              'symbol'
            )));
    }
    computeBasePoints() {
      const { orient: t } = this.attribute,
        { position: e, width: i, height: n } = this.getLayoutAttrFromConfig();
      let s, r;
      return (
        this._isHorizontal
          ? ((s = [{ x: e.x, y: e.y + n }]), (r = [{ x: e.x + i, y: e.y + n }]))
          : 'left' === t
          ? ((s = [{ x: e.x + i, y: e.y }]), (r = [{ x: e.x + i, y: e.y + n }]))
          : ((s = [{ x: e.x, y: e.y + n }]), (r = [{ x: e.x, y: e.y }])),
        { basePointStart: s, basePointEnd: r }
      );
    }
    getPreviewLinePoints() {
      const t = this._previewData.map(t => ({
        x: this._previewCallbackX && this._previewCallbackX(t),
        y: this._previewCallbackY && this._previewCallbackY(t)
      }));
      if (0 === t.length) return t;
      const { basePointStart: e, basePointEnd: i } = this.computeBasePoints();
      return e.concat(t).concat(i);
    }
    getPreviewAreaPoints() {
      const t = this._previewData.map(t => ({
        x: this._previewCallbackX && this._previewCallbackX(t),
        y: this._previewCallbackY && this._previewCallbackY(t),
        x1: this._previewCallbackX1 && this._previewCallbackX1(t),
        y1: this._previewCallbackY1 && this._previewCallbackY1(t)
      }));
      if (0 === t.length) return t;
      const { basePointStart: e, basePointEnd: i } = this.computeBasePoints();
      return e.concat(t).concat(i);
    }
    setPreviewAttributes(t, e) {
      this._previewGroup || (this._previewGroup = e.createOrUpdateChild('previewGroup', { pickable: !1 }, 'group')),
        'line' === t
          ? (this._previewLine = this._previewGroup.createOrUpdateChild('previewLine', {}, 'line'))
          : (this._previewArea = this._previewGroup.createOrUpdateChild('previewArea', { curveType: 'basis' }, 'area'));
      const { backgroundChartStyle: i } = this.attribute;
      'line' === t &&
        this._previewLine.setAttributes(
          Object.assign(
            { points: this.getPreviewLinePoints(), curveType: 'basis', pickable: !1 },
            null == i ? void 0 : i.line
          )
        ),
        'area' === t &&
          this._previewArea.setAttributes(
            Object.assign(
              { points: this.getPreviewAreaPoints(), curveType: 'basis', pickable: !1 },
              null == i ? void 0 : i.area
            )
          );
    }
    setSelectedPreviewAttributes(t, e) {
      this._selectedPreviewGroupClip ||
        ((this._selectedPreviewGroupClip = e.createOrUpdateChild(
          'selectedPreviewGroupClip',
          { pickable: !1 },
          'group'
        )),
        (this._selectedPreviewGroup = this._selectedPreviewGroupClip.createOrUpdateChild(
          'selectedPreviewGroup',
          {},
          'group'
        ))),
        'line' === t
          ? (this._selectedPreviewLine = this._selectedPreviewGroup.createOrUpdateChild(
              'selectedPreviewLine',
              {},
              'line'
            ))
          : (this._selectedPreviewArea = this._selectedPreviewGroup.createOrUpdateChild(
              'selectedPreviewArea',
              { curveType: 'basis' },
              'area'
            ));
      const { selectedBackgroundChartStyle: i } = this.attribute,
        { start: n, end: s } = this.state,
        { position: r, width: a, height: o } = this.getLayoutAttrFromConfig();
      this._selectedPreviewGroupClip.setAttributes({
        x: this._isHorizontal ? r.x + n * a : r.x,
        y: this._isHorizontal ? r.y : r.y + n * o,
        width: this._isHorizontal ? (s - n) * a : a,
        height: this._isHorizontal ? o : (s - n) * o,
        clip: !0,
        pickable: !1
      }),
        this._selectedPreviewGroup.setAttributes({
          x: -(this._isHorizontal ? r.x + n * a : r.x),
          y: -(this._isHorizontal ? r.y : r.y + n * o),
          width: this._isHorizontal ? (s - n) * a : a,
          height: this._isHorizontal ? o : (s - n) * o,
          pickable: !1
        }),
        'line' === t &&
          this._selectedPreviewLine.setAttributes(
            Object.assign(
              { points: this.getPreviewLinePoints(), curveType: 'basis', pickable: !1 },
              null == i ? void 0 : i.line
            )
          ),
        'area' === t &&
          this._selectedPreviewArea.setAttributes(
            Object.assign(
              { points: this.getPreviewAreaPoints(), curveType: 'basis', pickable: !1 },
              null == i ? void 0 : i.area
            )
          );
    }
    maybeAddLabel(t, e, i) {
      let n = this.find(t => t.name === i, !0);
      return n ? n.setAttributes(e) : ((n = new BY(e)), (n.name = i)), t.add(n), n;
    }
    setStartAndEnd(t, e) {
      const { start: i, end: n } = this.attribute;
      h(t) &&
        h(e) &&
        (t !== this.state.start || e !== this.state.end) &&
        ((this.state.start = t),
        (this.state.end = e),
        (i === this.state.start && n === this.state.end) ||
          (this.setAttributes({ start: t, end: e }), this._updateStateCallback && this._updateStateCallback(t, e)));
    }
    setPreviewData(t) {
      this._previewData = t;
    }
    setText(t, e) {
      'start' === e ? this._startText.setAttribute('text', t) : this._endText.setAttribute('text', t);
    }
    getStartValue() {
      return this._startValue;
    }
    getEndTextValue() {
      return this._endValue;
    }
    getMiddleHandlerSize() {
      var t, e, i, n;
      const { middleHandlerStyle: s } = this.attribute,
        r =
          null !== (e = null === (t = null == s ? void 0 : s.background) || void 0 === t ? void 0 : t.size) &&
          void 0 !== e
            ? e
            : 10,
        a =
          null !== (n = null === (i = null == s ? void 0 : s.icon) || void 0 === i ? void 0 : i.size) && void 0 !== n
            ? n
            : 10;
      return Math.max(r, ...V(a));
    }
    setUpdateStateCallback(t) {
      o(t) && (this._updateStateCallback = t);
    }
    setPreviewCallbackX(t) {
      o(t) && (this._previewCallbackX = t);
    }
    setPreviewCallbackY(t) {
      o(t) && (this._previewCallbackY = t);
    }
    setPreviewCallbackX1(t) {
      o(t) && (this._previewCallbackX1 = t);
    }
    setPreviewCallbackY1(t) {
      o(t) && (this._previewCallbackY1 = t);
    }
    setStatePointToData(t) {
      o(t) && (this._statePointToData = t);
    }
  };
  var nX, sX, rX;
  (iX.defaultAttributes = {
    orient: 'bottom',
    showDetail: 'auto',
    brushSelect: !0,
    backgroundStyle: { fill: 'white', stroke: '#D1DBEE', lineWidth: 1, cornerRadius: 2 },
    dragMaskStyle: { fill: '#B0C8F9', fillOpacity: 0.2 },
    backgroundChartStyle: {
      area: { visible: !0, stroke: '#D1DBEE', lineWidth: 1, fill: '#F6F8FC' },
      line: { visible: !0, stroke: '#D1DBEE', lineWidth: 1 }
    },
    selectedBackgroundStyle: { fill: '#B0C8F9', fillOpacity: 0.5 },
    selectedBackgroundChartStyle: {
      area: { visible: !0, stroke: '#B0C8F9', lineWidth: 1, fill: '#fbb934' },
      line: { visible: !0, stroke: '#fbb934', lineWidth: 1 }
    },
    middleHandlerStyle: {
      visible: !0,
      background: { size: 8, style: { fill: 'white', stroke: '#B0C8F9', cornerRadius: 2 } },
      icon: {
        size: 6,
        fill: 'white',
        stroke: '#B0C8F9',
        symbolType:
          'M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z',
        lineWidth: 0.5
      }
    },
    startHandlerStyle: {
      visible: !0,
      symbolType:
        'M -0.0544 0.25 C -0.0742 0.25 -0.0901 0.234 -0.0901 0.2143 L -0.0901 -0.1786 C -0.0901 -0.1983 -0.0742 -0.2143 -0.0544 -0.2143 L -0.0187 -0.2143 L -0.0187 -0.5 L 0.017 -0.5 L 0.017 -0.2143 L 0.0527 -0.2143 C 0.0724 -0.2143 0.0884 -0.1983 0.0884 -0.1786 L 0.0884 0.2143 C 0.0884 0.234 0.0724 0.25 0.0527 0.25 L 0.017 0.25 L 0.017 0.5 L -0.0187 0.5 L -0.0187 0.25 L -0.0544 0.25 Z M -0.0187 -0.1429 L -0.0544 -0.1429 L -0.0544 0.1786 L -0.0187 0.1786 L -0.0187 -0.1429 Z M 0.0527 -0.1429 L 0.017 -0.1429 L 0.017 0.1786 L 0.0527 0.1786 L 0.0527 -0.1429 Z',
      fill: 'white',
      stroke: '#B0C8F9',
      lineWidth: 0.5
    },
    endHandlerStyle: {
      visible: !0,
      symbolType:
        'M -0.0544 0.25 C -0.0742 0.25 -0.0901 0.234 -0.0901 0.2143 L -0.0901 -0.1786 C -0.0901 -0.1983 -0.0742 -0.2143 -0.0544 -0.2143 L -0.0187 -0.2143 L -0.0187 -0.5 L 0.017 -0.5 L 0.017 -0.2143 L 0.0527 -0.2143 C 0.0724 -0.2143 0.0884 -0.1983 0.0884 -0.1786 L 0.0884 0.2143 C 0.0884 0.234 0.0724 0.25 0.0527 0.25 L 0.017 0.25 L 0.017 0.5 L -0.0187 0.5 L -0.0187 0.25 L -0.0544 0.25 Z M -0.0187 -0.1429 L -0.0544 -0.1429 L -0.0544 0.1786 L -0.0187 0.1786 L -0.0187 -0.1429 Z M 0.0527 -0.1429 L 0.017 -0.1429 L 0.017 0.1786 L 0.0527 0.1786 L 0.0527 -0.1429 Z',
      fill: 'white',
      stroke: '#B0C8F9',
      lineWidth: 0.5
    },
    startTextStyle: { padding: 4, textStyle: { fontSize: 10, fill: '#6F6F6F' } },
    endTextStyle: { padding: 4, textStyle: { fontSize: 10, fill: '#6F6F6F' } }
  }),
    (function (t) {
      (t.start = 'start'),
        (t.middle = 'middle'),
        (t.end = 'end'),
        (t.insideStartTop = 'insideStartTop'),
        (t.insideStartBottom = 'insideStartBottom'),
        (t.insideMiddleTop = 'insideMiddleTop'),
        (t.insideMiddleBottom = 'insideMiddleBottom'),
        (t.insideEndTop = 'insideEndTop'),
        (t.insideEndBottom = 'insideEndBottom');
    })(nX || (nX = {})),
    (function (t) {
      (t.left = 'left'),
        (t.right = 'right'),
        (t.top = 'top'),
        (t.bottom = 'bottom'),
        (t.middle = 'middle'),
        (t.insideLeft = 'insideLeft'),
        (t.insideRight = 'insideRight'),
        (t.insideTop = 'insideTop'),
        (t.insideBottom = 'insideBottom');
    })(sX || (sX = {})),
    (function (t) {
      (t.top = 'top'),
        (t.bottom = 'bottom'),
        (t.middle = 'middle'),
        (t.insideTop = 'insideTop'),
        (t.insideBottom = 'insideBottom'),
        (t.insideMiddle = 'insideMiddle');
    })(rX || (rX = {}));
  class aX extends uY {
    constructor() {
      super(...arguments), (this.name = 'marker');
    }
    _initContainer() {
      var t, e;
      const { limitRect: i, clipInRange: n } = this.attribute;
      let s;
      if (n) {
        const n = QO(Object.assign(Object.assign({}, i), { clip: !0, pickable: !1 }));
        (s = QO({
          x: -(null !== (t = null == i ? void 0 : i.x) && void 0 !== t ? t : 0),
          y: -(null !== (e = null == i ? void 0 : i.y) && void 0 !== e ? e : 0)
        })),
          n.add(s),
          (this._containerClip = n),
          this.add(n);
      } else (s = QO({ x: 0, y: 0 })), this.add(s);
      (s.name = 'marker-container'), (this._container = s);
    }
    _updateContainer() {
      var t, e, i;
      const { limitRect: n, clipInRange: s } = this.attribute;
      null === (t = this._containerClip) || void 0 === t || t.setAttributes(Object.assign({}, n)),
        this._container.setAttributes({
          x: s ? -(null !== (e = null == n ? void 0 : n.x) && void 0 !== e ? e : 0) : 0,
          y: s ? -(null !== (i = null == n ? void 0 : n.y) && void 0 !== i ? i : 0) : 0
        });
    }
    render() {
      var t, e;
      const i = null === (t = this.attribute.visible) || void 0 === t || t;
      (null !== (e = this.attribute.interactive) && void 0 !== e && e) ||
        (this.setAttribute('pickable', !1), this.setAttribute('childrenPickable', !1)),
        i &&
          (this._container
            ? (this._updateContainer(), this.updateMarker())
            : (this._initContainer(), this.initMarker(this._container)));
    }
  }
  const oX = {
      startSymbol: { visible: !1, symbolType: 'triangle', size: 12, fill: 'rgba(46, 47, 50)', lineWidth: 0 },
      endSymbol: { visible: !0, symbolType: 'triangle', size: 12, fill: 'rgba(46, 47, 50)', lineWidth: 0 },
      label: {
        position: nX.end,
        refX: 0,
        refY: 0,
        refAngle: 0,
        textStyle: {
          fill: '#fff',
          stroke: '#fff',
          lineWidth: 0,
          fontSize: 10,
          fontWeight: 'normal',
          fontStyle: 'normal'
        },
        padding: [2, 2, 4, 4],
        panel: { visible: !0, cornerRadius: 0, fill: 'rgb(48, 115, 242)', fillOpacity: 0.8 }
      },
      lineStyle: { stroke: '#b2bacf', lineWidth: 1, lineDash: [2] }
    },
    lX = {
      start: { textAlign: 'right', textBaseline: 'middle' },
      insideStartTop: { textAlign: 'left', textBaseline: 'bottom' },
      insideStartBottom: { textAlign: 'left', textBaseline: 'top' },
      middle: { textAlign: 'center', textBaseline: 'middle' },
      insideMiddleTop: { textAlign: 'center', textBaseline: 'bottom' },
      insideMiddleBottom: { textAlign: 'center', textBaseline: 'top' },
      end: { textAlign: 'left', textBaseline: 'middle' },
      insideEndTop: { textAlign: 'right', textBaseline: 'bottom' },
      insideEndBottom: { textAlign: 'right', textBaseline: 'top' }
    },
    hX = {
      label: {
        position: sX.right,
        textStyle: {
          fill: '#fff',
          stroke: '#fff',
          lineWidth: 0,
          fontSize: 10,
          fontWeight: 'normal',
          fontStyle: 'normal'
        },
        padding: [2, 2, 4, 4],
        panel: { visible: !0, cornerRadius: 0, fill: 'rgb(48, 115, 242)', fillOpacity: 0.8 }
      },
      areaStyle: { fill: '#b2bacf', visible: !0 }
    },
    cX = {
      left: { textAlign: 'right', textBaseline: 'middle' },
      insideLeft: { textAlign: 'left', textBaseline: 'middle' },
      right: { textAlign: 'left', textBaseline: 'middle' },
      insideRight: { textAlign: 'right', textBaseline: 'middle' },
      top: { textAlign: 'center', textBaseline: 'bottom' },
      insideTop: { textAlign: 'center', textBaseline: 'top' },
      bottom: { textAlign: 'center', textBaseline: 'top' },
      insideBottom: { textAlign: 'center', textBaseline: 'bottom' },
      middle: { textAlign: 'center', textBaseline: 'middle' }
    },
    dX = {
      top: { textAlign: 'left', textBaseline: 'bottom' },
      bottom: { textAlign: 'left', textBaseline: 'top' },
      middle: { textAlign: 'left', textBaseline: 'middle' },
      insideTop: { textAlign: 'right', textBaseline: 'bottom' },
      insideBottom: { textAlign: 'right', textBaseline: 'top' },
      insideMiddle: { textAlign: 'right', textBaseline: 'middle' }
    };
  function uX(t, e) {
    const { x1: i, y1: n, x2: s, y2: r } = e,
      { x1: a, y1: o, x2: l, y2: h } = t.AABBBounds,
      { dx: c = 0, dy: d = 0 } = t.attribute;
    let u = 0,
      p = 0;
    a < i && (u = i - a),
      o < n && (p = n - o),
      l > s && (u = s - l),
      h > r && (p = r - h),
      u && t.setAttribute('dx', u + c),
      p && t.setAttribute('dy', p + d);
  }
  let pX = class t extends aX {
    constructor(e) {
      super(D({}, t.defaultAttributes, e));
    }
    setLabelPos() {
      var t, e;
      const { label: i = {}, limitRect: n } = this.attribute,
        { position: s = 'end', refX: r = 0, refY: a = 0, confine: o } = i,
        l = this._line.getMainSegmentPoints(),
        h = null !== (t = this._line.getEndAngle()) && void 0 !== t ? t : 0,
        c = r * Math.cos(h) + a * Math.cos(h - Math.PI / 2),
        d = r * Math.sin(h) + a * Math.sin(h - Math.PI / 2);
      let u;
      if (
        ((u =
          s.includes('start') || s.includes('Start')
            ? { x: l[0].x + c, y: l[0].y + d }
            : s.includes('middle') || s.includes('Middle')
            ? { x: (l[0].x + l[l.length - 1].x) / 2 + c, y: (l[0].y + l[l.length - 1].y) / 2 + d }
            : { x: l[l.length - 1].x + c, y: l[l.length - 1].y + d }),
        this._label.setAttributes(
          Object.assign(Object.assign({}, u), {
            angle: i.autoRotate ? h + (null !== (e = null == i ? void 0 : i.refAngle) && void 0 !== e ? e : 0) : 0,
            textStyle: Object.assign(Object.assign({}, lX[s]), i.textStyle)
          })
        ),
        n && o)
      ) {
        const { x: t, y: e, width: i, height: s } = n;
        uX(this._label, { x1: t, y1: e, x2: t + i, y2: e + s });
      }
    }
    initMarker(t) {
      const {
          points: e,
          startSymbol: i,
          endSymbol: n,
          label: s,
          lineStyle: r,
          mainSegmentIndex: a,
          multiSegment: o
        } = this.attribute,
        l = new w$({ points: e, startSymbol: i, endSymbol: n, lineStyle: r, mainSegmentIndex: a, multiSegment: o });
      (l.name = 'mark-line-line'), (this._line = l), t.add(l);
      const h = new BY(Object.assign({}, s));
      (h.name = 'mark-line-label'), (this._label = h), t.add(h), this.setLabelPos();
    }
    updateMarker() {
      var t, e;
      const {
        points: i,
        startSymbol: n,
        endSymbol: s,
        label: r,
        lineStyle: a,
        mainSegmentIndex: o,
        multiSegment: l
      } = this.attribute;
      null === (t = this._line) ||
        void 0 === t ||
        t.setAttributes({
          points: i,
          startSymbol: n,
          endSymbol: s,
          lineStyle: a,
          mainSegmentIndex: o,
          multiSegment: l
        }),
        null === (e = this._label) || void 0 === e || e.setAttributes(Object.assign({ dx: 0, dy: 0 }, r)),
        this.setLabelPos();
    }
  };
  pX.defaultAttributes = oX;
  let gX = class t extends aX {
    constructor(e) {
      super(D({}, t.defaultAttributes, e));
    }
    _getPositionByDirection(t, e) {
      const { x1: i, x2: n, y1: s, y2: r } = this._area.AABBBounds;
      return e.includes('left') || e.includes('Left')
        ? { x: i, y: (s + r) / 2 }
        : e.includes('right') || e.includes('Right')
        ? { x: n, y: (s + r) / 2 }
        : e.includes('top') || e.includes('Top')
        ? { x: (i + n) / 2, y: s }
        : e.includes('bottom') || e.includes('Bottom')
        ? { x: (i + n) / 2, y: r }
        : { x: (i + n) / 2, y: (s + r) / 2 };
    }
    setLabelPos() {
      var t;
      if (this._label && this._area) {
        const { label: e } = this.attribute,
          i = null !== (t = null == e ? void 0 : e.position) && void 0 !== t ? t : 'middle',
          n = this._getPositionByDirection(this._area, i);
        if (
          (this._label.setAttributes(
            Object.assign(Object.assign({}, n), { textStyle: Object.assign(Object.assign({}, cX[i]), e.textStyle) })
          ),
          this.attribute.limitRect && (null == e ? void 0 : e.confine))
        ) {
          const { x: t, y: e, width: i, height: n } = this.attribute.limitRect;
          uX(this._label, { x1: t, y1: e, x2: t + i, y2: e + n });
        }
      }
    }
    initMarker(t) {
      const { points: e, label: i, areaStyle: n } = this.attribute,
        s = oB(Object.assign({ points: e }, n));
      (s.name = 'mark-area-area'), (this._area = s), t.add(s);
      const r = new BY(Object.assign({}, i));
      (r.name = 'mark-area-label'), (this._label = r), t.add(r), this.setLabelPos();
    }
    updateMarker() {
      var t, e;
      const { points: i, label: n, areaStyle: s } = this.attribute;
      null === (t = this._area) || void 0 === t || t.setAttributes(Object.assign({ points: i }, s)),
        null === (e = this._label) || void 0 === e || e.setAttributes(Object.assign({ dx: 0, dy: 0 }, n)),
        this.setLabelPos();
    }
  };
  gX.defaultAttributes = hX;
  let fX = class t extends aX {
    constructor(e) {
      super(D({}, t.defaultAttributes, e));
    }
    setLabelPos() {}
    setItemAttributes(t, e, i, n) {
      var s;
      if (!t) return;
      const {
          autoRotate: r = !0,
          refX: a = 0,
          refY: o = 0,
          refAngle: l = 0,
          textStyle: h,
          richTextStyle: c,
          imageStyle: d,
          position: u = rX.middle
        } = e,
        p = (null === (s = this._line) || void 0 === s ? void 0 : s.getEndAngle()) || 0,
        g = a * Math.cos(p) + o * Math.cos(p - Math.PI / 2),
        f = a * Math.sin(p) + o * Math.sin(p - Math.PI / 2);
      'text' === n
        ? t.setAttributes(
            Object.assign(Object.assign({}, h), {
              textStyle: Object.assign(
                Object.assign({}, dX[(null == e ? void 0 : e.position) || 'end']),
                null == h ? void 0 : h.textStyle
              )
            })
          )
        : 'richText' === n
        ? t.setAttributes({
            dx: this.getItemDx(t, u, c) + ((null == c ? void 0 : c.dx) || 0),
            dy: this.getItemDy(t, u, c) + ((null == c ? void 0 : c.dy) || 0)
          })
        : 'image' === n &&
          t.setAttributes({
            dx: this.getItemDx(t, u, d) + ((null == d ? void 0 : d.dx) || 0),
            dy: this.getItemDy(t, u, d) + ((null == d ? void 0 : d.dy) || 0)
          }),
        t.setAttributes({ x: i.x + (g || 0), y: i.y + (f || 0), angle: r && p + l });
    }
    getItemDx(t, e, i) {
      var n, s;
      const r =
        null !== (s = null === (n = null == t ? void 0 : t.AABBBounds) || void 0 === n ? void 0 : n.width()) &&
        void 0 !== s
          ? s
          : (null == i ? void 0 : i.width) || 0;
      return e.includes('inside') ? -r : 0;
    }
    getItemDy(t, e, i) {
      var n, s;
      const r =
        null !== (s = null === (n = null == t ? void 0 : t.AABBBounds) || void 0 === n ? void 0 : n.height()) &&
        void 0 !== s
          ? s
          : (null == i ? void 0 : i.height) || 0;
      return e.includes('top') || e.includes('Top') ? -r : e.includes('middle') || e.includes('Middle') ? -r / 2 : 0;
    }
    initItem(t, e) {
      const { type: i = 'text', symbolStyle: n, richTextStyle: s, imageStyle: r, renderCustomCallback: a } = t;
      let o;
      return (
        'symbol' === i
          ? (o = rB(Object.assign(Object.assign({}, e), n)))
          : 'text' === i
          ? (o = new BY(Object.assign({}, e)))
          : 'richText' === i
          ? (o = lB(Object.assign(Object.assign({}, e), s)))
          : 'image' === i
          ? (o = aB(Object.assign(Object.assign({}, e), r)))
          : 'custom' === i && a && (o = a()),
        this.setItemAttributes(o, t, e, i),
        o
      );
    }
    getItemLineAttr(t, e, i) {
      let n = [];
      const { type: s = 'type-s' } = t;
      return (
        (n =
          'type-do' === s
            ? [e, { x: (e.x + i.x) / 2, y: i.y }, i]
            : 'type-po' === s
            ? [e, { x: i.x, y: e.y }, i]
            : 'type-op' === s
            ? [e, { x: e.x, y: i.y }, i]
            : [e, i]),
        n
      );
    }
    setItemLineAttr(t, e, i, n) {
      var s;
      const { startSymbol: r, endSymbol: a, lineStyle: o } = t,
        l = this.getItemLineAttr(t, e, i);
      null === (s = this._line) ||
        void 0 === s ||
        s.setAttributes({ points: l, startSymbol: r, endSymbol: a, lineStyle: o, visible: n });
    }
    getDecorativeLineAttr(t, e) {
      var i;
      const n = (null === (i = null == t ? void 0 : t.decorativeLine) || void 0 === i ? void 0 : i.length) || 10,
        s = this._line.getEndAngle() || 0;
      return {
        startPointOffsetX: (n / 2) * Math.cos(s - Math.PI / 2),
        startPointOffsetY: (n / 2) * Math.sin(s - Math.PI / 2),
        endPointOffsetX: (-n / 2) * Math.cos(s - Math.PI / 2),
        endPointOffsetY: (-n / 2) * Math.sin(s - Math.PI / 2)
      };
    }
    setDecorativeLineAttr(t, e, i) {
      var n;
      const { lineStyle: s } = t,
        {
          startPointOffsetX: r,
          startPointOffsetY: a,
          endPointOffsetX: o,
          endPointOffsetY: l
        } = this.getDecorativeLineAttr(t, e);
      null === (n = this._decorativeLine) ||
        void 0 === n ||
        n.setAttributes(
          Object.assign(
            Object.assign(
              {
                points: [
                  { x: e.x + r, y: e.y + a },
                  { x: e.x + o, y: e.y + l }
                ]
              },
              s
            ),
            { visible: i }
          )
        );
    }
    initMarker(t) {
      var e;
      const { position: i, itemLine: n, itemContent: s } = this.attribute,
        r = { x: i.x + ((null == s ? void 0 : s.offsetX) || 0), y: i.y + ((null == s ? void 0 : s.offsetY) || 0) },
        a = new w$({ points: [] });
      (a.name = 'mark-point-line'), (this._line = a), t.add(a);
      const o = tB({ points: [] });
      (o.name = 'mark-point-decorativeLine'),
        (this._decorativeLine = o),
        t.add(o),
        this.setItemLineAttr(n, i, r, null == n ? void 0 : n.visible),
        this.setDecorativeLineAttr(
          n,
          r,
          null === (e = null == n ? void 0 : n.decorativeLine) || void 0 === e ? void 0 : e.visible
        );
      const l = this.initItem(s, r);
      (this._item = l), t.add(l);
    }
    updateMarker() {
      var t;
      const { position: e, itemLine: i, itemContent: n } = this.attribute,
        { type: s = 'text' } = n,
        r = { x: e.x + ((null == n ? void 0 : n.offsetX) || 0), y: e.y + ((null == n ? void 0 : n.offsetY) || 0) };
      this.setItemLineAttr(i, e, r, null == i ? void 0 : i.visible),
        this.setDecorativeLineAttr(
          i,
          r,
          null === (t = null == i ? void 0 : i.decorativeLine) || void 0 === t ? void 0 : t.visible
        ),
        this.setItemAttributes(this._item, n, r, s);
    }
  };
  fX.defaultAttributes = {
    itemLine: {
      visible: !0,
      decorativeLine: { visible: !1, length: 30 },
      startSymbol: {
        visible: !0,
        clip: !0,
        symbolType: 'circle',
        size: 20,
        style: { fill: !1, stroke: 'rgba(46, 47, 50)' }
      },
      endSymbol: {
        visible: !1,
        clip: !0,
        symbolType: 'triangle',
        size: 12,
        style: { fill: !1, stroke: 'rgba(46, 47, 50)' }
      },
      lineStyle: { stroke: '#000', lineWidth: 1 }
    },
    itemContent: {
      type: 'text',
      position: 'middle',
      refX: 10,
      symbolStyle: { symbolType: 'star', fill: 'rgb(48, 115, 242)', fillOpacity: 0.8, size: 20 },
      textStyle: { dx: 0, dy: 0 },
      imageStyle: { width: 80, height: 80 },
      richTextStyle: { width: 100, height: 100 }
    }
  };
  const vX = {
    space: 8,
    style: { fill: 'rgb(47, 69, 84)', cursor: 'pointer', size: 15 },
    state: { disable: { fill: 'rgb(170, 170, 170)', cursor: 'not-allowed' }, hover: {} }
  };
  class mX extends uY {
    getCurrent() {
      return this._current;
    }
    constructor(t) {
      super(D({}, mX.defaultAttributes, t)),
        (this.name = 'pager'),
        (this._current = 1),
        (this._onHover = t => {
          const e = t.target;
          e.hasState('disable') || e.addState('hover');
        }),
        (this._onUnHover = t => {
          t.target.removeState('hover');
        }),
        (this._onClick = t => {
          var e, i;
          const n = t.target;
          if ('preHandler' === n.name) {
            if (1 === this._current) return;
            (this._current -= 1), 1 === this._current ? n.addState('disable') : n.removeState('disable');
            const i = new rM('toPrev', { current: this._current, total: this._total, direction: 'pre', event: t });
            (i.manager = null === (e = this.stage) || void 0 === e ? void 0 : e.eventSystem.manager),
              this.dispatchEvent(i);
          }
          if ('nextHandler' === n.name) {
            if (this._current === this._total) return;
            (this._current += 1), this._current === this._total ? n.addState('disable') : n.removeState('disable');
            const e = new rM('toNext', { current: this._current, total: this._total, direction: 'next', event: t });
            (e.manager = null === (i = this.stage) || void 0 === i ? void 0 : i.eventSystem.manager),
              this.dispatchEvent(e);
          }
          this._current > 1 && this.preHandler.removeState('disable'),
            this._current < this._total && this.nextHandler.removeState('disable'),
            this.text.setAttribute('text', `${this._current}/${this._total}`);
        });
    }
    render() {
      var t;
      this._reset();
      const {
        layout: e = 'horizontal',
        handler: i = vX,
        total: n,
        defaultCurrent: s = 1,
        textStyle: r,
        padding: a = 0
      } = this.attribute;
      this._current = s;
      const o = Je(a),
        l = 'horizontal' === e,
        h = QO({ x: 0, y: 0 }),
        c = i.style || {},
        d = c.size || 15,
        u = null !== (t = i.space) && void 0 !== t ? t : 8,
        p = i.state || {};
      let { preShape: g, nextShape: f } = i;
      g || (g = l ? 'triangleLeft' : 'triangleUp'), f || (f = l ? 'triangleRight' : 'triangleDown');
      const v = rB(
        Object.assign(Object.assign({ strokeBoundsBuffer: 0, pickMode: 'imprecise' }, c), {
          x: 0,
          y: 0,
          symbolType: g,
          size: d
        })
      );
      (v.states = p), (v.name = 'preHandler'), (this.preHandler = v), h.add(v);
      const { width: m, height: _ } = RY(
          `${n}/${n}`,
          Object.assign({ textAlign: 'center', textBaseline: 'middle' }, r)
        ),
        b = y(d) ? d : d[0],
        x = y(d) ? d : d[1],
        S = sB(
          Object.assign(
            {
              x: l ? b / 2 + u + m / 2 : 0,
              y: l ? 0 : x / 2 + u + _ / 2,
              text: `${s}/${n}`,
              textAlign: 'center',
              textBaseline: 'middle',
              lineHeight: null == r ? void 0 : r.fontSize
            },
            r
          )
        );
      (this.text = S), h.add(S);
      const w = rB(
        Object.assign(Object.assign({ strokeBoundsBuffer: 0, pickMode: 'imprecise' }, c), {
          x: l ? b + 2 * u + m : 0,
          y: l ? 0 : x + 2 * u + _,
          symbolType: f,
          size: d
        })
      );
      (w.name = 'nextHandler'),
        (w.states = p),
        (this.nextHandler = w),
        h.add(w),
        1 === this._total
          ? (v.addState('disable'), w.addState('disable'))
          : 1 === this._current
          ? v.addState('disable')
          : this._current === n && w.addState('disable');
      const A = h.AABBBounds,
        k = A.width(),
        M = A.height();
      h.translateTo(0 - A.x1 + o[3], 0 - A.y1 + o[0]),
        this.add(h),
        (this.attribute.width = k + o[1] + o[3]),
        (this.attribute.height = M + o[0] + o[2]),
        this._bindEvents();
    }
    _bindEvents() {
      this.preHandler &&
        (this.preHandler.addEventListener('pointerenter', this._onHover),
        this.preHandler.addEventListener('pointerleave', this._onUnHover),
        this.preHandler.addEventListener('pointerdown', this._onClick)),
        this.nextHandler &&
          (this.nextHandler.addEventListener('pointerenter', this._onHover),
          this.nextHandler.addEventListener('pointerleave', this._onUnHover),
          this.nextHandler.addEventListener('pointerdown', this._onClick));
    }
    _reset() {
      this.removeAllChild(),
        (this._current = 1),
        (this._total = this.attribute.total),
        (this.preHandler = this.nextHandler = this.text = null);
    }
  }
  mX.defaultAttributes = { handler: vX, textStyle: { fill: 'rgb(51, 51, 51)', fontSize: 12 } };
  const yX = 16,
    _X = 8,
    bX = 12;
  var xX, SX, wX;
  !(function (t) {
    (t.selected = 'selected'),
      (t.unSelected = 'unSelected'),
      (t.selectedHover = 'selectedHover'),
      (t.unSelectedHover = 'unSelectedHover'),
      (t.focus = 'focus');
  })(xX || (xX = {})),
    (function (t) {
      (t.legendItemHover = 'legendItemHover'),
        (t.legendItemUnHover = 'legendItemUnHover'),
        (t.legendItemClick = 'legendItemClick'),
        (t.legendItemAttributeUpdate = 'legendItemAttributeUpdate');
    })(SX || (SX = {})),
    (function (t) {
      (t.innerView = 'innerView'),
        (t.title = 'legendTitle'),
        (t.item = 'legendItem'),
        (t.itemShape = 'legendItemShape'),
        (t.itemLabel = 'legendItemLabel'),
        (t.itemValue = 'legendItemValue'),
        (t.focus = 'legendItemFocus');
    })(wX || (wX = {}));
  class AX extends uY {
    constructor() {
      super(...arguments), (this.name = 'legend'), (this._title = null);
    }
    render() {
      this.removeAllChild();
      const { interactive: t = !0, title: e, padding: i = 0 } = this.attribute,
        n = Je(i),
        s = QO({ x: n[3], y: n[0], pickable: t, childrenPickable: t });
      (s.name = wX.innerView),
        this.add(s),
        (this._innerView = s),
        (null == e ? void 0 : e.visible) && this._renderTitle(e),
        this._renderContent(),
        this._adjustLayout(),
        t && this._bindEvents();
      const r = this._innerView.AABBBounds;
      (this.attribute.width = r.width() + n[1] + n[3]), (this.attribute.height = r.height() + n[0] + n[2]);
    }
    _renderTitle(t) {
      const { text: e = '', textStyle: i, padding: n = 0, background: s, minWidth: r, maxWidth: a, shape: o } = t,
        l = { x: 0, y: 0, text: e, textStyle: i, padding: Je(n), minWidth: r, maxWidth: a };
      o && o.visible && ((l.shape = Object.assign({ visible: !0 }, o.style)), h(o.space) && (l.space = o.space)),
        s && s.visible && (l.panel = Object.assign({ visible: !0 }, s.style));
      const c = new BY(l);
      (c.name = wX.title), (this._title = c), this._innerView.add(c);
    }
    _adjustLayout() {
      var t;
      if (this._title) {
        const e = this._innerView.AABBBounds.width(),
          i = this._title.AABBBounds.width(),
          n = null === (t = this.attribute.title) || void 0 === t ? void 0 : t.align;
        'center' === n
          ? this._title.setAttribute('x', (e - i) / 2)
          : 'end' === n && this._title.setAttribute('x', e - i);
      }
    }
  }
  var kX = function (t, e) {
    var i = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
    if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
      var s = 0;
      for (n = Object.getOwnPropertySymbols(t); s < n.length; s++)
        e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (i[n[s]] = t[n[s]]);
    }
    return i;
  };
  const MX = {
    [xX.focus]: {},
    [xX.selected]: {},
    [xX.selectedHover]: {},
    [xX.unSelected]: {},
    [xX.unSelectedHover]: {}
  };
  let TX = class t extends AX {
    constructor(e) {
      super(D({}, t.defaultAttributes, e)),
        (this.name = 'discreteLegend'),
        (this._itemsContainer = null),
        (this._itemHeightByUser = void 0),
        (this._itemHeight = 0),
        (this._itemMaxWidth = 0),
        (this._onHover = t => {
          var e;
          const i = t.target;
          if (null === (e = null == i ? void 0 : i.name) || void 0 === e ? void 0 : e.startsWith(wX.item)) {
            const e = i.delegate;
            e.hasState(xX.selected)
              ? this._setLegendItemState(e, xX.selectedHover, t)
              : this._setLegendItemState(e, xX.unSelectedHover, t);
            const n = e.getChildren()[0].find(t => t.name === wX.focus, !1);
            n && n.setAttribute('visible', !0), this._dispatchEvent(SX.legendItemHover, e, t);
          }
        }),
        (this._onUnHover = t => {
          var e;
          const i = t.target;
          if (null === (e = null == i ? void 0 : i.name) || void 0 === e ? void 0 : e.startsWith(wX.item)) {
            const e = i.delegate;
            let n = !1;
            (e.hasState(xX.unSelectedHover) || e.hasState(xX.selectedHover)) && (n = !0),
              e.removeState(xX.unSelectedHover),
              e.removeState(xX.selectedHover),
              e
                .getChildren()[0]
                .getChildren()
                .forEach(t => {
                  n || (!t.hasState(xX.unSelectedHover) && !t.hasState(xX.selectedHover)) || (n = !0),
                    t.removeState(xX.unSelectedHover),
                    t.removeState(xX.selectedHover);
                });
            const s = e.getChildren()[0].find(t => t.name === wX.focus, !1);
            s && s.setAttribute('visible', !1),
              n && this._dispatchEvent(SX.legendItemAttributeUpdate, e, t),
              this._dispatchEvent(SX.legendItemUnHover, e, t);
          }
        }),
        (this._onClick = t => {
          var e, i, n, s, r;
          const a = t.target;
          if (null === (e = null == a ? void 0 : a.name) || void 0 === e ? void 0 : e.startsWith(wX.item)) {
            const e = a.delegate;
            if (a.name === wX.focus) {
              const s = e.hasState(xX.focus);
              e.toggleState(xX.focus),
                s
                  ? null === (i = this._itemsContainer) ||
                    void 0 === i ||
                    i.getChildren().forEach(e => {
                      this._removeLegendItemState(e, [xX.unSelected, xX.unSelectedHover, xX.focus], t),
                        this._setLegendItemState(e, xX.selected, t);
                    })
                  : (this._setLegendItemState(e, xX.selected, t),
                    this._removeLegendItemState(e, [xX.unSelected, xX.unSelectedHover], t),
                    null === (n = this._itemsContainer) ||
                      void 0 === n ||
                      n.getChildren().forEach(i => {
                        e !== i &&
                          (this._removeLegendItemState(i, [xX.selected, xX.selectedHover, xX.focus], t),
                          this._setLegendItemState(i, xX.unSelected, t));
                      }));
            } else {
              null === (s = this._itemsContainer) ||
                void 0 === s ||
                s.getChildren().forEach(t => {
                  t.removeState(xX.focus);
                });
              const { selectMode: i = 'multiple', allowAllCanceled: n = !0 } = this.attribute,
                a = e.hasState(xX.selected),
                o = this._getSelectedLegends();
              if ('multiple' === i) {
                if (!1 === n && a && 1 === o.length) return void this._dispatchEvent(SX.legendItemClick, e, t);
                a
                  ? (this._removeLegendItemState(e, [xX.selected, xX.selectedHover], t),
                    this._setLegendItemState(e, xX.unSelected, t))
                  : (this._setLegendItemState(e, xX.selected, t),
                    this._removeLegendItemState(e, [xX.unSelected, xX.unSelectedHover], t));
              } else
                this._setLegendItemState(e, xX.selected, t),
                  this._removeLegendItemState(e, [xX.unSelected, xX.unSelectedHover], t),
                  null === (r = this._itemsContainer) ||
                    void 0 === r ||
                    r.getChildren().forEach(i => {
                      e !== i &&
                        (this._removeLegendItemState(i, [xX.selected, xX.selectedHover], t),
                        this._setLegendItemState(i, xX.unSelected, t));
                    });
            }
            this._dispatchEvent(SX.legendItemClick, e, t);
          }
        });
    }
    setSelected(t) {
      var e;
      (null === (e = this._itemsContainer) || void 0 === e ? void 0 : e.getChildren()).forEach(e => {
        const i = e.data;
        t.includes(i.label)
          ? (this._setLegendItemState(e, xX.selected),
            this._removeLegendItemState(e, [xX.unSelected, xX.unSelectedHover]))
          : (this._removeLegendItemState(e, [xX.selected, xX.selectedHover]),
            this._setLegendItemState(e, xX.unSelected));
      });
    }
    _renderContent() {
      const { item: t = {}, items: e, reversed: i, maxCol: n = 1, maxRow: s = 2 } = this.attribute;
      if (!1 === t.visible || T(e)) return;
      let r = e;
      i && (r = null == e ? void 0 : e.reverse());
      const a = QO({ x: 0, y: 0 });
      this._itemsContainer = a;
      const { layout: o, maxWidth: l, maxHeight: c, defaultSelected: d = [], autoPage: u } = this.attribute,
        p = 'horizontal' === o,
        { spaceCol: g = yX, spaceRow: f = _X, maxWidth: v, width: m, height: y } = t;
      h(v)
        ? h(m)
          ? (this._itemWidthByUser = Math.min(v, m))
          : (this._itemWidthByUser = v)
        : h(m) && (this._itemWidthByUser = m),
        h(y) && (this._itemHeightByUser = y);
      let _ = !1,
        b = 0,
        x = 0,
        S = 0,
        w = 1,
        A = 1;
      r.forEach((t, e) => {
        t.id || (t.id = t.label), (t.index = e);
        const i = this._renderEachItem(t, !!T(d) || (null == d ? void 0 : d.includes(t.label)), e, r),
          o = i.attribute.width,
          u = i.attribute.height;
        (this._itemHeight = Math.max(this._itemHeight, u)),
          (b = Math.max(o, b)),
          (this._itemMaxWidth = Math.max(o, this._itemMaxWidth)),
          p
            ? ((w = s),
              h(l) &&
                (o >= l
                  ? ((_ = !0), e > 0 && ((x = 0), (S += u + f), (A += 1)))
                  : l < x + o && ((_ = !0), (x = 0), (S += u + f), (A += 1))),
              e > 0 && i.setAttributes({ x: x, y: S }),
              (x += g + o))
            : ((w = n),
              h(c) && c < S + u && ((_ = !0), (S = 0), (x += b + g), (b = 0), (A += 1)),
              e > 0 && i.setAttributes({ x: x, y: S }),
              (S += f + u)),
          a.add(i);
      });
      let k = !1;
      _ && u && A > w && (k = this._renderPager(p)),
        k ||
          (a.setAttribute('y', this._title ? this._title.AABBBounds.height() + C(this.attribute, 'title.space', 8) : 0),
          this._innerView.add(a));
    }
    _bindEvents() {
      if (!this._itemsContainer) return;
      const { hover: t = !0, select: e = !0 } = this.attribute;
      t &&
        (this._itemsContainer.addEventListener('pointermove', this._onHover),
        this._itemsContainer.addEventListener('pointerout', this._onUnHover)),
        e && this._itemsContainer.addEventListener('pointerdown', this._onClick);
    }
    _renderEachItem(t, e, i, n) {
      const { id: s, label: r, value: a, shape: o } = t,
        { padding: c = 0, focus: d, focusIconStyle: u = {} } = this.attribute.item;
      let { shape: p = {}, label: g = {}, value: f = {}, background: v = {} } = this.attribute.item;
      (p = this._handleStyle(p, t, e, i, n)),
        (g = this._handleStyle(g, t, e, i, n)),
        (f = this._handleStyle(f, t, e, i, n)),
        (v = this._handleStyle(v, t, e, i, n));
      const m = Je(c);
      let y;
      !1 === v.visible
        ? ((y = QO({ x: 0, y: 0, cursor: (null == v ? void 0 : v.style).cursor })),
          this._appendDataToShape(y, wX.item, t, y))
        : ((y = QO(Object.assign({ x: 0, y: 0 }, null == v ? void 0 : v.style))),
          this._appendDataToShape(y, wX.item, t, y, null == v ? void 0 : v.state)),
        y.addState(e ? xX.selected : xX.unSelected);
      const _ = QO({ x: 0, y: 0, pickable: !1 });
      y.add(_);
      let b = 0;
      const x = C(p, 'style.size', 10),
        S = C(p, 'space', 8),
        w = rB(Object.assign(Object.assign({ x: 0, y: 0, symbolType: 'circle', strokeBoundsBuffer: 0 }, o), p.style));
      let A;
      Object.keys(p.state || {}).forEach(t => {
        const e = p.state[t].fill || p.state[t].stroke;
        o.fill && l(p.state[t].fill) && e && (p.state[t].fill = e),
          o.stroke && l(p.state[t].stroke) && e && (p.state[t].stroke = e);
      }),
        this._appendDataToShape(w, wX.itemShape, t, y, null == p ? void 0 : p.state),
        w.addState(e ? xX.selected : xX.unSelected),
        _.add(w);
      let k = 0;
      if (d) {
        const e = C(u, 'size', 10);
        (A = rB(
          Object.assign(Object.assign({ x: 0, y: -e / 2 - 1, strokeBoundsBuffer: 0 }, u), {
            visible: !1,
            pickMode: 'imprecise',
            boundsPadding: m
          })
        )),
          this._appendDataToShape(A, wX.focus, t, y),
          (k = e);
      }
      const M = sB(
        Object.assign(
          Object.assign(
            {
              x: x / 2 + S,
              y: 0,
              textAlign: 'start',
              textBaseline: 'middle',
              lineHeight: (null == g ? void 0 : g.style).fontSize
            },
            null == g ? void 0 : g.style
          ),
          { text: g.formatMethod ? g.formatMethod(r, t, i) : r }
        )
      );
      this._appendDataToShape(M, wX.itemLabel, t, y, null == g ? void 0 : g.state),
        M.addState(e ? xX.selected : xX.unSelected),
        _.add(M);
      const T = C(g, 'space', 8);
      if (((b += x / 2 + S + M.AABBBounds.width() + T), h(a))) {
        const n = C(f, 'space', d ? 8 : 0),
          s = sB(
            Object.assign(
              Object.assign(
                {
                  x: b + T,
                  y: 0,
                  textAlign: 'start',
                  textBaseline: 'middle',
                  lineHeight: (null == f ? void 0 : f.style).fontSize
                },
                null == f ? void 0 : f.style
              ),
              { text: f.formatMethod ? f.formatMethod(a, t, i) : a }
            )
          );
        if (
          (this._appendDataToShape(s, wX.itemValue, t, y, null == f ? void 0 : f.state),
          s.addState(e ? xX.selected : xX.unSelected),
          this._itemWidthByUser)
        ) {
          const t = this._itemWidthByUser - m[1] - m[3] - x - S - T - k - n,
            e = s.AABBBounds,
            i = M.AABBBounds,
            r = e.width(),
            a = i.width();
          a > t
            ? (t - r) / a > 0.4
              ? M.setAttribute('maxLineWidth', t - r)
              : (s.setAttribute('maxLineWidth', 0.5 * t), M.setAttribute('maxLineWidth', 0.5 * t))
            : s.setAttribute('maxLineWidth', t - a),
            f.alignRight &&
              s.setAttributes({ textAlign: 'right', x: this._itemWidthByUser - x / 2 - m[1] - m[3] - k - n });
        }
        (b = s.AABBBounds.x2 + n), _.add(s);
      } else this._itemWidthByUser && M.setAttribute('maxLineWidth', this._itemWidthByUser - m[1] - m[3] - x - S - k);
      A && (A.setAttribute('x', b), _.add(A));
      const E = _.AABBBounds,
        P = E.width(),
        R = E.height(),
        O = h(this.attribute.item.width) ? this.attribute.item.width : P + m[1] + m[3],
        B = this._itemHeightByUser || R + m[0] + m[2];
      return (y.attribute.width = O), (y.attribute.height = B), _.translateTo(-E.x1 + m[3], -E.y1 + m[0]), y;
    }
    _renderPager(t) {
      const e = this._title ? this._title.AABBBounds.height() + C(this.attribute, 'title.space', 8) : 0,
        { maxWidth: i, maxHeight: n, maxCol: s = 1, maxRow: r = 2, item: a = {}, pager: o = {} } = this.attribute,
        { spaceCol: l = yX, spaceRow: h = _X } = a,
        c = this._itemsContainer,
        { animation: d = !0, animationDuration: u = 450, animationEasing: p = 'quadIn', space: g = bX } = o,
        f = kX(o, ['animation', 'animationDuration', 'animationEasing', 'space']);
      let v,
        m = 0,
        y = 0,
        _ = 0,
        b = 0,
        x = 1;
      if (t) {
        if (
          ((v = new mX(
            Object.assign(
              { layout: 1 === r ? 'horizontal' : 'vertical', total: 99 },
              D({ handler: { preShape: 'triangleUp', nextShape: 'triangleDown' } }, f)
            )
          )),
          (this._pager = v),
          this._innerView.add(v),
          (m = (r - 1) * h + this._itemHeight * r),
          (y = i - v.AABBBounds.width() - g),
          y <= 0)
        )
          return this._innerView.removeChild(v), !1;
        c.getChildren().forEach((t, e) => {
          const { width: i, height: n } = t.attribute;
          y < _ + i && ((_ = 0), (b += n + h), (x += 1)), e > 0 && t.setAttributes({ x: _, y: b }), (_ += l + i);
        }),
          v.setAttributes({ total: Math.ceil(x / r), x: y, y: e + m / 2 - v.AABBBounds.height() / 2 });
      } else {
        if (
          ((v = new mX(Object.assign({ layout: 'horizontal', total: 99 }, f))),
          (this._pager = v),
          this._innerView.add(v),
          (y = this._itemMaxWidth * s + (s - 1) * l),
          (m = n - v.AABBBounds.height() - g - e),
          m <= 0)
        )
          return this._innerView.removeChild(v), !1;
        c.getChildren().forEach((t, e) => {
          const { height: i } = t.attribute;
          m < b + i && ((b = 0), (_ += this._itemMaxWidth + l), (x += 1)),
            e > 0 && t.setAttributes({ x: _, y: b }),
            (b += h + i);
        }),
          v.setAttributes({ total: Math.ceil(x / s), x: (y - v.AABBBounds.width()) / 2, y: n - v.AABBBounds.height() });
      }
      o.defaultCurrent > 1 &&
        (t
          ? c.setAttribute('y', -(o.defaultCurrent - 1) * (m + h))
          : c.setAttribute('x', -(o.defaultCurrent - 1) * (y + l)));
      const S = QO({ x: 0, y: e, width: y, height: m, clip: !0, pickable: !1 });
      S.add(c), this._innerView.add(S);
      const w = e => {
        const { current: i } = e.detail;
        d
          ? c.animate().to(t ? { y: -(i - 1) * (m + h) } : { x: -(i - 1) * (y + l) }, u, p)
          : t
          ? c.setAttribute('y', -(i - 1) * (m + h))
          : c.setAttribute('x', -(i - 1) * (y + l));
      };
      return this._pager.addEventListener('toPrev', w), this._pager.addEventListener('toNext', w), !0;
    }
    _setLegendItemState(t, e, i) {
      let n = !1;
      t.hasState(e) || (n = !0),
        t.addState(e, !0),
        t
          .getChildren()[0]
          .getChildren()
          .forEach(t => {
            t.name !== wX.focus && (n || t.hasState(e) || (n = !0), t.addState(e, !0));
          }),
        n && this._dispatchEvent(SX.legendItemAttributeUpdate, t, i);
    }
    _removeLegendItemState(t, e, i) {
      let n = !1;
      e.forEach(e => {
        !n && t.hasState(e) && (n = !0), t.removeState(e);
      }),
        t
          .getChildren()[0]
          .getChildren()
          .forEach(t => {
            t.name !== wX.focus &&
              e.forEach(e => {
                !n && t.hasState(e) && (n = !0), t.removeState(e);
              });
          }),
        n && this._dispatchEvent(SX.legendItemAttributeUpdate, t, i);
    }
    _getSelectedLegends() {
      var t;
      const e = [];
      return (
        null === (t = this._itemsContainer) ||
          void 0 === t ||
          t.getChildren().forEach(t => {
            t.hasState(xX.selected) && e.push(t.data);
          }),
        e
      );
    }
    _appendDataToShape(t, e, i, n) {
      let s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
      (t.name = e), (t.data = i), (t.delegate = n), (t.states = D({}, MX, s));
    }
    _dispatchEvent(t, e, i) {
      var n;
      const s = this._getSelectedLegends();
      s.sort((t, e) => t.index - e.index);
      const r = s.map(t => t.label),
        a = new rM(t, {
          item: e,
          data: e.data,
          selected: e.hasState(xX.selected),
          currentSelectedItems: s,
          currentSelected: r,
          event: i
        });
      (a.manager = null === (n = this.stage) || void 0 === n ? void 0 : n.eventSystem.manager), this.dispatchEvent(a);
    }
    _handleStyle(t, e, i, n, s) {
      const r = D({}, t);
      return (
        t.style && o(t.style) && (r.style = t.style(e, i, n, s)),
        t.state &&
          Object.keys(t.state).forEach(a => {
            t.state[a] && o(t.state[a]) && (r.state[a] = t.state[a](e, i, n, s));
          }),
        r
      );
    }
  };
  var CX;
  function EX(t) {
    return f(t) ? t : [t, t];
  }
  function PX(t) {
    return t ? 'ew-resize' : 'ns-resize';
  }
  (TX.defaultAttributes = {
    layout: 'horizontal',
    title: { align: 'start', space: 12, textStyle: { fontSize: 12, fontWeight: 'bold', fill: '#2C3542' } },
    item: {
      spaceCol: yX,
      spaceRow: _X,
      shape: {
        space: 8,
        style: { size: 10, cursor: 'pointer' },
        state: { selectedHover: { opacity: 0.85 }, unSelected: { fill: '#D8D8D8' } }
      },
      label: {
        space: 8,
        style: { fontSize: 12, fill: '#2C3542', cursor: 'pointer' },
        state: { selectedHover: { opacity: 0.85 }, unSelected: { fill: '#D8D8D8' } }
      },
      value: {
        alignRight: !1,
        style: { fontSize: 12, fill: '#ccc', cursor: 'pointer' },
        state: { selectedHover: { opacity: 0.85 }, unSelected: { fill: '#D8D8D8' } }
      },
      background: { style: { cursor: 'pointer' } },
      focus: !1,
      focusIconStyle: {
        size: 10,
        symbolType:
          'M8 1C11.866 1 15 4.13401 15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1ZM8.75044 2.55077L8.75 3.75H7.25L7.25006 2.5507C4.81247 2.88304 2.88304 4.81247 2.5507 7.25006L3.75 7.25V8.75L2.55077 8.75044C2.8833 11.1878 4.81264 13.117 7.25006 13.4493L7.25 12.25H8.75L8.75044 13.4492C11.1876 13.1167 13.1167 11.1876 13.4492 8.75044L12.25 8.75V7.25L13.4493 7.25006C13.117 4.81264 11.1878 2.8833 8.75044 2.55077ZM8 5.5C9.38071 5.5 10.5 6.61929 10.5 8C10.5 9.38071 9.38071 10.5 8 10.5C6.61929 10.5 5.5 9.38071 5.5 8C5.5 6.61929 6.61929 5.5 8 5.5ZM8 7C7.44772 7 7 7.44772 7 8C7 8.55228 7.44772 9 8 9C8.55228 9 9 8.55228 9 8C9 7.44772 8.55228 7 8 7Z',
        fill: '#333',
        cursor: 'pointer'
      }
    },
    autoPage: !0,
    pager: { space: bX, handler: { style: { size: 10 }, space: 4 } },
    hover: !0,
    select: !0,
    selectMode: 'multiple',
    allowAllCanceled: !0
  }),
    (function (t) {
      (t.innerView = 'innerView'),
        (t.railContainer = 'sliderRailContainer'),
        (t.rail = 'sliderRail'),
        (t.startText = 'sliderStartText'),
        (t.endText = 'sliderEndText'),
        (t.startHandler = 'sliderStartHandler'),
        (t.startHandlerText = 'startHandlerText'),
        (t.endHandler = 'sliderEndHandler'),
        (t.endHandlerText = 'sliderEndHandlerText'),
        (t.track = 'sliderTrack'),
        (t.trackContainer = 'sliderTrackContainer');
    })(CX || (CX = {}));
  let RX = class t extends uY {
    get track() {
      return this._track;
    }
    get currentValue() {
      return this._currentValue;
    }
    get startHandler() {
      return this._startHandler;
    }
    get endHandler() {
      return this._endHandler;
    }
    constructor(e) {
      super(D({}, t.defaultAttributes, e)),
        (this.name = 'slider'),
        (this._isHorizontal = !0),
        (this._startHandler = null),
        (this._endHandler = null),
        (this._startHandlerText = null),
        (this._endHandlerText = null),
        (this._currentHandler = null),
        (this._currentValue = {}),
        (this._onHandlerPointerdown = t => {
          t.stopPropagation(),
            (this._currentHandler = t.target),
            (this._prePos = this._isHorizontal ? t.clientX : t.clientY),
            'browser' === gN.env
              ? (gN.addEventListener('pointermove', this._onHandlerPointerMove),
                gN.addEventListener('pointerup', this._onHandlerPointerUp))
              : (this._currentHandler.addEventListener('pointermove', this._onHandlerPointerMove),
                this._currentHandler.addEventListener('pointerup', this._onHandlerPointerUp),
                this._currentHandler.addEventListener('pointerupoutside', this._onHandlerPointerUp));
        }),
        (this._onHandlerPointerMove = t => {
          var e, i;
          t.stopPropagation();
          const { railWidth: n, railHeight: s, min: r, max: a } = this.attribute;
          if (a === r) return;
          let o,
            l,
            h,
            c = 0;
          this._isHorizontal
            ? ((o = t.clientX),
              (c = o - this._prePos),
              (l = null === (i = this._currentHandler) || void 0 === i ? void 0 : i.attribute.x),
              (h = n))
            : ((o = t.clientY),
              (c = o - this._prePos),
              (l = null === (e = this._currentHandler) || void 0 === e ? void 0 : e.attribute.y),
              (h = s));
          const d = pt(l + c, 0, h),
            u = (d / h) * (a - r) + r;
          'text' === this._currentHandler.type
            ? this._updateHandlerText(this._currentHandler, d, u)
            : this._updateHandler(this._currentHandler, d, u),
            this._updateTrack(),
            (this._prePos = o),
            this._dispatchChangeEvent();
        }),
        (this._onHandlerPointerUp = t => {
          if ((t.preventDefault(), (this._currentHandler = null), 'browser' === gN.env))
            gN.removeEventListener('pointermove', this._onHandlerPointerMove),
              gN.removeEventListener('pointerup', this._onHandlerPointerUp);
          else {
            const e = t.target;
            e.removeEventListener('pointermove', this._onHandlerPointerMove),
              e.removeEventListener('pointerup', this._onHandlerPointerUp),
              e.removeEventListener('pointerupoutside', this._onHandlerPointerUp);
          }
        }),
        (this._onTrackPointerdown = t => {
          t.stopPropagation(),
            (this._prePos = this._isHorizontal ? t.clientX : t.clientY),
            'browser' === gN.env
              ? (gN.addEventListener('pointermove', this._onTrackPointerMove),
                gN.addEventListener('pointerup', this._onTrackPointerUp))
              : (this._track.addEventListener('pointermove', this._onTrackPointerMove),
                this._track.addEventListener('pointerup', this._onTrackPointerUp),
                this._track.addEventListener('pointerupoutside', this._onTrackPointerUp));
        }),
        (this._onTrackPointerMove = t => {
          t.stopPropagation();
          const { railWidth: e, railHeight: i, min: n, max: s } = this.attribute;
          if (s === n) return;
          const { startHandler: r, endHandler: a } = this._getHandlers();
          let o, l, h;
          this._isHorizontal
            ? ((o = t.clientX), (l = this._track.attribute.width), (h = e))
            : ((o = t.clientY), (l = this._track.attribute.height), (h = i));
          const c = o - this._prePos;
          if (r) {
            const t = this._isHorizontal ? r.attribute.x : r.attribute.y,
              e = pt(t + c, 0, h - l),
              i = (e / h) * (s - n) + n;
            this._updateHandler(r, e, i);
          }
          if (a) {
            const t = this._isHorizontal ? a.attribute.x : a.attribute.y,
              e = pt(t + c, l, h),
              i = (e / h) * (s - n) + n;
            this._updateHandler(a, e, i),
              this._track.setAttributes(
                this._isHorizontal
                  ? {
                      x: Math.min(null == r ? void 0 : r.attribute.x, null == a ? void 0 : a.attribute.x),
                      width: Math.abs((null == r ? void 0 : r.attribute.x) - (null == a ? void 0 : a.attribute.x))
                    }
                  : {
                      y: Math.min(null == r ? void 0 : r.attribute.y, null == a ? void 0 : a.attribute.y),
                      height: Math.abs((null == r ? void 0 : r.attribute.y) - (null == a ? void 0 : a.attribute.y))
                    }
              );
          }
          (this._prePos = o), this._dispatchChangeEvent();
        }),
        (this._onTrackPointerUp = t => {
          t.preventDefault(),
            'browser' === gN.env
              ? (gN.removeEventListener('pointermove', this._onTrackPointerMove),
                gN.removeEventListener('pointerup', this._onTrackPointerUp))
              : (this._track.removeEventListener('pointermove', this._onTrackPointerMove),
                this._track.removeEventListener('pointerup', this._onTrackPointerUp),
                this._track.removeEventListener('pointerupoutside', this._onTrackPointerUp));
        }),
        (this._onRailPointerDown = t => {
          t.stopPropagation();
          const { railWidth: e, railHeight: i, min: n, max: s } = this.attribute;
          if (s === n) return;
          const r = this._startHandler,
            a = this._endHandler;
          let o, l, c, d;
          this._isHorizontal
            ? ((o = t.viewX - this._rail.globalAABBBounds.x1),
              (l = null == r ? void 0 : r.attribute.x),
              (c = null == a ? void 0 : a.attribute.x),
              (d = e))
            : ((o = t.viewY - this._rail.globalAABBBounds.y1),
              (l = null == r ? void 0 : r.attribute.y),
              (c = null == a ? void 0 : a.attribute.y),
              (d = i));
          const u = (o / d) * (s - n) + n;
          if (h(c)) {
            const t = Math.abs(o - l) > Math.abs(o - c) ? a : r;
            this._updateHandler(t, o, u);
          } else this._updateHandler(r, o, u);
          this._updateTrack(), this._dispatchChangeEvent();
        });
    }
    setValue(t) {
      const { layout: e, railWidth: i, railHeight: n, min: s, max: r } = this.attribute;
      if (r === s) return;
      const [a, o] = V(t),
        { startHandler: l, endHandler: h } = this._getHandlers(),
        c = 'vertical' === e ? n : i,
        d = ((a - s) / (r - s)) * c;
      if ((l && this._updateHandler(l, d, a), h)) {
        const t = ((o - s) / (r - s)) * c;
        this._updateHandler(h, t, o);
      }
      this._updateTrack();
    }
    render() {
      var t, e;
      this.removeAllChild();
      const {
        layout: i = 'horizontal',
        railWidth: n,
        railHeight: s,
        startText: r,
        endText: a,
        min: o,
        max: c,
        showHandler: d = !0
      } = this.attribute;
      let { value: u } = this.attribute;
      l(u) && (u = [o, c]), (this._currentValue = { startValue: EX(u)[0], endValue: EX(u)[1] });
      const p = 'horizontal' === i;
      this._isHorizontal = p;
      const g = QO({ x: 0, y: 0 });
      (g.name = CX.innerView), this.add(g), (this._innerView = g);
      let f,
        v = 0;
      if (r && r.visible) {
        (f = sB(
          Object.assign(
            {
              x: p ? 0 : n / 2,
              y: p ? s / 2 : 0,
              textAlign: p ? 'start' : 'center',
              textBaseline: p ? 'middle' : 'top',
              text: r.text,
              lineHeight: null === (t = r.style) || void 0 === t ? void 0 : t.fontSize
            },
            r.style
          )
        )),
          (f.name = CX.startText),
          g.add(f);
        const e = h(r.space) ? r.space : 0;
        v += (p ? f.AABBBounds.width() : f.AABBBounds.height()) + e;
      }
      const m = QO({ x: p ? v : 0, y: p ? 0 : v });
      g.add(m);
      const y = QO({ x: 0, y: 0 });
      let _;
      if (
        ((y.name = CX.railContainer),
        (this._railContainer = y),
        m.add(y),
        this._renderRail(y),
        (v += p ? n : s),
        a && a.visible)
      ) {
        const t = h(a.space) ? a.space : 0;
        (_ = sB(
          Object.assign(
            {
              x: p ? v + t : n / 2,
              y: p ? s / 2 : v + t,
              textAlign: p ? 'start' : 'center',
              textBaseline: p ? 'middle' : 'top',
              text: a.text,
              lineHeight: null === (e = a.style) || void 0 === e ? void 0 : e.fontSize
            },
            a.style
          )
        )),
          (_.name = CX.endText),
          g.add(_);
      }
      this._renderTrack(y), d && (this._renderHandlers(m), this._bindEvents());
    }
    _renderRail(t) {
      const { railWidth: e, railHeight: i, railStyle: n, slidable: s } = this.attribute;
      let r = 'default';
      !1 !== s && (r = 'pointer');
      const a = iB(Object.assign({ x: 0, y: 0, width: e, height: i, cursor: r }, n));
      return (a.name = CX.rail), t.add(a), (this._rail = a), a;
    }
    _renderHandlers(t) {
      const {
        range: e,
        min: i,
        max: n,
        handlerSize: s = 14,
        handlerStyle: r,
        handlerText: a,
        railHeight: o,
        railWidth: h,
        slidable: c
      } = this.attribute;
      let { value: d } = this.attribute;
      l(d) && (d = [i, n]);
      const u = a && a.visible,
        p = this._isHorizontal,
        g = p ? h : o,
        [f, v] = EX(d),
        m = n === i ? (e ? 0 : g) : ((f - i) / (n - i)) * g,
        y = this._renderHandler(
          Object.assign(
            {
              x: p ? m : h / 2,
              y: p ? o / 2 : m,
              size: s,
              strokeBoundsBuffer: 0,
              cursor: !1 === c ? 'default' : PX(p)
            },
            r
          )
        );
      if (((y.name = CX.startHandler), (this._startHandler = y), t.add(y), (this._currentValue.startPos = m), u)) {
        const i = this._renderHandlerText(f, e ? 'start' : 'end');
        (i.name = CX.startHandlerText), t.add(i), (this._startHandlerText = i);
      }
      if (e) {
        const e = n === i ? g : ((v - i) / (n - i)) * g,
          a = this._renderHandler(
            Object.assign(
              {
                x: p ? e : h / 2,
                y: p ? o / 2 : e,
                size: s,
                strokeBoundsBuffer: 0,
                cursor: !1 === c ? 'default' : PX(p)
              },
              r
            )
          );
        if (((a.name = CX.endHandler), (this._endHandler = a), t.add(a), (this._currentValue.endPos = e), u)) {
          const e = this._renderHandlerText(v, 'end');
          (e.name = CX.endHandlerText), t.add(e), (this._endHandlerText = e);
        }
      }
    }
    _renderTrack(t) {
      const {
        range: e,
        min: i,
        max: n,
        railHeight: s,
        railWidth: r,
        trackStyle: a,
        railStyle: o,
        slidable: h,
        value: d
      } = this.attribute;
      let u, p;
      if (l(d)) e ? ((u = i), (p = n)) : (u = p = i);
      else if (e) {
        const t = gt(d, i, n);
        (u = t[0]), (p = t[1]);
      } else (u = i), (p = pt(d, i, n));
      const g = this._isHorizontal,
        f = g ? r : s;
      e || (u = i);
      const v = QO({
        x: 0,
        y: 0,
        width: r,
        height: s,
        cornerRadius: null == o ? void 0 : o.cornerRadius,
        clip: !0,
        pickable: !1
      });
      v.name = CX.trackContainer;
      const m = c(e) && !0 === e.draggableTrack;
      let y;
      y = !1 === h ? 'default' : !1 === e || !1 === m ? 'pointer' : PX(g);
      const _ = n === i ? f : ((p - u) / (n - i)) * f,
        b = n === i ? 0 : ((u - i) / (n - i)) * f,
        x = iB(Object.assign({ x: g ? b : 0, y: g ? 0 : b, width: g ? _ : r, height: g ? s : _, cursor: y }, a));
      (x.name = CX.track), (this._track = x), v.add(x), t.add(v);
    }
    _renderHandler(t) {
      return rB(t);
    }
    _renderHandlerText(t, e) {
      var i, n, s;
      const {
          align: r,
          min: a,
          max: o,
          handlerSize: l = 14,
          handlerText: h = {},
          railHeight: c,
          railWidth: d,
          slidable: u
        } = this.attribute,
        p = this._isHorizontal,
        g = p ? d : c,
        f = o === a ? ('start' === e ? 0 : g) : ((t - a) / (o - a)) * g,
        v = null !== (i = h.space) && void 0 !== i ? i : 4,
        m = Object.assign(
          {
            text: (null == h ? void 0 : h.formatter)
              ? h.formatter(t)
              : t.toFixed(null !== (n = null == h ? void 0 : h.precision) && void 0 !== n ? n : 0),
            lineHeight: null === (s = h.style) || void 0 === s ? void 0 : s.lineHeight,
            cursor: !1 === u ? 'default' : PX(p)
          },
          h.style
        );
      return (
        p
          ? 'top' === r
            ? ((m.textBaseline = 'bottom'), (m.textAlign = 'center'), (m.x = f), (m.y = (c - l) / 2 - v))
            : ((m.textBaseline = 'top'), (m.textAlign = 'center'), (m.x = f), (m.y = (c + l) / 2 + v))
          : 'left' === r
          ? ((m.textBaseline = 'middle'), (m.textAlign = 'end'), (m.x = (d - l) / 2 - v), (m.y = f))
          : ((m.textBaseline = 'middle'), (m.textAlign = 'start'), (m.x = (d + l) / 2 + v), (m.y = f)),
        sB(m)
      );
    }
    _bindEvents() {
      const { slidable: t, range: e } = this.attribute;
      t &&
        (this._startHandler && this._startHandler.addEventListener('pointerdown', this._onHandlerPointerdown),
        this._startHandlerText && this._startHandlerText.addEventListener('pointerdown', this._onHandlerPointerdown),
        this._endHandler && this._endHandler.addEventListener('pointerdown', this._onHandlerPointerdown),
        this._endHandlerText && this._endHandlerText.addEventListener('pointerdown', this._onHandlerPointerdown),
        c(e) && e.draggableTrack && this._track.addEventListener('pointerdown', this._onTrackPointerdown),
        this._railContainer.addEventListener('pointerdown', this._onRailPointerDown));
    }
    _updateTrack() {
      const t = this._startHandler,
        e = this._endHandler;
      if (this._isHorizontal) {
        const i = null == t ? void 0 : t.attribute.x;
        if (e) {
          const t = null == e ? void 0 : e.attribute.x;
          this._track.setAttributes({ x: Math.min(i, t), width: Math.abs(i - t) });
        } else this._track.setAttributes({ width: i });
      } else {
        const i = null == t ? void 0 : t.attribute.y;
        if (e) {
          const t = null == e ? void 0 : e.attribute.y;
          this._track.setAttributes({ y: Math.min(i, t), height: Math.abs(i - t) });
        } else this._track.setAttributes({ height: i });
      }
    }
    _updateHandler(t, e, i) {
      var n;
      const s = this._isHorizontal;
      t.setAttribute(s ? 'x' : 'y', e);
      const r = t.name === CX.startHandler ? this._startHandlerText : this._endHandlerText;
      if (r) {
        const { handlerText: t } = this.attribute;
        null == r ||
          r.setAttributes({
            text: (null == t ? void 0 : t.formatter)
              ? t.formatter(i)
              : i.toFixed(null !== (n = null == t ? void 0 : t.precision) && void 0 !== n ? n : 0),
            [s ? 'x' : 'y']: e
          });
      }
      t.name === CX.startHandler
        ? ((this._currentValue.startValue = i), (this._currentValue.startPos = e))
        : ((this._currentValue.endValue = i), (this._currentValue.endPos = e));
    }
    _updateHandlerText(t, e, i) {
      var n;
      const s = this._isHorizontal,
        { handlerText: r } = this.attribute;
      t.setAttributes({
        [s ? 'x' : 'y']: e,
        text: (null == r ? void 0 : r.formatter)
          ? r.formatter(i)
          : i.toFixed(null !== (n = null == r ? void 0 : r.precision) && void 0 !== n ? n : 0)
      });
      const a = t.name === CX.startHandlerText ? this._startHandler : this._endHandler;
      a && (null == a || a.setAttributes({ [s ? 'x' : 'y']: e })),
        t.name === CX.startHandlerText
          ? ((this._currentValue.startValue = i), (this._currentValue.startPos = e))
          : ((this._currentValue.endValue = i), (this._currentValue.endPos = e));
    }
    _dispatchChangeEvent() {
      var t;
      const e = !!this.attribute.range,
        i = this._currentValue,
        n = new rM('change', {
          value: e ? [Math.min(i.endValue, i.startValue), Math.max(i.endValue, i.startValue)] : i.startValue,
          position: e ? [Math.min(i.endPos, i.startPos), Math.max(i.endPos, i.startPos)] : i.startPos
        });
      (n.manager = null === (t = this.stage) || void 0 === t ? void 0 : t.eventSystem.manager), this.dispatchEvent(n);
    }
    _getHandlers() {
      let t,
        e = this._startHandler,
        i = this._endHandler;
      return (
        this._isHorizontal
          ? i && i.attribute.x < (null == e ? void 0 : e.attribute.x) && ((t = e), (e = i), (i = t))
          : i && i.attribute.y < (null == e ? void 0 : e.attribute.y) && ((t = e), (e = i), (i = t)),
        { startHandler: e, endHandler: i }
      );
    }
  };
  RX.defaultAttributes = {
    slidable: !0,
    layout: 'horizontal',
    align: 'bottom',
    height: 8,
    showHandler: !0,
    handlerSize: 14,
    handlerStyle: { symbolType: 'circle', fill: '#fff', stroke: '#91caff', lineWidth: 2 },
    railStyle: { fill: 'rgba(0,0,0,.04)' },
    trackStyle: { fill: '#91caff' },
    showValue: !0,
    valueStyle: { fill: '#2C3542', fontSize: 12 },
    startText: { style: { fill: '#2C3542', fontSize: 12 } },
    endText: { style: { fill: '#2C3542', fontSize: 12 } },
    handlerText: { visible: !0, space: 4, precision: 0, style: { fill: '#2C3542', fontSize: 12 } }
  };
  class OX extends AX {
    constructor(t) {
      super(D({}, OX.defaultAttributes, t)),
        (this.name = 'colorLegend'),
        (this._onSliderChange = t => {
          this._updateColor(), this.dispatchEvent(t);
        });
    }
    setSelected(t) {
      this._slider && (this._slider.setValue(t), this._updateColor());
    }
    _renderContent() {
      const {
          colors: t,
          slidable: e,
          layout: i,
          align: n,
          min: s,
          max: r,
          value: a,
          railWidth: o,
          railHeight: l,
          showHandler: h = !0,
          handlerSize: c,
          handlerStyle: d,
          railStyle: u,
          trackStyle: p,
          startText: g,
          endText: f,
          handlerText: v,
          showTooltip: m,
          tooltip: y
        } = this.attribute,
        _ = [],
        b = (r - s) / (t.length - 1);
      for (let e = 0; e < t.length; e++) _.push(s + b * e);
      (this._colorScale = new Vl().domain(_, !0).range(t)), (this._color = this._getTrackColor());
      const x = new RX({
        x: 0,
        y: 0,
        range: { draggableTrack: !0 },
        slidable: e,
        layout: i,
        align: n,
        min: s,
        max: r,
        value: a,
        railWidth: o,
        railHeight: l,
        showHandler: h,
        handlerSize: c,
        handlerStyle: d,
        railStyle: u,
        trackStyle: Object.assign({ fill: this._color }, p),
        startText: g,
        endText: f,
        handlerText: v,
        showTooltip: m,
        tooltip: y
      });
      this._innerView.add(x),
        (this._slider = x),
        x.translateTo(
          0 - x.AABBBounds.x1,
          (this._title ? this._title.AABBBounds.height() + C(this.attribute, 'title.space', 12) : 0) - x.AABBBounds.y1
        ),
        this._updateColor();
    }
    _bindEvents() {
      this._slider && this._slider.addEventListener('change', this._onSliderChange);
    }
    _getTrackColor() {
      const { colors: t, layout: e } = this.attribute;
      if (T(t)) return;
      const i = t.length;
      if (1 === i) return t[0];
      const n = [];
      for (let e = 0; e < i; e++) {
        const s = e / (i - 1);
        n.push({ offset: s, color: t[e] });
      }
      const s = 'horizontal' === e;
      return { gradient: 'linear', stops: n, x0: 0, y0: 0, x1: s ? 1 : 0, y1: s ? 0 : 1 };
    }
    _updateColor() {
      const { layout: t = 'horizontal', colors: e, railWidth: i, railHeight: n } = this.attribute,
        { startHandler: s, endHandler: r, track: a } = this._slider,
        { startValue: o, endValue: l, startPos: h, endPos: c } = this._slider.currentValue,
        d = this._colorScale.scale(o),
        u = this._colorScale.scale(l);
      null == s || s.setAttribute('fill', d), null == r || r.setAttribute('fill', u);
      const p = 'horizontal' === t ? i : n;
      if (Math.abs(h - c) !== p && e && e.length > 1) {
        const t = this._color.stops,
          e = Math.min(h, c),
          i = Math.max(h, c),
          n = e / p,
          s = i / p,
          r = s - n,
          d = t.filter(t => t.offset > n && t.offset < s),
          u = Math.min(o, l),
          g = Math.max(o, l),
          f = this._colorScale.scale(u),
          v = this._colorScale.scale(g),
          m = [{ offset: 0, color: f }];
        d.forEach(t => {
          m.push({ offset: (t.offset - n) / r, color: t.color });
        }),
          m.push({ offset: 1, color: v }),
          a.setAttribute('fill', Object.assign(Object.assign({}, this._color), { stops: m }));
      }
    }
  }
  function BX() {
    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'bottom',
      e = 0;
    return 'top' === t
      ? `\n    M${e},-6L${e - 3.5},-2.5\n    v5\n    h7\n    v-5\n    Z\n`
      : 'left' === t
      ? ((e = 1), `\n    M${e - 6},0L${e - 6 + 2.5},-3.5\n    h5\n    v7\n    h-5\n    Z\n`)
      : 'right' === t
      ? ((e = -1), `\n    M${e + 6},0L${e + 6 - 2.5},-3.5\n    h-5\n    v7\n    h5\n    Z\n  `)
      : `\n    M${e},6L${e - 3.5},2.5\n    v-5\n    h7\n    v5\n    Z\n`;
  }
  OX.defaultAttributes = {
    layout: 'horizontal',
    title: { align: 'start', space: 12, textStyle: { fontSize: 12, fontWeight: 'bold', fill: 'rgba(46, 47, 50, 1)' } },
    handlerSize: 10,
    handlerStyle: { lineWidth: 4, stroke: '#fff', outerBorder: { distance: 2, lineWidth: 1, stroke: '#ccc' } }
  };
  class IX extends AX {
    constructor(t) {
      super(D({}, IX.defaultAttributes, t)),
        (this.name = 'sizeLegend'),
        (this._onSliderChange = t => {
          this.dispatchEvent(t);
        });
    }
    setSelected(t) {
      this._slider && this._slider.setValue(t);
    }
    _renderContent() {
      const {
          slidable: t,
          layout: e,
          align: i,
          min: n,
          max: s,
          value: r,
          railWidth: a,
          railHeight: o,
          showHandler: l = !0,
          handlerSize: h,
          handlerStyle: c,
          railStyle: d,
          trackStyle: u,
          startText: p,
          endText: g,
          handlerText: f,
          showTooltip: v,
          tooltip: m,
          sizeBackground: y
        } = this.attribute,
        _ = QO({ x: 0, y: 0 });
      this._innerView.add(_);
      const b = new RX({
        x: 0,
        y: 0,
        zIndex: 1,
        range: { draggableTrack: !0 },
        slidable: t,
        layout: e,
        align: i,
        min: n,
        max: s,
        value: r,
        railWidth: a,
        railHeight: o,
        showHandler: l,
        handlerSize: h,
        handlerStyle: Object.assign({ symbolType: BX(i) }, c),
        railStyle: d,
        trackStyle: u,
        startText: p,
        endText: g,
        handlerText: f,
        showTooltip: v,
        tooltip: m
      });
      _.add(b);
      let x,
        S = 0;
      'horizontal' === e
        ? 'top' === i
          ? ((x = `M0,0L${a},0L${a},12Z`), (S = o))
          : ((x = `M0,12L${a},12L${a},0Z`), b.setAttribute('y', 12))
        : 'left' === i
        ? (x = `M${a},0L${a},0L${a + 12},${o}L${a},${o}Z`)
        : ((x = `M0,${o}L12,${o}L12,0Z`), b.setAttribute('x', 12));
      const w = eB(Object.assign(Object.assign({ x: 0, y: S, path: x }, y), { zIndex: 0 }));
      _.add(w);
      const A = this._title ? this._title.AABBBounds.height() + C(this.attribute, 'title.space', 12) : 0;
      _.translate(0 - _.AABBBounds.x1, A - _.AABBBounds.y1), (this._slider = b);
    }
    _bindEvents() {
      this._slider && this._slider.addEventListener('change', this._onSliderChange);
    }
  }
  IX.defaultAttributes = {
    layout: 'horizontal',
    title: { align: 'start', space: 12, textStyle: { fontSize: 12, fontWeight: 'bold', fill: 'rgba(46, 47, 50, 1)' } },
    handlerSize: 10,
    handlerStyle: { lineWidth: 1, stroke: '#ccc', fill: '#fff' },
    sizeBackground: { fill: 'rgba(20,20,20,0.1)' }
  };
  let DX = class t extends uY {
    constructor(e) {
      super(D({}, t.defaultAttributes, e)), (this.name = 'title');
    }
    render() {
      var t,
        e,
        i,
        n,
        s,
        r,
        a,
        o,
        l,
        c,
        d,
        u,
        p,
        g,
        f,
        v,
        m,
        y,
        _,
        b,
        x,
        S,
        w,
        A,
        k,
        M,
        T,
        C,
        E,
        P,
        R,
        O,
        B,
        I,
        D,
        L,
        F,
        j,
        z,
        H,
        N,
        V,
        W,
        G,
        U,
        Y,
        $,
        X,
        K,
        q,
        Z,
        J,
        Q,
        tt,
        et,
        it,
        nt,
        st,
        rt,
        at,
        ot,
        lt;
      const {
          text: ht,
          textStyle: ct,
          subtext: dt,
          subtextStyle: ut,
          width: pt,
          height: gt,
          minWidth: ft,
          maxWidth: vt,
          minHeight: mt,
          maxHeight: yt,
          align: _t,
          verticalAlign: bt,
          padding: xt = 0
        } = this.attribute,
        St = Je(xt),
        wt = this.createOrUpdateChild('title-container', { x: St[3], y: St[0], zIndex: 1 }, 'group');
      if (
        !1 !== (null === (t = this.attribute) || void 0 === t ? void 0 : t.visible) &&
        !1 !== (null == ct ? void 0 : ct.visible)
      )
        if (ct && h(null == ct ? void 0 : ct.character)) {
          const t = {
            x: null !== (e = ct.x) && void 0 !== e ? e : 0,
            y: null !== (i = ct.y) && void 0 !== i ? i : 0,
            width: null !== (s = null !== (n = ct.width) && void 0 !== n ? n : pt) && void 0 !== s ? s : 0,
            height: null !== (a = null !== (r = ct.height) && void 0 !== r ? r : gt) && void 0 !== a ? a : 0,
            ellipsis: null === (o = ct.ellipsis) || void 0 === o || o,
            wordBreak: null !== (l = ct.wordBreak) && void 0 !== l ? l : 'break-word',
            maxHeight: ct.maxHeight,
            maxWidth: ct.maxWidth,
            textConfig: ct.character
          };
          this._mainTitle = wt.createOrUpdateChild('mainTitle', t, 'richtext');
        } else
          h(ht) &&
            (this._mainTitle = wt.createOrUpdateChild(
              'mainTitle',
              Object.assign(Object.assign({ text: [ht] }, ct), {
                maxLineWidth: null !== (c = null == ct ? void 0 : ct.maxLineWidth) && void 0 !== c ? c : pt,
                heightLimit: null == ct ? void 0 : ct.heightLimit,
                lineClamp: null == ct ? void 0 : ct.lineClamp,
                ellipsis: null === (d = null == ct ? void 0 : ct.ellipsis) || void 0 === d || d,
                x: 0,
                y: 0
              }),
              'wrapText'
            ));
      const At = this._mainTitle
          ? null === (u = this._mainTitle) || void 0 === u
            ? void 0
            : u.AABBBounds.height()
          : 0,
        kt = this._mainTitle ? (null === (p = this._mainTitle) || void 0 === p ? void 0 : p.AABBBounds.width()) : 0;
      if (
        !1 !== (null === (g = this.attribute) || void 0 === g ? void 0 : g.visible) &&
        !1 !== (null == ut ? void 0 : ut.visible)
      )
        if (ut && h(null == ut ? void 0 : ut.character)) {
          const t = {
            x: null !== (f = ut.x) && void 0 !== f ? f : 0,
            y: null !== (v = ut.y) && void 0 !== v ? v : At,
            width: null !== (y = null !== (m = ut.width) && void 0 !== m ? m : pt) && void 0 !== y ? y : 0,
            height: null !== (b = null !== (_ = ut.height) && void 0 !== _ ? _ : gt) && void 0 !== b ? b : 0,
            ellipsis: null === (x = ut.ellipsis) || void 0 === x || x,
            wordBreak: null !== (S = ut.wordBreak) && void 0 !== S ? S : 'break-word',
            maxHeight: ut.maxHeight,
            maxWidth: ut.maxWidth,
            textConfig: ut.character
          };
          this._subTitle = wt.createOrUpdateChild('subTitle', t, 'richtext');
        } else
          h(dt) &&
            (this._subTitle = wt.createOrUpdateChild(
              'subTitle',
              Object.assign(Object.assign({ text: [dt] }, ut), {
                maxLineWidth: null !== (w = null == ut ? void 0 : ut.maxLineWidth) && void 0 !== w ? w : pt,
                heightLimit: null == ut ? void 0 : ut.heightLimit,
                lineClamp: null == ut ? void 0 : ut.lineClamp,
                ellipsis: null === (A = null == ut ? void 0 : ut.ellipsis) || void 0 === A || A,
                x: 0,
                y: At
              }),
              'wrapText'
            ));
      const Mt = this._subTitle ? (null === (k = this._subTitle) || void 0 === k ? void 0 : k.AABBBounds.height()) : 0,
        Tt = this._subTitle ? (null === (M = this._subTitle) || void 0 === M ? void 0 : M.AABBBounds.width()) : 0;
      let Ct = Math.max(kt, Tt),
        Et = At + (null !== (T = null == ut ? void 0 : ut.height) && void 0 !== T ? T : Mt);
      if (
        (h(pt) &&
          ((Ct = pt),
          null === (C = this._mainTitle) || void 0 === C || C.setAttribute('maxLineWidth', pt),
          null === (E = this._subTitle) || void 0 === E || E.setAttribute('maxLineWidth', pt)),
        h(gt) && (Et = gt),
        h(ft) && Ct < ft && (Ct = ft),
        h(vt) &&
          (null === (P = this._mainTitle) || void 0 === P || P.setAttribute('maxLineWidth', vt),
          null === (R = this._subTitle) || void 0 === R || R.setAttribute('maxLineWidth', vt),
          null === (O = this._mainTitle) || void 0 === O || O.setAttribute('maxWidth', vt),
          null === (B = this._subTitle) || void 0 === B || B.setAttribute('maxWidth', vt),
          Ct > vt && (Ct = vt)),
        h(mt) && Et < mt && (Et = mt),
        h(yt) &&
          (null === (I = this._mainTitle) || void 0 === I || I.setAttribute('maxHeight', yt),
          null === (D = this._subTitle) || void 0 === D || D.setAttribute('maxHeight', yt - At),
          Et > yt && (Et = yt)),
        (wt.attribute.width = Ct + St[1] + St[3]),
        (wt.attribute.height = Et + St[0] + St[2]),
        h(_t) || h(null == ct ? void 0 : ct.align))
      ) {
        const t = (null == ct ? void 0 : ct.align) ? (null == ct ? void 0 : ct.align) : _t,
          e = null !== (L = null == ct ? void 0 : ct.width) && void 0 !== L ? L : kt;
        'left' === t
          ? (null === (F = this._mainTitle) || void 0 === F || F.setAttribute('x', 0),
            null === (j = this._mainTitle) || void 0 === j || j.setAttribute('textAlign', 'left'))
          : 'center' === t
          ? (null === (z = this._mainTitle) || void 0 === z || z.setAttribute('x', e / 2),
            null === (H = this._mainTitle) || void 0 === H || H.setAttribute('textAlign', 'center'))
          : 'right' === t &&
            (null === (N = this._mainTitle) || void 0 === N || N.setAttribute('x', e),
            null === (V = this._mainTitle) || void 0 === V || V.setAttribute('textAlign', 'right'));
      }
      if (h(bt) || h(null == ct ? void 0 : ct.verticalAlign)) {
        const t = (null == ct ? void 0 : ct.verticalAlign) ? (null == ct ? void 0 : ct.verticalAlign) : bt,
          e = (null == ct ? void 0 : ct.height) ? (null == ct ? void 0 : ct.height) : Ct;
        'top' === t
          ? (null === (W = this._mainTitle) || void 0 === W || W.setAttribute('y', 0),
            null === (G = this._mainTitle) || void 0 === G || G.setAttribute('textBaseline', 'top'))
          : 'middle' === t
          ? (null === (U = this._mainTitle) || void 0 === U || U.setAttribute('y', e / 2),
            null === (Y = this._mainTitle) || void 0 === Y || Y.setAttribute('textBaseline', 'middle'))
          : 'bottom' === t &&
            (null === ($ = this._mainTitle) || void 0 === $ || $.setAttribute('y', e),
            null === (X = this._mainTitle) || void 0 === X || X.setAttribute('textBaseline', 'bottom'));
      }
      if (h(_t) || h(null == ut ? void 0 : ut.align)) {
        const t = (null == ut ? void 0 : ut.align) ? (null == ut ? void 0 : ut.align) : _t,
          e = null !== (K = null == ut ? void 0 : ut.width) && void 0 !== K ? K : Tt;
        'left' === t
          ? (null === (q = this._subTitle) || void 0 === q || q.setAttribute('x', 0),
            null === (Z = this._subTitle) || void 0 === Z || Z.setAttribute('textAlign', 'left'))
          : 'center' === t
          ? (null === (J = this._subTitle) || void 0 === J || J.setAttribute('x', e / 2),
            null === (Q = this._subTitle) || void 0 === Q || Q.setAttribute('textAlign', 'center'))
          : 'right' === t &&
            (null === (tt = this._subTitle) || void 0 === tt || tt.setAttribute('x', e),
            null === (et = this._subTitle) || void 0 === et || et.setAttribute('textAlign', 'right'));
      }
      if (h(bt) || h(null == ct ? void 0 : ct.verticalAlign)) {
        const t = (null == ut ? void 0 : ut.verticalAlign) ? (null == ut ? void 0 : ut.verticalAlign) : bt,
          e = At,
          i = null !== (it = null == ut ? void 0 : ut.height) && void 0 !== it ? it : 0;
        'top' === t
          ? (null === (nt = this._subTitle) || void 0 === nt || nt.setAttribute('y', e),
            null === (st = this._subTitle) || void 0 === st || st.setAttribute('textBaseline', 'top'))
          : 'middle' === t
          ? (null === (rt = this._subTitle) || void 0 === rt || rt.setAttribute('y', e + i / 2),
            null === (at = this._subTitle) || void 0 === at || at.setAttribute('textBaseline', 'middle'))
          : 'bottom' === t &&
            (null === (ot = this._subTitle) || void 0 === ot || ot.setAttribute('y', e + i),
            null === (lt = this._subTitle) || void 0 === lt || lt.setAttribute('textBaseline', 'bottom'));
      }
    }
  };
  DX.defaultAttributes = {
    textStyle: {
      ellipsis: '...',
      fill: '#333',
      fontSize: 20,
      fontWeight: 'bold',
      textAlign: 'left',
      textBaseline: 'top'
    },
    subtextStyle: {
      ellipsis: '...',
      fill: '#6F6F6F',
      fontSize: 16,
      fontWeight: 'normal',
      textAlign: 'left',
      textBaseline: 'top'
    }
  };
  const LX = {
    title: {
      style: {
        text: '',
        fontSize: 20,
        fill: 'black',
        fontWeight: 'normal',
        fillOpacity: 1,
        textBaseline: 'top',
        textAlign: 'center'
      }
    },
    content: {
      style: {
        text: '',
        fontSize: 16,
        fill: 'black',
        fontWeight: 'normal',
        fillOpacity: 1,
        textBaseline: 'top',
        textAlign: 'center'
      }
    }
  };
  let FX = class extends uY {
    constructor() {
      super(...arguments), (this.name = 'indicator');
    }
    render() {
      var t;
      const { visible: e, title: i, content: n, size: s, limitRatio: r = 1 / 0 } = this.attribute,
        a = Math.min(s.width, s.height) * r,
        o = this.createOrUpdateChild('indicator-container', { x: 0, y: 0, zIndex: 1 }, 'group');
      if (!0 !== e) return void (o && o.hideAll());
      if (h(i))
        if (!1 !== i.visible) {
          const t = D({}, C(LX, 'title.style'), i.style);
          (this._title = o.createOrUpdateChild(
            'indicator-title',
            Object.assign(Object.assign({}, t), {
              lineHeight: h(t.lineHeight) ? t.lineHeight : t.fontSize,
              visible: i.visible,
              x: 0,
              y: 0
            }),
            'text'
          )),
            i.autoFit && _(a) && this._setAutoFit(a, this._title, i),
            i.autoLimit && _(r) && this._title.setAttribute('maxLineWidth', a);
        } else {
          const t = o.find(t => 'indicator-title' === t.name, !1);
          t && o.removeChild(t), (this._title = void 0);
        }
      const l = this._title ? this._title.AABBBounds.height() : 0;
      if (h(n)) {
        const t = this._title && (null == i ? void 0 : i.space) ? i.space : 0,
          e = V(n),
          s = [];
        let c = 0;
        e.forEach((e, i) => {
          if (!1 !== e.visible) {
            const n = D({}, C(LX, 'content.style'), e.style),
              d = o.createOrUpdateChild(
                'indicator-content-' + i,
                Object.assign(Object.assign({}, n), {
                  lineHeight: h(n.lineHeight) ? n.lineHeight : n.fontSize,
                  visible: e.visible,
                  x: 0,
                  y: l + t + c
                }),
                'text'
              );
            e.autoFit && _(a) && this._setAutoFit(a, d, e),
              e.autoLimit && _(r) && d.setAttribute('maxLineWidth', a),
              s.push(d);
            const u = (null == e ? void 0 : e.space) ? e.space : 0;
            c += d.AABBBounds.height() + u;
          } else {
            const t = o.find(t => t.name === 'indicator-content-' + i, !1);
            t && o.removeChild(t);
          }
        }),
          (this._content = s);
      }
      const c = null !== (t = null == o ? void 0 : o.AABBBounds.height()) && void 0 !== t ? t : 0;
      o.setAttribute('y', s.height / 2 - c / 2), o.setAttribute('x', s.width / 2);
    }
    _setAutoFit(t, e, i) {
      var n, s, r, a, o, l;
      const c = RY(
        null !== (s = null === (n = i.style) || void 0 === n ? void 0 : n.text) && void 0 !== s ? s : '',
        null !== (r = i.style) && void 0 !== r ? r : {}
      ).width;
      if (c > 0) {
        const n = (t * (null !== (a = i.fitPercent) && void 0 !== a ? a : 0.5)) / c,
          s = Math.floor(
            (null !== (l = null === (o = i.style) || void 0 === o ? void 0 : o.fontSize) && void 0 !== l ? l : 20) * n
          );
        e.setAttribute('fontSize', s), e.setAttribute('lineHeight', h(i.style.lineHeight) ? i.style.lineHeight : s);
      }
    }
  };
  class jX extends XR {
    constructor(t) {
      super(t);
    }
  }
  var zX, HX;
  !(function (t) {
    (t.OnPlay = 'onPlay'), (t.OnPause = 'onPause'), (t.OnForward = 'onForward'), (t.OnBackward = 'onBackward');
  })(zX || (zX = {})),
    (function (t) {
      (t.Start = 'start'), (t.Pause = 'pause'), (t.Forward = 'forward'), (t.Backward = 'backward');
    })(HX || (HX = {}));
  class NX extends uY {
    constructor(t) {
      super(D({}, NX.defaultAttributes, t)),
        (this._isPaused = !0),
        (this.updateAttributes = () => {
          (this._startAttr = {
            style: Object.assign(
              Object.assign(
                Object.assign(
                  {
                    symbolType:
                      'M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -73.1429 161.4994 a 48.7619 48.7619 0 0 1 25.9901 7.5093 l 201.7524 127.1223 a 48.7619 48.7619 0 0 1 0.3657 82.2613 l -201.7524 129.6335 A 48.7619 48.7619 0 0 1 292.5952 540.1838 v -256.7314 a 48.7619 48.7619 0 0 1 48.7619 -48.7619 z m 24.381 92.9402 v 167.9116 l 131.9497 -84.7726 L 365.7381 327.6063 z'
                  },
                  NX.defaultControllerAttr
                ),
                { visible: this.attribute.start.visible }
              ),
              this.attribute.start.style
            )
          }),
            (this._pauseAttr = {
              style: Object.assign(
                Object.assign(
                  Object.assign(
                    {
                      symbolType:
                        'M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -48.7619 195.0476 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z m 158.4762 0 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z'
                    },
                    NX.defaultControllerAttr
                  ),
                  { visible: this.attribute.pause.visible }
                ),
                this.attribute.pause.style
              )
            }),
            (this._forwardAttr = {
              style: Object.assign(
                Object.assign(Object.assign({}, NX.defaultControllerAttr), { visible: this.attribute.forward.visible }),
                this.attribute.forward.style
              )
            }),
            (this._backwardAttr = {
              style: Object.assign(
                Object.assign(Object.assign({}, NX.defaultControllerAttr), {
                  visible: this.attribute.backward.visible
                }),
                this.attribute.backward.style
              )
            }),
            this.updateLayout();
        }),
        (this.updateLayout = () => {
          var t, e, i, n, s, r, a, o;
          (this._layout = this.attribute.layout),
            'horizontal' === this._layout
              ? ((this._backwardAttr.style.symbolType =
                  null !== (e = null === (t = this._backwardAttr.style) || void 0 === t ? void 0 : t.symbolType) &&
                  void 0 !== e
                    ? e
                    : 'M 521.29 734.276 L 230.929 448.019 L 521.29 161.762 c 37.685 -37.153 38.003 -97.625 0.707 -134.384 c -37.297 -36.758 -98.646 -36.435 -136.331 0.718 l -357.43 352.378 c -0.155 0.153 -0.297 0.314 -0.451 0.468 c -0.084 0.082 -0.172 0.157 -0.256 0.239 c -18.357 18.092 -27.581 41.929 -27.743 65.902 c -0.004 0.311 -0.017 0.623 -0.018 0.934 c 0.001 0.316 0.014 0.632 0.018 0.948 c 0.165 23.97 9.389 47.803 27.743 65.892 c 0.083 0.082 0.171 0.157 0.255 0.239 c 0.154 0.154 0.296 0.315 0.452 0.468 l 357.43 352.378 c 37.685 37.153 99.034 37.476 136.331 0.718 c 37.297 -36.758 36.979 -97.231 -0.707 -134.384 z'),
                (this._forwardAttr.style.symbolType =
                  null !== (n = null === (i = this._forwardAttr.style) || void 0 === i ? void 0 : i.symbolType) &&
                  void 0 !== n
                    ? n
                    : 'M 30 163 L 320.361 449.257 L 30 735.514 c -37.685 37.153 -38.003 97.625 -0.707 134.384 c 37.297 36.758 98.646 36.435 136.331 -0.718 l 357.43 -352.378 c 0.155 -0.153 0.297 -0.314 0.451 -0.468 c 0.084 -0.082 0.172 -0.157 0.256 -0.239 c 18.357 -18.092 27.581 -41.929 27.743 -65.902 c 0.004 -0.311 0.017 -0.623 0.018 -0.934 c -0.001 -0.316 -0.014 -0.632 -0.018 -0.948 c -0.165 -23.97 -9.389 -47.803 -27.743 -65.892 c -0.083 -0.082 -0.171 -0.157 -0.255 -0.239 c -0.154 -0.154 -0.296 -0.315 -0.452 -0.468 l -357.43 -352.378 c -37.685 -37.153 -99.034 -37.476 -136.331 -0.718 c -37.297 36.758 -36.979 97.231 0.707 134.384 z'))
              : 'vertical' === this._layout &&
                ((this._backwardAttr.style.symbolType =
                  null !== (r = null === (s = this._backwardAttr.style) || void 0 === s ? void 0 : s.symbolType) &&
                  void 0 !== r
                    ? r
                    : 'm 161.724 521.29 l 286.257 -290.361 l 286.257 290.361 c 37.153 37.685 97.625 38.003 134.384 0.707 c 36.758 -37.297 36.435 -98.646 -0.718 -136.331 l -352.378 -357.43 c -0.153 -0.155 -0.314 -0.297 -0.468 -0.451 c -0.082 -0.084 -0.157 -0.172 -0.239 -0.256 c -18.092 -18.357 -41.929 -27.581 -65.902 -27.743 c -0.311 -0.004 -0.623 -0.017 -0.934 -0.018 c -0.316 0.001 -0.632 0.014 -0.948 0.018 c -23.97 0.165 -47.803 9.389 -65.892 27.743 c -0.082 0.083 -0.157 0.171 -0.239 0.255 c -0.154 0.154 -0.315 0.296 -0.468 0.452 l -352.378 357.43 c -37.153 37.685 -37.476 99.034 -0.718 136.331 c 36.758 37.297 97.231 36.979 134.384 -0.707 z'),
                (this._forwardAttr.style.symbolType =
                  null !== (o = null === (a = this._forwardAttr.style) || void 0 === a ? void 0 : a.symbolType) &&
                  void 0 !== o
                    ? o
                    : 'M 734.276 28.71 L 448.019 319.071 L 161.762 28.71 c -37.153 -37.685 -97.625 -38.003 -134.384 -0.707 c -36.758 37.297 -36.435 98.646 0.718 136.331 l 352.378 357.43 c 0.153 0.155 0.314 0.297 0.468 0.451 c 0.082 0.084 0.157 0.172 0.239 0.256 c 18.092 18.357 41.929 27.581 65.902 27.743 c 0.311 0.004 0.623 0.017 0.934 0.018 c 0.316 -0.001 0.632 -0.014 0.948 -0.018 c 23.97 -0.165 47.803 -9.389 65.892 -27.743 c 0.082 -0.083 0.157 -0.171 0.239 -0.255 c 0.154 -0.154 0.315 -0.296 0.468 -0.452 l 352.378 -357.43 c 37.153 -37.685 37.476 -99.034 0.718 -136.331 c -36.758 -37.297 -97.231 -36.979 -134.384 0.707 z'));
        }),
        (this._initPlay = () => {
          l(this._playController) &&
            ((this._playController = new jX(Object.assign({}, this._startAttr.style))), this.add(this._playController));
        }),
        (this._initBackward = () => {
          l(this._backwardController) &&
            ((this._backwardController = new jX(Object.assign({}, this._backwardAttr.style))),
            this.add(this._backwardController));
        }),
        (this._initForward = () => {
          l(this._forwardController) &&
            ((this._forwardController = new jX(Object.assign({}, this._forwardAttr.style))),
            this.add(this._forwardController));
        }),
        (this._initEvents = () => {
          this._playController.addEventListener('pointerdown', t => {
            t.stopPropagation(), !0 === this._isPaused ? this.play() : this.pause();
          }),
            this._backwardController.addEventListener('pointerdown', t => {
              t.stopPropagation(), this.backward();
            }),
            this._forwardController.addEventListener('pointerdown', t => {
              t.stopPropagation(), this.forward();
            });
        }),
        (this._createCustomEvent = t => {
          var e;
          const i = new rM(t, { eventType: t });
          return (i.manager = null === (e = this.stage) || void 0 === e ? void 0 : e.eventSystem.manager), i;
        }),
        (this.renderPlay = () => {
          this._isPaused
            ? this._playController.setAttributes(
                Object.assign(
                  { symbolType: this._playController.getComputedAttribute('symbolType') },
                  this._startAttr.style
                )
              )
            : this._playController.setAttributes(
                Object.assign(
                  { symbolType: this._playController.getComputedAttribute('symbolType') },
                  this._pauseAttr.style
                )
              );
        }),
        (this.renderBackward = () => {
          this._backwardController.setAttributes(this._backwardAttr.style);
        }),
        (this.renderForward = () => {
          this._forwardController.setAttributes(this._forwardAttr.style);
        }),
        (this.play = () => {
          const t = this._createCustomEvent(zX.OnPlay);
          this.dispatchEvent(t);
        }),
        (this.pause = () => {
          const t = this._createCustomEvent(zX.OnPause);
          this.dispatchEvent(t);
        }),
        (this.forward = () => {
          const t = this._createCustomEvent(zX.OnForward);
          this.dispatchEvent(t);
        }),
        (this.backward = () => {
          const t = this._createCustomEvent(zX.OnBackward);
          this.dispatchEvent(t);
        }),
        (this.togglePlay = () => {
          this._playController.setAttributes(this._startAttr.style), (this._isPaused = !0);
        }),
        (this.togglePause = () => {
          this._playController.setAttributes(this._pauseAttr.style), (this._isPaused = !1);
        }),
        this.updateAttributes(),
        this._initPlay(),
        this._initBackward(),
        this._initForward(),
        this._initEvents();
    }
    render() {
      this.updateAttributes(), this.renderPlay(), this.renderBackward(), this.renderForward();
    }
  }
  (NX.defaultControllerAttr = {
    visible: !0,
    x: 0,
    y: 0,
    size: 20,
    fill: '#91caff',
    pickMode: 'imprecise',
    cursor: 'pointer'
  }),
    (NX.defaultAttributes = { [HX.Start]: {}, [HX.Pause]: {}, [HX.Backward]: {}, [HX.Forward]: {} });
  const VX = { visible: !0, style: { x: 0, y: 0, dx: 0, dy: 0, size: 20 }, order: 0, space: 10 },
    WX = [200, 10];
  var GX, UX;
  !(function (t) {
    (t.Default = 'default'), (t.Reverse = 'reverse');
  })(GX || (GX = {})),
    (function (t) {
      (t.change = 'change'),
        (t.play = 'play'),
        (t.pause = 'pause'),
        (t.backward = 'backward'),
        (t.forward = 'forward'),
        (t.end = 'end'),
        (t.OnChange = 'change'),
        (t.OnPlay = 'play'),
        (t.OnPause = 'pause'),
        (t.OnBackward = 'backward'),
        (t.OnForward = 'forward'),
        (t.OnEnd = 'end');
    })(UX || (UX = {}));
  const YX = t => {
      let { direction: e, maxIndex: i, minIndex: n, dataIndex: s } = t;
      return (
        (t => {
          let { direction: e, maxIndex: i, dataIndex: n } = t;
          return e === GX.Default && n === i;
        })({ direction: e, maxIndex: i, dataIndex: s }) ||
        (t => {
          let { direction: e, minIndex: i, dataIndex: n } = t;
          return e === GX.Reverse && n === i;
        })({ direction: e, minIndex: n, dataIndex: s })
      );
    },
    $X = t => {
      let { direction: e, maxIndex: i, minIndex: n, dataIndex: s } = t;
      return (
        (t => {
          let { direction: e, minIndex: i, dataIndex: n } = t;
          return e === GX.Default && n === i;
        })({ direction: e, minIndex: n, dataIndex: s }) ||
        (t => {
          let { direction: e, maxIndex: i, dataIndex: n } = t;
          return e === GX.Reverse && n === i;
        })({ direction: e, maxIndex: i, dataIndex: s })
      );
    },
    XX = t => 'top' === t || 'bottom' === t;
  class KX extends uY {
    constructor(t) {
      super(D({}, KX.defaultAttributes, t)),
        (this._data = []),
        (this._layoutInfo = {}),
        (this._updateSliderAttrs = () => {
          var t, e, i;
          let n;
          _(this._handlerStyle.size)
            ? (n = this._handlerStyle.size)
            : this._handlerStyle.size &&
              this._handlerStyle.size.length &&
              (n = Bt(this._handlerStyle.size[0], this._handlerStyle.size[1]));
          const s = {
            visible: this._sliderVisible,
            min: this._minIndex,
            max: this._maxIndex,
            value: null !== (t = this.attribute.dataIndex) && void 0 !== t ? t : 0,
            railWidth: this._railStyle.width,
            railHeight: this._railStyle.height,
            railStyle: this._railStyle,
            trackStyle: this._trackStyle,
            handlerSize: _(n) ? n : void 0,
            handlerStyle: this._handlerStyle,
            dy: this.attribute.slider.dy,
            dx: this.attribute.slider.dx,
            slidable: !0,
            range: !1,
            handlerText: { visible: !1 },
            startText: { visible: !1 },
            endText: { visible: !1 }
          };
          if (XX(this._orient)) {
            const t = Math.max(0, this._layoutInfo.slider.size),
              i = null !== (e = this._railStyle.height) && void 0 !== e ? e : WX[1];
            (s.layout = 'horizontal'),
              (s.railHeight = i),
              (s.railWidth = t),
              (s.x = this._layoutInfo.slider.x),
              (s.y = this._layoutInfo.slider.y);
          } else {
            const t = Math.max(0, this._layoutInfo.slider.size),
              e = null !== (i = this._railStyle.width) && void 0 !== i ? i : WX[1];
            (s.layout = 'vertical'),
              (s.railWidth = e),
              (s.railHeight = t),
              (s.x = this._layoutInfo.slider.x),
              (s.y = this._layoutInfo.slider.y);
          }
          return s;
        }),
        (this._initSlider = () => {
          const t = this._updateSliderAttrs();
          (this._slider = new RX(t)), this._sliderVisible && this.add(this._slider);
        }),
        (this._updateControllerAttrs = () => {
          const t = { start: this._start, pause: this._pause, forward: this._forward, backward: this._backward };
          return (
            XX(this._orient)
              ? ((t.layout = 'horizontal'),
                (t.start = Object.assign(Object.assign({}, t.start), {
                  style: Object.assign(Object.assign({}, t.start.style), {
                    x: this._layoutInfo.start.x,
                    y: this._layoutInfo.start.y
                  })
                })),
                (t.pause = Object.assign(Object.assign({}, t.pause), {
                  style: Object.assign(Object.assign({}, t.pause.style), {
                    x: this._layoutInfo.start.x,
                    y: this._layoutInfo.start.y
                  })
                })),
                (t.backward = Object.assign(Object.assign({}, t.backward), {
                  style: Object.assign(Object.assign({}, t.backward.style), {
                    x: this._layoutInfo.backward.x,
                    y: this._layoutInfo.backward.y
                  })
                })),
                (t.forward = Object.assign(Object.assign({}, t.forward), {
                  style: Object.assign(Object.assign({}, t.forward.style), {
                    x: this._layoutInfo.forward.x,
                    y: this._layoutInfo.forward.y
                  })
                })))
              : ((t.layout = 'vertical'),
                (t.start = Object.assign(Object.assign({}, t.start), {
                  style: Object.assign(Object.assign({}, t.start.style), {
                    x: this._layoutInfo.start.x,
                    y: this._layoutInfo.start.y
                  })
                })),
                (t.pause = Object.assign(Object.assign({}, t.pause), {
                  style: Object.assign(Object.assign({}, t.pause.style), {
                    x: this._layoutInfo.start.x,
                    y: this._layoutInfo.start.y
                  })
                })),
                (t.backward = Object.assign(Object.assign({}, t.backward), {
                  style: Object.assign(Object.assign({}, t.backward.style), {
                    x: this._layoutInfo.backward.x,
                    y: this._layoutInfo.backward.y
                  })
                })),
                (t.forward = Object.assign(Object.assign({}, t.forward), {
                  style: Object.assign(Object.assign({}, t.forward.style), {
                    x: this._layoutInfo.forward.x,
                    y: this._layoutInfo.forward.y
                  })
                }))),
            t
          );
        }),
        (this._initController = () => {
          const t = this._updateControllerAttrs();
          (this._controller = new NX(t)), this._controllerVisible && this.add(this._controller);
        }),
        this._initAttributes(),
        this._initLayoutInfo(),
        this._initController(),
        this._initSlider();
    }
    _initAttributes() {
      var t, e, i, n, s, r, a, o, l, h, c, d, u, p, g, f, v, m;
      (this._size = this.attribute.size),
        (this._orient = this.attribute.orient),
        (this._data = this.attribute.data),
        (this._minIndex = 0),
        (this._maxIndex = this._data.length - 1),
        (this._sliderVisible =
          null === (e = null === (t = this.attribute) || void 0 === t ? void 0 : t.slider) || void 0 === e
            ? void 0
            : e.visible),
        (this._railStyle = Object.assign(
          {},
          null === (n = null === (i = this.attribute) || void 0 === i ? void 0 : i.slider) || void 0 === n
            ? void 0
            : n.railStyle
        )),
        (this._trackStyle = Object.assign(
          {},
          null === (r = null === (s = this.attribute) || void 0 === s ? void 0 : s.slider) || void 0 === r
            ? void 0
            : r.trackStyle
        )),
        (this._handlerStyle = Object.assign(
          {},
          null === (o = null === (a = this.attribute) || void 0 === a ? void 0 : a.slider) || void 0 === o
            ? void 0
            : o.handlerStyle
        )),
        (this._controllerVisible =
          null === (h = null === (l = this.attribute) || void 0 === l ? void 0 : l.controller) || void 0 === h
            ? void 0
            : h.visible),
        (this._start = Object.assign(
          {},
          null === (d = null === (c = this.attribute) || void 0 === c ? void 0 : c.controller) || void 0 === d
            ? void 0
            : d.start
        )),
        (this._pause = Object.assign(
          {},
          null === (p = null === (u = this.attribute) || void 0 === u ? void 0 : u.controller) || void 0 === p
            ? void 0
            : p.pause
        )),
        (this._forward = Object.assign(
          {},
          null === (f = null === (g = this.attribute) || void 0 === g ? void 0 : g.controller) || void 0 === f
            ? void 0
            : f.forward
        )),
        (this._backward = Object.assign(
          {},
          null === (m = null === (v = this.attribute) || void 0 === v ? void 0 : v.controller) || void 0 === m
            ? void 0
            : m.backward
        ));
    }
    _initLayoutInfo() {
      var t, e, i;
      const n = [this._start, this._backward, this._forward].sort((t, e) => t.order - e.order),
        s = n.filter(t => 'end' !== t.position),
        r = n.filter(t => 'end' === t.position),
        a =
          null !== (t = XX(this._orient) ? this._railStyle.height : this._railStyle.width) && void 0 !== t ? t : WX[1],
        o = n.reduce((t, e) => {
          const i = e.style.size,
            n = y(i) ? i : Bt(i[0], i[1]);
          return t + e.space + n;
        }, 0),
        l = this._sliderVisible
          ? (XX(this._orient)
              ? null === (e = this._size) || void 0 === e
                ? void 0
                : e.width
              : null === (i = this._size) || void 0 === i
              ? void 0
              : i.height) - o
          : 0,
        h = l - this.attribute.slider.space,
        c = s.reduce((t, e) => {
          const {
              key: i,
              space: n,
              style: { size: s }
            } = e,
            r = y(s) ? s : Bt(s[0], s[1]);
          return (
            (this._layoutInfo[i] = Object.assign(Object.assign({}, this._layoutInfo[i]), {
              size: r,
              x: XX(this._orient) ? t + n : (this._size.width - r) / 2,
              y: XX(this._orient) ? (this._size.height - r) / 2 : t + n
            })),
            t + n + r
          );
        }, 0);
      (this._layoutInfo.slider = Object.assign(Object.assign({}, this._layoutInfo.slider), {
        size: h,
        x: XX(this._orient) ? c + this.attribute.slider.space : (this._size.width - a) / 2,
        y: XX(this._orient) ? (this._size.height - a) / 2 : c + this.attribute.slider.space
      })),
        r.reduce((t, e) => {
          const {
              key: i,
              space: n,
              style: { size: s }
            } = e,
            r = y(s) ? s : Bt(s[0], s[1]);
          return (
            (this._layoutInfo[i] = Object.assign(Object.assign({}, this._layoutInfo[i]), {
              size: r,
              x: XX(this._orient) ? t + n : (this._size.width - r) / 2,
              y: XX(this._orient) ? (this._size.height - r) / 2 : t + n
            })),
            t + n + r
          );
        }, c + l);
    }
    render() {
      this._initLayoutInfo(), this.renderSlider(), this.renderController();
    }
    renderSlider() {
      const t = this._updateSliderAttrs();
      this._slider.setAttributes(t);
    }
    renderController() {
      const t = this._updateControllerAttrs();
      this._controller.setAttributes(t);
    }
    dispatchCustomEvent(t, e) {
      var i;
      const n = new rM(t, { eventType: t, index: e, value: this._data[e] });
      (n.manager = null === (i = this.stage) || void 0 === i ? void 0 : i.eventSystem.manager), this.dispatchEvent(n);
    }
  }
  KX.defaultAttributes = {
    visible: !0,
    data: [],
    interval: 1e3,
    orient: 'bottom',
    align: 'center',
    size: { height: 20, width: 300 },
    slider: { visible: !0, space: 10, dx: 0, dy: 0, railStyle: { cornerRadius: 5 }, trackStyle: {}, handlerStyle: {} },
    controller: {
      visible: !0,
      start: Object.assign(Object.assign({}, VX), { key: 'start', position: 'start', space: 0 }),
      pause: Object.assign(Object.assign({}, VX), { key: 'pause', position: 'start' }),
      forward: Object.assign(Object.assign({}, VX), { key: 'forward', position: 'end' }),
      backward: Object.assign(Object.assign({}, VX), { key: 'backward', position: 'start' })
    }
  };
  class qX extends KX {
    constructor(t) {
      super(D({}, t)),
        (this._activeIndex = -1),
        (this._isReachEnd = !1),
        (this._initAttributes = () => {
          var t, e, i, n;
          super._initAttributes(),
            (this._alternate = null !== (t = this.attribute.alternate) && void 0 !== t && t),
            (this._interval = null !== (e = this.attribute.interval) && void 0 !== e ? e : 1e3),
            (this._direction = null !== (i = this.attribute.direction) && void 0 !== i ? i : GX.Default),
            (this._dataIndex = l(this.attribute.dataIndex)
              ? 'default' === this._direction
                ? this._minIndex
                : this._maxIndex
              : null !== (n = this.attribute.dataIndex) && void 0 !== n
              ? n
              : 0),
            this._slider.setAttribute('value', this._dataIndex);
        }),
        (this._initEvents = () => {
          this._controller.addEventListener(zX.OnPlay, t => {
            t.stopPropagation(), this.play();
          }),
            this._controller.addEventListener(zX.OnPause, t => {
              t.stopPropagation(), this.pause();
            }),
            this._controller.addEventListener(zX.OnForward, t => {
              t.stopPropagation(), this.forward();
            }),
            this._controller.addEventListener(zX.OnBackward, t => {
              t.stopPropagation(), this.backward();
            }),
            this._slider.addEventListener('change', t => {
              const e = Math.floor(t.detail.value) + 0.5;
              (this._dataIndex = t.detail.value >= e ? Math.ceil(t.detail.value) : Math.floor(t.detail.value)),
                this._slider.setValue(this._dataIndex),
                this.dispatchCustomEvent(UX.change);
            });
        }),
        (this.play = () => {
          this._isPlaying ||
            (1 !== this._data.length &&
              (this._controller.togglePause(),
              (this._isPlaying = !0),
              (YX({
                dataIndex: this._dataIndex,
                maxIndex: this._maxIndex,
                minIndex: this._minIndex,
                direction: this._direction
              }) ||
                $X({
                  dataIndex: this._dataIndex,
                  maxIndex: this._maxIndex,
                  minIndex: this._minIndex,
                  direction: this._direction
                })) &&
                (this._direction === GX.Default
                  ? this._updateDataIndex(this._minIndex)
                  : this._updateDataIndex(this._maxIndex)),
              this.dispatchCustomEvent(UX.play),
              (this._isReachEnd = !1),
              (this._tickTime = Date.now()),
              (this._rafId = gN.getRequestAnimationFrame()(this._play.bind(this, !0)))));
        }),
        (this._play = t => {
          const e = Date.now();
          if (this._isReachEnd && e - this._tickTime >= this._interval)
            return (this._isReachEnd = !1), void this._playEnd();
          t && this._activeIndex !== this._dataIndex
            ? (this.dispatchCustomEvent(UX.change), (this._activeIndex = this._dataIndex))
            : e - this._tickTime >= this._interval &&
              ((this._tickTime = e),
              this._updateDataIndex(
                ((t, e, i, n) => ('default' === t ? Math.min(e + 1, n) : Math.max(e - 1, i)))(
                  this._direction,
                  this._dataIndex,
                  this._minIndex,
                  this._maxIndex
                )
              ),
              (this._activeIndex = this._dataIndex),
              this.dispatchCustomEvent(UX.change)),
            (('default' === this._direction && this._dataIndex >= this._maxIndex) ||
              ('reverse' === this._direction && this._dataIndex <= this._minIndex)) &&
              (this._isReachEnd = !0),
            (this._rafId = gN.getRequestAnimationFrame()(this._play.bind(this, !1)));
        }),
        (this._updateDataIndex = t => {
          (this._dataIndex = t), this._slider.setValue(this._dataIndex);
        }),
        (this._playEnd = () => {
          (this._isPlaying = !1),
            this._controller.togglePlay(),
            gN.getCancelAnimationFrame()(this._rafId),
            (this._activeIndex = -1),
            this.dispatchCustomEvent(UX.end);
        }),
        (this.pause = () => {
          this._isPlaying &&
            ((this._isPlaying = !1),
            gN.getCancelAnimationFrame()(this._rafId),
            this._controller.togglePlay(),
            this.dispatchCustomEvent(UX.pause));
        }),
        (this.backward = () => {
          const t = Math.max(this._dataIndex - 1, this._minIndex);
          this._updateDataIndex(t), this.dispatchCustomEvent(UX.change), this.dispatchCustomEvent(UX.backward);
        }),
        (this.forward = () => {
          const t = Math.min(this._dataIndex + 1, this._maxIndex);
          this._updateDataIndex(t), this.dispatchCustomEvent(UX.change), this.dispatchCustomEvent(UX.forward);
        }),
        this._initAttributes(),
        this._initEvents();
    }
    setAttributes(t, e) {
      super.setAttributes(t, e), this._initAttributes();
    }
    dispatchCustomEvent(t) {
      super.dispatchCustomEvent(t, this._dataIndex);
    }
  }
  var ZX,
    JX = function (t, e, i, n) {
      return new (i || (i = Promise))(function (s, r) {
        function a(t) {
          try {
            l(n.next(t));
          } catch (t) {
            r(t);
          }
        }
        function o(t) {
          try {
            l(n.throw(t));
          } catch (t) {
            r(t);
          }
        }
        function l(t) {
          var e;
          t.done
            ? s(t.value)
            : ((e = t.value),
              e instanceof i
                ? e
                : new i(function (t) {
                    t(e);
                  })).then(a, o);
        }
        l((n = n.apply(t, e || [])).next());
      });
    };
  class QX extends KX {
    constructor(t) {
      super(t),
        (this._isPlaying = !1),
        (this._startTime = Date.now()),
        (this._initAttributes = () => {
          var t, e;
          super._initAttributes(),
            (this._maxIndex = this._data.length),
            this._slider.setAttribute('max', this._maxIndex),
            (this._isPlaying = !1),
            (this._elapsed = 0),
            (this._interval = null !== (t = this.attribute.interval) && void 0 !== t ? t : 1e3),
            (this._dataIndex = null !== (e = this.attribute.dataIndex) && void 0 !== e ? e : this._minIndex);
          const i = this._data.length;
          this.attribute.totalDuration && this._data.length
            ? ((this._totalDuration = this.attribute.totalDuration),
              (this._interval = this._totalDuration / (null != i ? i : 1)))
            : ((this._totalDuration = this._interval * i), (this._interval = this.attribute.interval));
        }),
        (this._initEvents = () => {
          this._controller.addEventListener(zX.OnPlay, t => {
            t.stopPropagation(), this.play();
          }),
            this._controller.addEventListener(zX.OnPause, t => {
              t.stopPropagation(), this.pause();
            }),
            this._controller.addEventListener(zX.OnForward, t => {
              t.stopPropagation(), this.forward();
            }),
            this._controller.addEventListener(zX.OnBackward, t => {
              t.stopPropagation(), this.backward();
            }),
            this._slider.addEventListener('change', t => {
              var e;
              t.stopPropagation();
              const i = null === (e = t.detail) || void 0 === e ? void 0 : e.value,
                n = i / this._maxIndex;
              (this._elapsed = n * this._totalDuration),
                (this._startTime = Date.now() - this._elapsed),
                this._dispatchChange(i);
            });
        }),
        (this._getSliderValue = () => {
          const t = this._elapsed / this._totalDuration;
          return Math.min(t * this._maxIndex, this._maxIndex);
        }),
        (this._updateSlider = () => {
          const t = this._getSliderValue();
          (this._dataIndex = Math.floor(t)),
            this._slider.setValue(Math.min(t, this._maxIndex)),
            this._dispatchChange(Math.floor(t));
        }),
        (this._dispatchChange = t => {
          const e = Math.floor(t);
          e !== this._activeIndex &&
            ((this._dataIndex = e),
            (this._activeIndex = e),
            e !== this._maxIndex && this.dispatchCustomEvent(UX.change));
        }),
        (this.play = () =>
          JX(this, void 0, void 0, function* () {
            this._isPlaying ||
              (this._controller.togglePause(),
              (this._isPlaying = !0),
              this._elapsed >= this._totalDuration && (this._elapsed = 0),
              (this._startTime = Date.now() - this._elapsed),
              this.dispatchCustomEvent(UX.play),
              (this._rafId = gN.getRequestAnimationFrame()(this._play.bind(this))));
          })),
        (this._play = () => {
          this._elapsed = Date.now() - this._startTime;
          const t = this._getSliderValue();
          this._updateSlider(),
            t >= this._maxIndex
              ? this._playEnd()
              : (this._rafId = gN.getRequestAnimationFrame()(this._play.bind(this)));
        }),
        (this._playEnd = () => {
          (this._isPlaying = !1),
            gN.getCancelAnimationFrame()(this._rafId),
            this._controller.togglePlay(),
            this.dispatchCustomEvent(UX.end);
        }),
        (this.pause = () => {
          this._isPlaying &&
            ((this._isPlaying = !1),
            (this._elapsed = Date.now() - this._startTime),
            gN.getCancelAnimationFrame()(this._rafId),
            this._controller.togglePlay(),
            this.dispatchCustomEvent(UX.pause));
        }),
        (this.backward = () => {
          const t = Date.now(),
            e = 1 * this._interval,
            i = this._elapsed - e;
          i <= 0
            ? ((this._elapsed = 0), (this._startTime = t))
            : ((this._elapsed = i), (this._startTime = this._startTime + this._interval)),
            this._updateSlider(),
            this.dispatchCustomEvent(UX.backward);
        }),
        (this.forward = () => {
          const t = Date.now(),
            e = 1 * this._interval,
            i = this._elapsed + e;
          i >= this._totalDuration
            ? ((this._startTime = t - this._totalDuration), (this._elapsed = this._totalDuration))
            : ((this._startTime = this._startTime - e), (this._elapsed = i)),
            this._updateSlider(),
            this.dispatchCustomEvent(UX.forward);
        }),
        this._initAttributes(),
        this._initEvents();
    }
    dispatchCustomEvent(t) {
      super.dispatchCustomEvent(t, this._dataIndex);
    }
    render() {
      super.render();
    }
  }
  !(function (t) {
    (t.drawStart = 'drawStart'),
      (t.drawEnd = 'drawEnd'),
      (t.drawing = 'drawing'),
      (t.moving = 'moving'),
      (t.moveStart = 'moveStart'),
      (t.moveEnd = 'moveEnd'),
      (t.brushClear = 'brushClear');
  })(ZX || (ZX = {}));
  const tK = 5,
    eK = { debounce: mt, throttle: yt };
  let iK = class t extends uY {
    constructor(e) {
      super(D({}, t.defaultAttributes, e)),
        (this.name = 'brush'),
        (this._activeDrawState = !1),
        (this._cacheDrawPoints = []),
        (this._isDrawedBeforeEnd = !1),
        (this._activeMoveState = !1),
        (this._operatingMaskMoveDx = 0),
        (this._operatingMaskMoveDy = 0),
        (this._operatingMaskMoveRangeX = [-1 / 0, 1 / 0]),
        (this._operatingMaskMoveRangeY = [-1 / 0, 1 / 0]),
        (this._brushMaskAABBBoundsDict = {}),
        (this._onBrushStart = t => {
          var e, i;
          if (this._outOfInteractiveRange(t)) return;
          const n =
            null === (i = null === (e = this.attribute) || void 0 === e ? void 0 : e.brushMoved) || void 0 === i || i;
          (this._activeMoveState = n && this._isPosInBrushMask(t)),
            (this._activeDrawState = !this._activeMoveState),
            this._activeDrawState && this._initDraw(t),
            this._activeMoveState && this._initMove(t);
        }),
        (this._onBrushing = t => {
          this._outOfInteractiveRange(t) ||
            (this._activeDrawState && this._drawing(t), this._activeMoveState && this._moving(t));
        }),
        (this._onBrushEnd = t => {
          var e;
          const { removeOnClick: i = !0 } = this.attribute;
          this._activeDrawState && !this._isDrawedBeforeEnd && i
            ? (this._container.incrementalClearChild(),
              this._updateDragMaskCallback &&
                this._updateDragMaskCallback({
                  operateType: ZX.brushClear,
                  operateMask: this._operatingMask,
                  operatedMaskAABBBounds: this._brushMaskAABBBoundsDict
                }))
            : this._outOfInteractiveRange(t) ||
              (this._updateDragMaskCallback &&
                this._updateDragMaskCallback({
                  operateType: this._activeDrawState ? ZX.drawEnd : ZX.moveEnd,
                  operateMask: this._operatingMask,
                  operatedMaskAABBBounds: this._brushMaskAABBBoundsDict
                })),
            (this._activeDrawState = !1),
            (this._activeMoveState = !1),
            (this._isDrawedBeforeEnd = !1),
            null === (e = this._operatingMask) || void 0 === e || e.setAttribute('pickable', !1);
        });
    }
    bindBrushEvents() {
      const { delayType: t = 'throttle', delayTime: e = 0 } = this.attribute;
      this.stage.addEventListener('pointerdown', this._onBrushStart),
        this.stage.addEventListener('pointermove', eK[t](this._onBrushing, e)),
        this.stage.addEventListener('pointerup', this._onBrushEnd),
        this.stage.addEventListener('pointerupoutside', this._onBrushEnd);
    }
    _isPosInBrushMask(t) {
      const e = this.eventPosToStagePos(t),
        i = this._container.getChildren();
      for (let t = 0; t < i.length; t++) {
        const { points: n = [], dx: s = 0, dy: r = 0 } = i[t].attribute,
          a = n.map(t => ({ x: t.x + s, y: t.y + r }));
        if (We(a, e.x, e.y)) return (this._operatingMask = i[t]), !0;
      }
      return !1;
    }
    _initDraw(t) {
      const { brushMode: e } = this.attribute,
        i = this.eventPosToStagePos(t);
      (this._cacheDrawPoints = [i]),
        (this._isDrawedBeforeEnd = !1),
        'single' === e && this._container.incrementalClearChild(),
        this._addBrushMask(),
        this._updateDragMaskCallback &&
          this._updateDragMaskCallback({
            operateType: ZX.drawStart,
            operateMask: this._operatingMask,
            operatedMaskAABBBounds: this._brushMaskAABBBoundsDict
          });
    }
    _initMove(t) {
      var e, i;
      (this._cacheMovePoint = this.eventPosToStagePos(t)),
        (this._operatingMaskMoveDx = null !== (e = this._operatingMask.attribute.dx) && void 0 !== e ? e : 0),
        (this._operatingMaskMoveDy = null !== (i = this._operatingMask.attribute.dy) && void 0 !== i ? i : 0);
      const { interactiveRange: n } = this.attribute,
        { minY: s = -1 / 0, maxY: r = 1 / 0, minX: a = -1 / 0, maxX: o = 1 / 0 } = n,
        { x1: l, x2: h, y1: c, y2: d } = this._operatingMask.globalAABBBounds,
        u = a - l,
        p = o - h,
        g = s - c,
        f = r - d;
      (this._operatingMaskMoveRangeX = [u, p]),
        (this._operatingMaskMoveRangeY = [g, f]),
        this._operatingMask.setAttribute('pickable', !0),
        this._updateDragMaskCallback &&
          this._updateDragMaskCallback({
            operateType: ZX.moveStart,
            operateMask: this._operatingMask,
            operatedMaskAABBBounds: this._brushMaskAABBBoundsDict
          });
    }
    _drawing(t) {
      var e;
      const i = this.eventPosToStagePos(t),
        {
          x1: n = 0,
          x2: s = 0,
          y1: r = 0,
          y2: a = 0
        } = null === (e = this._operatingMask) || void 0 === e ? void 0 : e._AABBBounds,
        { sizeThreshold: o = tK } = this.attribute;
      if (
        ((this._isDrawedBeforeEnd = !!(Math.abs(s - n) > o || Math.abs(r - a) > o)), this._cacheDrawPoints.length > 0)
      ) {
        const t = this._cacheDrawPoints[this._cacheDrawPoints.length - 1];
        if (i.x === (null == t ? void 0 : t.x) && i.y === (null == t ? void 0 : t.y)) return;
      }
      this._cacheDrawPoints.push(i);
      const l = this._computeMaskPoints();
      this._operatingMask.setAttribute('points', l),
        (this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds),
        this._updateDragMaskCallback &&
          this._updateDragMaskCallback({
            operateType: ZX.drawing,
            operateMask: this._operatingMask,
            operatedMaskAABBBounds: this._brushMaskAABBBoundsDict
          });
    }
    _moving(t) {
      const e = this._cacheMovePoint,
        i = this.eventPosToStagePos(t);
      if (i.x === (null == e ? void 0 : e.x) && i.y === (null == e ? void 0 : e.y)) return;
      const n = i.x - e.x,
        s = i.y - e.y,
        r =
          Math.min(this._operatingMaskMoveRangeX[1], Math.max(this._operatingMaskMoveRangeX[0], n)) +
          this._operatingMaskMoveDx,
        a =
          Math.min(this._operatingMaskMoveRangeY[1], Math.max(this._operatingMaskMoveRangeY[0], s)) +
          this._operatingMaskMoveDy;
      this._operatingMask.setAttributes({ dx: r, dy: a }),
        (this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds),
        this._updateDragMaskCallback &&
          this._updateDragMaskCallback({
            operateType: ZX.moving,
            operateMask: this._operatingMask,
            operatedMaskAABBBounds: this._brushMaskAABBBoundsDict
          });
    }
    _computeMaskPoints() {
      const { brushType: t, xRange: e = [0, 0], yRange: i = [0, 0] } = this.attribute;
      let n = [];
      const s = this._cacheDrawPoints[0],
        r = this._cacheDrawPoints[this._cacheDrawPoints.length - 1];
      return (
        (n =
          'rect' === t
            ? [s, { x: r.x, y: s.y }, r, { x: s.x, y: r.y }]
            : 'x' === t
            ? [
                { x: s.x, y: i[0] },
                { x: r.x, y: i[0] },
                { x: r.x, y: i[1] },
                { x: s.x, y: i[1] }
              ]
            : 'y' === t
            ? [
                { x: e[0], y: s.y },
                { x: e[0], y: r.y },
                { x: e[1], y: r.y },
                { x: e[1], y: s.y }
              ]
            : R(this._cacheDrawPoints)),
        n
      );
    }
    _addBrushMask() {
      const { brushStyle: t } = this.attribute,
        e = oB(Object.assign({ points: R(this._cacheDrawPoints), cursor: 'move', pickable: !1 }, t));
      (e.name = `brush-${Date.now()}`),
        (this._operatingMask = e),
        this._container.add(e),
        (this._brushMaskAABBBoundsDict[e.name] = e.AABBBounds);
    }
    _outOfInteractiveRange(t) {
      const { interactiveRange: e } = this.attribute,
        { minY: i = -1 / 0, maxY: n = 1 / 0, minX: s = -1 / 0, maxX: r = 1 / 0 } = e,
        a = this.eventPosToStagePos(t);
      return a.x > r || a.x < s || a.y > n || a.y < i;
    }
    eventPosToStagePos(t) {
      var e, i, n;
      const s = null === (e = this.stage) || void 0 === e ? void 0 : e.window.getBoundingClientRect();
      return {
        x:
          t.clientX -
          ((null == s ? void 0 : s.left) || 0) -
          ((null === (i = this.stage) || void 0 === i ? void 0 : i.x) || 0),
        y:
          t.clientY -
          ((null == s ? void 0 : s.top) || 0) -
          ((null === (n = this.stage) || void 0 === n ? void 0 : n.y) || 0)
      };
    }
    render() {
      this.bindBrushEvents();
      const t = this.createOrUpdateChild('brush-container', {}, 'group');
      this._container = t;
    }
    setUpdateDragMaskCallback(t) {
      o(t) && (this._updateDragMaskCallback = t);
    }
    releaseBrushEvents() {
      const { delayType: t = 'throttle', delayTime: e = 0 } = this.attribute;
      this.stage.removeEventListener('pointerdown', this._onBrushStart),
        this.stage.removeEventListener('pointermove', eK[t](this._onBrushing, e)),
        this.stage.removeEventListener('pointerup', this._onBrushEnd),
        this.stage.removeEventListener('pointerupoutside', this._onBrushEnd);
    }
  };
  iK.defaultAttributes = {
    brushMode: 'single',
    brushType: 'rect',
    brushStyle: { fill: '#B0C8F9', fillOpacity: 0.2, stroke: '#B0C8F9', strokeWidth: 2 },
    brushMoved: !0,
    removeOnClick: !0,
    delayType: 'throttle',
    delayTime: 10,
    interactiveRange: { y1: -1 / 0, y2: 1 / 0, x1: -1 / 0, x2: 1 / 0 }
  };
  const nK = function (t) {
      for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) i[n - 1] = arguments[n];
      const s = [t.shape, ...i.map(t => (null == t ? void 0 : t.shape))],
        r = [t.key, ...i.map(t => (null == t ? void 0 : t.key))],
        a = [t.value, ...i.map(t => (null == t ? void 0 : t.value))];
      return D(t, ...i, {
        shape: s.every(l) ? void 0 : D({}, ...s),
        key: r.every(l) ? void 0 : D({}, ...r),
        value: a.every(l) ? void 0 : D({}, ...a)
      });
    },
    sK = t => {
      const { width: e, height: i, wordBreak: n = 'break-word', textAlign: s, textBaseline: r, text: a } = t;
      return {
        width: e,
        height: i,
        wordBreak: n,
        textAlign: s,
        textBaseline: r,
        singleLine: !1,
        textConfig: V(a).map(e => Object.assign(Object.assign({}, t), { text: e }))
      };
    },
    rK = {
      panel: {
        visible: !0,
        cornerRadius: [3, 3, 3, 3],
        fill: 'white',
        shadow: !0,
        shadowBlur: 12,
        shadowColor: 'rgba(0, 0, 0, 0.1)',
        shadowOffsetX: 0,
        shadowOffsetY: 4,
        shadowSpread: 0,
        stroke: 'white'
      },
      titleStyle: {
        value: {
          fill: '#4E5969',
          fontFamily: TY,
          fontSize: 14,
          lineHeight: 18,
          textAlign: 'left',
          textBaseline: 'middle'
        },
        spaceRow: 6
      },
      contentStyle: {
        shape: { fill: 'black', size: 8, symbolType: 'circle', spacing: 6 },
        key: {
          fill: '#4E5969',
          fontFamily: TY,
          fontSize: 12,
          lineHeight: 18,
          textAlign: 'left',
          textBaseline: 'middle',
          spacing: 26
        },
        value: {
          fill: '#4E5969',
          fontFamily: TY,
          fontSize: 12,
          lineHeight: 18,
          textAlign: 'right',
          textBaseline: 'middle',
          spacing: 0
        },
        spaceRow: 6
      },
      padding: 10,
      positionX: 'right',
      positionY: 'bottom',
      offsetX: 10,
      offsetY: 10,
      parentBounds: new Kt().setValue(
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      ),
      autoCalculatePosition: !0,
      autoMeasure: !0,
      pickable: !1,
      childrenPickable: !1,
      zIndex: 500
    },
    aK = ['pointerX', 'pointerY', 'offsetX', 'offsetY', 'positionX', 'positionY', 'parentBounds'];
  let oK = class t extends uY {
    constructor(e) {
      super(D({}, t.defaultAttributes, e)), (this.name = 'tooltip');
    }
    render() {
      const {
        visible: e,
        content: i,
        panel: n,
        keyWidth: s,
        valueWidth: r,
        hasContentShape: a,
        autoCalculatePosition: o,
        autoMeasure: l
      } = this.attribute;
      if (!e) return void this.hideAll();
      l && t.measureTooltip(this.attribute), o && t.calculateTooltipPosition(this.attribute);
      const c = Je(this.attribute.padding);
      (this._tooltipPanel = this.createOrUpdateChild('tooltip-background', Object.assign({ visible: !0 }, n), 'rect')),
        (this._tooltipTitleContainer = this.createOrUpdateChild(
          'tooltip-title',
          { visible: !0, x: c[3], y: c[0] },
          'group'
        ));
      const d = t.getTitleAttr(this.attribute);
      (this._tooltipTitleSymbol = this._tooltipTitleContainer.createOrUpdateChild(
        'tooltip-title-shape',
        D({ symbolType: 'circle' }, d.shape, { visible: fY(d) && fY(d.shape) }),
        'symbol'
      )),
        d.value.multiLine
          ? (this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild(
              'tooltip-title-value',
              Object.assign({ visible: fY(d) && fY(d.value) }, sK(d.value)),
              'richtext'
            ))
          : (this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild(
              'tooltip-title-value',
              Object.assign({ text: '', visible: fY(d) && fY(d.value) }, d.value),
              'text'
            ));
      const u = fY(d.shape) ? d.shape.size + d.shape.spacing : 0,
        { textAlign: p, textBaseline: g } = d.value,
        f = n.width - c[3] - c[0] - u;
      'center' === p
        ? this._tooltipTitle.setAttribute('x', u + f / 2)
        : 'right' === p || 'end' === p
        ? this._tooltipTitle.setAttribute('x', u + f)
        : this._tooltipTitle.setAttribute('x', u),
        'bottom' === g
          ? this._tooltipTitle.setAttribute('y', d.height)
          : 'middle' === g
          ? this._tooltipTitle.setAttribute('y', d.height / 2)
          : this._tooltipTitle.setAttribute('y', 0);
      const v = fY(d) ? d.height + d.spaceRow : 0;
      if (
        ((this._tooltipContent = this.createOrUpdateChild('tooltip-content', { visible: !0 }, 'group')),
        this._tooltipContent.removeAllChild(),
        null == i ? void 0 : i.length)
      ) {
        this._tooltipContent.setAttribute('x', c[3]), this._tooltipContent.setAttribute('y', c[0] + v);
        let e = 0;
        i.forEach((i, n) => {
          var o;
          const l = t.getContentAttr(this.attribute, n);
          if (!fY(l)) return;
          const c = `tooltip-content-${n}`,
            d = this._tooltipContent.createOrUpdateChild(c, { visible: !0, x: 0, y: e }, 'group');
          let u = 0;
          if (
            (fY(l.shape) &&
              d.createOrUpdateChild(
                `${c}-shape`,
                Object.assign(
                  {
                    visible: !0,
                    x: l.shape.size / 2,
                    y:
                      l.shape.size / 2 +
                      ((null !== (o = l.key.lineHeight) && void 0 !== o ? o : l.key.fontSize) - l.shape.size) / 2
                  },
                  l.shape
                ),
                'symbol'
              ),
            a && (u += l.shape.size + l.shape.spacing),
            fY(l.key))
          ) {
            let t;
            t = l.key.multiLine
              ? d.createOrUpdateChild(
                  `${c}-key`,
                  Object.assign(Object.assign({ visible: !0 }, sK(l.key)), { textBaseline: 'top' }),
                  'richtext'
                )
              : d.createOrUpdateChild(
                  `${c}-key`,
                  Object.assign(Object.assign({ visible: !0 }, l.key), { textBaseline: 'top' }),
                  'text'
                );
            const { textAlign: e } = l.key;
            'center' === e
              ? t.setAttribute('x', u + s / 2)
              : 'right' === e || 'end' === e
              ? t.setAttribute('x', u + s)
              : t.setAttribute('x', u),
              t.setAttribute('y', 0),
              (u += s + l.key.spacing);
          }
          if (fY(l.value)) {
            let t;
            t = l.value.multiLine
              ? d.createOrUpdateChild(
                  `${c}-value`,
                  Object.assign(Object.assign({ visible: !0 }, sK(l.value)), { textBaseline: 'top' }),
                  'richtext'
                )
              : d.createOrUpdateChild(
                  `${c}-value`,
                  Object.assign(Object.assign({ visible: !0 }, l.value), { textBaseline: 'top' }),
                  'text'
                );
            let e = 'right';
            h(l.value.textAlign) ? (e = l.value.textAlign) : fY(l.key) || (e = 'left'),
              t.setAttribute('textAlign', e),
              'center' === e
                ? t.setAttribute('x', u + r / 2)
                : 'right' === e || 'end' === e
                ? t.setAttribute('x', u + r)
                : t.setAttribute('x', u),
              (u += r),
              t.setAttribute('y', 0),
              d.add(t);
          }
          e += l.height + l.spaceRow;
        });
      }
    }
    setAttributes(e, i) {
      const n = Object.keys(e);
      this.attribute.autoCalculatePosition && n.every(t => aK.includes(t))
        ? (this._mergeAttributes(e, n),
          l(this.attribute.panel.width) && this.attribute.autoMeasure && t.measureTooltip(this.attribute),
          t.calculateTooltipPosition(this.attribute),
          super.setAttributes({ x: this.attribute.x, y: this.attribute.y }, i))
        : super.setAttributes(e, i);
    }
    static calculateTooltipPosition(t) {
      const { width: e = 0, height: i = 0 } = t.panel,
        { offsetX: n, offsetY: s, pointerX: r, pointerY: a, positionX: o, positionY: l, parentBounds: h } = t;
      let c = r,
        d = a;
      return (
        'left' === o ? (c -= e + n) : 'center' === o ? (c -= e / 2) : (c += n),
        'top' === l ? (d -= i + s) : 'middle' === l ? (d -= i / 2) : (d += s),
        c + e > h.x2 && (c -= e + n),
        d + i > h.y2 && (d -= i + s),
        c < h.x1 && (c = h.x1),
        d < h.y1 && (d = h.y1),
        (t.x = c),
        (t.y = d),
        t
      );
    }
    static measureTooltip(e) {
      const { content: i, contentStyle: n } = e,
        s = Je(e.padding),
        r = t.getTitleAttr(e);
      let a = 0,
        o = s[0] + s[2],
        l = 0;
      const { value: c, shape: d } = r,
        { visible: u = !1, symbolType: p = '' } = null != d ? d : {};
      if (h(c)) {
        const { width: t, height: e } = PY(c).quickMeasure(c.text);
        (a = t), (l = e);
      }
      if (
        (u && YR[p] && ((a += d.size + d.spacing), (l = Math.max(d.size, l))),
        e.title && ((e.title.width = a), (e.title.height = l)),
        fY(r) && (o += l + r.spaceRow),
        null == i ? void 0 : i.length)
      ) {
        const s = [];
        if (
          (i.forEach((i, n) => {
            const r = t.getContentAttr(e, n);
            (i.key || i.value) && fY(r) && s.push([i, r]);
          }),
          s.length)
        ) {
          let t = !1;
          const r = [],
            l = [],
            h = [];
          s.forEach((e, i) => {
            let [a, c] = e;
            var d;
            const { key: u, value: p, shape: g, spaceRow: f } = c,
              v = fY(g),
              m = null !== (d = null == g ? void 0 : g.symbolType) && void 0 !== d ? d : '',
              y = PY(u),
              _ = PY(p);
            let b = 0;
            if (fY(u)) {
              const { width: t, height: e } = y.quickMeasure(u.text);
              l.push(t), (b = Math.max(b, e));
            }
            if (fY(p)) {
              const { width: t, height: e } = _.quickMeasure(p.text);
              h.push(t), (b = Math.max(b, e));
            }
            v && YR[m] && ((t = !0), r.push(g.size), (b = Math.max(g.size, b))),
              (a.height = b),
              (o += b),
              i < s.length - 1 && (o += null != f ? f : n.spaceRow);
          });
          const c = r.length ? Math.max(...r) : 0,
            d = l.length ? Math.max(...l) : 0,
            u = h.length ? Math.max(...h) : 0;
          (a = Math.max(d + u + n.key.spacing + n.value.spacing + (t ? c + n.shape.spacing : 0), a)),
            i.forEach(t => {
              t.width = a;
            }),
            (e.hasContentShape = t),
            (e.keyWidth = d),
            (e.valueWidth = u);
        }
      }
      return (e.panel.width = a + s[1] + s[3]), (e.panel.height = o), e;
    }
    static getTitleAttr(e) {
      return nK({}, t.defaultAttributes.titleStyle, t.defaultAttributes.title, e.titleStyle, e.title);
    }
    static getContentAttr(e, i) {
      return nK({}, t.defaultAttributes.contentStyle, e.contentStyle, e.content[i]);
    }
  };
  oK.defaultAttributes = rK;
  class lK extends cY {
    parseAddition(t) {
      return super.parseAddition(t), this.scale(t.scale), this;
    }
    scale(t) {
      if (this.spec.scale) {
        const t = g(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
        this.detach(t), (this.spec.scale = void 0);
      }
      const e = g(t) ? this.view.getScaleById(t) : t;
      return (this.spec.scale = e), this.attach(e), this._updateComponentEncoders(), this.commit(), this;
    }
  }
  XG($W.lineAxis, (t, e) => new N$(t, e)), XG($W.circleAxis, t => new G$(t));
  const hK = (t, e, i, n, s) => {
    var r;
    const a = t.getCoordinateAxisPosition();
    'auto' === (null == s ? void 0 : s.position) && (s.position = i ? 'content' : a);
    const o = t.getCoordinateAxisPoints(n);
    if (o)
      return {
        start: o[0],
        end: o[1],
        verticalFactor:
          ('top' === a || 'left' === a ? -1 : 1) *
          (i ? -1 : 1) *
          ((null === (r = t.getSpec().range) || void 0 === r ? void 0 : r.reversed) ? -1 : 1)
      };
    const l = e.radius(),
      h = e.angle();
    return { center: e.origin(), radius: l[1], innerRadius: l[0], inside: i, startAngle: h[0], endAngle: h[1] };
  };
  class cK extends lK {
    constructor(t, e, i) {
      super(t, UW.axis, e), (this.spec.componentType = UW.axis), (this.mode = i);
    }
    parseAddition(t) {
      return (
        super.parseAddition(t),
        this.axisType(t.axisType),
        this.tickCount(t.tickCount),
        this.inside(t.inside),
        this.baseValue(t.baseValue),
        this
      );
    }
    scale(t) {
      return super.scale(t), (this._axisComponentType = null), this;
    }
    axisType(t) {
      return (this.spec.axisType = t), (this._axisComponentType = null), this._prepareRejoin(), this.commit(), this;
    }
    addGraphicItem(t, e) {
      const i = D({ x: 0, y: 0, start: { x: 0, y: 0 }, end: { x: 0, y: 0 } }, t),
        n = $G(this._getAxisComponentType()).creator(i, this.mode);
      return super.addGraphicItem(i, e, n);
    }
    tickCount(t) {
      return this.setFunctionSpec(t, 'tickCount');
    }
    inside(t) {
      return this.setFunctionSpec(t, 'inside');
    }
    baseValue(t) {
      return this.setFunctionSpec(t, 'baseValue');
    }
    getAxisComponentType() {
      return this._axisComponentType;
    }
    _updateComponentEncoders() {
      const t = g(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale,
        e = Object.assign({ update: {} }, this.spec.encode),
        i = Object.keys(e).reduce((i, n) => {
          const s = e[n];
          return (
            s &&
              (i[n] = {
                callback: (e, i, n) => {
                  var r, a;
                  const o = this.view.getCurrentTheme();
                  let l = NG(s, e, i, n);
                  const h = LW(this.spec.inside, n, e, i),
                    c = LW(this.spec.baseValue, n, e, i),
                    d = null === (r = null == t ? void 0 : t.getCoordinate) || void 0 === r ? void 0 : r.call(t);
                  d && (l = Object.assign(hK(t, d, h, c, this.spec.layout), l));
                  const u = null === (a = null == t ? void 0 : t.getScale) || void 0 === a ? void 0 : a.call(t),
                    p = LW(this.spec.tickCount, n, e, i);
                  switch (this._getAxisComponentType()) {
                    case $W.lineAxis:
                      return ((t, e, i, n) => {
                        var s, r, a, o;
                        const l =
                          null !==
                            (r = null === (s = null == e ? void 0 : e.components) || void 0 === s ? void 0 : s.axis) &&
                          void 0 !== r
                            ? r
                            : {};
                        return t
                          ? D(
                              {},
                              l,
                              {
                                items: [
                                  (null !== (o = null === (a = t.tickData) || void 0 === a ? void 0 : a.call(t, n)) &&
                                  void 0 !== o
                                    ? o
                                    : []
                                  ).map(t => ({ id: t.index, label: t.tick, value: t.value, rawValue: t.tick }))
                                ]
                              },
                              null != i ? i : {}
                            )
                          : D({}, l, null != i ? i : {});
                      })(u, o, l, p);
                    case $W.circleAxis:
                      return ((t, e, i, n) => {
                        var s, r, a, o;
                        const l =
                          null !==
                            (r =
                              null === (s = null == e ? void 0 : e.components) || void 0 === s
                                ? void 0
                                : s.circleAxis) && void 0 !== r
                            ? r
                            : {};
                        return t
                          ? D(
                              {},
                              l,
                              {
                                items: [
                                  (null !== (o = null === (a = t.tickData) || void 0 === a ? void 0 : a.call(t, n)) &&
                                  void 0 !== o
                                    ? o
                                    : []
                                  ).map(t => ({ id: t.index, label: t.tick, value: t.value, rawValue: t.tick }))
                                ]
                              },
                              null != i ? i : {}
                            )
                          : D({}, l, null != i ? i : {});
                      })(u, o, l, p);
                  }
                  return l;
                }
              }),
            i
          );
        }, {});
      this._encoders = i;
    }
    _getAxisComponentType() {
      var t;
      if (this._axisComponentType) return this._axisComponentType;
      let e = this.spec.axisType;
      if (l(e)) {
        const i = g(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
        e = (null === (t = null == i ? void 0 : i.getCoordinate) || void 0 === t ? void 0 : t.call(i))
          ? i.getCoordinateAxisPoints()
            ? 'line'
            : 'circle'
          : 'line';
      }
      return (this._axisComponentType = 'circle' === e ? $W.circleAxis : $W.lineAxis), this._axisComponentType;
    }
  }
  XG(XW.lineAxisGrid, (t, e) => new Z$(t, e)), XG(XW.circleAxisGrid, (t, e) => new tX(t));
  class dK extends lK {
    constructor(t, e, i) {
      super(t, UW.grid, e), (this.spec.componentType = UW.grid), (this.mode = i);
    }
    parseAddition(t) {
      return (
        super.parseAddition(t), this.target(t.target), this.gridType(t.gridType), this.gridShape(t.gridShape), this
      );
    }
    scale(t) {
      return super.scale(t), (this._gridComponentType = null), this;
    }
    gridType(t) {
      return (this.spec.gridType = t), (this._gridComponentType = null), this._prepareRejoin(), this.commit(), this;
    }
    gridShape(t) {
      return (this.spec.gridShape = t), this.commit(), this;
    }
    target(t) {
      if (this.spec.target) {
        const t = g(this.spec.target) ? this.view.getMarkById(this.spec.target) : this.spec.target;
        this.detach(t);
      }
      this.spec.target = t;
      const e = g(t) ? this.view.getMarkById(t) : t;
      return (
        this.attach(e),
        (this._targetAxis = e),
        (this._gridComponentType = null),
        this._updateComponentEncoders(),
        this.commit(),
        this
      );
    }
    tickCount(t) {
      return this.setFunctionSpec(t, 'tickCount');
    }
    inside(t) {
      return this.setFunctionSpec(t, 'inside');
    }
    baseValue(t) {
      return this.setFunctionSpec(t, 'baseValue');
    }
    addGraphicItem(t, e) {
      const i = D({ x: 0, y: 0, start: { x: 0, y: 0 }, end: { x: 0, y: 0 } }, t),
        n = $G(this._getGridComponentType()).creator(i, this.mode);
      return super.addGraphicItem(i, e, n);
    }
    _updateComponentEncoders() {
      const t = Object.assign({ update: {} }, this.spec.encode),
        e = Object.keys(t).reduce((e, i) => {
          const n = t[i];
          return (
            n &&
              (e[i] = {
                callback: (t, e, i) => {
                  var s, r, a, o, l, h;
                  const c = this.view.getCurrentTheme();
                  let d,
                    u = NG(n, t, e, i);
                  if (this._targetAxis) {
                    const t = null === (s = this._targetAxis.getSpec()) || void 0 === s ? void 0 : s.scale;
                    d = g(t) ? this.view.getScaleById(t) : t;
                    const e = this._targetAxis.elements[0];
                    if (e)
                      switch (this._getGridComponentType()) {
                        case XW.lineAxisGrid:
                          u = Object.assign(
                            {
                              x: e.getGraphicAttribute('x'),
                              y: e.getGraphicAttribute('y'),
                              start: e.getGraphicAttribute('start'),
                              end: e.getGraphicAttribute('end'),
                              verticalFactor:
                                null !== (r = e.getGraphicAttribute('verticalFactor')) && void 0 !== r ? r : 1
                            },
                            u
                          );
                          break;
                        case XW.circleAxisGrid:
                          u = Object.assign(
                            {
                              x: e.getGraphicAttribute('x'),
                              y: e.getGraphicAttribute('y'),
                              center: e.getGraphicAttribute('center'),
                              radius: e.getGraphicAttribute('radius'),
                              innerRadius: e.getGraphicAttribute('innerRadius'),
                              inside: e.getGraphicAttribute('inside'),
                              startAngle: e.getGraphicAttribute('startAngle'),
                              endAngle: e.getGraphicAttribute('endAngle')
                            },
                            u
                          );
                      }
                  } else {
                    d = g(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
                    const n = LW(this.spec.inside, i, t, e),
                      s = LW(this.spec.baseValue, i, t, e),
                      r = null === (a = null == d ? void 0 : d.getCoordinate) || void 0 === a ? void 0 : a.call(d);
                    r && (u = Object.assign(hK(d, r, n, s, this.spec.layout), u));
                  }
                  this._getGridComponentType() === XW.lineAxisGrid &&
                    (u =
                      'line' !== this.spec.gridShape && this.spec.gridShape
                        ? Object.assign({ center: u.start, closed: !0 }, u, { type: this.spec.gridShape })
                        : Object.assign(
                            {
                              length: Yt.distancePP(
                                null !== (o = u.start) && void 0 !== o ? o : { x: 0, y: 0 },
                                null !== (l = u.end) && void 0 !== l ? l : { x: 0, y: 0 }
                              )
                            },
                            u,
                            { type: 'line' }
                          ));
                  const p = null === (h = null == d ? void 0 : d.getScale) || void 0 === h ? void 0 : h.call(d),
                    f = LW(this.spec.tickCount, i, t, e);
                  switch (this._getGridComponentType()) {
                    case XW.lineAxisGrid:
                      return ((t, e, i, n) => {
                        var s, r, a, o;
                        const l =
                          null !==
                            (r = null === (s = null == e ? void 0 : e.components) || void 0 === s ? void 0 : s.grid) &&
                          void 0 !== r
                            ? r
                            : {};
                        return t
                          ? D(
                              {},
                              l,
                              {
                                items: (null !==
                                  (o = null === (a = t.tickData) || void 0 === a ? void 0 : a.call(t, n)) &&
                                void 0 !== o
                                  ? o
                                  : []
                                ).map(t => ({ id: t.index, label: t.tick, value: t.value, rawValue: t.tick }))
                              },
                              null != i ? i : {}
                            )
                          : D({}, l, null != i ? i : {});
                      })(p, c, u, f);
                    case XW.circleAxisGrid:
                      return ((t, e, i, n) => {
                        var s, r, a, o;
                        const l =
                          null !==
                            (r =
                              null === (s = null == e ? void 0 : e.components) || void 0 === s
                                ? void 0
                                : s.circleGrid) && void 0 !== r
                            ? r
                            : {};
                        return t
                          ? D(
                              {},
                              l,
                              {
                                items: (null !==
                                  (o = null === (a = t.tickData) || void 0 === a ? void 0 : a.call(t, n)) &&
                                void 0 !== o
                                  ? o
                                  : []
                                ).map(t => ({ id: t.index, label: t.tick, value: t.value, rawValue: t.tick }))
                              },
                              null != i ? i : {}
                            )
                          : D({}, l, null != i ? i : {});
                      })(p, c, u, f);
                  }
                  return u;
                }
              }),
            e
          );
        }, {});
      this._encoders = e;
    }
    _getGridComponentType() {
      var t;
      if (this._gridComponentType) return this._gridComponentType;
      if (this.spec.gridType)
        'circle' === this.spec.gridType
          ? (this._gridComponentType = XW.circleAxisGrid)
          : (this._gridComponentType = XW.lineAxisGrid);
      else if (this._targetAxis)
        switch (this._targetAxis.getAxisComponentType()) {
          case $W.circleAxis:
            this._gridComponentType = XW.circleAxisGrid;
            break;
          case $W.lineAxis:
          default:
            this._gridComponentType = XW.lineAxisGrid;
        }
      else if (this.spec.scale) {
        const e = g(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
        this._gridComponentType = (
          null === (t = null == e ? void 0 : e.getCoordinate) || void 0 === t ? void 0 : t.call(e)
        )
          ? e.getCoordinateAxisPoints()
            ? XW.lineAxisGrid
            : XW.circleAxisGrid
          : XW.lineAxisGrid;
      } else this._gridComponentType = XW.lineAxisGrid;
      return this._gridComponentType;
    }
  }
  XG(KW.discreteLegend, t => new TX(t)), XG(KW.colorLegend, t => new OX(t)), XG(KW.sizeLegend, t => new IX(t));
  class uK extends lK {
    constructor(t, e) {
      super(t, UW.legend, e), (this.spec.componentType = UW.legend), (this.spec.legendType = 'auto');
    }
    parseAddition(t) {
      var e, i;
      return (
        this.shapeScale(t.shapeScale),
        super.parseAddition(t),
        this.target(
          null === (e = t.target) || void 0 === e ? void 0 : e.data,
          null === (i = t.target) || void 0 === i ? void 0 : i.filter
        ),
        this.legendType(t.legendType),
        this
      );
    }
    scale(t) {
      return super.scale(t), (this._legendComponentType = null), this;
    }
    shapeScale(t) {
      if (this.spec.shapeScale) {
        const t = g(this.spec.shapeScale) ? this.view.getScaleById(this.spec.shapeScale) : this.spec.shapeScale;
        this.detach(t), (this.spec.shapeScale = void 0);
      }
      const e = g(t) ? this.view.getScaleById(t) : t;
      return (this.spec.shapeScale = e), this.attach(e), this.commit(), this;
    }
    legendType(t) {
      return (this.spec.legendType = t), (this._legendComponentType = null), this._prepareRejoin(), this.commit(), this;
    }
    isContinuousLegend() {
      return this._getLegendComponentType() !== KW.discreteLegend;
    }
    target(t, e) {
      var i;
      const n = this.isContinuousLegend(),
        s = n ? 'change' : SX.legendItemClick,
        r = null === (i = this.spec.target) || void 0 === i ? void 0 : i.data,
        a = g(r) ? this.view.getDataById(r) : r;
      a && this.view.removeEventListener(s, this._filterCallback), (this.spec.target = void 0);
      const o = g(t) ? this.view.getDataById(t) : t,
        l = g(e) ? (n ? (t, i) => t[e] >= i.start && t[e] <= i.end : (t, i) => i.includes(t[e])) : e;
      return (
        this._filterData(
          a,
          o,
          YW.legend,
          t => (n ? { start: t.detail.value[0], end: t.detail.value[1] } : t.detail.currentSelected),
          l
        ),
        o && (this.view.addEventListener(s, this._filterCallback), (this.spec.target = { data: o, filter: e })),
        this
      );
    }
    setSelected(t) {
      var e, i;
      return (
        (null === (i = null === (e = this.elements[0]) || void 0 === e ? void 0 : e.getGraphicItem) || void 0 === i
          ? void 0
          : i.call(e)
        ).setSelected(t),
        this
      );
    }
    addGraphicItem(t, e) {
      const i = $G(this._getLegendComponentType()).creator(t);
      return super.addGraphicItem(t, e, i);
    }
    release() {
      this._filterCallback && this.view.removeEventListener('change', this._filterCallback), super.release();
    }
    _updateComponentEncoders() {
      const t = g(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale,
        e = g(this.spec.shapeScale) ? this.view.getScaleById(this.spec.shapeScale) : this.spec.shapeScale,
        i = Object.assign({ update: {} }, this.spec.encode),
        n = Object.keys(i).reduce((n, s) => {
          const r = i[s];
          return (
            r &&
              (n[s] = {
                callback: (i, n, s) => {
                  var a, o;
                  const l = this.view.getCurrentTheme(),
                    h = NG(r, i, n, s),
                    c = null === (a = null == t ? void 0 : t.getScale) || void 0 === a ? void 0 : a.call(t);
                  switch (this._getLegendComponentType()) {
                    case KW.discreteLegend:
                      return ((t, e, i, n) => {
                        var s;
                        const r =
                          null === (s = null == e ? void 0 : e.components) || void 0 === s ? void 0 : s.discreteLegend;
                        if (!t) return D({}, r, null != i ? i : {});
                        const a = Array.from(new Set(V(t.domain()))).map((i, s) => {
                          var r, a, o, l, h, c, d, u, p, g;
                          const f = t.scale(i),
                            v = NW(f),
                            m = v
                              ? Object.assign(
                                  Object.assign(
                                    {},
                                    null !==
                                      (h =
                                        null ===
                                          (l =
                                            null ===
                                              (o =
                                                null ===
                                                  (a =
                                                    null === (r = null == e ? void 0 : e.components) || void 0 === r
                                                      ? void 0
                                                      : r.discreteLegend) || void 0 === a
                                                  ? void 0
                                                  : a.items) || void 0 === o
                                              ? void 0
                                              : o[0]) || void 0 === l
                                          ? void 0
                                          : l.shape) && void 0 !== h
                                      ? h
                                      : {}
                                  ),
                                  { fill: v, stroke: v }
                                )
                              : null !==
                                  (g =
                                    null ===
                                      (p =
                                        null ===
                                          (u =
                                            null ===
                                              (d =
                                                null === (c = null == e ? void 0 : e.components) || void 0 === c
                                                  ? void 0
                                                  : c.discreteLegend) || void 0 === d
                                              ? void 0
                                              : d.items) || void 0 === u
                                          ? void 0
                                          : u[0]) || void 0 === p
                                      ? void 0
                                      : p.shape) && void 0 !== g
                              ? g
                              : {};
                          return (
                            n && Object.assign(m, { symbolType: n.scale(i) }),
                            { label: i.toString(), id: i, shape: m, index: s }
                          );
                        });
                        return D({}, r, { items: a }, null != i ? i : {});
                      })(c, l, h, null === (o = null == e ? void 0 : e.getScale) || void 0 === o ? void 0 : o.call(e));
                    case KW.colorLegend:
                      return ((t, e, i) => {
                        var n;
                        const s =
                          null === (n = null == e ? void 0 : e.components) || void 0 === n ? void 0 : n.colorLegend;
                        if (!t) return D({}, s, null != i ? i : {});
                        const r = t.domain();
                        return D({}, s, { colors: t.range().slice(), min: r[0], max: W(r) }, null != i ? i : {});
                      })(c, l, h);
                    case KW.sizeLegend:
                      return ((t, e, i) => {
                        var n;
                        const s =
                          null === (n = null == e ? void 0 : e.components) || void 0 === n ? void 0 : n.sizeLegend;
                        if (!t) return D({}, s, null != i ? i : {});
                        const r = t.domain();
                        return D(
                          {},
                          s,
                          { min: r[0], max: r[r.length - 1], value: [r[0], r[r.length - 1]] },
                          null != i ? i : {}
                        );
                      })(c, l, h);
                  }
                  return h;
                }
              }),
            n
          );
        }, {});
      this._encoders = n;
    }
    _getLegendComponentType() {
      var t;
      if (this._legendComponentType) return this._legendComponentType;
      if (this.spec.legendType && 'auto' !== this.spec.legendType)
        this._legendComponentType =
          'color' === this.spec.legendType
            ? 'colorLegend'
            : 'size' === this.spec.legendType
            ? 'sizeLegend'
            : 'discreteLegend';
      else {
        const e = g(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale,
          i = null === (t = null == e ? void 0 : e.getScaleType) || void 0 === t ? void 0 : t.call(e);
        if (i && Zo(i)) {
          const t = e.getScale().range();
          NW(null == t ? void 0 : t[0])
            ? (this._legendComponentType = KW.colorLegend)
            : (this._legendComponentType = KW.sizeLegend);
        } else this._legendComponentType = KW.discreteLegend;
      }
      return this._legendComponentType;
    }
  }
  XG(qW.lineCrosshair, t => new YY(t)),
    XG(qW.rectCrosshair, t => new $Y(t)),
    XG(qW.sectorCrosshair, t => new KY(t)),
    XG(qW.circleCrosshair, t => new XY(t)),
    XG(qW.polygonCrosshair, t => new qY(t)),
    XG(qW.ringCrosshair, t => new KY(t));
  const pK = function (t, e, i, n, s) {
      let r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
      var a, o;
      const l = { x: 0, y: 0 },
        h = { x: 0, y: 0 },
        c =
          'angle' === i
            ? null !== (a = null == s ? void 0 : s.radius) && void 0 !== a
              ? a
              : Math.min(n.width, n.height) / 2
            : null,
        d =
          'angle' === i
            ? null !== (o = null == s ? void 0 : s.center) && void 0 !== o
              ? o
              : { x: n.width / 2, y: n.height / 2 }
            : null;
      let u = 0;
      if (Qo(e.type)) {
        if ('x' === i) u = e.scale(e.invert(t.x));
        else if ('y' === i) u = e.scale(e.invert(t.y));
        else if ('angle' === i) {
          const i = Jt(ee(d, t) + 2 * Math.PI);
          u = e.scale(e.invert(i));
        }
      } else Zo(e.type) && ('x' === i ? (u = t.x) : 'y' === i ? (u = t.y) : 'angle' === i && (u = ee(d, t)));
      switch (((u += r), i)) {
        case 'x':
          (l.x = u), (l.y = 0), (h.x = u), (h.y = n.height);
          break;
        case 'y':
          (l.x = 0), (l.y = u), (h.x = n.width), (h.y = u);
          break;
        case 'angle':
          (l.x = d.x), (l.y = d.y), (h.x = d.x + c * Math.cos(u)), (h.y = d.y + c * Math.sin(u));
      }
      return { start: l, end: h };
    },
    gK = (t, e, i, n, s, r) => {
      var a, o, l;
      const h =
        null !==
          (o = null !== (a = null == r ? void 0 : r.center) && void 0 !== a ? a : null == s ? void 0 : s.center) &&
        void 0 !== o
          ? o
          : { x: n.width / 2, y: n.height / 2 };
      let c = 0;
      if (Qo(e.type)) {
        const i = 'band' === e.type ? e.bandwidth() / 2 : 0,
          n = Math.sqrt((t.x - h.x) ** 2 + (t.y - h.y) ** 2);
        c = e.scale(e.invert(n)) + i;
      } else if (Zo(e.type)) {
        const e = null !== (l = null == s ? void 0 : s.radius) && void 0 !== l ? l : Math.min(n.width, n.height) / 2;
        c = Math.min(e, Math.sqrt((t.x - h.x) ** 2 + (t.y - h.y) ** 2));
      }
      return { radius: c, center: h };
    };
  class fK extends lK {
    constructor(t, e) {
      super(t, UW.crosshair, e),
        (this._onCrosshairShow = t => {
          var e, i, n, s;
          if (
            !(null === (i = null === (e = this.elements[0]) || void 0 === e ? void 0 : e.getGraphicItem) || void 0 === i
              ? void 0
              : i.call(e))
          )
            return;
          const r = this.group.getGroupGraphicItem(),
            a = { x: 0, y: 0 };
          if (
            (r.globalTransMatrix.transformPoint(t.canvas, a),
            a.x < 0 || a.x > r.attribute.width || a.y < 0 || a.y > r.attribute.height)
          )
            return;
          const o = this.elements[0].getGraphicItem(),
            l = null !== (n = this.spec.crosshairType) && void 0 !== n ? n : 'x',
            h = { width: r.attribute.width, height: r.attribute.height },
            c = (g(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale).getScale(),
            d = this.spec.componentConfig,
            u = this.view.getCurrentTheme(),
            p = null !== (s = this._additionalEncodeResult) && void 0 !== s ? s : {};
          let f = {};
          switch (this._getCrosshairComponentType()) {
            case qW.lineCrosshair:
              f = ((t, e, i, n, s, r, a) => {
                var o, l, h;
                const c = null === (o = null == r ? void 0 : r.components) || void 0 === o ? void 0 : o.lineCrosshair,
                  d = 'band' === e.type ? e.bandwidth() / 2 : 0;
                return D(
                  {},
                  c,
                  pK(
                    t,
                    e,
                    i,
                    n,
                    {
                      radius:
                        null !== (l = null == a ? void 0 : a.radius) && void 0 !== l
                          ? l
                          : null == s
                          ? void 0
                          : s.radius,
                      center:
                        null !== (h = null == a ? void 0 : a.center) && void 0 !== h ? h : null == s ? void 0 : s.center
                    },
                    d
                  ),
                  null != a ? a : {}
                );
              })(a, c, l, h, d, u, p);
              break;
            case qW.rectCrosshair:
              f = ((t, e, i, n, s, r, a) => {
                var o, l, h;
                const c = null === (o = null == r ? void 0 : r.components) || void 0 === o ? void 0 : o.rectCrosshair,
                  d = 'band' === e.type || 'point' === e.type ? e.step() : void 0,
                  u = null == a ? void 0 : a.rectStyle,
                  p =
                    null != d
                      ? d
                      : 'y' === i
                      ? null !== (l = null == u ? void 0 : u.width) && void 0 !== l
                        ? l
                        : c.rectStyle.width
                      : null !== (h = null == u ? void 0 : u.height) && void 0 !== h
                      ? h
                      : c.rectStyle.height,
                  g = pK(t, e, i, n, s, 'band' === e.type ? 0 : -p / 2),
                  f = {};
                'x' === i ? (f.width = p) : (f.height = p);
                const v = D({}, c, { start: g.start, end: g.end, rectStyle: f }, null != a ? a : {});
                return (
                  'x' === i ? (v.rectStyle.height = v.end.y - v.start.y) : (v.rectStyle.width = v.end.x - v.start.x), v
                );
              })(a, c, l, h, d, u, p);
              break;
            case qW.sectorCrosshair:
              f = ((t, e, i, n, s, r, a) => {
                var o, l, h, c, d;
                const u = null === (o = null == r ? void 0 : r.components) || void 0 === o ? void 0 : o.sectorCrosshair,
                  p =
                    null !==
                      (h =
                        null !== (l = null == a ? void 0 : a.radius) && void 0 !== l
                          ? l
                          : null == s
                          ? void 0
                          : s.radius) && void 0 !== h
                      ? h
                      : Math.min(n.width, n.height) / 2,
                  g =
                    null !==
                      (d =
                        null !== (c = null == a ? void 0 : a.center) && void 0 !== c
                          ? c
                          : null == s
                          ? void 0
                          : s.center) && void 0 !== d
                      ? d
                      : { x: n.width / 2, y: n.height / 2 },
                  f = u.endAngle - u.startAngle,
                  v = 'band' === e.type || 'point' === e.type ? e.step() : f;
                let m = 0;
                if (Qo(e.type)) {
                  const i = Jt(ee(g, t) + 2 * Math.PI);
                  m = e.scale(e.invert(i)) + ('band' === e.type ? e.bandwidth() / 2 : 0);
                } else Zo(e.type) && (m = ee(g, t));
                return D(
                  {},
                  u,
                  { center: g, radius: p, startAngle: m - v / 2, endAngle: m + v / 2 },
                  null != a ? a : {}
                );
              })(a, c, 0, h, d, u, p);
              break;
            case qW.circleCrosshair:
              f = ((t, e, i, n, s, r, a) => {
                var o;
                const l = null === (o = null == r ? void 0 : r.components) || void 0 === o ? void 0 : o.circleCrosshair,
                  { center: h, radius: c } = gK(t, e, 0, n, s, a);
                return D(
                  {},
                  l,
                  { center: h, radius: c, startAngle: l.startAngle, endAngle: l.endAngle },
                  null != a ? a : {}
                );
              })(a, c, 0, h, d, u, p);
              break;
            case qW.polygonCrosshair:
              f = ((t, e, i, n, s, r, a) => {
                var o;
                const l = null === (o = null == r ? void 0 : r.components) || void 0 === o ? void 0 : o.circleCrosshair,
                  { center: h, radius: c } = gK(t, e, 0, n, s, a);
                return D(
                  {},
                  l,
                  { center: h, radius: c, startAngle: l.startAngle, endAngle: l.endAngle },
                  null != a ? a : {}
                );
              })(a, c, 0, h, d, u, p);
              break;
            case qW.ringCrosshair:
              f = ((t, e, i, n, s, r, a) => {
                var o;
                const l = null === (o = null == r ? void 0 : r.components) || void 0 === o ? void 0 : o.circleCrosshair,
                  { center: h, radius: c } = gK(t, e, 0, n, s, a),
                  d = l.startAngle,
                  u = l.endAngle,
                  p = 'band' === e.type || 'point' === e.type ? e.step() : 0;
                return D(
                  {},
                  l,
                  { center: h, innerRadius: c - p / 2, radius: c + p / 2, startAngle: d, endAngle: u },
                  null != a ? a : {}
                );
              })(a, c, 0, h, d, u, p);
          }
          o.showAll(), o.setAttributes(f);
        }),
        (this._onCrosshairHide = t => {
          this.elements[0].getGraphicItem().hideAll();
        }),
        (this.spec.componentType = UW.crosshair),
        (this.spec.crosshairShape = 'line'),
        (this.spec.crosshairType = 'x');
    }
    parseAddition(t) {
      return super.parseAddition(t), this.crosshairType(t.crosshairType), this.crosshairShape(t.crosshairShape), this;
    }
    crosshairType(t) {
      return (
        (this.spec.crosshairType = t), (this._crosshairComponentType = null), this._prepareRejoin(), this.commit(), this
      );
    }
    crosshairShape(t) {
      return (
        (this.spec.crosshairShape = t),
        (this._crosshairComponentType = null),
        this._prepareRejoin(),
        this.commit(),
        this
      );
    }
    addGraphicItem(t, e) {
      const i = Object.assign(this._getDefaultCrosshairAttribute(), t),
        n = $G(this._getCrosshairComponentType()).creator(i);
      return super.addGraphicItem(i, e, n);
    }
    release() {
      var t, e, i, n;
      null === (e = null === (t = this._lastGroup) || void 0 === t ? void 0 : t.off) ||
        void 0 === e ||
        e.call(t, 'pointermove', this._onCrosshairShow),
        null === (n = null === (i = this._lastGroup) || void 0 === i ? void 0 : i.off) ||
          void 0 === n ||
          n.call(i, 'pointerleave', this._onCrosshairHide),
        super.release();
    }
    init(t, e) {
      var i, n, s, r, a, o;
      super.init(t, e);
      const l = this.group ? this.group.getGroupGraphicItem() : t.defaultLayer;
      this._lastGroup !== l &&
        (null === (n = null === (i = this._lastGroup) || void 0 === i ? void 0 : i.off) ||
          void 0 === n ||
          n.call(i, 'pointermove', this._onCrosshairShow),
        null === (r = null === (s = this._lastGroup) || void 0 === s ? void 0 : s.off) ||
          void 0 === r ||
          r.call(s, 'pointerleave', this._onCrosshairHide)),
        null === (a = null == l ? void 0 : l.on) || void 0 === a || a.call(l, 'pointermove', this._onCrosshairShow),
        null === (o = null == l ? void 0 : l.on) || void 0 === o || o.call(l, 'pointerleave', this._onCrosshairHide),
        (this._lastGroup = l);
    }
    _updateComponentEncoders() {
      const t = Object.assign({ update: {} }, this.spec.encode),
        e = Object.keys(t).reduce((e, i) => {
          const n = t[i];
          return (
            n &&
              (e[i] = {
                callback: (t, e, i) => {
                  this._additionalEncodeResult = NG(n, t, e, i);
                }
              }),
            e
          );
        }, {});
      this._encoders = e;
    }
    _getCrosshairComponentType() {
      var t, e;
      if (this._crosshairComponentType) return this._crosshairComponentType;
      const i = null !== (t = this.spec.crosshairShape) && void 0 !== t ? t : 'line',
        n = null !== (e = this.spec.crosshairType) && void 0 !== e ? e : 'x';
      return (
        (this._crosshairComponentType =
          'rect' === i
            ? 'angle' === n
              ? qW.sectorCrosshair
              : 'radius' === n
              ? qW.ringCrosshair
              : 'radius-polygon' === n
              ? qW.polygonCrosshair
              : qW.rectCrosshair
            : 'radius' === n
            ? qW.circleCrosshair
            : 'radius-polygon' === n
            ? qW.polygonCrosshair
            : qW.lineCrosshair),
        this._crosshairComponentType
      );
    }
    _getDefaultCrosshairAttribute() {
      var t;
      const e = null !== (t = this.spec.crosshairType) && void 0 !== t ? t : 'x';
      return 'radius' === e || 'radius-polygon' === e
        ? { center: { x: 0, y: 0 } }
        : { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
    }
  }
  XG(UW.slider, t => new RX(t));
  class vK extends cY {
    constructor(t, e) {
      super(t, UW.slider, e), (this.spec.componentType = UW.slider);
    }
    parseAddition(t) {
      var e, i;
      return (
        super.parseAddition(t),
        this.target(
          null === (e = t.target) || void 0 === e ? void 0 : e.data,
          null === (i = t.target) || void 0 === i ? void 0 : i.filter
        ),
        this.min(t.min),
        this.max(t.max),
        this
      );
    }
    min(t) {
      return this.setFunctionSpec(t, 'min');
    }
    max(t) {
      return this.setFunctionSpec(t, 'max');
    }
    target(t, e) {
      var i;
      const n = null === (i = this.spec.target) || void 0 === i ? void 0 : i.data,
        s = g(n) ? this.view.getDataById(n) : n;
      s && this.view.removeEventListener('change', this._filterCallback), (this.spec.target = void 0);
      const r = g(t) ? this.view.getDataById(t) : t,
        a = g(e) ? (t, i) => t[e] >= i.start && t[e] <= i.end : e;
      return (
        this._filterData(s, r, YW.slider, t => ({ start: t.detail.value[0], end: t.detail.value[1] }), a),
        r && (this.view.addEventListener('change', this._filterCallback), (this.spec.target = { data: r, filter: e })),
        this
      );
    }
    setStartEndValue(t, e) {
      var i, n;
      return (
        (null === (n = null === (i = this.elements[0]) || void 0 === i ? void 0 : i.getGraphicItem) || void 0 === n
          ? void 0
          : n.call(i)
        ).setValue([t, e]),
        this
      );
    }
    release() {
      this._filterCallback && this.view.removeEventListener('change', this._filterCallback), super.release();
    }
    _updateComponentEncoders() {
      const t = Object.assign({ update: {} }, this.spec.encode),
        e = Object.keys(t).reduce((e, i) => {
          const n = t[i];
          return (
            n &&
              (e[i] = {
                callback: (t, e, i) =>
                  ((t, e, i, n) => {
                    var s;
                    return D(
                      {},
                      null === (s = null == i ? void 0 : i.components) || void 0 === s ? void 0 : s.slider,
                      { min: t, max: e, value: [t, e] },
                      null != n ? n : {}
                    );
                  })(
                    l(this.spec.min) ? 0 : LW(this.spec.min, i, t, e),
                    l(this.spec.max) ? 1 : LW(this.spec.max, i, t, e),
                    this.view.getCurrentTheme(),
                    NG(n, t, e, i)
                  )
              }),
            e
          );
        }, {});
      this._encoders = e;
    }
  }
  XG(UW.label, t => new S$(t));
  let mK = class extends cY {
    constructor(t, e) {
      super(t, UW.label, e), (this.spec.componentType = UW.label);
    }
    parseAddition(t) {
      return super.parseAddition(t), this.labelStyle(t.labelStyle), this.size(t.size), this.target(t.target), this;
    }
    labelStyle(t) {
      return this.setFunctionSpec(t, 'labelStyle');
    }
    size(t) {
      return this.setFunctionSpec(t, 'size');
    }
    target(t) {
      if (this.spec.target) {
        const t = V(this.spec.target).map(t => (g(t) ? this.view.getMarkById(t) : t));
        this.detach(t);
      }
      if (((this.spec.target = t), t)) {
        const e = V(t).map(t => (g(t) ? this.view.getMarkById(t) : t));
        this.attach(e);
      }
      return this.commit(), this;
    }
    _updateComponentEncoders() {
      const t = Object.assign({ update: {} }, this.spec.encode),
        e = Object.keys(t).reduce((e, i) => {
          const n = t[i];
          return (
            n &&
              (e[i] = {
                callback: (t, e, i) => {
                  var s, r, a, o;
                  const h = V(this.spec.target).map(t => (g(t) ? this.view.getMarkById(t) : t)),
                    c =
                      null === (r = null === (s = this.group) || void 0 === s ? void 0 : s.getGroupGraphicItem) ||
                      void 0 === r
                        ? void 0
                        : r.call(s);
                  let d = LW(this.spec.size, i);
                  d ||
                    (d = c
                      ? {
                          width: null !== (a = c.attribute.width) && void 0 !== a ? a : c.AABBBounds.width(),
                          height: null !== (o = c.attribute.height) && void 0 !== o ? o : c.AABBBounds.height()
                        }
                      : { width: 1 / 0, height: 1 / 0 });
                  const u = this.view.getCurrentTheme();
                  return ((t, e, i, n, s, r) => {
                    var a;
                    const o = null === (a = null == r ? void 0 : r.components) || void 0 === a ? void 0 : a.dataLabel,
                      h = t
                        .map(t => {
                          var e, a, o, l, h, c;
                          let d = {};
                          switch (t.markType) {
                            case GW.line:
                              d =
                                null === (e = null == r ? void 0 : r.components) || void 0 === e ? void 0 : e.lineLabel;
                              break;
                            case GW.rect:
                            case GW.interval:
                              d =
                                null === (a = null == r ? void 0 : r.components) || void 0 === a ? void 0 : a.rectLabel;
                              break;
                            case GW.symbol:
                            case GW.circle:
                            case GW.cell:
                              d =
                                null === (o = null == r ? void 0 : r.components) || void 0 === o
                                  ? void 0
                                  : o.symbolLabel;
                              break;
                            case GW.arc:
                            case GW.arc3d:
                              d =
                                null === (l = null == r ? void 0 : r.components) || void 0 === l ? void 0 : l.arcLabel;
                              break;
                            case GW.polygon:
                            case GW.path:
                            default:
                              d =
                                null === (h = null == r ? void 0 : r.components) || void 0 === h
                                  ? void 0
                                  : h.pointLabel;
                          }
                          const u = [];
                          t.graphicItem.forEachChildren(t => {
                            var e, n;
                            if ('willRelease' !== t.releaseStatus) {
                              const r = t[iG],
                                a = NG(i, r.getDatum(), r, s),
                                o = D(
                                  {},
                                  null !==
                                    (n = null === (e = null == d ? void 0 : d.data) || void 0 === e ? void 0 : e[0]) &&
                                    void 0 !== n
                                    ? n
                                    : {},
                                  a
                                );
                              u.push(o);
                            }
                          });
                          const p = LW(n, s, t),
                            g = null === (c = t.graphicItem) || void 0 === c ? void 0 : c.name;
                          return D({}, d, { data: u, baseMarkGroupName: g }, null != p ? p : {});
                        })
                        .filter(t => !l(t));
                    return D({}, o, { size: e, dataLabels: h });
                  })(h, d, n, this.spec.labelStyle, i, u);
                }
              }),
            e
          );
        }, {});
      this._encoders = e;
    }
  };
  XG(UW.datazoom, t => new iX(t));
  class yK extends cY {
    constructor(t, e) {
      super(t, UW.datazoom, e), (this.spec.componentType = UW.datazoom);
    }
    parseAddition(t) {
      var e, i, n, s, r, a, o;
      return (
        super.parseAddition(t),
        this.preview(
          null === (e = t.preview) || void 0 === e ? void 0 : e.data,
          null === (i = t.preview) || void 0 === i ? void 0 : i.x,
          null === (n = t.preview) || void 0 === n ? void 0 : n.y,
          null === (s = t.preview) || void 0 === s ? void 0 : s.x1,
          null === (r = t.preview) || void 0 === r ? void 0 : r.y1
        ),
        this.target(
          null === (a = t.target) || void 0 === a ? void 0 : a.data,
          null === (o = t.target) || void 0 === o ? void 0 : o.filter
        ),
        this._updateComponentEncoders(),
        this
      );
    }
    preview(t, e, i, n, s) {
      if (!l(this.spec.preview)) {
        const t = this.spec.preview.data,
          e = g(t) ? this.view.getDataById(t) : t;
        this.detach(e),
          this.detach(kG(this.spec.preview.x, this.view)),
          this.detach(kG(this.spec.preview.y, this.view)),
          this.detach(kG(this.spec.preview.x1, this.view)),
          this.detach(kG(this.spec.preview.y1, this.view));
      }
      if (((this.spec.preview = void 0), t)) {
        this.spec.preview = { data: t, x: e, y: i, x1: n, y1: s };
        const r = g(t) ? this.view.getDataById(t) : t;
        this.attach(r),
          this.attach(kG(e, this.view)),
          this.attach(kG(i, this.view)),
          this.attach(kG(n, this.view)),
          this.attach(kG(s, this.view));
      }
      return this._updateComponentEncoders(), this.commit(), this;
    }
    target(t, e) {
      var i, n, s;
      const r = null === (i = this.spec.target) || void 0 === i ? void 0 : i.data,
        a = g(r) ? this.view.getDataById(r) : r,
        o =
          null === (s = null === (n = this.elements[0]) || void 0 === n ? void 0 : n.getGraphicItem) || void 0 === s
            ? void 0
            : s.call(n);
      a && o && o.setUpdateStateCallback(null), (this.spec.target = void 0);
      const h = g(t) ? this.view.getDataById(t) : t,
        c = g(e)
          ? (t, i) => {
              if (l(i.start) || l(i.end)) return !0;
              const n = this._getDatazoomMainScale(),
                s = n.range(),
                r = (n.scale(t[e]) - s[0]) / (s[s.length - 1] - s[0]);
              return i.startRatio <= r && i.endRatio >= r;
            }
          : e;
      return (
        this._filterData(
          a,
          h,
          YW.datazoom,
          t => {
            const e = t.start,
              i = t.end;
            return {
              startRatio: e,
              endRatio: i,
              start: this._invertDatazoomRatio(e),
              end: this._invertDatazoomRatio(i)
            };
          },
          c
        ),
        h &&
          o &&
          (o.setUpdateStateCallback((t, e) => {
            this._filterCallback({ start: t, end: e }, this.elements[0]);
          }),
          (this.spec.target = { data: h, filter: e })),
        this
      );
    }
    setStartEndValue(t, e) {
      var i, n;
      return (
        (null === (n = null === (i = this.elements[0]) || void 0 === i ? void 0 : i.getGraphicItem) || void 0 === n
          ? void 0
          : n.call(i)
        ).setStartAndEnd(t, e),
        this
      );
    }
    addGraphicItem(t, e) {
      var i;
      const n = this.view.getCurrentTheme(),
        s = Object.assign(
          {},
          null === (i = null == n ? void 0 : n.components) || void 0 === i ? void 0 : i.datazoom,
          t
        ),
        r = $G(this.componentType).creator(s),
        a = r;
      return (
        this._filterCallback &&
          a.setUpdateStateCallback((t, e) => {
            this._filterCallback({ start: t, end: e }, this.elements[0]);
          }),
        a.setStatePointToData(t => {
          var e;
          return this.spec.preview && null !== (e = this._invertDatazoomRatio(t)) && void 0 !== e ? e : t;
        }),
        a.setPreviewCallbackX(t => {
          var e, i;
          if (
            (null === (e = this.spec.preview) || void 0 === e ? void 0 : e.x) &&
            (null === (i = this.spec.preview) || void 0 === i ? void 0 : i.data)
          )
            return NG({ x: this.spec.preview.x }, t, this.elements[0], this.parameters()).x;
        }),
        a.setPreviewCallbackY(t => {
          var e, i;
          if (
            (null === (e = this.spec.preview) || void 0 === e ? void 0 : e.y) &&
            (null === (i = this.spec.preview) || void 0 === i ? void 0 : i.data)
          )
            return NG({ y: this.spec.preview.y }, t, this.elements[0], this.parameters()).y;
        }),
        a.setPreviewCallbackX1(t => {
          var e, i;
          if (
            (null === (e = this.spec.preview) || void 0 === e ? void 0 : e.x1) &&
            (null === (i = this.spec.preview) || void 0 === i ? void 0 : i.data)
          )
            return NG({ x1: this.spec.preview.x1 }, t, this.elements[0], this.parameters()).x1;
        }),
        a.setPreviewCallbackY1(t => {
          var e, i;
          if (
            (null === (e = this.spec.preview) || void 0 === e ? void 0 : e.y1) &&
            (null === (i = this.spec.preview) || void 0 === i ? void 0 : i.data)
          )
            return NG({ y1: this.spec.preview.y1 }, t, this.elements[0], this.parameters()).y1;
        }),
        super.addGraphicItem(s, e, r)
      );
    }
    _updateComponentEncoders() {
      var t;
      const e = null === (t = this.spec.preview) || void 0 === t ? void 0 : t.data,
        i = g(e) ? this.view.getDataById(e) : e,
        n = Object.assign({ update: {} }, this.spec.encode),
        s = Object.keys(n).reduce((t, e) => {
          const s = n[e];
          return (
            s &&
              (t[e] = {
                callback: (t, e, n) => {
                  var r;
                  const a = this.view.getCurrentTheme(),
                    o = NG(s, t, e, n);
                  return ((t, e, i) => {
                    var n;
                    const s = null === (n = null == e ? void 0 : e.components) || void 0 === n ? void 0 : n.datazoom;
                    return t ? D({}, s, { previewData: t }, null != i ? i : {}) : D({}, s, null != i ? i : {});
                  })(null === (r = null == i ? void 0 : i.getValue) || void 0 === r ? void 0 : r.call(i), a, o);
                }
              }),
            t
          );
        }, {});
      this._encoders = s;
    }
    _invertDatazoomRatio(t) {
      const e = this._getDatazoomMainScale();
      if (e) {
        const i = e.range(),
          n = (i[i.length - 1] - i[0]) * t + i[0];
        return e.invert(n);
      }
      return null;
    }
    _getDatazoomMainScale() {
      var t, e, i, n;
      const s =
        null === (e = null === (t = this.elements[0]) || void 0 === t ? void 0 : t.getGraphicItem) || void 0 === e
          ? void 0
          : e.call(t);
      if (s && this.spec.preview) {
        const t =
            'top' === s.attribute.orient || 'bottom' === s.attribute.orient
              ? null === (i = this.spec.preview.x) || void 0 === i
                ? void 0
                : i.scale
              : null === (n = this.spec.preview.y) || void 0 === n
              ? void 0
              : n.scale,
          e = g(t) ? this.view.getScaleById(t) : t;
        return null == e ? void 0 : e.getScale();
      }
      return null;
    }
  }
  XG(JW.continuousPlayer, t => new QX(t)), XG(JW.discretePlayer, t => new qX(t));
  let _K = class extends cY {
    constructor(t, e) {
      super(t, UW.player, e), (this.spec.componentType = UW.player), (this.spec.playerType = 'auto');
    }
    parseAddition(t) {
      var e, i;
      return (
        super.parseAddition(t),
        this.playerType(t.playerType),
        this.target(
          null === (e = t.target) || void 0 === e ? void 0 : e.data,
          null === (i = t.target) || void 0 === i ? void 0 : i.source
        ),
        this
      );
    }
    playerType(t) {
      return (this.spec.playerType = t), (this._playerComponentType = null), this._prepareRejoin(), this.commit(), this;
    }
    target(t, e) {
      var i, n, s;
      if (null === (i = this.spec.target) || void 0 === i ? void 0 : i.source) {
        const t = null === (n = this.spec.target) || void 0 === n ? void 0 : n.source,
          e = f(t) ? null : g(t) ? this.view.getDataById(t) : t;
        this.detach(e);
      }
      const r = f(e) ? null : g(e) ? this.view.getDataById(e) : e;
      this.attach(r);
      const a = null === (s = this.spec.target) || void 0 === s ? void 0 : s.data,
        o = g(a) ? this.view.getDataById(a) : a;
      o && this.view.removeEventListener(UX.OnChange, this._filterCallback), (this.spec.target = void 0);
      const l = g(t) ? this.view.getDataById(t) : t;
      return (
        this._filterData(
          o,
          l,
          YW.player,
          t => ({ index: t.detail.index, value: t.detail.value }),
          void 0,
          (t, e) => e.value
        ),
        l &&
          (this.view.addEventListener(UX.OnChange, this._filterCallback), (this.spec.target = { data: l, source: e })),
        this
      );
    }
    play() {
      var t, e;
      return (
        (null === (e = null === (t = this.elements[0]) || void 0 === t ? void 0 : t.getGraphicItem) || void 0 === e
          ? void 0
          : e.call(t)
        ).play(),
        this
      );
    }
    pause() {
      var t, e;
      return (
        (null === (e = null === (t = this.elements[0]) || void 0 === t ? void 0 : t.getGraphicItem) || void 0 === e
          ? void 0
          : e.call(t)
        ).pause(),
        this
      );
    }
    backward() {
      var t, e;
      return (
        (null === (e = null === (t = this.elements[0]) || void 0 === t ? void 0 : t.getGraphicItem) || void 0 === e
          ? void 0
          : e.call(t)
        ).backward(),
        this
      );
    }
    forward() {
      var t, e;
      return (
        (null === (e = null === (t = this.elements[0]) || void 0 === t ? void 0 : t.getGraphicItem) || void 0 === e
          ? void 0
          : e.call(t)
        ).forward(),
        this
      );
    }
    addGraphicItem(t, e, i) {
      const n = D({ slider: { handlerStyle: { size: 16 } } }, t),
        s = null != i ? i : $G(this._getPlayerComponentType()).creator(n);
      return super.addGraphicItem(n, e, s);
    }
    release() {
      this._filterCallback && this.view.removeEventListener('change', this._filterCallback), super.release();
    }
    _updateComponentEncoders() {
      const t = Object.assign({ update: {} }, this.spec.encode),
        e = Object.keys(t).reduce((e, i) => {
          const n = t[i];
          return (
            n &&
              (e[i] = {
                callback: (t, e, i) => {
                  var s, r;
                  const a = this.view.getCurrentTheme(),
                    o = NG(n, t, e, i),
                    l = null === (s = this.spec.target) || void 0 === s ? void 0 : s.source,
                    h = f(l) ? null : g(l) ? this.view.getDataById(l) : l,
                    c = f(l) ? l : null !== (r = null == h ? void 0 : h.getValue()) && void 0 !== r ? r : [];
                  switch (this._getPlayerComponentType()) {
                    case 'continuousPlayer':
                      return ((t, e, i) => {
                        var n;
                        return D(
                          {},
                          null === (n = null == e ? void 0 : e.components) || void 0 === n
                            ? void 0
                            : n.continuousPlayer,
                          { data: t, dataIndex: 0 },
                          null != i ? i : {}
                        );
                      })(c, a, o);
                    case 'discretePlayer':
                      return ((t, e, i) => {
                        var n;
                        return D(
                          {},
                          null === (n = null == e ? void 0 : e.components) || void 0 === n ? void 0 : n.discretePlayer,
                          { data: t, dataIndex: 0 },
                          null != i ? i : {}
                        );
                      })(c, a, o);
                  }
                }
              }),
            e
          );
        }, {});
      this._encoders = e;
    }
    _getPlayerComponentType() {
      return (
        this._playerComponentType ||
          (this.spec.playerType && 'auto' !== this.spec.playerType
            ? (this._playerComponentType =
                'discrete' === this.spec.playerType
                  ? 'discretePlayer'
                  : 'continuous' === this.spec.playerType
                  ? 'continuousPlayer'
                  : 'discretePlayer')
            : (this._playerComponentType = 'discretePlayer')),
        this._playerComponentType
      );
    }
  };
  XG(UW.tooltip, t => new oK(t)), XG(UW.dimensionTooltip, t => new oK(t));
  const bK = (t, e, i, n, s, r) => {
    var a;
    return D(
      {},
      null === (a = null == s ? void 0 : s.components) || void 0 === a ? void 0 : a.tooltip,
      { visible: !0, pointerX: t.x, pointerY: t.y, title: e, content: i, parentBounds: n },
      null != r ? r : {}
    );
  };
  class xK extends cY {
    parseAddition(t) {
      return super.parseAddition(t), this.title(t.title), this.content(t.content), this;
    }
    title(t) {
      return (
        !this.spec.title ||
          g(this.spec.title) ||
          o(this.spec.title) ||
          this.detach(this._parseTooltipRow(this.spec.title)),
        (this.spec.title = t),
        !t || g(t) || o(t) || this.attach(this._parseTooltipRow(t)),
        this.commit(),
        this
      );
    }
    content(t) {
      return (
        this.spec.content && !o(this.spec.content) && this.detach(this._parseTooltipRow(this.spec.content)),
        (this.spec.content = t),
        t && !o(t) && this.attach(this._parseTooltipRow(t)),
        this.commit(),
        this
      );
    }
    configureComponent(t) {
      return super.configureComponent(t), this;
    }
    _updateComponentEncoders() {
      const t = Object.assign({ update: {} }, this.spec.encode),
        e = Object.keys(t).reduce((e, i) => {
          const n = t[i];
          return (
            n &&
              (e[i] = {
                callback: (t, e, i) => {
                  this._additionalEncodeResult = NG(n, t, e, i);
                }
              }),
            e
          );
        }, {});
      this._encoders = e;
    }
    _parseTooltipRow(t) {
      return V(t).reduce(
        (t, e) => (
          (t = t.concat(IW(e.visible, this.view))),
          AG(e.key) || (t = t.concat(IW(e.key, this.view))),
          AG(e.value) || (t = t.concat(IW(e.value, this.view))),
          AG(e.symbol) || (t = t.concat(IW(e.symbol, this.view))),
          t
        ),
        []
      );
    }
    _computeTooltipRow(t, e, i) {
      const n = this.elements[0];
      let s,
        r,
        a,
        o = LW(t.visible, i, e, n);
      return (
        (o = !!l(o) || !!o),
        (s = AG(t.key) ? jo(t.key.field)(e) : LW(t.key, i, e, n)),
        (s = l(s) ? void 0 : d(s) ? s : { text: s }),
        (r = AG(t.value) ? jo(t.value.field)(e) : LW(t.value, i, e, n)),
        (r = l(r) ? void 0 : d(r) ? r : { text: r }),
        (a = AG(t.symbol) ? jo(t.symbol.field)(e) : LW(t.symbol, i, e, n)),
        (a = l(a) ? void 0 : d(a) ? a : { symbolType: a }),
        { visible: o, key: s, value: r, shape: a }
      );
    }
    _computeTitleContent(t) {
      const e = this.elements[0],
        i = this.parameters(),
        n = h(this.spec.title)
          ? o(this.spec.title)
            ? this.spec.title.call(null, t, e, i)
            : this._computeTooltipRow(g(this.spec.title) ? { value: this.spec.title } : this.spec.title, t, i)
          : void 0,
        s = h(this.spec.content)
          ? o(this.spec.content)
            ? V(this.spec.content.call(null, t, e, i))
            : V(t).reduce((t, e) => t.concat(V(this.spec.content).map(t => this._computeTooltipRow(t, e, i))), [])
          : void 0;
      return { title: f(n) ? n[0] : n, content: s };
    }
  }
  let SK = class extends xK {
    constructor(t, e) {
      super(t, UW.tooltip, e),
        (this._targetMarks = []),
        (this._onTooltipShow = yt((t, e) => {
          const i = this.elements[0].getGraphicItem();
          if (!this._targetMarks.includes(null == e ? void 0 : e.mark)) return void i.hideAll();
          i.showAll();
          const n = this.group.getGroupGraphicItem(),
            s = { x: 0, y: 0 };
          if ((n.globalTransMatrix.transformPoint(t.canvas, s), e === this._lastElement))
            return void i.setAttributes({ pointerX: s.x, pointerY: s.y });
          const r = { x: 0, y: 0 };
          n.globalTransMatrix.transformPoint({ x: 0, y: 0 }, r);
          const a = { x: 0, y: 0 };
          n.globalTransMatrix.transformPoint(
            { x: this.view.getSignalById('width').getValue(), y: this.view.getSignalById('height').getValue() },
            a
          );
          const o = new Kt().set(r.x, r.y, a.x, a.y),
            { title: l, content: h } = this._computeTitleContent(e.getDatum()),
            c = this.view.getCurrentTheme(),
            d = bK(s, l, h, o, c, this._additionalEncodeResult);
          i.setAttributes(d);
        }, 10)),
        (this._onTooltipHide = t => {
          this.elements[0].getGraphicItem().hideAll();
        }),
        (this.spec.componentType = UW.tooltip);
    }
    parseAddition(t) {
      return super.parseAddition(t), this.target(t.target), this;
    }
    target(t) {
      if (this.spec.target) {
        const t = V(this.spec.target).map(t => (g(t) ? this.view.getMarkById(t) : t));
        this.detach(t);
      }
      this.spec.target = t;
      const e = V(t).map(t => (g(t) ? this.view.getMarkById(t) : t));
      return this.attach(e), (this._targetMarks = e.filter(t => !l(t))), this.commit(), this;
    }
    release() {
      this.view.removeEventListener('pointermove', this._onTooltipShow),
        this.view.removeEventListener('pointerleave', this._onTooltipHide),
        super.release();
    }
    init(t, e) {
      super.init(t, e),
        this.view.addEventListener('pointermove', this._onTooltipShow),
        this.view.addEventListener('pointerleave', this._onTooltipHide);
    }
  };
  class wK extends xK {
    constructor(t, e) {
      super(t, UW.dimensionTooltip, e),
        (this._avoidMarks = []),
        (this._tooltipDataFilter = null),
        (this._onTooltipShow = yt((t, e) => {
          var i, n, s;
          const r = this.elements[0].getGraphicItem(),
            a = (g(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale).getScale(),
            o = this.group.getGroupGraphicItem(),
            l = { x: 0, y: 0 };
          o.globalTransMatrix.transformPoint(t.canvas, l);
          const h = { width: o.attribute.width, height: o.attribute.height };
          if (l.x < 0 || l.x > o.attribute.width || l.y < 0 || l.y > o.attribute.height) return void r.hideAll();
          const c =
            null === (n = null === (i = t.target) || void 0 === i ? void 0 : i[iG]) || void 0 === n ? void 0 : n.mark;
          if (this._avoidMarks.includes(c)) return void r.hideAll();
          const d = null === (s = this.spec.target) || void 0 === s ? void 0 : s.data,
            u = d ? (g(d) ? this.view.getDataById(d) : d) : null,
            p = u ? u.getValue() : [],
            f = ((t, e, i, n, s) => {
              var r, a;
              if ('x' === i) return e.invert(t.x);
              if ('y' === i) return e.invert(t.y);
              if ('radius' === i) {
                const i =
                    null !== (r = null == s ? void 0 : s.center) && void 0 !== r
                      ? r
                      : { x: n.width / 2, y: n.height / 2 },
                  a = Math.sqrt((i.x - t.x) ** 2 + (i.y - t.y) ** 2);
                return e.invert(a);
              }
              if ('angle' === i) {
                const i = ee(
                  null !== (a = null == s ? void 0 : s.center) && void 0 !== a
                    ? a
                    : { x: n.width / 2, y: n.height / 2 },
                  t
                );
                return e.invert(i);
              }
              return e.invert(t.x);
            })(l, a, this.spec.tooltipType, h, this.spec.componentConfig),
            v = this._tooltipDataFilter ? p.filter(t => this._tooltipDataFilter(t, f)) : [];
          if (
            (r.showAll(),
            ((t, e) => {
              const i = V(t),
                n = V(e);
              return i.length === n.length && i.every(t => n.includes(t)) && n.every(t => i.includes(t));
            })(v, this._lastDatum))
          )
            return void r.setAttributes({ pointerX: l.x, pointerY: l.y });
          this._lastDatum = v;
          const m = { x: 0, y: 0 };
          o.globalTransMatrix.transformPoint({ x: 0, y: 0 }, m);
          const y = { x: 0, y: 0 };
          o.globalTransMatrix.transformPoint(
            { x: this.view.getSignalById('width').getValue(), y: this.view.getSignalById('height').getValue() },
            y
          );
          const _ = new Kt().set(m.x, m.y, y.x, y.y),
            { title: b, content: x } = this._computeTitleContent(v),
            S = this.view.getCurrentTheme(),
            w = bK(l, b, x, _, S, this._additionalEncodeResult);
          r.setAttributes(w);
        }, 10)),
        (this._onTooltipHide = t => {
          this.elements[0].getGraphicItem().hideAll();
        }),
        (this.spec.componentType = UW.dimensionTooltip),
        (this.spec.tooltipType = 'x');
    }
    parseAddition(t) {
      var e, i;
      return (
        super.parseAddition(t),
        this.scale(t.scale),
        this.tooltipType(t.tooltipType),
        this.target(
          null === (e = t.target) || void 0 === e ? void 0 : e.data,
          null === (i = t.target) || void 0 === i ? void 0 : i.filter
        ),
        this.avoidMark(t.avoidMark),
        this
      );
    }
    scale(t) {
      if (this.spec.scale) {
        const t = g(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
        this.detach(t), (this.spec.scale = void 0);
      }
      const e = g(t) ? this.view.getScaleById(t) : t;
      return (this.spec.scale = e), this.attach(e), this.commit(), this;
    }
    tooltipType(t) {
      return (this.spec.tooltipType = t), this.commit(), this;
    }
    target(t, e) {
      var i;
      const n = null === (i = this.spec.target) || void 0 === i ? void 0 : i.data;
      if (n) {
        const t = g(n) ? this.view.getDataById(n) : n;
        this.detach(t), (this.spec.target = void 0);
      }
      const s = g(t) ? this.view.getDataById(t) : t;
      return (
        (this._tooltipDataFilter = g(e) ? (t, i) => i === t[e] : e),
        s && (this.attach(s), (this.spec.target = { data: s, filter: e })),
        this.commit(),
        this
      );
    }
    avoidMark(t) {
      if (this.spec.avoidMark) {
        const t = V(this.spec.avoidMark).map(t => (g(t) ? this.view.getMarkById(t) : t));
        this.detach(t);
      }
      this.spec.avoidMark = t;
      const e = V(t).map(t => (g(t) ? this.view.getMarkById(t) : t));
      return this.attach(e), (this._avoidMarks = e.filter(t => !l(t))), this.commit(), this;
    }
    release() {
      var t, e, i, n;
      null === (e = null === (t = this._lastGroup) || void 0 === t ? void 0 : t.off) ||
        void 0 === e ||
        e.call(t, 'pointermove', this._onTooltipShow),
        null === (n = null === (i = this._lastGroup) || void 0 === i ? void 0 : i.off) ||
          void 0 === n ||
          n.call(i, 'pointerleave', this._onTooltipHide),
        super.release();
    }
    init(t, e) {
      var i, n, s, r, a, o;
      super.init(t, e);
      const l = this.group ? this.group.getGroupGraphicItem() : t.defaultLayer;
      this._lastGroup !== l &&
        (null === (n = null === (i = this._lastGroup) || void 0 === i ? void 0 : i.off) ||
          void 0 === n ||
          n.call(i, 'pointermove', this._onTooltipShow),
        null === (r = null === (s = this._lastGroup) || void 0 === s ? void 0 : s.off) ||
          void 0 === r ||
          r.call(s, 'pointerleave', this._onTooltipHide)),
        null === (a = null == l ? void 0 : l.on) || void 0 === a || a.call(l, 'pointermove', this._onTooltipShow),
        null === (o = null == l ? void 0 : l.on) || void 0 === o || o.call(l, 'pointerleave', this._onTooltipHide),
        (this._lastGroup = l);
    }
  }
  XG(UW.title, t => new DX(t));
  let AK = class extends cY {
    constructor(t, e) {
      super(t, UW.title, e), (this.spec.componentType = UW.title);
    }
    parseAddition(t) {
      return super.parseAddition(t), this;
    }
    title(t) {
      return this.setFunctionSpec(t, 'title');
    }
    subTitle(t) {
      return this.setFunctionSpec(t, 'subTitle');
    }
    _updateComponentEncoders() {
      const t = Object.assign({ update: {} }, this.spec.encode),
        e = Object.keys(t).reduce((e, i) => {
          const n = t[i];
          return (
            n &&
              (e[i] = {
                callback: (t, e, i) => {
                  const s = this.view.getCurrentTheme();
                  return ((t, e, i, n) => {
                    var s;
                    const r = null === (s = null == i ? void 0 : i.components) || void 0 === s ? void 0 : s.title,
                      a = {};
                    return h(t) && (a.text = t), h(e) && (a.subtext = e), D({}, r, a, null != n ? n : {});
                  })(LW(this.spec.title, i, t, e), LW(this.spec.subTitle, i, t, e), s, NG(n, t, e, i));
                }
              }),
            e
          );
        }, {});
      this._encoders = e;
    }
  };
  var kK = function (t, e, i, n) {
    return new (i || (i = Promise))(function (s, r) {
      function a(t) {
        try {
          l(n.next(t));
        } catch (t) {
          r(t);
        }
      }
      function o(t) {
        try {
          l(n.throw(t));
        } catch (t) {
          r(t);
        }
      }
      function l(t) {
        var e;
        t.done
          ? s(t.value)
          : ((e = t.value),
            e instanceof i
              ? e
              : new i(function (t) {
                  t(e);
                })).then(a, o);
      }
      l((n = n.apply(t, e || [])).next());
    });
  };
  const MK = {
    csv: Ga,
    dsv: Wa,
    tsv: Ua,
    json: function (t) {
      if (!g(t)) return V(t);
      try {
        return V(JSON.parse(t));
      } catch (t) {
        return [];
      }
    }
  };
  var TK = function (t, e, i, n) {
    return new (i || (i = Promise))(function (s, r) {
      function a(t) {
        try {
          l(n.next(t));
        } catch (t) {
          r(t);
        }
      }
      function o(t) {
        try {
          l(n.throw(t));
        } catch (t) {
          r(t);
        }
      }
      function l(t) {
        var e;
        t.done
          ? s(t.value)
          : ((e = t.value),
            e instanceof i
              ? e
              : new i(function (t) {
                  t(e);
                })).then(a, o);
      }
      l((n = n.apply(t, e || [])).next());
    });
  };
  class CK extends VU {
    constructor(t, e, i) {
      super(t),
        (this.grammarType = 'data'),
        (this.spec = {}),
        (this._dataIDKey = `VGRAMMAR_DATA_ID_KEY_${this.uid}`),
        (this._loadTasks = []),
        (this._postFilters = []),
        (this.ingest = t => {
          const e = FW(t.format, this.parameters());
          return (
            (this._input = ((t, e) => {
              if (!e || !MK[e.type]) return V(t);
              const i = 'dsv' === e.type ? { delimiter: e.delimiter } : {};
              return MK[e.type](t, i, new yo(new vo()));
            })(t.values, e)),
            this._input
          );
        }),
        (this.load = t => {
          var e;
          if (t.values) return this.ingest(t);
          const i = FW(t.url, this.parameters()),
            n = null !== (e = FW(t.format, this.parameters())) && void 0 !== e ? e : { type: 'json' };
          return (t =>
            kK(void 0, void 0, void 0, function* () {
              try {
                return (yield fetch(t)).text();
              } catch (t) {
                return null;
              }
            }))(i).then(t => this.ingest({ values: t, format: n }));
        }),
        (this.relay = t => t[0]),
        (this.evaluateSync = (t, e) => {
          this.view.emit(tG.BEFORE_EVALUATE_DATA);
          const i = this._isLoaded ? this.transforms : this._loadTasks.concat(this.transforms),
            n = this.evaluateTransformSync(i, this.grammarSource ? t : this._input, e),
            s = this._evaluateFilter(n, e);
          return this.setValues(s), (this._isLoaded = !0), this.view.emit(tG.AFTER_EVALUATE_DATA), this;
        }),
        (this._loadTasks = []),
        l(e) || this.values(e, i);
    }
    parse(t) {
      return (
        super.parse(t),
        (this._isLoaded = !1),
        this.source(t.source, t.format, !1),
        this.url(t.url, t.format, !1),
        this.values(t.values, t.format, !1),
        this.transform(t.transform),
        this.parseLoad(t),
        this.commit(),
        this
      );
    }
    parseDataSource(t) {
      const e = [],
        i = [],
        n = t.format ? IW(t.format, this.view)[0] : null;
      if ((n && e.push(n), t.values)) {
        const n = IW(t.values, this.view)[0];
        n && e.push(n),
          i.push({
            type: 'ingest',
            transform: this.ingest,
            isRawOptions: !0,
            options: { values: t.values, format: t.format }
          });
      } else if (t.url) {
        const s = IW(t.url, this.view)[0];
        s && e.push(s),
          i.push({
            type: 'load',
            transform: this.load,
            options: { url: null != s ? s : t.url, format: null != n ? n : t.format }
          });
      } else if (t.source) {
        const n = [];
        V(t.source).forEach(t => {
          const i = zW(t) ? t : this.view.getDataById(t);
          i && (e.push(i), n.push(i));
        }),
          n.length && (i.push({ type: 'relay', transform: this.relay, options: n }), (this.grammarSource = n[0]));
      }
      return { transforms: i, refs: e };
    }
    evaluate(t, e) {
      return TK(this, void 0, void 0, function* () {
        this.view.emit(tG.BEFORE_EVALUATE_DATA);
        const i = this._isLoaded ? this.transforms : this._loadTasks.concat(this.transforms);
        this.grammarSource && (this._input = t);
        const n = yield this.evaluateTransform(i, this._input, e),
          s = this._evaluateFilter(n, e);
        return this.setValues(s), (this._isLoaded = !0), this.view.emit(tG.AFTER_EVALUATE_DATA), this;
      });
    }
    output() {
      return this._values;
    }
    getDataIDKey() {
      return this._dataIDKey;
    }
    values(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      const n = Object.assign({}, this.spec, { values: t, format: e });
      return l(t) || ((n.url = void 0), (n.source = void 0)), i ? this.parseLoad(n) : this;
    }
    url(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      const n = Object.assign({}, this.spec, { url: t, format: e });
      return l(t) || ((n.values = void 0), (n.source = void 0)), i ? this.parseLoad(n) : this;
    }
    source(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      const n = Object.assign({}, this.spec, { source: t, format: e });
      return l(t) || ((n.values = void 0), (n.url = void 0)), i ? this.parseLoad(n) : this;
    }
    parseLoad(t) {
      this.detach(this.parseDataSource(this.spec).refs), (this.spec = t);
      const e = this.parseDataSource(this.spec);
      return this.attach(e.refs), (this._loadTasks = e.transforms), (this._isLoaded = !1), this.commit(), this;
    }
    setValues(t) {
      this._values = V(t).map((t, e) => {
        const i = t === Object(t) ? t : { data: t };
        return (i[this._dataIDKey] = e), i;
      });
    }
    field(t) {
      return this._values.map(e => e[t]);
    }
    transform(t) {
      const e = UU(this.spec.transform, this.view);
      e && (this.detach(e.refs), (this.transforms = [])), (this.spec.transform = t);
      const i = UU(this.spec.transform, this.view);
      return i && (this.attach(i.refs), (this.transforms = i.transforms)), this.commit(), this;
    }
    getValue() {
      return this._values;
    }
    getInput() {
      return this._input;
    }
    addDataFilter(t) {
      return (
        (this._postFilters = this._postFilters.concat(V(t))),
        this._postFilters.sort((t, e) => {
          var i, n;
          return (null !== (i = t.rank) && void 0 !== i ? i : 0) - (null !== (n = e.rank) && void 0 !== n ? n : 0);
        }),
        this
      );
    }
    removeDataFilter(t) {
      const e = V(t);
      return (this._postFilters = this._postFilters.filter(t => !e.includes(t))), this;
    }
    _evaluateFilter(t, e) {
      return this._postFilters.reduce((t, i) => i.filter(t, e), t);
    }
    reuse(t) {
      return t.grammarType !== this.grammarType || ((this._isLoaded = !1), (this._values = t.output())), this;
    }
    clear() {
      super.clear(), (this._input = null), (this._values = null);
    }
  }
  function EK(t, e, i, n) {
    let s, r;
    const a = t[e];
    for (; e > i && ((r = Math.floor((e - 1) / 2)), (s = t[r]), n(a, s) < 0); ) (t[e] = s), (e = r);
    return (t[e] = a);
  }
  function PK(t, e, i, n) {
    const s = e,
      r = null != i ? i : t.length,
      a = t[e];
    let o,
      l = 2 * e + 1;
    for (; l < r; ) (o = l + 1), o < r && n(t[l], t[o]) >= 0 && (l = o), (t[e] = t[l]), (l = 2 * (e = l) + 1);
    return (t[e] = a), EK(t, e, s, n);
  }
  class RK {
    constructor(t) {
      (this.compare = t), (this.nodes = []);
    }
    size() {
      return this.nodes.length;
    }
    last() {
      return this.nodes[0];
    }
    validate() {
      for (let t = this.nodes.length - 1; t > 0; t -= 1) {
        const e = Math.floor((t - 1) / 2);
        if (this.compare(this.nodes[e], this.nodes[t]) > 0) return !1;
      }
      return !0;
    }
    push(t) {
      if (this.nodes.includes(t)) {
        const e = this.nodes.indexOf(t);
        return EK(this.nodes, e, 0, this.compare), PK(this.nodes, e, null, this.compare);
      }
      return this.nodes.push(t), EK(this.nodes, this.nodes.length - 1, 0, this.compare);
    }
    remove(t) {
      if (this.nodes.includes(t)) {
        const e = this.nodes.indexOf(t);
        (this.nodes = this.nodes.slice(0, e).concat(this.nodes.slice(e + 1))),
          EK(this.nodes, e, 0, this.compare),
          PK(this.nodes, e, null, this.compare);
      }
    }
    pop() {
      const t = this.nodes.pop();
      let e;
      return (
        this.nodes.length ? ((e = this.nodes[0]), (this.nodes[0] = t), PK(this.nodes, 0, null, this.compare)) : (e = t),
        e
      );
    }
    clear() {
      this.nodes = [];
    }
  }
  class OK {
    constructor(t) {
      (this.list = []), (this.ids = {}), (this.idFunc = t || zo);
    }
    add(t) {
      const e = this.idFunc(t);
      return this.ids[e] || ((this.ids[e] = 1), this.list.push(t)), this;
    }
    remove(t) {
      const e = this.idFunc(t);
      return this.ids[e] && ((this.ids[e] = 0), (this.list = this.list.filter(e => e !== t))), this;
    }
    forEach(t, e) {
      e ? this.list.slice().reverse().forEach(t) : this.list.forEach(t);
    }
    filter(t) {
      return this.list.filter(t);
    }
    get length() {
      return this.list.length;
    }
    getElementByIndex(t) {
      return this.list[t];
    }
  }
  var BK = function (t, e, i, n) {
    return new (i || (i = Promise))(function (s, r) {
      function a(t) {
        try {
          l(n.next(t));
        } catch (t) {
          r(t);
        }
      }
      function o(t) {
        try {
          l(n.throw(t));
        } catch (t) {
          r(t);
        }
      }
      function l(t) {
        var e;
        t.done
          ? s(t.value)
          : ((e = t.value),
            e instanceof i
              ? e
              : new i(function (t) {
                  t(e);
                })).then(a, o);
      }
      l((n = n.apply(t, e || [])).next());
    });
  };
  class IK {
    constructor() {
      (this.grammars = []),
        (this.logger = Ze.getInstance()),
        (this._curRank = 0),
        (this._committed = new OK(t => t.uid)),
        (this._heap = new RK((t, e) => t.qrank - e.qrank)),
        (this._beforeRunner = null),
        (this._afterRunner = null),
        (this._isRunning = !1),
        (this._updateCounter = 0),
        (this._finishFirstRender = !1);
    }
    asyncCallback(t) {
      return BK(this, void 0, void 0, function* () {
        try {
          yield t(this);
        } catch (t) {
          this.logger.error(t);
        }
      });
    }
    add(t) {
      if (t)
        return this._setRankOfGrammar(t), this.commit(t), !this.grammars.includes(t) && (this.grammars.push(t), !0);
    }
    remove(t) {
      t && (this._committed.remove(t), this._heap.remove(t), (this.grammars = this.grammars.filter(e => e !== t)));
    }
    _setRankOfGrammar(t) {
      t.rank = ++this._curRank;
    }
    _reRank(t) {
      const e = [t];
      for (; e.length; ) {
        const i = e.pop();
        this._setRankOfGrammar(i);
        const n = i.targets;
        n &&
          n.forEach(i => {
            e.push(i), i === t && this.logger.error('Cycle detected in dataflow graph.');
          }, !0);
      }
    }
    _enqueue(t) {
      (t.qrank = t.rank), this._heap.push(t);
    }
    _logGrammarRunInfo(t) {
      if (this.logger.canLogError()) {
        const e = [
          { key: 'id', value: t.id() },
          { key: 'name', value: t.name() }
        ].reduce((t, e, i) => (l(e.value) ? t : `${t}${i ? ' , ' : ''}${e.key}: ${e.value}`), '');
        this.logger.debug('Run Operator: ', t, e);
      }
    }
    hasCommitted() {
      return !!this._committed.length;
    }
    commit(t) {
      return this._isRunning ? this._enqueue(t) : this._committed.add(t), this;
    }
    _beforeEvaluate() {
      this.grammars.forEach(t => {
        t.targets.some(e => e.rank < t.rank) && this._reRank(t);
      }),
        this._committed.forEach(t => this._enqueue(t)),
        (this._committed = new OK(t => t.uid));
    }
    _enqueueTargets(t) {
      t.targets && t.targets.length && this._finishFirstRender && t.targets.forEach(t => this._enqueue(t));
    }
    evaluate() {
      return BK(this, void 0, void 0, function* () {
        if ((this._beforeRunner && (yield this.asyncCallback(this._beforeRunner)), !this._committed.length))
          return this.logger.info('Dataflow invoked, but nothing to do.'), !1;
        (this._isRunning = !0), (this._updateCounter += 1);
        let t,
          e,
          i,
          n,
          s = 0;
        this.logger.canLogInfo() &&
          ((i = Date.now()), this.logger.debug(`-- START PROPAGATION (${this._updateCounter}) -----`)),
          this._beforeEvaluate();
        try {
          for (; this._heap.size() > 0; )
            (t = this._heap.pop()),
              t.rank === t.qrank
                ? ((e = t.run()),
                  e && e.then && (e = yield e),
                  this._logGrammarRunInfo(t),
                  this._enqueueTargets(t),
                  (s += 1))
                : this._enqueue(t);
        } catch (t) {
          this._heap.clear(), (n = t);
        }
        return (
          (this._isRunning = !1),
          this.logger.canLogInfo() && ((i = Date.now() - i), this.logger.info(`> ${s} grammars; ${i} ms`)),
          n ? this.logger.error(n) : this._afterRunner && (yield this.asyncCallback(this._afterRunner)),
          (this._finishFirstRender = !0),
          !0
        );
      });
    }
    evaluateSync() {
      if ((this._beforeRunner && this._beforeRunner(this), !this._committed.length))
        return this.logger.info('Dataflow invoked, but nothing to do.'), !1;
      (this._isRunning = !0), (this._updateCounter += 1);
      let t,
        e,
        i = 0;
      for (
        this.logger.canLogInfo() &&
          ((e = Date.now()), this.logger.debug(`-- START PROPAGATION (${this._updateCounter}) -----`)),
          this._beforeEvaluate();
        this._heap.size() > 0;

      )
        (t = this._heap.pop()),
          t.rank === t.qrank
            ? (t.runSync(), this._logGrammarRunInfo(t), this._enqueueTargets(t), (i += 1))
            : this._enqueue(t);
      return (
        (this._isRunning = !1),
        this.logger.canLogInfo() && ((e = Date.now() - e), this.logger.info(`> ${i} grammars updated; ${e} ms`)),
        this._afterRunner && this._afterRunner(this),
        (this._finishFirstRender = !0),
        !0
      );
    }
    runBefore(t) {
      this._beforeRunner = t;
    }
    runAfter(t) {
      this._afterRunner = t;
    }
    release() {
      this._heap && (this._heap.clear(), (this._heap = null)), (this.logger = null), (this._committed = null);
    }
  }
  const DK = (t, e, i, n, s) => {
    const r = t => {
      if ((s || !t || (n && !n(t)) || i.call(null, t), t.markType === GW.group)) {
        const i = t[e];
        i &&
          i.forEach(t => {
            r(t);
          });
      }
      s && (!t || (n && !n(t)) || i.call(null, t));
    };
    r(t);
  };
  class LK {
    constructor(t) {
      (this.handleAfterNextRender = () => {
        this._stage && !this._viewOptions.disableDirtyBounds && this._stage.enableDirtyBounds(),
          this._view.emit(tG.AFTER_VRENDER_DRAW),
          this._view.emit(tG.AFTER_VRENDER_NEXT_RENDER);
      }),
        (this._view = t);
    }
    initialize(t, e, i, n) {
      return (
        (this._width = t), (this._height = e), (this._viewOptions = i), (this._eventConfig = n), this.initStage(), this
      );
    }
    stage() {
      var t;
      return null !== (t = this._stage) && void 0 !== t ? t : null;
    }
    canvas() {
      return this._stage ? this._stage.window.getNativeHandler().nativeCanvas : null;
    }
    context() {
      return this._stage ? this._stage.window.getContext().nativeContext : null;
    }
    combineIncrementalLayers() {
      return (
        this._stage &&
          (function (t) {
            return gE(this, void 0, void 0, function* () {
              const e = [],
                i = t.getChildren();
              yield new Promise(t => {
                WA.global.getRequestAnimationFrame()(() => {
                  t(null);
                });
              }),
                i.forEach(t => {
                  t.subLayers.size &&
                    t.subLayers.forEach(t => {
                      t.drawContribution &&
                        t.drawContribution.hooks &&
                        t.drawContribution.rendering &&
                        e.push(
                          new Promise(e => {
                            t.drawContribution.hooks.completeDraw.tap('outWait', () => {
                              (t.drawContribution.hooks.completeDraw.taps =
                                t.drawContribution.hooks.completeDraw.taps.filter(t => 'outWait' !== t.name)),
                                e(null);
                            });
                          })
                        );
                    });
                }),
                yield Promise.all(e);
            });
          })(this._stage).then(() => {
            this._stage && this._stage.defaultLayer.combineSubLayer();
          }),
        this
      );
    }
    background(t) {
      if (this._stage) return (this._stage.background = t), this;
    }
    setDpr(t, e) {
      var i, n;
      return (
        null === (n = null === (i = this._stage) || void 0 === i ? void 0 : i.setDpr) || void 0 === n || n.call(i, t),
        e && this.renderNextFrame(),
        this
      );
    }
    shouldResize(t, e) {
      return t !== this._width || e !== this._height;
    }
    resize(t, e) {
      return (
        this._view.emit(tG.BEFORE_STAGE_RESIZE),
        this.shouldResize(t, e) && ((this._width = t), (this._height = e), this._stage && this._stage.resize(t, e)),
        this._view.emit(tG.AFTER_STAGE_RESIZE),
        this
      );
    }
    setViewBox(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      return this._stage
        ? (!t ||
            (this._viewBox &&
              t.x1 === this._viewBox.x1 &&
              t.x2 === this._viewBox.x2 &&
              t.y1 === this._viewBox.y1 &&
              t.y2 === this._viewBox.y2) ||
            ((this._viewBox = t), this._stage.setViewBox(t.x1, t.y1, t.x2 - t.x1, t.y2 - t.y1, e)),
          this)
        : this;
    }
    render() {
      let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      return (
        this._view.emit(tG.BEFORE_VRENDER_DRAW),
        this.initStage(),
        this._stage.disableDirtyBounds(),
        this._stage.afterNextRender(this.handleAfterNextRender),
        t && (this._stage.render(), this._view.emit(tG.AFTER_VRENDER_DRAW)),
        this
      );
    }
    renderNextFrame() {
      return this.initStage(), this._stage.renderNextFrame(), this;
    }
    toCanvas() {
      return this._stage ? this._stage.toCanvas() : null;
    }
    release() {
      this._view.traverseMarkTree(t => {
        t.release();
      }),
        this._dragController && this._dragController.release(),
        this._gestureController && this._gestureController.release(),
        this._stage && this._stage.release(),
        (this._stage = null),
        (this._layer = null),
        (this._dragController = null),
        (this._gestureController = null);
    }
    createStage() {
      var t, e, i, n, s;
      this._view.emit(tG.BEFORE_CREATE_VRENDER_STAGE);
      const r = this._viewOptions,
        a =
          null !== (t = r.stage) && void 0 !== t
            ? t
            : (function (t) {
                return new PN(t);
              })({
                width: this._width,
                height: this._height,
                renderStyle: r.renderStyle,
                viewBox: r.viewBox,
                dpr: r.dpr,
                canvas: r.renderCanvas,
                canvasControled: r.canvasControled,
                container: r.container,
                title: r.rendererTitle,
                beforeRender: r.beforeRender,
                afterRender: r.afterRender,
                disableDirtyBounds: !!r.disableDirtyBounds,
                autoRender: !0,
                pluginList: r.pluginList
              });
      (null === (e = r.options3d) || void 0 === e ? void 0 : e.enable) && a.set3dOptions(r.options3d),
        a.enableIncrementalAutoRender(),
        (this._viewBox = r.viewBox),
        this._view.emit(tG.AFTER_CREATE_VRENDER_STAGE),
        this._view.emit(tG.BEFORE_CREATE_VRENDER_LAYER);
      const o = null !== (i = r.layer) && void 0 !== i ? i : a.defaultLayer;
      if (
        (this._view.emit(tG.AFTER_CREATE_VRENDER_LAYER),
        (null === (n = this._eventConfig) || void 0 === n ? void 0 : n.drag) && (this._dragController = new uM(o)),
        null === (s = this._eventConfig) || void 0 === s ? void 0 : s.gesture)
      ) {
        const t = c(this._eventConfig.gesture) ? this._eventConfig.gesture : {};
        this._gestureController = new fM(o, t);
      }
      return { stage: a, layer: o };
    }
    initStage() {
      if (!this._stage) {
        const { stage: t, layer: e } = this.createStage();
        (this._stage = t), (this._layer = e);
        const i = this._view.background();
        this.background(i);
      }
    }
  }
  class FK extends VU {
    constructor() {
      super(...arguments), (this.grammarType = 'signal'), (this.spec = { value: null, update: null });
    }
    parse(t) {
      return super.parse(t), this.value(t.value), this.update(t.update), this.commit(), this;
    }
    evaluate(t, e) {
      return (
        (this._signal = this.spec.update ? LW(this.spec.update, e, this._signal) : this.spec.value),
        (this.spec.value = this._signal),
        this
      );
    }
    output() {
      return this._signal;
    }
    getValue() {
      return this.output();
    }
    set(t) {
      if (f(t) && f(this.value) && t.length === this.value.length) {
        for (let e = 0; e < t.length; e++)
          if (this.value[e] !== t[e]) return (this._signal = t), (this.spec.value = t), !0;
        return !1;
      }
      return this._signal !== t && ((this._signal = t), (this.spec.value = t), !0);
    }
    update(t) {
      return l(t) || this.value(void 0), this.setFunctionSpec(t, 'update');
    }
    value(t) {
      return l(t) || this.update(void 0), (this.spec.value = t), this.commit(), this;
    }
    reuse(t) {
      return t.grammarType !== this.grammarType || (this._signal = t.output()), this;
    }
    clear() {
      super.clear(), (this._signal = null);
    }
  }
  function jK(t) {
    switch (t) {
      case 'band':
        return new xl();
      case 'linear':
        return new Vl();
      case 'log':
        return new Gl();
      case 'ordinal':
        return new il();
      case 'point':
        return new Ul();
      case 'pow':
        return new Yl();
      case 'quantile':
        return new $l();
      case 'quantize':
        return new Xl();
      case 'sqrt':
        return new Kl();
      case 'symlog':
        return new ql();
      case 'threshold':
        return new Zl();
      case 'time':
        return new eh();
      case 'utc':
        return new eh(!0);
      case 'identity':
        return new nh();
    }
    return new Vl();
  }
  function zK(t) {
    return !l(null == t ? void 0 : t.data);
  }
  function HK(t, e) {
    var i;
    if (g(t.data)) {
      const i = e.getGrammarById(t.data);
      return i ? [i] : [];
    }
    return 'data' === (null === (i = t.data) || void 0 === i ? void 0 : i.grammarType) ? [t.data] : [];
  }
  function NK(t) {
    return !l(null == t ? void 0 : t.datas);
  }
  function VK(t) {
    return !l(null == t ? void 0 : t.coordinate);
  }
  function WK(t, e) {
    let i = [];
    return (
      (i = i.concat(IW(t.nice, e))),
      (i = i.concat(IW(t.niceMin, e))),
      (i = i.concat(IW(t.niceMax, e))),
      (i = i.concat(IW(t.min, e))),
      (i = i.concat(IW(t.max, e))),
      (i = i.concat(IW(t.zero, e))),
      (i = i.concat(IW(t.roundRange, e))),
      i
    );
  }
  function GK(t, e) {
    let i = [];
    return (
      (i = i.concat(IW(t.round, e))),
      (i = i.concat(IW(t.padding, e))),
      (i = i.concat(IW(t.paddingInner, e))),
      (i = i.concat(IW(t.paddingOuter, e))),
      (i = i.concat(IW(t.align, e))),
      i
    );
  }
  function UK(t, e) {
    return zK(t)
      ? HK(t, e)
      : NK(t)
      ? (function (t, e) {
          if ((null == t ? void 0 : t.datas) && t.datas.length) {
            const i = [];
            return (
              t.datas.forEach(t => {
                const n = HK(t, e);
                n.length && i.push(n[0]);
              }),
              i
            );
          }
          return [];
        })(t, e)
      : VK(t)
      ? (function (t, e) {
          var i;
          if (g(t.coordinate)) {
            const i = e.getCoordinateById(t.coordinate);
            return i ? [i] : [];
          }
          return 'coordinate' === (null === (i = t.coordinate) || void 0 === i ? void 0 : i.grammarType)
            ? [t.coordinate]
            : [];
        })(t, e)
      : IW(t, e);
  }
  function YK(t, e, i) {
    if (l(e)) return [];
    const n = IW(e.unknown, i);
    switch (t) {
      case 'linear':
      case 'sqrt':
        return n.concat(WK(e, i));
      case 'ordinal':
        return n.concat([]);
      case 'band':
        return n.concat(
          (function (t, e) {
            return GK(t, e).concat(IW(t.paddingInner, e));
          })(e, i)
        );
      case 'point':
        return n.concat(
          (function (t, e) {
            return GK(t, e);
          })(e, i)
        );
      case 'pow':
        return n.concat(
          (function (t, e) {
            return WK(t, e).concat(IW(t.exponent, e));
          })(e, i)
        );
      case 'log':
      case 'time':
      case 'utc':
        return n.concat(
          (function (t, e) {
            let i = [];
            return (
              (i = i.concat(IW(t.nice, e))),
              (i = i.concat(IW(t.min, e))),
              (i = i.concat(IW(t.max, e))),
              (i = i.concat(IW(t.zero, e))),
              (i = i.concat(IW(t.roundRange, e))),
              i
            );
          })(e, i)
        );
      case 'symlog':
        return n.concat(
          (function (t, e) {
            return WK(t, e).concat(IW(t.constant, e));
          })(e, i)
        );
      case 'quantize':
        return n.concat(
          (function (t, e) {
            let i = [];
            return (
              (i = i.concat(IW(t.nice, e))),
              (i = i.concat(IW(t.niceMin, e))),
              (i = i.concat(IW(t.niceMax, e))),
              (i = i.concat(IW(t.min, e))),
              (i = i.concat(IW(t.max, e))),
              (i = i.concat(IW(t.zero, e))),
              i
            );
          })(e, i)
        );
    }
    return n;
  }
  function $K(t, e, i) {
    const n = LW(t.nice, i, e);
    !0 === n ? e.nice() : _(n) && e.nice(n);
  }
  function XK(t, e, i) {
    const n = LW(t.niceMax, i, e);
    !0 === n ? e.niceMax() : _(n) && e.niceMax(n);
    const s = LW(t.niceMin, i, e);
    !0 === s ? e.niceMin() : _(s) && e.niceMin(s);
  }
  function KK(t, e, i) {
    const n = LW(t.min, i, e),
      s = LW(t.max, i, e),
      r = LW(t.zero, i, e),
      a = _(n),
      o = _(s),
      l = e.domain();
    if (2 === l.length && (a || o || r)) {
      let t = Math.min(l[0], l[l.length - 1]),
        i = Math.max(l[0], l[l.length - 1]);
      r && t > 0 ? (t = 0) : a && (t = Math.min(t, n)),
        r && i < 0 ? (i = 0) : o && (i = Math.max(i, s)),
        e.domain([t, i], !0);
    }
  }
  function qK(t, e, i) {
    LW(t.roundRange, i, e) && e.rangeRound(e.range(), !0);
    const n = LW(t.config, i, e);
    (null == n ? void 0 : n.interpolate) && e.interpolate(n.interpolate, !0),
      l(null == n ? void 0 : n.clamp) || (o(n.clamp) ? e.clamp(!0, n.clamp, !0) : e.clamp(n.clamp, void 0, !0));
  }
  function ZK(t, e, i) {
    $K(t, e, i), XK(t, e, i), KK(t, e, i), qK(t, e, i);
  }
  function JK(t, e, i) {
    t.round && e.round(LW(t.round, i, e), !0),
      t.padding && e.padding(LW(t.padding, i, e), !0),
      t.paddingInner && e.paddingInner(LW(t.paddingInner, i, e), !0),
      t.paddingOuter && e.paddingOuter(LW(t.paddingOuter, i, e), !0),
      t.align && e.align(LW(t.align, i, e), !0);
  }
  function QK(t, e) {
    const i = t.field,
      n = jW(t.data, e),
      s = [];
    if (f(i))
      i.forEach(t => {
        const e = jo(t);
        n &&
          n.forEach(t => {
            s.push(e(t));
          });
      });
    else {
      const t = jo(i);
      n &&
        n.forEach(e => {
          s.push(t(e));
        });
    }
    return s;
  }
  function tq(t, e) {
    let i = [];
    return (
      t.datas.forEach(t => {
        i = i.concat(QK(t, e));
      }),
      i
    );
  }
  function eq(t, e, i, n) {
    return (
      i && t.sort(i), Zo(e.type) ? (n && t.filter(t => y(t)), [Math.min.apply(null, t), Math.max.apply(null, t)]) : t
    );
  }
  function iq(t, e, i) {
    if (
      (zK(t.domain)
        ? e.domain(eq(QK(t.domain, i), e, t.domain.sort, !0), !0)
        : NK(t.domain)
        ? e.domain(eq(tq(t.domain, i), e, t.domain.sort, !0), !0)
        : e.domain(LW(t.domain, i, e), !0),
      'identity' !== t.type)
    )
      if (zK(t.range)) e.range(eq(QK(t.range, i), e), !0);
      else if (NK(t.range)) e.range(eq(tq(t.range, i), e), !0);
      else if (VK(t.range)) {
        const n = jW(t.range.coordinate, i);
        !(function (t) {
          switch (t) {
            case qo.Quantile:
            case qo.Quantize:
            case qo.Threshold:
              return !0;
            default:
              return !1;
          }
        })(e.type) &&
          n &&
          e.range(n.getRangeByDimension(t.range.dimension, t.range.isSubshaft, t.range.reversed));
      } else e.range(LW(t.range, i, e), !0);
    switch ((l(t.unknown) || e.unknown(LW(t.unknown, i, e)), t.type)) {
      case 'linear':
        ZK(t, e, i), e.rescale();
        break;
      case 'band':
      case 'point':
        (function (t, e, i) {
          JK(t, e, i);
        })(t, e, i),
          e.rescale();
        break;
      case 'pow':
        (function (t, e, i) {
          ZK(t, e, i);
          const n = LW(t.exponent, i, e);
          n > 0 && e.exponent(n);
        })(t, e, i),
          e.rescale();
        break;
      case 'log':
        (function (t, e, i) {
          $K(t, e, i), KK(t, e, i), qK(t, e, i);
          const n = LW(t.base, i, e);
          n > 0 && e.base(n);
        })(t, e, i),
          e.rescale();
        break;
      case 'sqrt':
        (function (t, e, i) {
          ZK(t, e, i);
        })(t, e, i),
          e.rescale();
        break;
      case 'symlog':
        (function (t, e, i) {
          ZK(t, e, i);
          const n = LW(t.constant, i, e);
          _(n) && e.constant(n);
        })(t, e, i),
          e.rescale();
        break;
      case 'time':
      case 'utc':
        (function (t, e, i) {
          $K(t, e, i), KK(t, e, i), qK(t, e, i);
        })(t, e, i),
          e.rescale();
        break;
      case 'quantize':
        (function (t, e, i) {
          $K(t, e, i), XK(t, e, i), KK(t, e, i);
        })(t, e, i),
          e.rescale();
        break;
      case 'quantile':
        e.rescale();
    }
  }
  class nq extends VU {
    constructor(t, e) {
      super(t), (this.grammarType = 'scale'), (this.spec.type = e), (this.scale = jK(e));
    }
    parse(t) {
      return super.parse(t), this.domain(t.domain), this.range(t.range), this.configure(t), this.commit(), this;
    }
    evaluate(t, e) {
      return (
        this.view.emit(tG.BEFORE_EVALUATE_SCALE),
        this.spec.type || (this.spec.type = 'linear'),
        (this.scale && this.scale.type === this.spec.type) || (this.scale = jK(this.spec.type)),
        iq(this.spec, this.scale, e),
        this.view.emit(tG.BEFORE_EVALUATE_SCALE),
        this
      );
    }
    output() {
      return this.scale;
    }
    getScaleType() {
      return this.spec.type;
    }
    getScale() {
      return this.scale;
    }
    ticks(t) {
      var e, i, n;
      return null !==
        (n =
          null === (i = null === (e = this.scale) || void 0 === e ? void 0 : e.tickData) || void 0 === i
            ? void 0
            : i.call(e, t)) && void 0 !== n
        ? n
        : [];
    }
    domain(t) {
      return (
        l(this.spec.domain) || this.detach(UK(this.spec.domain, this.view)),
        (this.spec.domain = t),
        this.attach(UK(t, this.view)),
        this.commit(),
        this
      );
    }
    range(t) {
      return (
        l(this.spec.range) || this.detach(UK(this.spec.range, this.view)),
        (this.spec.range = t),
        this.attach(UK(t, this.view)),
        this.commit(),
        this
      );
    }
    getCoordinateAxisPosition() {
      const t = this.spec.range,
        e = null == t ? void 0 : t.coordinate;
      if (!l(e)) {
        const i = t.dimension,
          n = t.isSubshaft,
          s = t.reversed,
          r = this.parameters()[e];
        return null == r ? void 0 : r.getVisualPositionByDimension(i, n, s);
      }
      return null;
    }
    getCoordinateAxisPoints(t) {
      const e = this.spec.range,
        i = null == e ? void 0 : e.coordinate;
      if (!l(i)) {
        const n = e.dimension,
          s = e.isSubshaft,
          r = e.reversed,
          a = this.parameters()[i];
        return null == a ? void 0 : a.getAxisPointsByDimension(n, s, r, t);
      }
      return null;
    }
    getCoordinate() {
      const t = this.spec.range,
        e = null == t ? void 0 : t.coordinate;
      return l(e) ? null : this.parameters()[e];
    }
    configure(t) {
      return (
        this.detach(YK(this.spec.type, t, this.view)),
        l(t)
          ? (this.spec = { type: this.spec.type, domain: this.spec.domain, range: this.spec.range })
          : (Object.assign(this.spec, t), this.attach(YK(this.spec.type, t, this.view))),
        this.commit(),
        this
      );
    }
    reuse(t) {
      return t.grammarType !== this.grammarType || (this.scale = t.output()), this;
    }
    clear() {
      super.clear(), (this.scale = null);
    }
  }
  let sq = -1;
  const rq = [tY, eY, sY, iY, nY, rY, aY],
    aq = t => {
      var e, i, n, s;
      return y(t)
        ? { top: t, bottom: t, left: t, right: t }
        : {
            top: null !== (e = null == t ? void 0 : t.top) && void 0 !== e ? e : 0,
            bottom: null !== (i = null == t ? void 0 : t.bottom) && void 0 !== i ? i : 0,
            left: null !== (n = null == t ? void 0 : t.left) && void 0 !== n ? n : 0,
            right: null !== (s = null == t ? void 0 : t.right) && void 0 !== s ? s : 0
          };
    },
    oq = t => {
      var e, i, n, s, r, a, o, l, h, c, d, u, p, g;
      return {
        reuse: null === (e = null == t ? void 0 : t.reuse) || void 0 === e || e,
        morph: null === (i = null == t ? void 0 : t.morph) || void 0 === i || i,
        morphAll: null !== (n = null == t ? void 0 : t.morphAll) && void 0 !== n && n,
        animation: {
          easing:
            null !== (r = null === (s = null == t ? void 0 : t.animation) || void 0 === s ? void 0 : s.easing) &&
            void 0 !== r
              ? r
              : gG,
          delay:
            null !== (o = null === (a = null == t ? void 0 : t.animation) || void 0 === a ? void 0 : a.delay) &&
            void 0 !== o
              ? o
              : dG,
          duration:
            null !== (h = null === (l = null == t ? void 0 : t.animation) || void 0 === l ? void 0 : l.duration) &&
            void 0 !== h
              ? h
              : cG,
          oneByOne:
            null !== (d = null === (c = null == t ? void 0 : t.animation) || void 0 === c ? void 0 : c.oneByOne) &&
            void 0 !== d
              ? d
              : pG,
          splitPath:
            null !== (p = null === (u = null == t ? void 0 : t.animation) || void 0 === u ? void 0 : u.splitPath) &&
            void 0 !== p
              ? p
              : null
        },
        enableExitAnimation: null === (g = null == t ? void 0 : t.enableExitAnimation) || void 0 === g || g
      };
    },
    lq = (t, e) =>
      (null == e ? void 0 : e.debounce) ? mt(t, e.debounce) : (null == e ? void 0 : e.throttle) ? yt(t, e.throttle) : t,
    hq = function (t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ZU;
      const i = {},
        n = t.split(':');
      if (2 === n.length) {
        const [t, s] = n;
        '#' === t[0]
          ? ((i.markId = t.slice(1)), (i.source = e))
          : '@' === t[0]
          ? ((i.markName = t.slice(1)), (i.source = e))
          : ZG[t]
          ? ((i.markType = t), (i.source = e))
          : (i.source = t === qU ? qU : e),
          (i.type = s);
      } else 1 === n.length && ((i.type = t), (i.source = e));
      return i;
    },
    cq = {},
    dq = () => cq;
  let uq = class extends hY {
    constructor(t, e) {
      super(t, GW.group, e), (this.children = []);
    }
    appendChild(t) {
      return this.children.push(t), this;
    }
    removeChild(t) {
      return (this.children = this.children.filter(e => e !== t)), this;
    }
    includesChild(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      return (
        !!this.children.includes(t) ||
        (!!e && this.children.some(e => e.markType === GW.group && e.includesChild(t, !0)))
      );
    }
    updateLayoutChildren() {
      return this.children.length
        ? (this.layoutChildren || (this.layoutChildren = []),
          (this.layoutChildren = this.children.filter(t => t.needLayout())),
          this)
        : this;
    }
    getAttributeTransforms() {
      return IG.rect;
    }
    evaluateJoin(t) {
      if (!this.elements.length) {
        const t = $U(this);
        t.updateData(rG, aG, () => '', this.view), (this.elements = [t]), this.elementMap.set(rG, t);
      }
    }
  };
  function pq(t, e) {
    if (_(t)) return t;
    const i = t.trim();
    if ('auto' === i) return 0;
    if (i.endsWith('%')) {
      const t = parseFloat(i.substring(0, i.length - 1));
      return _(t) ? t * e : 0;
    }
    return 0;
  }
  function gq(t, e) {
    return Math.min(t < 0 ? t + e : t - 1, e);
  }
  function fq(t, e, i) {
    let n = gq(t, i),
      s = gq(e, i);
    if (
      (_(t) || _(e) ? (_(t) ? _(e) || (n = gq(Math.max(0, s - 1), i)) : (s = gq(n + 1, i))) : ((n = 1), (s = 2)), n > s)
    ) {
      const t = s;
      (s = n), (n = t);
    }
    return { start: n, end: s };
  }
  const vq = (t, e, i, n) => {
      const s = (function (t, e, i) {
        var n, s, r, a;
        const o = null !== (n = t.gridTemplateRows) && void 0 !== n ? n : [i],
          l = null !== (s = t.gridTemplateColumns) && void 0 !== s ? s : [e],
          h = null !== (r = t.gridRowGap) && void 0 !== r ? r : 0,
          c = null !== (a = t.gridColumnGap) && void 0 !== a ? a : 0,
          d = o.map(t => pq(t, i)),
          u = l.map(t => pq(t, e)),
          p = Math.max(0, d.reduce((t, e) => t - e, i) - d.length * h) / o.filter(t => 'auto' === t).length,
          g = Math.max(0, u.reduce((t, e) => t - e, e) - u.length * c) / l.filter(t => 'auto' === t).length;
        let f = 0;
        const v = d.map((t, e) => {
          const i = 'auto' === o[e] ? p : t,
            n = f;
          return (f += i + h), n;
        });
        v.push(f);
        let m = 0;
        const y = u.map((t, e) => {
          const i = 'auto' === l[e] ? g : t,
            n = m;
          return (m += i + c), n;
        });
        return y.push(m), { rows: v, columns: y, rowGap: h, columnGap: c };
      })(t.getSpec().layout, i.width(), i.height());
      null == e ||
        e.forEach(t => {
          const e = t.getSpec().layout;
          (t.layoutBounds = (function (t, e, i, n, s) {
            const r = t.rows.length,
              a = t.columns.length,
              { start: o, end: l } = fq(e, i, r),
              { start: h, end: c } = fq(n, s, a),
              d = t.columns[o],
              u = t.columns[l] - (c === a ? 0 : t.columnGap),
              p = t.rows[h],
              g = t.rows[c] - (l === r ? 0 : t.rowGap);
            return new Xt().set(d, p, u, g);
          })(s, e.gridRowStart, e.gridRowEnd, e.gridColumnStart, e.gridColumnEnd)),
            t.commit();
        });
    },
    mq = { [UW.axis]: 0, [UW.legend]: 1, [UW.slider]: 2, [UW.player]: 3, [UW.datazoom]: 4 },
    yq = t => {
      var e, i, n;
      return null !== (i = null === (e = t.getSpec().layout) || void 0 === e ? void 0 : e.order) && void 0 !== i
        ? i
        : 'component' === t.markType && null !== (n = mq[t.componentType]) && void 0 !== n
        ? n
        : 1 / 0;
    },
    _q = (t, e, i, n) => {
      const s = i.clone(),
        r = t.getSpec().layout,
        a = Yo(r.maxChildWidth, s.width()),
        o = Yo(r.maxChildHeight, s.width());
      let l = 0,
        h = 0,
        c = 0,
        d = 0;
      e.forEach(t => {
        const e = t.getSpec().layout,
          r = aq(e.padding),
          u = n.parseMarkBounds ? n.parseMarkBounds(t.getBounds(), t) : t.getBounds();
        if ('top' === e.position || 'bottom' === e.position) {
          const t = Math.min(u.height() + r.top + r.bottom, o);
          'top' === e.position ? (s.y1 += t) : (s.y2 -= t),
            u.x1 < i.x1 && (l = Math.max(l, i.x1 - u.x1)),
            u.x2 > i.x2 && (h = Math.max(h, u.x2 - i.x2));
        }
        if ('left' === e.position || 'right' === e.position) {
          const t = Math.min(u.width() + r.left + r.right, a);
          'left' === e.position ? (s.x1 += t) : (s.x2 -= t),
            u.y1 < i.y1 && (c = Math.max(c, i.y1 - u.y1)),
            u.y2 > i.y2 && (d = Math.max(d, u.y2 - i.y2));
        }
        'outside' === e.position &&
          ((s.x1 += Math.max(i.x1 - u.x1, 0) + r.left),
          (s.x2 -= Math.max(u.x2 - i.x2, 0) + r.right),
          (s.y1 += Math.max(i.y1 - u.y1, 0) + r.top),
          (s.y2 -= Math.max(u.y2 - i.y2) + r.bottom));
      }),
        l > s.x1 - i.x1 && l < i.width() && (s.x1 = i.x1 + l),
        h > i.x2 - s.x2 && h < i.width() && (s.x2 = i.x2 - h),
        c > s.y1 - i.y1 && c < i.height() && (s.y1 = i.y1 + c),
        d > i.y2 - s.y2 && d < i.height() && (s.y2 = i.y2 - d);
      let u = s.y1,
        p = s.y2,
        g = s.x1,
        f = s.x2;
      const v = e.slice().sort((t, e) => yq(t) - yq(e));
      for (let t = 0, e = v.length; t < e; t++) {
        const e = v[t],
          r = e.getSpec().layout,
          l = aq(r.padding),
          h = n.parseMarkBounds ? n.parseMarkBounds(e.getBounds(), e) : e.getBounds();
        if ('top' === r.position || 'bottom' === r.position) {
          const t = Math.min(h.height() + l.top + l.bottom, o);
          if (
            ('top' === r.position
              ? ((e.layoutBounds = new Xt().set(s.x1, u - t, s.x2, u)), (u -= t))
              : ((e.layoutBounds = new Xt().set(s.x1, p, s.x2, p + t)), (p += t)),
            (e.relativePosition = { top: e.layoutBounds.y1 - s.y1, bottom: e.layoutBounds.y1 - s.y2 }),
            r.align)
          ) {
            const t = h.width() + l.left + l.right;
            t < s.width() &&
              ('center' === r.align
                ? ((e.layoutBounds.x1 = (s.x1 + s.x2) / 2 - t / 2),
                  (e.layoutBounds.x2 = e.layoutBounds.x1 + t),
                  (e.relativePosition.left = e.relativePosition.right = (s.width() - t) / 2))
                : 'right' === r.align
                ? ((e.layoutBounds.x1 = s.x2 - t),
                  (e.layoutBounds.x2 = s.x2),
                  (e.relativePosition.right = 0),
                  (e.relativePosition.left = s.width() - t))
                : 'left' === r.align &&
                  ((e.layoutBounds.x1 = s.x1),
                  (e.layoutBounds.x2 = s.x1 + t),
                  (e.relativePosition.left = 0),
                  (e.relativePosition.right = s.width() - t)));
          }
        } else if ('left' === r.position || 'right' === r.position) {
          const t = Math.min(h.width() + l.left + l.right, a);
          if (
            ('left' === r.position
              ? ((e.layoutBounds = new Xt().set(g - t, s.y1, g, s.y2)), (g -= t))
              : ((e.layoutBounds = new Xt().set(f, s.y1, f + t, s.y2)), (f += t)),
            (e.relativePosition = { left: e.layoutBounds.x1 - s.x1, right: e.layoutBounds.x1 - s.x2 }),
            r.align)
          ) {
            const i = h.height() + l.top + l.bottom;
            t < s.width() &&
              ('middle' === r.align
                ? ((e.layoutBounds.y1 = (s.y1 + s.y2) / 2 - i / 2),
                  (e.layoutBounds.y2 = e.layoutBounds.y1 + i),
                  (e.relativePosition.top = e.relativePosition.bottom = (s.height() - i) / 2))
                : 'bottom' === r.align
                ? ((e.layoutBounds.y1 = s.y2 - i),
                  (e.layoutBounds.y2 = s.y2),
                  (e.relativePosition.top = s.height() - i),
                  (e.relativePosition.bottom = 0))
                : 'top' === r.align &&
                  ((e.layoutBounds.y1 = s.y1),
                  (e.layoutBounds.y2 = s.y1 + i),
                  (e.relativePosition.bottom = s.height() - i),
                  (e.relativePosition.top = 0)));
          }
        } else
          'outside' === r.position
            ? ((g -= Math.max(i.x1 - h.x1, 0) + l.left),
              (f -= Math.max(h.x2 - i.x2, 0) + l.right),
              (u -= Math.max(i.y1 - h.y1, 0) + l.top),
              (p += Math.max(h.y2 - i.y2) + l.bottom))
            : (e.layoutBounds = s);
      }
      return s;
    },
    bq = (t, e, i) => {
      null == t ||
        t.forEach(t => {
          var n;
          if (t.markType !== GW.group) return;
          const s = t.layoutChildren,
            r = t.getSpec().layout,
            a = null !== (n = t.layoutBounds) && void 0 !== n ? n : t.getBounds();
          if (a) {
            if (o(r)) r.call(null, t, s, a, e);
            else if (o(r.callback)) r.callback.call(null, t, s, a, e);
            else if ('relative' === r.display)
              if (r.updateViewSignals) {
                const n = i.getViewBox();
                n && a.intersect(n);
                const r = _q(t, s, a, e),
                  o = r.width(),
                  l = r.height(),
                  h = { top: r.y1, right: i.width() - r.x2, left: r.x1, bottom: i.height() - r.y2 };
                i.updateSignal(iY, o), i.updateSignal(nY, l), i.updateSignal(sY, h);
              } else _q(t, s, a, e);
            else 'grid' === r.display && vq(t, s, a);
            bq(s, e, i);
          }
        });
    };
  class xq extends hY {
    constructor(t, e, i) {
      super(t, GW.glyph, i), (this.glyphType = e), (this.glyphMeta = CG(e));
    }
    configureGlyph(t) {
      return (this.spec.glyphConfig = t), this.commit(), this;
    }
    getGlyphMeta() {
      return this.glyphMeta;
    }
    getGlyphConfig() {
      return this.spec.glyphConfig;
    }
    addGraphicItem(t, e) {
      const i = QG(this, this.glyphMeta, t);
      return super.addGraphicItem(t, e, i);
    }
  }
  let Sq = class {
    constructor() {
      (this.startPoint = { x: 0, y: 0 }),
        (this.endPoint = { x: 0, y: 0 }),
        (this.originPoint = { x: 0, y: 0 }),
        (this.width = 0),
        (this.height = 0),
        (this.transforms = []);
    }
    start(t, e) {
      return l(t) ? this.startPoint : ((this.startPoint = this._parsePoint(t, e)), this._updateSize(), this);
    }
    end(t, e) {
      return l(t) ? this.endPoint : ((this.endPoint = this._parsePoint(t, e)), this._updateSize(), this);
    }
    _parsePoint(t, e) {
      const i = { x: 0, y: 0 };
      return f(t) ? ((i.x = t[0]), (i.y = t[1])) : y(t) ? ((i.x = t), (i.y = e)) : ((i.x = t.x), (i.y = t.y)), i;
    }
    _updateSize() {
      (this.width = this.endPoint.x - this.startPoint.x), (this.height = this.endPoint.y - this.startPoint.y);
    }
    isTransposed() {
      return this.transforms && this.transforms.filter(t => 'transpose' === t.type).length % 2 != 0;
    }
    isMainDimension(t) {
      let e = 'x' === t || 'theta' === t || '0' === t;
      return this.isTransposed() && (e = !e), e;
    }
    applyTransforms(t) {
      return (this.transforms = t.slice()), this._invokeTransforms(), this;
    }
    _invokeTransforms() {
      (this.invertMatrix = null),
        (this.convertMatrix = null),
        (this.invertMatrix = new ie()),
        this.invertMatrix.translate(this.originPoint.x, this.originPoint.y),
        this.transforms.forEach(t => {
          switch (t.type) {
            case 'translate':
              this.invertMatrix.translate(t.offset.x, t.offset.y);
              break;
            case 'rotate':
              this.invertMatrix.rotateByCenter(t.angle, this.originPoint.x, this.originPoint.y);
              break;
            case 'scale':
              this.invertMatrix.scale(t.scale.x, t.scale.y);
              break;
            case 'transpose':
              'polar' !== this.type && this.invertMatrix.transpose();
          }
        }),
        this.invertMatrix,
        (this.convertMatrix = this.invertMatrix.getInverse());
    }
  };
  class wq extends Sq {
    constructor() {
      super(...arguments), (this.type = 'cartesian');
    }
    convert(t) {
      var e, i;
      if (_(t.x1) || _(t.y1)) {
        const n = this.convertPoint(t),
          s = this.convertPoint({
            x: null !== (e = t.x1) && void 0 !== e ? e : t.x,
            y: null !== (i = t.y1) && void 0 !== i ? i : t.y
          });
        return (n.x1 = s.x), (n.y1 = s.y), n;
      }
      return this.convertPoint(t);
    }
    invert(t) {
      var e, i;
      if (_(t.x1) || _(t.y1)) {
        const n = this.invertPoint(t),
          s = this.invertPoint({
            x: null !== (e = t.x1) && void 0 !== e ? e : t.x,
            y: null !== (i = t.y1) && void 0 !== i ? i : t.y
          });
        return (n.x1 = s.x), (n.y1 = s.y), n;
      }
      return this.invertPoint(t);
    }
    getRangeByDimension(t, e, i) {
      const n = this.start(),
        s = this.end(),
        r = this.isMainDimension(t) ? [n.x, s.x] : [s.y, n.y];
      return i ? [r[1], r[0]] : r;
    }
    getVisualPositionByDimension(t, e, i) {
      return this.isMainDimension(t) ? (e ? 'top' : 'bottom') : e ? 'right' : 'left';
    }
    getAxisPointsByDimension(t, e, i, n) {
      const s = this.start(),
        r = this.end();
      if (this.isMainDimension(t)) {
        const t = l(n)
          ? e
            ? [
                { x: s.x, y: s.y },
                { x: r.x, y: s.y }
              ]
            : [
                { x: s.x, y: r.y },
                { x: r.x, y: r.y }
              ]
          : [
              { x: s.x, y: n },
              { x: r.x, y: n }
            ];
        return i ? [t[1], t[0]] : t;
      }
      const a = l(n)
        ? e
          ? [
              { x: r.x, y: r.y },
              { x: r.x, y: s.y }
            ]
          : [
              { x: s.x, y: r.y },
              { x: s.x, y: s.y }
            ]
        : [
            { x: n, y: r.y },
            { x: n, y: s.y }
          ];
      return i ? [a[1], a[0]] : a;
    }
    convertPoint(t) {
      const e = f(t) ? { x: t[0], y: t[1] } : t,
        i = Object.assign({}, e);
      return this.convertMatrix.transformPoint(e, i), i;
    }
    invertPoint(t) {
      const e = Object.assign({}, t);
      return this.invertMatrix.transformPoint(t, e), e;
    }
  }
  class Aq extends Sq {
    constructor() {
      super(...arguments),
        (this.type = 'polar'),
        (this._isUserOrigin = !1),
        (this._isUserRadius = !1),
        (this.startAngle = 0),
        (this.endAngle = 2 * Math.PI),
        (this.innerRadius = 0),
        (this.outerRadius = 0);
    }
    _updateStartEndPoint() {
      const t = this.origin(),
        e = Math.min(this.startAngle, this.endAngle),
        i = Math.max(this.startAngle, this.endAngle),
        n = (2 * e) / Math.PI,
        s = (2 * i) / Math.PI,
        r = [e, i];
      let a = Math.ceil(n);
      for (; a <= s; ) r.push((a * Math.PI) / 2), a++;
      const o = r.length,
        l = [],
        h = [];
      for (a = 0; a < o; a++) {
        const e = te(t, this.innerRadius, r[a]),
          i = te(t, this.outerRadius, r[a]);
        l.push(e.x), l.push(i.x), h.push(e.y), h.push(i.y);
      }
      const c = Math.min.apply(null, l),
        d = Math.min.apply(null, h),
        u = Math.max.apply(null, l),
        p = Math.max.apply(null, h);
      (this.startPoint = { x: c, y: d }), (this.endPoint = { x: u, y: p });
    }
    _updateSize() {
      super._updateSize(),
        this._isUserOrigin ||
          ((this.originPoint = { x: this.width / 2, y: this.height / 2 }), this._invokeTransforms()),
        this._isUserRadius ||
          (this.outerRadius = Math.min(
            Math.abs(this.startPoint.x - this.originPoint.x),
            Math.abs(this.endPoint.x - this.originPoint.x),
            Math.abs(this.startPoint.y - this.originPoint.y),
            Math.abs(this.endPoint.y - this.originPoint.y)
          ));
    }
    angle(t, e) {
      return l(t)
        ? [this.startAngle, this.endAngle]
        : (Array.isArray(t)
            ? ((this.startAngle = t[0]), (this.endAngle = t[1]))
            : ((this.startAngle = t), (this.endAngle = null != e ? e : t)),
          this._updateStartEndPoint(),
          this);
    }
    radius(t, e) {
      return l(t)
        ? [this.innerRadius, this.outerRadius]
        : ((this._isUserRadius = !0),
          Array.isArray(t)
            ? ((this.innerRadius = Math.min(t[0], t[1])), (this.outerRadius = Math.max(t[1], t[1])))
            : ((this.innerRadius = Math.min(t, e)), (this.outerRadius = Math.max(t, e))),
          this._updateStartEndPoint(),
          this);
    }
    origin(t, e) {
      return l(t)
        ? this.originPoint
        : ((this._isUserOrigin = !0),
          (this.originPoint = this._parsePoint(t, e)),
          this._updateStartEndPoint(),
          this._invokeTransforms(),
          this);
    }
    convert(t) {
      var e, i, n, s;
      if (_(t.r1) || _(t.theta1)) {
        const n = this.convertPoint(t),
          s = this.convertPoint({
            r: null !== (e = t.r1) && void 0 !== e ? e : t.r,
            theta: null !== (i = t.theta1) && void 0 !== i ? i : t.theta
          });
        return (n.x1 = s.x), (n.y1 = s.y), n;
      }
      if (_(t.x1) || _(t.y1)) {
        const e = this.convertPoint(t),
          i = this.convertPoint({
            x: null !== (n = t.x1) && void 0 !== n ? n : t.x,
            y: null !== (s = t.y1) && void 0 !== s ? s : t.y
          });
        return (e.x1 = i.x), (e.y1 = i.y), e;
      }
      return this.convertPoint(t);
    }
    invert(t) {
      var e, i;
      if (_(t.x1) || _(t.y1)) {
        const n = this.invertPoint(t),
          s = this.invertPoint({
            x: null !== (e = t.x1) && void 0 !== e ? e : t.x,
            y: null !== (i = t.y1) && void 0 !== i ? i : t.y
          });
        return (n.r1 = s.r), (n.theta1 = s.theta), n;
      }
      return this.invertPoint(t);
    }
    getRangeByDimension(t, e, i) {
      const n = this.isMainDimension(t) ? [this.startAngle, this.endAngle] : [this.innerRadius, this.outerRadius];
      return i ? [n[1], n[0]] : n;
    }
    getVisualPositionByDimension(t, e, i) {
      return this.isMainDimension(t) ? (e ? 'inside' : 'outside') : e ? 'end' : 'start';
    }
    getAxisPointsByDimension(t, e, i, n) {
      if (!this.isMainDimension(t)) {
        const t = this.origin(),
          s = l(n)
            ? e
              ? [te(t, this.innerRadius, this.endAngle), te(t, this.outerRadius, this.endAngle)]
              : [te(t, this.innerRadius, this.startAngle), te(t, this.outerRadius, this.startAngle)]
            : [te(t, this.innerRadius, n), te(t, this.outerRadius, n)];
        return i ? [s[1], s[0]] : s;
      }
      return null;
    }
    convertPoint(t) {
      const e = this.isTransposed();
      let i, n;
      l(t.r) || l(t.theta)
        ? f(t)
          ? ((i = e ? t[0] : t[1]), (n = e ? t[1] : t[0]))
          : ((i = e ? t.y : t.x), (n = e ? t.x : t.y))
        : ((i = e ? t.r : t.theta), (n = e ? t.theta : t.r));
      const s = { x: Math.cos(i) * n, y: Math.sin(i) * n };
      !1 === t.defined && (s.defined = !1);
      const r = Object.assign({}, s);
      return this.convertMatrix.transformPoint(s, r), r;
    }
    invertPoint(t) {
      const e = Object.assign({}, t);
      this.invertMatrix.transformPoint(t, e);
      const i = e.x,
        n = e.y;
      if (ot(i, 0) && ot(n, 0)) {
        const t = { r: 0, theta: 0 };
        return !1 === e.defined && (t.defined = !1), t;
      }
      let s = Math.atan(n / i);
      (s += i >= 0 ? 2 * Math.PI : Math.PI), s >= 2 * Math.PI && (s -= 2 * Math.PI), (s = Jt(s));
      const r = ot(n, 0) ? i / Math.cos(s) : n / Math.sin(s),
        a = this.isTransposed() ? { r: s, theta: r } : { r: r, theta: s };
      return !1 === e.defined && (a.defined = !1), a;
    }
  }
  function kq(t) {
    switch (t) {
      case 'cartesian':
      default:
        return new wq();
      case 'polar':
        return new Aq();
    }
  }
  class Mq extends VU {
    constructor(t, e) {
      super(t),
        (this.grammarType = 'coordinate'),
        (this.spec = { type: 'cartesian' }),
        (this.spec.type = e),
        (this.coordinate = kq(e));
    }
    parse(t) {
      return (
        super.parse(t),
        this.start(t.start),
        this.end(t.end),
        this.origin(t.origin),
        this.translate(t.translate),
        this.rotate(t.rotate),
        this.scale(t.scale),
        this.transpose(t.transpose),
        this.commit(),
        this
      );
    }
    evaluate(t, e) {
      return (
        (this.coordinate && this.coordinate.type === this.spec.type) || (this.coordinate = kq(this.spec.type)),
        (function (t, e, i) {
          var n, s, r, a, o, h, c;
          !l(t.start) && e.start(null !== (n = LW(t.start, i)) && void 0 !== n ? n : [0, 0]),
            !l(t.end) && e.end(null !== (s = LW(t.end, i)) && void 0 !== s ? s : [0, 0]),
            !l(t.origin) && e.origin(null !== (r = LW(t.origin, i)) && void 0 !== r ? r : [0, 0]);
          const d = [];
          if (!l(t.translate)) {
            const e = LW(t.translate, i);
            d.push({
              type: 'translate',
              offset: {
                x: null !== (a = null == e ? void 0 : e[0]) && void 0 !== a ? a : 0,
                y: null !== (o = null == e ? void 0 : e[1]) && void 0 !== o ? o : 0
              }
            });
          }
          if (!l(t.rotate)) {
            const e = LW(t.rotate, i);
            d.push({ type: 'rotate', angle: null != e ? e : 0 });
          }
          if (!l(t.scale)) {
            const e = LW(t.scale, i);
            d.push({
              type: 'scale',
              scale: {
                x: null !== (h = null == e ? void 0 : e[0]) && void 0 !== h ? h : 1,
                y: null !== (c = null == e ? void 0 : e[1]) && void 0 !== c ? c : 1
              }
            });
          }
          l(t.transpose) || (LW(t.transpose, i) && d.push({ type: 'transpose' })), e.applyTransforms(d);
        })(this.spec, this.coordinate, e),
        this
      );
    }
    output() {
      return this.coordinate;
    }
    start(t) {
      return this.setFunctionSpec(t, 'start');
    }
    end(t) {
      return this.setFunctionSpec(t, 'end');
    }
    origin(t) {
      return this.setFunctionSpec(t, 'origin');
    }
    translate(t) {
      return this.setFunctionSpec(t, 'translate');
    }
    rotate(t) {
      return this.setFunctionSpec(t, 'rotate');
    }
    scale(t) {
      return this.setFunctionSpec(t, 'scale');
    }
    transpose(t) {
      return this.setFunctionSpec(t, 'transpose');
    }
    reuse(t) {
      return t.grammarType !== this.grammarType || (this.coordinate = t.output()), this;
    }
    clear() {
      super.clear(), (this.coordinate = null);
    }
  }
  const Tq = Symbol.for('key');
  class Cq {
    diffGrammar(t, e) {
      return (function (t, e, i) {
        const n = { enter: [], exit: [], update: [] },
          s = new mG(t, i);
        return (
          s.setCallback((t, e, i) => {
            l(e)
              ? n.exit.push({ prev: i[0] })
              : l(i)
              ? n.enter.push({ next: e[0] })
              : n.update.push({ next: e[0], prev: i[0] });
          }),
          s.setCurrentData(vG(e, i)),
          s.doDiff(),
          n
        );
      })(t, e, t => {
        var e;
        return null !== (e = t.id()) && void 0 !== e ? e : Symbol();
      });
    }
    diffMark(t, e, i) {
      const n = { enter: [], exit: [], update: [] };
      let s = [],
        r = [];
      t.forEach(t => {
        t.markType !== GW.group && ((i.morph && t.getMorphConfig().morph) || i.morphAll || i.reuse)
          ? s.push(t)
          : n.exit.push({ prev: [t] });
      }),
        e.forEach(t => {
          t.markType !== GW.group && ((i.morph && t.getMorphConfig().morph) || i.morphAll || i.reuse)
            ? r.push(t)
            : n.enter.push({ next: [t] });
        });
      const a = this.diffUpdateByGroup(
        s,
        r,
        t => t.getMorphConfig().morphKey,
        t => t.getMorphConfig().morphKey
      );
      (s = a.prev), (r = a.next), (n.update = n.update.concat(a.update));
      const o = this.diffUpdateByGroup(
        s,
        r,
        t => t.id(),
        t => t.id()
      );
      (s = o.prev), (r = o.next), (n.update = n.update.concat(o.update));
      const l = vG(s, t => {
          var e, i;
          return null === (i = null === (e = t.group) || void 0 === e ? void 0 : e.id) || void 0 === i
            ? void 0
            : i.call(e);
        }),
        h = vG(r, t => {
          var e, i;
          return null === (i = null === (e = t.group) || void 0 === e ? void 0 : e.id) || void 0 === i
            ? void 0
            : i.call(e);
        });
      return (
        Object.keys(h).forEach(t => {
          const e = l.data.get(t),
            i = h.data.get(t);
          if (e && i) {
            for (let t = 0; t < Math.max(e.length, i.length); t += 1) {
              const s = e[t],
                r = i[t];
              s && r
                ? n.update.push({ prev: [s], next: [r] })
                : s
                ? n.exit.push({ prev: [s] })
                : r && n.enter.push({ next: [r] });
            }
            (s = s.filter(t => !e.includes(t))), (r = r.filter(t => !i.includes(t)));
          }
        }),
        s.forEach(t => n.exit.push({ prev: [t] })),
        r.forEach(t => n.enter.push({ next: [t] })),
        n
      );
    }
    _appendMorphKeyToElements(t) {
      const e = t.getMorphConfig();
      if (!l(e.morphElementKey)) {
        const i = HW(e.morphElementKey);
        t.elements &&
          t.elements.forEach(t => {
            t.morphKey = i(t.getDatum());
          });
      }
    }
    morph(t, e, i) {
      const n = (function (t, e, i) {
        const n = { enter: [], exit: [], update: [] },
          s = new mG(t, i);
        return (
          s.setCallback((t, e, i) => {
            l(e) ? n.exit.push({ prev: i }) : l(i) ? n.enter.push({ next: e }) : n.update.push({ next: e, prev: i });
          }),
          s.setCurrentData(vG(e, i)),
          s.doDiff(),
          n
        );
      })(
        t.reduce((t, e) => (this._appendMorphKeyToElements(e), t.concat(e.elements)), []),
        e.reduce((t, e) => (this._appendMorphKeyToElements(e), t.concat(e.elements)), []),
        t => {
          var e;
          return null !== (e = t.morphKey) && void 0 !== e ? e : t.key;
        }
      );
      t.forEach(t => {
        var e, i;
        return null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.disable) || void 0 === i
          ? void 0
          : i.call(e);
      }),
        e.forEach(t => {
          var e, i;
          return null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.disable) || void 0 === i
            ? void 0
            : i.call(e);
        });
      const s = t.concat(e).reduce((t, e) => (Object.assign(t, e.parameters()), t), {});
      let r = 0;
      const a = () => {
        (r -= 1),
          0 === r &&
            e.forEach(t => {
              var e, i;
              null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.enable) || void 0 === i || i.call(e);
            });
      };
      n.enter.forEach(t => {
        t.next.forEach(t => {
          this.doMorph([], [t], i, a, s);
        }),
          (r += 1);
      }),
        n.update.forEach(t => {
          const e = Math.min(t.prev.length, t.next.length),
            n = this.divideElements(t.prev, e),
            o = this.divideElements(t.next, e);
          for (let t = 0; t < e; t++) this.doMorph(n[t], o[t], i, a, s), (r += 1);
        });
    }
    diffUpdateByGroup(t, e, i, n) {
      const s = vG(t, t => {
          var e;
          return null !== (e = i(t)) && void 0 !== e ? e : Tq;
        }),
        r = vG(e, t => {
          var e;
          return null !== (e = n(t)) && void 0 !== e ? e : Tq;
        });
      let a = t,
        o = e;
      const l = [];
      return (
        r.keys.forEach(t => {
          if (t !== Tq) {
            const e = s.data.get(t),
              i = r.data.get(t);
            e &&
              i &&
              (l.push({ prev: e, next: i }), (a = a.filter(t => !e.includes(t))), (o = o.filter(t => !i.includes(t))));
          }
        }),
        { prev: a, next: o, update: l }
      );
    }
    doMorph(t, e, i, n, s) {
      var r, a;
      const o = { prev: t.map(t => t.getDatum()), next: e.map(t => t.getDatum()) },
        l = { prev: t.slice(), next: e.slice() },
        h = i.animation.easing,
        c = LW(i.animation.delay, s, o, l),
        d = LW(i.animation.duration, s, o, l),
        u = LW(i.animation.oneByOne, s, o, l),
        p = LW(i.animation.splitPath, s, o, l),
        g = _(u) && u > 0 ? t => (y(u) ? t * u : !0 === u ? t * d : 0) : void 0;
      (1 !== t.length && 0 !== t.length) || 1 !== e.length
        ? 1 === t.length && e.length > 1
          ? ((t, e, i) => {
              var n;
              const s = e.filter(t => t && t.toCustomPath && t.valid);
              s.length || console.error(s, ' is not validate'),
                (t.valid && t.toCustomPath) || console.error(t, ' is not validate');
              const r = (
                  'clone' === (null == i ? void 0 : i.splitPath)
                    ? jT
                    : null !== (n = null == i ? void 0 : i.splitPath) && void 0 !== n
                    ? n
                    : zT
                )(t, s.length, !1),
                a = null == i ? void 0 : i.onEnd;
              let o = s.length;
              const l = () => {
                o--, 0 === o && a && a();
              };
              s.forEach((e, n) => {
                var a;
                const o = r[n],
                  h =
                    (null !== (a = null == i ? void 0 : i.delay) && void 0 !== a ? a : 0) +
                    ((null == i ? void 0 : i.individualDelay) ? i.individualDelay(n, s.length, o, e) : 0);
                IT(o, e, Object.assign({}, i, { onEnd: l, delay: h }), t.globalTransMatrix);
              });
            })(
              t[0].getGraphicItem(),
              e.map(t => t.getGraphicItem()),
              { delay: c, duration: d, easing: h, onEnd: n, individualDelay: g, splitPath: p }
            )
          : t.length > 1 &&
            1 === e.length &&
            ((t, e, i) => {
              var n, s, r;
              const a = t.filter(t => t.toCustomPath && t.valid);
              a.length || console.error(t, ' is not validate'),
                (e.valid && e.toCustomPath) || console.error(e, ' is not validate');
              const o = (
                  'clone' === (null == i ? void 0 : i.splitPath)
                    ? jT
                    : null !== (n = null == i ? void 0 : i.splitPath) && void 0 !== n
                    ? n
                    : zT
                )(e, a.length, !0),
                l = e.attribute;
              e.setAttribute('visible', !1);
              const h = a.map((t, e) =>
                  PT(t.toCustomPath(), o[e].toCustomPath(), {
                    fromTransform: t.globalTransMatrix,
                    toTransfrom: o[e].globalTransMatrix
                  })
                ),
                c = a.map((t, e) => OT(t.attribute, l));
              if (null == i ? void 0 : i.individualDelay) {
                const n = i.onEnd;
                let s = a.length;
                const r = () => {
                  s--,
                    0 === s &&
                      (e.setAttributes({ visible: !0, ratio: null }, !1, { type: Pw.ANIMATE_END }),
                      e.detachShadow(),
                      n && n());
                };
                o.forEach((e, n) => {
                  var s, o, l;
                  const d = (null !== (s = i.delay) && void 0 !== s ? s : 0) + i.individualDelay(n, a.length, t[n], e),
                    u = e.animate(Object.assign({}, i, { onEnd: r }));
                  u.wait(d),
                    u.play(
                      new BT(
                        { morphingData: h[n], saveOnEnd: !0, otherAttrs: c[n] },
                        null !== (o = i.duration) && void 0 !== o ? o : PM,
                        null !== (l = i.easing) && void 0 !== l ? l : RM
                      )
                    );
                });
              } else {
                const t = null == i ? void 0 : i.onEnd,
                  n = i ? Object.assign({}, i) : {};
                n.onEnd = () => {
                  e.setAttribute('visible', !0, !1, { type: Pw.ANIMATE_END }), e.detachShadow(), t && t();
                };
                const a = e.animate(n);
                (null == i ? void 0 : i.delay) && a.wait(i.delay),
                  a.play(
                    new DT(
                      { morphingData: h, otherAttrs: c },
                      null !== (s = null == i ? void 0 : i.duration) && void 0 !== s ? s : PM,
                      null !== (r = null == i ? void 0 : i.easing) && void 0 !== r ? r : RM
                    )
                  );
              }
            })(
              t.map(t => t.getGraphicItem()),
              e[0].getGraphicItem(),
              { delay: c, duration: d, easing: h, onEnd: n, individualDelay: g, splitPath: p }
            )
        : IT(
            null === (a = null === (r = t[0]) || void 0 === r ? void 0 : r.getGraphicItem) || void 0 === a
              ? void 0
              : a.call(r),
            e[0].getGraphicItem(),
            { delay: c, duration: d, easing: h, onEnd: n }
          );
    }
    divideElements(t, e) {
      const i = Math.floor(t.length / e);
      return new Array(e).fill(0).map((n, s) => t.slice(i * s, s === e - 1 ? t.length : i * (s + 1)));
    }
  }
  class Eq {
    constructor(t, e) {
      (this._grammars = { signal: [], data: [], scale: [], coordinate: [], mark: [], customized: [] }),
        (this._grammarMap = { signal: {}, data: {}, scale: {}, coordinate: {}, mark: {}, customized: {} }),
        (this._size = 0),
        (this._mapKey = g(t) ? e => e[t] : t),
        (this._warning = e);
    }
    record(t) {
      var e, i;
      const n = t.grammarType,
        s = this._mapKey(t);
      return (
        this._grammarMap[n]
          ? (this._grammars[n].push(t),
            l(s) ||
              (this._grammarMap[n][s]
                ? null === (e = this._warning) || void 0 === e || e.call(this, s, t)
                : (this._grammarMap[n][s] = t)))
          : (this._grammars.customized.push(t),
            l(s) ||
              (this._grammarMap.customized[s]
                ? null === (i = this._warning) || void 0 === i || i.call(this, s, t)
                : (this._grammarMap.customized[s] = t))),
        (this._size += 1),
        this
      );
    }
    unrecord(t) {
      const e = t.grammarType,
        i = this._mapKey(t);
      return (
        this._grammarMap[e]
          ? ((this._grammars[e] = this._grammars[e].filter(e => e !== t)),
            l(i) || this._grammarMap[e][i] !== t || delete this._grammarMap[e][i])
          : ((this._grammars.customized = this._grammars.customized.filter(e => e !== t)),
            l(i) || this._grammarMap.customized[i] !== t || delete this._grammarMap.customized[i]),
        (this._size -= 1),
        this
      );
    }
    size() {
      return this._size;
    }
    getSignal(t) {
      var e;
      return null !== (e = this._grammarMap.signal[t]) && void 0 !== e ? e : null;
    }
    getData(t) {
      var e;
      return null !== (e = this._grammarMap.data[t]) && void 0 !== e ? e : null;
    }
    getScale(t) {
      var e;
      return null !== (e = this._grammarMap.scale[t]) && void 0 !== e ? e : null;
    }
    getCoordinate(t) {
      var e;
      return null !== (e = this._grammarMap.coordinate[t]) && void 0 !== e ? e : null;
    }
    getMark(t) {
      var e;
      return null !== (e = this._grammarMap.mark[t]) && void 0 !== e ? e : null;
    }
    getCustomized(t) {
      var e;
      return null !== (e = this._grammarMap.customized[t]) && void 0 !== e ? e : null;
    }
    getGrammar(t) {
      return this._grammarMap.data[t]
        ? this._grammarMap.data[t]
        : this._grammarMap.signal[t]
        ? this._grammarMap.signal[t]
        : this._grammarMap.scale[t]
        ? this._grammarMap.scale[t]
        : this._grammarMap.coordinate[t]
        ? this._grammarMap.coordinate[t]
        : this._grammarMap.mark[t]
        ? this._grammarMap.mark[t]
        : this._grammarMap.customized[t]
        ? this._grammarMap.customized[t]
        : null;
    }
    getAllSignals() {
      return this._grammars.signal;
    }
    getAllData() {
      return this._grammars.data;
    }
    getAllScales() {
      return this._grammars.scale;
    }
    getAllCoordinates() {
      return this._grammars.coordinate;
    }
    getAllMarks() {
      return this._grammars.mark;
    }
    getAllCustomized() {
      return this._grammars.customized;
    }
    traverse(t) {
      var e;
      Object.values(null !== (e = this._grammars) && void 0 !== e ? e : {}).forEach(e =>
        (null != e ? e : []).forEach(e => {
          t.call(null, e);
        })
      );
    }
    find(t) {
      let e = null;
      return this.traverse(i => !0 === t.call(null, i) && ((e = i), !0)), e;
    }
    filter(t) {
      const e = [];
      return (
        this.traverse(i => {
          !0 === t.call(null, i) && e.push(i);
        }),
        e
      );
    }
    clear() {
      (this._size = 0),
        (this._grammars = { signal: [], data: [], scale: [], coordinate: [], mark: [], customized: [] }),
        (this._grammarMap = { signal: {}, data: {}, scale: {}, coordinate: {}, mark: {}, customized: {} });
    }
    release() {
      (this._size = 0), (this._grammars = null), (this._grammarMap = null);
    }
  }
  class Pq extends Eq {
    constructor() {
      super(...arguments), (this._markNodes = []);
    }
    record(t) {
      if ((super.record(t), 'mark' === t.grammarType)) {
        const e = t,
          i = { mark: e, parent: null, children: [] };
        this._markNodes.forEach(t => {
          const n = t.mark;
          n.markType === GW.group && n.includesChild(e, !1)
            ? (t.children.push(i), (i.parent = t))
            : e.markType === GW.group && e.includesChild(n, !1) && (i.children.push(t), (t.parent = i));
        }),
          this._markNodes.push(i);
      }
      return this;
    }
    unrecord(t) {
      if ((super.unrecord(t), 'mark' === t.grammarType)) {
        const e = t,
          i = this._markNodes.find(t => t.mark === e);
        this._markNodes.forEach(t => {
          const n = t.mark;
          n.markType === GW.group && n.includesChild(e, !1)
            ? ((t.children = t.children.filter(t => t !== i)), (i.parent = null))
            : e.markType === GW.group &&
              e.includesChild(n, !1) &&
              ((i.children = i.children.filter(e => e !== t)), (t.parent = null));
        }),
          (this._markNodes = this._markNodes.filter(t => t !== i));
      }
      return this;
    }
    getAllMarkNodes() {
      return this._markNodes;
    }
    clear() {
      super.clear(), (this._markNodes = []);
    }
    release() {
      super.release(), (this._markNodes = null);
    }
  }
  class Rq {
    constructor(t) {
      (this._animations = []),
        (this._additionalAnimateMarks = []),
        (this._onAnimationStart = t => {
          (this._additionalAnimateMarks = this._additionalAnimateMarks.filter(t => {
            var e;
            return null === (e = null == t ? void 0 : t.animate) || void 0 === e ? void 0 : e.isAnimating();
          })),
            0 === this._animations.length &&
              0 === this._additionalAnimateMarks.length &&
              this._view.emit(tG.ALL_ANIMATION_START, {}),
            (this._animations = this._animations.concat({ config: t.animationConfig, mark: t.mark }));
        }),
        (this._onAnimationEnd = t => {
          (this._additionalAnimateMarks = this._additionalAnimateMarks.filter(t => {
            var e;
            return null === (e = null == t ? void 0 : t.animate) || void 0 === e ? void 0 : e.isAnimating();
          })),
            (this._animations = this._animations.filter(e => e.config !== t.animationConfig || e.mark !== t.mark)),
            0 === this._animations.length &&
              0 === this._additionalAnimateMarks.length &&
              this._view.emit(tG.ALL_ANIMATION_END, {});
        }),
        (this._view = t),
        this._view.addEventListener(tG.ANIMATION_START, this._onAnimationStart),
        this._view.addEventListener(tG.ANIMATION_END, this._onAnimationEnd);
    }
    stop() {
      return (
        this._view.traverseMarkTree(t => {
          var e, i;
          null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.stop) || void 0 === i || i.call(e);
        }),
        this._additionalAnimateMarks.forEach(t => {
          var e, i;
          t.view &&
            (null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.stop) || void 0 === i || i.call(e));
        }),
        (this._additionalAnimateMarks = []),
        this
      );
    }
    pause() {
      return (
        this._view.traverseMarkTree(t => {
          var e, i;
          null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.pause) || void 0 === i || i.call(e);
        }),
        this._additionalAnimateMarks.forEach(t => {
          var e, i;
          t.view &&
            (null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.pause) || void 0 === i || i.call(e));
        }),
        this
      );
    }
    resume() {
      return (
        this._view.traverseMarkTree(t => {
          var e, i;
          null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.resume) || void 0 === i || i.call(e);
        }),
        this._additionalAnimateMarks.forEach(t => {
          var e, i;
          t.view &&
            (null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.resume) || void 0 === i || i.call(e));
        }),
        this
      );
    }
    enable() {
      return (
        this._view.traverseMarkTree(t => {
          var e, i;
          null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.enable) || void 0 === i || i.call(e);
        }),
        this
      );
    }
    disable() {
      return (
        this._view.traverseMarkTree(t => {
          var e, i;
          null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.disable) || void 0 === i || i.call(e);
        }),
        this._additionalAnimateMarks.forEach(t => {
          var e, i;
          t.view &&
            (null === (i = null === (e = t.animate) || void 0 === e ? void 0 : e.stop) || void 0 === i || i.call(e));
        }),
        (this._additionalAnimateMarks = []),
        this
      );
    }
    enableAnimationState(t) {
      return (
        this._view.traverseMarkTree(e => {
          var i, n;
          null === (n = null === (i = e.animate) || void 0 === i ? void 0 : i.enableAnimationState) ||
            void 0 === n ||
            n.call(i, t);
        }),
        this
      );
    }
    disableAnimationState(t) {
      return (
        this._view.traverseMarkTree(e => {
          var i, n;
          null === (n = null === (i = e.animate) || void 0 === i ? void 0 : i.disableAnimationState) ||
            void 0 === n ||
            n.call(i, t);
        }),
        this
      );
    }
    isAnimating() {
      return (
        0 !== this._animations.length ||
        this._additionalAnimateMarks.some(t => {
          var e;
          return (null === (e = null == t ? void 0 : t.animate) || void 0 === e ? void 0 : e.isAnimating()) || !1;
        })
      );
    }
    animate() {
      return (
        this._view.traverseMarkTree(
          t => {
            t.isUpdated && t.animate && t.animate.animate(), t.cleanExitElements(), (t.isUpdated = !1);
          },
          null,
          !0
        ),
        this
      );
    }
    animateAddition(t) {
      return t.animate.animate(), this._additionalAnimateMarks.push(t), this;
    }
    release() {
      (this._additionalAnimateMarks = []),
        this._view.removeEventListener(tG.ALL_ANIMATION_START, this._onAnimationStart),
        this._view.removeEventListener(tG.ALL_ANIMATION_END, this._onAnimationEnd);
    }
  }
  class Oq extends hY {
    encodeState(t, e, i) {
      return super.encodeState(t, e, i), this._updateComponentEncoders(t), this;
    }
    _updateComponentEncoders(t) {
      this._encoders || (this._encoders = {});
      const e = this.spec.encode[t];
      if (e && 'update' === t) {
        const i = this.parameters(),
          n = DW(e) ? null : Object.keys(e).reduce((t, n) => (wG(e[n]) && (t[n] = jW(e[n].scale, i)), t), {});
        this._encoders[t] = {
          callback: (t, i, s) => {
            var r, a, o;
            const h = NG(e, t, i, s);
            if (((this.disableCoordinateTransform = !1), n && n.x && n.x.type === qo.Band)) {
              if (!l(n.y)) {
                const t = n.y.domain(),
                  e = Math.min.apply(null, t),
                  i = Math.max.apply(null, t),
                  s = e > 0 ? e : i < 0 ? i : 0;
                h.y1 = n.y.scale(s);
              }
              const t = n.x.bandwidth();
              (h.x = h.x + t / 4), (h.x1 = h.x + t / 2);
            } else if (n && n.y && n.y.type === qo.Band) {
              if (!l(n.x)) {
                const t = n.x.domain(),
                  e = Math.min.apply(null, t),
                  i = Math.max.apply(null, t),
                  s = e > 0 ? e : i < 0 ? i : 0;
                h.x1 = n.x.scale(s);
              }
              const t = n.y.bandwidth();
              (h.y = h.y + t / 4), (h.y1 = h.y + t / 2);
            }
            if (n) {
              const t = (
                null !== (a = this.view.getScaleById(null === (r = e.x) || void 0 === r ? void 0 : r.scale)) &&
                void 0 !== a
                  ? a
                  : this.view.getScaleById(null === (o = e.y) || void 0 === o ? void 0 : o.scale)
              ).getCoordinate();
              if (t && 'polar' === t.type) {
                this.disableCoordinateTransform = !0;
                const e = t.origin();
                (h.cx = e.x), (h.cy = e.y);
              }
            }
            return h;
          }
        };
      } else this._encoders[t] = e;
    }
    _getEncoders() {
      var t;
      return null !== (t = this._encoders) && void 0 !== t ? t : {};
    }
    getAttributeTransforms() {
      return this.coord && 'polar' === this.coord.output().type
        ? [
            {
              channels: ['x', 'y', 'x1', 'y1', 'cx', 'cy'],
              transform: (t, e, i) => {
                (t.x = i.cx),
                  (t.y = i.cy),
                  this.coord.output().isTransposed()
                    ? ((t.startAngle = i.y), (t.endAngle = i.y1), (t.innerRadius = i.x), (t.outerRadius = i.x1))
                    : ((t.startAngle = i.x), (t.endAngle = i.x1), (t.innerRadius = i.y), (t.outerRadius = i.y1));
              },
              storedAttrs: 'sizeAttrs'
            }
          ]
        : IG.rect;
    }
    addGraphicItem(t, e) {
      const i = JG(this, this.coord && 'polar' === this.coord.output().type ? GW.arc : GW.rect, t);
      return super.addGraphicItem(t, e, i);
    }
    release() {
      super.release(), (this._encoders = null);
    }
  }
  class Bq extends hY {
    encodeState(t, e, i) {
      return super.encodeState(t, e, i), this._updateComponentEncoders(t), this;
    }
    _updateComponentEncoders(t) {
      this._encoders || (this._encoders = {});
      const e = this.spec.encode[t];
      if (e && 'update' === t) {
        const i = this.parameters(),
          n = DW(e) ? null : Object.keys(e).reduce((t, n) => (wG(e[n]) && (t[n] = jW(e[n].scale, i)), t), {});
        this._encoders[t] = {
          callback: (t, i, s) => {
            const r = NG(e, t, i, s);
            if (l(r.size)) {
              const t = n.x ? WG(n.x) : void 0,
                e = n.y ? WG(n.y) : void 0;
              l(t) && l(e) ? (r.size = 10) : l(t) ? (r.size = e) : l(e) && (r.size = t), (r.size = [t, e]);
            }
            return l(r.shape) && (r.shape = 'rect'), r;
          }
        };
      } else this._encoders[t] = e;
    }
    _getEncoders() {
      var t;
      return null !== (t = this._encoders) && void 0 !== t ? t : {};
    }
    getAttributeTransforms() {
      return [
        {
          channels: ['size', 'padding'],
          transform: (t, e, i) => {
            if (y(i.padding) && i.padding > 0)
              t.size = f(i.size) ? i.size.map(t => Math.max(t - i.padding, 1)) : Math.max(i.size - i.padding, 1);
            else if (f(i.padding) && 2 === i.padding.length) {
              const e = f(i.size) ? i.size : [i.size, i.size];
              t.size = [Math.max(e[0] - i.padding[0], 1), Math.max(e[1] - i.padding[1], 1)];
            } else t.size = i.size;
          },
          storedAttrs: 'paddingAttrs'
        }
      ].concat(IG.symbol);
    }
    release() {
      super.release(), (this._encoders = null);
    }
  }
  const Iq = {
      axis: {
        label: {
          visible: !0,
          inside: !1,
          space: 4,
          style: { fontSize: 12, fill: '#89909d', fontWeight: 'normal', fillOpacity: 1 }
        },
        tick: {
          visible: !0,
          inside: !1,
          alignWithLabel: !0,
          length: 4,
          style: { lineWidth: 1, stroke: '#D9DDE4', strokeOpacity: 1 }
        },
        subTick: {
          visible: !1,
          inside: !1,
          count: 4,
          length: 2,
          style: { lineWidth: 1, stroke: '#D9DDE4', strokeOpacity: 1 }
        },
        line: { visible: !0, style: { lineWidth: 1, stroke: '#D9DDE4', strokeOpacity: 1 } },
        items: [],
        start: { x: 0, y: 0 },
        end: { x: 100, y: 0 },
        x: 0,
        y: 0
      },
      circleAxis: {
        title: {
          space: 4,
          padding: [0, 0, 0, 0],
          textStyle: { fontSize: 12, fill: '#333333', fontWeight: 'normal', fillOpacity: 1 },
          text: 'theta'
        },
        label: {
          visible: !0,
          inside: !1,
          space: 4,
          style: { fontSize: 12, fill: '#6F6F6F', fontWeight: 'normal', fillOpacity: 1 }
        },
        tick: {
          visible: !0,
          inside: !1,
          alignWithLabel: !0,
          length: 4,
          style: { lineWidth: 1, stroke: '#D9DDE4', strokeOpacity: 1 }
        },
        subTick: {
          visible: !1,
          inside: !1,
          count: 4,
          length: 2,
          style: { lineWidth: 1, stroke: '#D9DDE4', strokeOpacity: 1 }
        },
        line: { visible: !0, style: { lineWidth: 1, stroke: '#D9DDE4', strokeOpacity: 1 } },
        items: [],
        startAngle: 0,
        endAngle: 2 * Math.PI,
        radius: 100,
        innerRadius: 0,
        center: { x: 0, y: 0 },
        x: 0,
        y: 0
      },
      grid: { style: { stroke: '#f1f2f5' } },
      circleGrid: {},
      discreteLegend: {
        layout: 'vertical',
        title: { align: 'start', space: 12, textStyle: { fontSize: 12, fontWeight: 'bold', fill: '#2C3542' } },
        item: {
          spaceCol: 10,
          spaceRow: 10,
          shape: {
            space: 4,
            style: { size: 10, cursor: 'pointer' },
            state: {
              selectedHover: { opacity: 0.85 },
              unSelected: { fill: '#D8D8D8', stroke: '#D8D8D8', fillOpacity: 0.5 }
            }
          },
          label: {
            space: 4,
            style: { fontSize: 12, fill: 'black', cursor: 'pointer' },
            state: { selectedHover: { opacity: 0.85 }, unSelected: { fill: '#D8D8D8', fillOpacity: 0.5 } }
          },
          value: {
            alignRight: !1,
            style: { fontSize: 12, fill: '#ccc', cursor: 'pointer' },
            state: { selectedHover: { opacity: 0.85 }, unSelected: { fill: '#D8D8D8' } }
          },
          background: {
            style: { cursor: 'pointer' },
            state: {
              selectedHover: { fillOpacity: 0.7, fill: 'gray' },
              unSelectedHover: { fillOpacity: 0.2, fill: 'gray' }
            }
          },
          focus: !1,
          focusIconStyle: { size: 10, fill: '#333', cursor: 'pointer' },
          visible: !0,
          padding: { top: 2, bottom: 2, left: 2, right: 2 }
        },
        autoPage: !0,
        pager: { space: 12, handler: { style: { size: 10 }, space: 4 } },
        hover: !0,
        select: !0,
        selectMode: 'multiple',
        allowAllCanceled: !1,
        items: [{ index: 0, id: '', label: '', shape: { fill: '#6690F2', stroke: '#6690F2', symbolType: 'circle' } }]
      },
      colorLegend: {
        title: { visible: !1, text: '' },
        colors: [],
        layout: 'horizontal',
        railWidth: 200,
        railHeight: 8,
        railStyle: { cornerRadius: 5 }
      },
      sizeLegend: {
        title: { visible: !1, text: '' },
        trackStyle: { fill: '#ccc' },
        layout: 'horizontal',
        align: 'bottom',
        railWidth: 200,
        railHeight: 6,
        min: 0,
        max: 1,
        value: [0, 1]
      },
      lineCrosshair: { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } },
      rectCrosshair: { start: { x: 0, y: 0 }, end: { x: 0, y: 0 }, rectStyle: { width: 10, height: 10 } },
      sectorCrosshair: { center: { x: 0, y: 0 }, radius: 100, startAngle: 0, endAngle: Math.PI / 6 },
      circleCrosshair: { center: { x: 0, y: 0 }, radius: 100, startAngle: 0, endAngle: 2 * Math.PI },
      polygonCrosshair: { center: { x: 0, y: 0 }, radius: 100, startAngle: 0, endAngle: 2 * Math.PI, sides: 6 },
      slider: {
        layout: 'horizontal',
        railWidth: 200,
        railHeight: 10,
        railStyle: { cornerRadius: 5 },
        range: { draggableTrack: !0 },
        startText: { visible: !0, text: '', space: 8 },
        endText: { visible: !0, text: '', space: 8 },
        min: 0,
        max: 1,
        value: [0, 1]
      },
      dataLabel: { size: { width: 400, height: 400 }, dataLabels: [] },
      pointLabel: {
        data: [{ text: '', fill: '#606773', data: {} }],
        overlap: { avoidBaseMark: !1, clampForce: !1, size: { width: 1e3, height: 1e3 } },
        smartInvert: !1
      },
      lineLabel: {
        type: 'line',
        data: [{ text: '', data: {} }],
        position: 'start',
        overlap: {
          avoidBaseMark: !0,
          clampForce: !1,
          size: { width: 1e3, height: 1e3 },
          strategy: [{ type: 'position' }]
        },
        smartInvert: !1
      },
      rectLabel: {
        type: 'rect',
        data: [{ text: '', fill: '#606773', data: {} }],
        position: 'top',
        overlap: { size: { width: 1e3, height: 1e3 }, strategy: [{ type: 'position' }] },
        smartInvert: !1
      },
      symbolLabel: {
        type: 'symbol',
        data: [{ text: '', fill: '#606773', data: {} }],
        position: 'top',
        overlap: { avoidBaseMark: !0, size: { width: 1e3, height: 1e3 }, strategy: [{ type: 'position' }] },
        smartInvert: !1
      },
      arcLabel: {
        type: 'arc',
        data: [{ text: '', fill: '#606773', data: {} }],
        width: 800,
        height: 600,
        position: 'outside',
        zIndex: 302
      },
      datazoom: {
        orient: 'bottom',
        showDetail: 'auto',
        brushSelect: !0,
        start: 0,
        end: 1,
        position: { x: 0, y: 0 },
        size: { width: 500, height: 40 },
        previewData: []
      },
      continuousPlayer: {},
      discretePlayer: {},
      tooltip: {},
      title: { textStyle: { fill: '#21252c' }, subtextStyle: { fill: '#606773' } }
    },
    Dq = { symbol: { shape: 'circle', size: 8 }, text: { fontSize: 14, fill: '#000000' } },
    Lq = Object.assign({}, Iq);
  (Lq.axis = Object.assign({}, Lq.axis, {
    label: { style: { fill: '#bbbdc3' } },
    line: { style: { stroke: '#4b4f54' } },
    tick: { style: { stroke: '#4b4f54' } },
    subTick: { style: { stroke: '#4b4f54' } }
  })),
    (Lq.circleAxis = Object.assign({}, Lq.circleAxis, {
      label: { style: { fill: '#bbbdc3' } },
      line: { style: { stroke: '#4b4f54' } },
      tick: { style: { stroke: '#4b4f54' } },
      subTick: { style: { stroke: '#4b4f54' } }
    })),
    (Lq.grid = Object.assign({}, Lq.grid, { style: { stroke: '#404349' } })),
    (Lq.circleGrid = Object.assign({}, Lq.circleGrid, { style: { stroke: '#404349' } })),
    (Lq.rectLabel = Object.assign({}, Lq.rectLabel, { data: [{ text: '', fill: '#888c93', data: {} }] })),
    (Lq.lineLabel = Object.assign({}, Lq.lineLabel, { data: [{ text: '', fill: '#888c93', data: {} }] })),
    (Lq.symbolLabel = Object.assign({}, Lq.symbolLabel, { data: [{ text: '', fill: '#888c93', data: {} }] })),
    (Lq.title = Object.assign({}, Lq.title, { textStyle: { fill: '#fdfdfd' }, subtextStyle: { fill: '#888c93' } }));
  const Fq = {
      name: 'dark',
      padding: 5,
      background: '#202226',
      palette: {
        default: [
          '#5383F4',
          '#7BCF8E',
          '#FF9D2C',
          '#FFDB26',
          '#7568D9',
          '#80D8FB',
          '#1857A3',
          '#CAB0E8',
          '#FF8867',
          '#B9E493',
          '#2CB4A8',
          '#B9E4E3'
        ]
      },
      marks: Dq,
      components: Lq
    },
    jq = {
      name: 'default',
      padding: 5,
      palette: {
        default: [
          '#6690F2',
          '#70D6A3',
          '#B4E6E2',
          '#63B5FC',
          '#FF8F62',
          '#FFDC83',
          '#BCC5FD',
          '#A29BFE',
          '#63C4C7',
          '#F68484'
        ]
      },
      marks: Dq,
      components: Iq
    };
  let zq = class t {
    static registerTheme(e, i) {
      e && t._themes.set(e, i);
    }
    static unregisterTheme(e) {
      t._themes.delete(e);
    }
    static getTheme(e) {
      return t._themes.get(e);
    }
    static getDefaultTheme() {
      return t.getTheme('default');
    }
  };
  (zq._themes = new Map()), zq.registerTheme('default', jq), zq.registerTheme('dark', Fq);
  var Hq = function (t, e, i, n) {
    return new (i || (i = Promise))(function (s, r) {
      function a(t) {
        try {
          l(n.next(t));
        } catch (t) {
          r(t);
        }
      }
      function o(t) {
        try {
          l(n.throw(t));
        } catch (t) {
          r(t);
        }
      }
      function l(t) {
        var e;
        t.done
          ? s(t.value)
          : ((e = t.value),
            e instanceof i
              ? e
              : new i(function (t) {
                  t(e);
                })).then(a, o);
      }
      l((n = n.apply(t, e || [])).next());
    });
  };
  class Nq extends s {
    constructor() {
      var t;
      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(),
        (t = this),
        (this._observer = null),
        (this._onResize = mt(function () {
          const e = t._getContainerSize();
          e && t.resize(e.width, e.height);
        }, 100)),
        (this.delegateEvent = (t, e) => {
          var i;
          const n = null === (i = t.target) || void 0 === i ? void 0 : i[iG],
            s = oY(0, t, n, e, ZU);
          this.emit(e, s, n);
        }),
        (this.handleProgressiveFrame = () => {
          this._progressiveMarks.length &&
            this._progressiveMarks.forEach(t => {
              t.isDoingProgressive() && t.evaluateProgressive();
            }),
            this.doPreProgressive();
        }),
        (this._config = i),
        (this._options = Object.assign({ mode: 'browser', cursor: !0 }, e)),
        this.initialize();
    }
    getGrammarById(t) {
      return this.grammars.getGrammar(t);
    }
    getSignalById(t) {
      return this.grammars.getSignal(t);
    }
    getDataById(t) {
      return this.grammars.getData(t);
    }
    getScaleById(t) {
      return this.grammars.getScale(t);
    }
    getCoordinateById(t) {
      return this.grammars.getCoordinate(t);
    }
    getMarkById(t) {
      return this.grammars.getMark(t);
    }
    getCustomizedById(t) {
      return this.grammars.getCustomized(t);
    }
    getGrammarsByName(t) {
      return this.grammars.filter(e => e.name() === t);
    }
    getGrammarsByType(t) {
      return this.grammars.filter(e => e.grammarType === t);
    }
    getMarksByType(t) {
      return this.grammars.getAllMarks().filter(e => e.markType === t);
    }
    updateSignal(t, e) {
      g(t) && (t = this.getSignalById(t)), t.set(e), this.commit(t);
    }
    signal(t, e) {
      const i = new FK(this);
      return (
        arguments.length >= 1 && i.value(t),
        arguments.length >= 2 && i.update(e),
        this.grammars.record(i),
        this._dataflow.add(i),
        i
      );
    }
    data(t) {
      const e = new CK(this, t);
      return this.grammars.record(e), this._dataflow.add(e), e;
    }
    scale(t) {
      const e = new nq(this, t);
      return this.grammars.record(e), this._dataflow.add(e), e;
    }
    coordinate(t) {
      const e = new Mq(this, t);
      return this.grammars.record(e), this._dataflow.add(e), e;
    }
    mark(t, e, i) {
      const n = g(e) ? this.getMarkById(e) : e;
      let s;
      switch (t) {
        case GW.group:
          s = new uq(this, n);
          break;
        case GW.glyph:
          s = new xq(this, null == i ? void 0 : i.glyphType, n);
          break;
        case GW.component:
          s = ((t, e, i, n) => {
            switch (e) {
              case UW.axis:
                return new cK(t, i, n);
              case UW.grid:
                return new dK(t, i, n);
              case UW.legend:
                return new uK(t, i);
              case UW.crosshair:
                return new fK(t, i);
              case UW.slider:
                return new vK(t, i);
              case UW.label:
                return new mK(t, i);
              case UW.datazoom:
                return new yK(t, i);
              case UW.player:
                return new _K(t, i);
              case UW.tooltip:
                return new SK(t, i);
              case UW.dimensionTooltip:
                return new wK(t, i);
              case UW.title:
                return new AK(t, i);
            }
            return new cY(t, e, i, n);
          })(this, null == i ? void 0 : i.componentType, n, null == i ? void 0 : i.mode);
          break;
        case GW.interval:
          s = new Oq(this, t, n);
          break;
        case GW.cell:
          s = new Bq(this, t, n);
          break;
        default:
          s = new hY(this, t, n);
      }
      return this.grammars.record(s), this._dataflow.add(s), s;
    }
    group(t) {
      return this.mark(GW.group, t);
    }
    glyph(t, e) {
      return this.mark(GW.glyph, e, { glyphType: t });
    }
    component(t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : '2d';
      return this.mark(GW.component, e, { componentType: t, mode: i });
    }
    axis(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '2d';
      return this.mark(GW.component, t, { componentType: UW.axis, mode: e });
    }
    grid(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '2d';
      return this.mark(GW.component, t, { componentType: UW.grid, mode: e });
    }
    legend(t) {
      return this.mark(GW.component, t, { componentType: UW.legend });
    }
    crosshair(t) {
      return this.mark(GW.component, t, { componentType: UW.crosshair });
    }
    slider(t) {
      return this.mark(GW.component, t, { componentType: UW.slider });
    }
    label(t) {
      return this.mark(GW.component, t, { componentType: UW.label });
    }
    datazoom(t) {
      return this.mark(GW.component, t, { componentType: UW.datazoom });
    }
    player(t) {
      return this.mark(GW.component, t, { componentType: UW.player });
    }
    tooltip(t) {
      return this.mark(GW.component, t, { componentType: UW.tooltip });
    }
    dimensionTooltip(t) {
      return this.mark(GW.component, t, { componentType: UW.dimensionTooltip });
    }
    title(t) {
      return this.mark(GW.component, t, { componentType: UW.title });
    }
    customized(t, e) {
      const i = (t => cq[t])(t);
      if (i) {
        const t = new i.grammarClass(this);
        return t.parse(e), this.grammars.record(t), this._dataflow.add(t), t;
      }
    }
    addGrammar(t) {
      return (
        this.grammars.find(e => e.uid === t.uid) ||
          (this.grammars.record(t), this._dataflow.add(t), t.parse(t.getSpec()), (this._needBuildLayoutTree = !0)),
        this
      );
    }
    removeGrammar(t) {
      const e = g(t) ? this.getGrammarById(t) : t;
      return e && this.grammars.find(t => t.uid === e.uid)
        ? ('mark' === e.grammarType && e.prepareRelease(),
          this._cachedGrammars.record(e),
          this._dataflow.remove(e),
          this.grammars.unrecord(e),
          (this._needBuildLayoutTree = !0),
          this)
        : this;
    }
    removeAllGrammars() {
      return (
        this.grammars.traverse(t => {
          ('signal' === t.grammarType && rq.includes(t.id())) ||
            ('mark' === t.grammarType && 'root' === t.id()) ||
            this.removeGrammar(t);
        }),
        this
      );
    }
    parseSpec(t) {
      var e, i, n, s, r, a, o, l;
      if (
        (this.emit(tG.BEFORE_PARSE_VIEW),
        (this._spec = t),
        (t => {
          var e;
          const i = (t, e) => {
            var n, s;
            t.group = e;
            const r = null !== (n = t.id) && void 0 !== n ? n : 'VGRAMMAR_MARK_' + ++sq;
            (t.id = r), (null !== (s = t.marks) && void 0 !== s ? s : []).forEach(t => i(t, r));
          };
          (null !== (e = t.marks) && void 0 !== e ? e : []).forEach(t => i(t, 'root'));
        })(t),
        t.theme ? this.theme(t.theme) : this.theme(zq.getDefaultTheme()),
        t.width && this.width(t.width),
        t.height && this.height(t.height),
        this.padding(
          null !== (i = null !== (e = t.padding) && void 0 !== e ? e : this._options.padding) && void 0 !== i
            ? i
            : this._theme.padding
        ),
        !this.width() || !this.height())
      ) {
        const t = this._getContainerSize();
        t && (this.updateSignal(tY, t.width), this.updateSignal(eY, t.height));
      }
      (null === (n = t.signals) || void 0 === n ? void 0 : n.length) &&
        t.signals.forEach(t => {
          this.signal().parse(t);
        }),
        (null === (s = t.data) || void 0 === s ? void 0 : s.length) &&
          t.data.forEach(t => {
            this.data(null).parse(t);
          }),
        (null === (r = t.coordinates) || void 0 === r ? void 0 : r.length) &&
          t.coordinates.forEach(t => {
            this.coordinate(t.type).parse(t);
          }),
        (null === (a = t.scales) || void 0 === a ? void 0 : a.length) &&
          t.scales.forEach(t => {
            this.scale(t.type).parse(t);
          });
      const h = dq();
      return (
        Object.keys(h).forEach(e => {
          var i;
          const { specKey: n } = h[e];
          (null === (i = t[n]) || void 0 === i ? void 0 : i.length) &&
            t[n].forEach(t => {
              this.customized(e, t);
            });
        }),
        (null === (o = t.marks) || void 0 === o ? void 0 : o.length) &&
          t.marks.forEach(t => {
            this.parseMarkSpec(t);
          }),
        (null === (l = t.events) || void 0 === l ? void 0 : l.length) &&
          t.events.forEach(t => {
            this.event(t);
          }),
        this.emit(tG.AFTER_PARSE_VIEW),
        (this._needBuildLayoutTree = !0),
        (this._layoutState = QW.before),
        this
      );
    }
    updateSpec(t) {
      return this.removeAllGrammars(), this.parseSpec(t);
    }
    parseBuiltIn() {
      ((t, e, i) => {
        var n, s, r, a, o;
        return [
          { id: tY, value: null !== (n = t[tY]) && void 0 !== n ? n : 0 },
          { id: eY, value: null !== (s = t[eY]) && void 0 !== s ? s : 0 },
          {
            id: sY,
            value: aq(null !== (a = null !== (r = t[sY]) && void 0 !== r ? r : e[sY]) && void 0 !== a ? a : i.padding)
          },
          {
            id: iY,
            update: {
              callback: (t, e) => {
                const i = aq(e[sY]);
                return e[tY] - i.left - i.right;
              },
              dependency: [tY, sY]
            }
          },
          {
            id: nY,
            update: {
              callback: (t, e) => {
                const i = aq(e[sY]);
                return e[eY] - i.top - i.bottom;
              },
              dependency: [eY, sY]
            }
          },
          {
            id: rY,
            update: {
              callback: (t, e) => {
                const i = aq(e[sY]);
                return (t || new Xt()).setValue(i.left, i.top, i.left + e[iY], i.top + e[nY]);
              },
              dependency: [iY, nY, sY]
            }
          },
          { id: aY, value: null !== (o = t[aY]) && void 0 !== o ? o : e[aY] }
        ];
      })(this._options, this._config, this.getCurrentTheme()).map(t => {
        const e = this.signal().parse(t);
        t.value && e.set(t.value);
      }),
        this.parseMarkSpec({
          id: 'root',
          type: 'group',
          encode: { enter: { x: 0, y: 0 }, update: { width: { signal: 'width' }, height: { signal: 'height' } } }
        }),
        (this.rootMark = this.getMarkById('root'));
    }
    parseMarkSpec(t) {
      var e;
      const i =
        t.type === GW.glyph
          ? { glyphType: t.glyphType }
          : t.type === GW.component
          ? { componentType: t.componentType, mode: t.mode }
          : null;
      this.mark(t.type, t.group, i).parse(t),
        null === (e = t.marks) ||
          void 0 === e ||
          e.forEach(t => {
            this.parseMarkSpec(t);
          });
    }
    theme(t) {
      var e, i, n, s, r, a, o, l, h;
      return (
        g(t)
          ? (this._theme = null !== (e = zq.getTheme(t)) && void 0 !== e ? e : zq.getDefaultTheme())
          : (this._theme = t),
        this.background(
          null !==
            (s =
              null !== (n = null === (i = this._spec) || void 0 === i ? void 0 : i.background) && void 0 !== n
                ? n
                : this._options.background) && void 0 !== s
            ? s
            : this._theme.background
        ),
        this.padding(
          null !==
            (o =
              null !== (a = null === (r = this._spec) || void 0 === r ? void 0 : r.padding) && void 0 !== a
                ? a
                : this._options.padding) && void 0 !== o
            ? o
            : this._theme.padding
        ),
        null === (h = null === (l = this.renderer.stage()) || void 0 === l ? void 0 : l.setTheme) ||
          void 0 === h ||
          h.call(l, Object.assign({}, this._theme.marks)),
        this
      );
    }
    getCurrentTheme() {
      return this._theme;
    }
    setCurrentTheme(t) {
      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      return Hq(this, void 0, void 0, function* () {
        return (
          this.theme(t),
          this.grammars.getAllMarks().forEach(t => {
            t.commit();
          }),
          e ? (yield this.evaluate(), this.renderer.render(!0)) : yield this._dataflow.evaluate(),
          this
        );
      });
    }
    background(t) {
      return arguments.length ? ((this._background = t), this.renderer.background(t), t) : this._background;
    }
    width(t) {
      const e = this.getSignalById(tY);
      return arguments.length ? ((this._options.width = t), this.updateSignal(e, t), t) : e.output();
    }
    height(t) {
      const e = this.getSignalById(eY);
      return arguments.length ? ((this._options.height = t), this.updateSignal(e, t), t) : e.output();
    }
    viewWidth(t) {
      const e = this.getSignalById(iY);
      if (arguments.length) {
        const e = this.padding();
        return this.width(t + e.left + e.right), t;
      }
      return e.output();
    }
    viewHeight(t) {
      const e = this.getSignalById(nY);
      if (arguments.length) {
        const e = this.padding();
        return this.height(t + e.top + e.bottom), t;
      }
      return e.output();
    }
    padding(t) {
      const e = this.getSignalById(sY);
      if (arguments.length) {
        const i = aq(t);
        return this.updateSignal(e, i), i;
      }
      return aq(e.output());
    }
    autoFit(t) {
      const e = this.getSignalById(aY);
      return arguments.length ? (this.updateSignal(e, t), t) : e.output();
    }
    getViewBox() {
      const t = this.getSignalById(rY);
      return null == t ? void 0 : t.output();
    }
    updateLayoutTag() {
      return (this._layoutState = QW.before), this;
    }
    getLayoutState() {
      return this._layoutState;
    }
    buildLayoutTree() {
      const t = {},
        e = [];
      this.traverseMarkTree(
        i => {
          (t[i.id()] = !0),
            (i.group && t[i.group.id()]) || e.push(i),
            i.markType === GW.group && i.updateLayoutChildren();
        },
        t => t.needLayout()
      ),
        (this._layoutMarks = e);
    }
    doLayout() {
      var t;
      const e = this._options.doLayout || bq;
      e &&
        (null === (t = this._layoutMarks) || void 0 === t ? void 0 : t.length) &&
        (this.emit(tG.BEFORE_DO_LAYOUT), e(this._layoutMarks, this._options, this), this.emit(tG.AFTER_DO_LAYOUT));
    }
    handleLayoutEnd() {
      this.emit(tG.BEFORE_MARK_LAYOUT_END),
        this._layoutMarks.forEach(t => {
          DK(
            t,
            'layoutChildren',
            t => {
              t.handleLayoutEnd();
            },
            e => e !== t
          );
        }),
        this.emit(tG.AFTER_MARK_LAYOUT_END);
    }
    handleRenderEnd() {
      this.emit(tG.BEFORE_MARK_RENDER_END),
        DK(this.rootMark, 'children', t => {
          t.handleRenderEnd();
        }),
        this.emit(tG.AFTER_MARK_RENDER_END);
    }
    commit(t) {
      return this._dataflow.commit(t), this;
    }
    run(t) {
      return this.evaluate(t), this;
    }
    runSync(t) {
      return this.evaluateSync(t), this;
    }
    isRunning() {
      return this._running;
    }
    runAsync(t) {
      return Hq(this, void 0, void 0, function* () {
        for (; this._running; ) yield this._running;
        const e = () => {
          this._running = null;
        };
        return (this._running = this.evaluate(t)).then(e, e), this._running;
      });
    }
    runNextTick(t) {
      return Hq(this, void 0, void 0, function* () {
        return (
          this._currentDataflow ||
            (this._currentDataflow = Promise.resolve().then(() =>
              this.runAsync(t)
                .then(() => {
                  this._currentDataflow = null;
                })
                .catch(t => {
                  (this._currentDataflow = null), this.logger.error(t);
                })
            )),
          yield this._currentDataflow,
          this
        );
      });
    }
    doRender(t) {
      this.emit(tG.BEFORE_DO_RENDER),
        this.renderer &&
          (this._progressiveMarks || this.animate.animate(), this.renderer.render(t), this.handleRenderEnd()),
        this.emit(tG.AFTER_DO_RENDER);
    }
    evaluate(t) {
      var e, i;
      return Hq(this, void 0, void 0, function* () {
        const n = oq(t);
        this.reuseCachedGrammars(n);
        const s = this._cachedGrammars.size() > 0;
        this.detachCachedGrammar();
        const r = this._resizeRenderer(),
          a = this._dataflow.hasCommitted();
        return s || a || this._layoutState || r
          ? (this.clearProgressive(),
            yield this._dataflow.evaluate(),
            this._needBuildLayoutTree && (this.buildLayoutTree(), (this._needBuildLayoutTree = !1)),
            this._layoutState &&
              ((this._layoutState = QW.layouting),
              this.doLayout(),
              this._dataflow.hasCommitted() && ((this._layoutState = QW.reevaluate), yield this._dataflow.evaluate()),
              (this._layoutState = QW.after),
              (null === (e = this._layoutMarks) || void 0 === e ? void 0 : e.length) && this.handleLayoutEnd()),
            (this._layoutState = null),
            this.findProgressiveMarks(),
            this._resizeRenderer(),
            this.doRender(!1),
            null === (i = this._willMorphMarks) ||
              void 0 === i ||
              i.forEach(t => {
                this._morph.morph(t.prev, t.next, n);
              }),
            (this._willMorphMarks = null),
            this.releaseCachedGrammars(n),
            this.doPreProgressive(),
            this)
          : this;
      });
    }
    evaluateSync(t) {
      var e, i;
      const n = oq(t);
      this.reuseCachedGrammars(n);
      const s = this._cachedGrammars.size() > 0;
      this.detachCachedGrammar();
      const r = this._resizeRenderer(),
        a = this._dataflow.hasCommitted();
      return s || a || this._layoutState || r
        ? (this.clearProgressive(),
          this._dataflow.evaluateSync(),
          this._needBuildLayoutTree && (this.buildLayoutTree(), (this._needBuildLayoutTree = !1)),
          this._layoutState &&
            ((this._layoutState = QW.layouting),
            this.doLayout(),
            this._dataflow.hasCommitted() && ((this._layoutState = QW.reevaluate), this._dataflow.evaluateSync()),
            (this._layoutState = QW.after),
            (null === (e = this._layoutMarks) || void 0 === e ? void 0 : e.length) && this.handleLayoutEnd()),
          (this._layoutState = null),
          this.findProgressiveMarks(),
          this._resizeRenderer(),
          this.doRender(!0),
          null === (i = this._willMorphMarks) ||
            void 0 === i ||
            i.forEach(t => {
              this._morph.morph(t.prev, t.next, n);
            }),
          (this._willMorphMarks = null),
          this.releaseCachedGrammars(n),
          this.doPreProgressive(),
          this)
        : this;
    }
    reuseCachedGrammars(t) {
      if ((this._willMorphMarks || (this._willMorphMarks = []), t.reuse)) {
        const t = t => {
          t.next.reuse(t.prev), t.prev.detachAll(), t.prev.clear(), this._cachedGrammars.unrecord(t.prev);
        };
        this._morph
          .diffGrammar(
            this._cachedGrammars.getAllSignals(),
            this.grammars.getAllSignals().filter(t => !rq.includes(t.id()))
          )
          .update.forEach(t),
          this._morph.diffGrammar(this._cachedGrammars.getAllData(), this.grammars.getAllData()).update.forEach(t),
          this._morph.diffGrammar(this._cachedGrammars.getAllScales(), this.grammars.getAllScales()).update.forEach(t),
          this._morph
            .diffGrammar(this._cachedGrammars.getAllCoordinates(), this.grammars.getAllCoordinates())
            .update.forEach(t);
      }
      this._morph
        .diffMark(
          this._cachedGrammars.getAllMarks(),
          this.grammars.getAllMarks().filter(t => 'root' !== t.id()),
          t
        )
        .update.forEach(e => {
          const i = 1 === e.prev.length && 1 === e.next.length && e.prev[0].markType === e.next[0].markType,
            n = e.prev.every(t => t.getMorphConfig().morph) && e.next.every(t => t.getMorphConfig().morph);
          i && t.reuse
            ? (e.next[0].reuse(e.prev[0]),
              e.prev[0].detachAll(),
              e.prev[0].clear(),
              this._cachedGrammars.unrecord(e.prev[0]))
            : ((t.morph && n) || t.morphAll) && this._willMorphMarks.push({ prev: e.prev, next: e.next });
        });
    }
    detachCachedGrammar() {
      this._cachedGrammars.traverse(t => {
        var e, i;
        if ((t.detachAll(), 'mark' === t.grammarType)) {
          const n = t;
          null === (i = null === (e = n.group) || void 0 === e ? void 0 : e.removeChild) ||
            void 0 === i ||
            i.call(e, n);
        }
      });
    }
    releaseCachedGrammars(t) {
      this._cachedGrammars.traverse(t => {
        'mark' !== t.grammarType && t.release();
      });
      const e = this._cachedGrammars.getAllMarkNodes();
      e.forEach(e => {
        e.mark.animate.stop(), t.enableExitAnimation && this.animate.animateAddition(e.mark);
      });
      const i = t => {
        if (t.mark.view && 0 === t.mark.animate.getAnimatorCount() && (!t.children || 0 === t.children.length)) {
          t.mark.release();
          const e = t.parent;
          e && ((t.parent.children = t.parent.children.filter(e => e !== t)), (t.parent = null), i(e));
        }
      };
      e.forEach(t => {
        const e = t.mark;
        0 === e.animate.getAnimatorCount()
          ? i(t)
          : e.addEventListener('animationEnd', () => {
              0 === e.animate.getAnimatorCount() && i(t);
            });
      }),
        this._cachedGrammars.clear();
    }
    runAfter(t) {
      return (
        this._dataflow.runAfter(() => {
          t.call(null, this);
        }),
        this
      );
    }
    runBefore(t) {
      return (
        this._dataflow.runBefore(() => {
          t.call(null, this);
        }),
        this
      );
    }
    getImageBuffer() {
      var t, e;
      if ('node' !== this._options.mode)
        return void this.logger.error(new TypeError('getImageBuffer() now only support node environment.'));
      const i =
        null === (e = null === (t = this.renderer) || void 0 === t ? void 0 : t.stage) || void 0 === e
          ? void 0
          : e.call(t);
      return i
        ? (i.render(), i.window.getImageBuffer())
        : (this.logger.error(new ReferenceError('render is not defined')), null);
    }
    traverseMarkTree(t, e, i) {
      return DK(this.rootMark, 'children', t, e, i), this;
    }
    _bindResizeEvent() {
      var t, e, i, n, s, r;
      if (this.autoFit()) {
        const a =
          null ===
            (s =
              null ===
                (n =
                  null ===
                    (i =
                      null === (e = null === (t = this.renderer) || void 0 === t ? void 0 : t.stage) || void 0 === e
                        ? void 0
                        : e.call(t)) || void 0 === i
                    ? void 0
                    : i.window) || void 0 === n
                ? void 0
                : n.getContainer) || void 0 === s
            ? void 0
            : s.call(n);
        if (a) {
          const t = window.ResizeObserver;
          (this._observer = new t(this._onResize)), null === (r = this._observer) || void 0 === r || r.observe(a);
        }
        window.addEventListener('resize', this._onResize);
      }
    }
    _unBindResizeEvent() {
      this.autoFit() &&
        (window.removeEventListener('resize', this._onResize),
        this._observer && (this._observer.disconnect(), (this._observer = null)));
    }
    _getContainerSize() {
      var t, e, i, n, s, r, a, o, l, h, c;
      const d =
        null ===
          (s =
            null ===
              (n =
                null ===
                  (i =
                    null === (e = null === (t = this.renderer) || void 0 === t ? void 0 : t.stage) || void 0 === e
                      ? void 0
                      : e.call(t)) || void 0 === i
                  ? void 0
                  : i.window) || void 0 === n
              ? void 0
              : n.getContainer) || void 0 === s
          ? void 0
          : s.call(n);
      if (d) {
        const { width: t, height: e } = cn(d);
        return {
          width:
            null !==
              (o =
                null !== (a = null === (r = this._spec) || void 0 === r ? void 0 : r.width) && void 0 !== a
                  ? a
                  : this._options.width) && void 0 !== o
              ? o
              : t,
          height:
            null !==
              (c =
                null !== (h = null === (l = this._spec) || void 0 === l ? void 0 : l.height) && void 0 !== h
                  ? h
                  : this._options.height) && void 0 !== c
              ? c
              : e
        };
      }
      return null;
    }
    resize(t, e) {
      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      return Hq(this, void 0, void 0, function* () {
        let n = !1;
        return (
          t !== this.width() && ((n = !0), this.updateSignal(tY, t)),
          e !== this.height() && ((n = !0), this.updateSignal(eY, e)),
          n && (i ? yield this.evaluate() : yield this._dataflow.evaluate()),
          this
        );
      });
    }
    _resizeRenderer() {
      const t = this.width(),
        e = this.height();
      return (
        !!this.renderer.shouldResize(t, e) &&
        (this.renderer.resize(t, e), this.emit('resize', {}, { width: t, height: e }), !0)
      );
    }
    bindEvents(t) {
      if (this._eventConfig.disable) return;
      const { type: e, filter: i, callback: n, throttle: s, debounce: r, consume: a, target: o, dependency: h } = t,
        d = hq(e);
      if (!d) return;
      const { source: u, type: p } = d,
        f = l((_ = d).markId)
          ? t => t && t.mark.id() === _.markId
          : l(_.markName)
          ? t => t && t.mark.name() === _.markName
          : l(_.type)
          ? t => t && t.mark.markType === _.type
          : () => !0,
        v = (
          Array.isArray(o) && o.length
            ? o.map(t => ({ signal: this.getSignalById(t.target), callback: t.callback }))
            : [{ signal: g(o) ? this.getSignalById(o) : null, callback: n }]
        ).filter(t => t.signal || t.callback),
        m = BW(h, this),
        y = lq(
          (t, e) => {
            const n =
              (u === ZU &&
                (function (t, e) {
                  const i = t.defaults,
                    n = i.prevent,
                    s = i.allow;
                  return !1 !== n && !0 !== s && (!0 === n || !1 === s || (n ? n[e] : !!s && !s[e]));
                })(this._eventConfig, p)) ||
              (a && (void 0 === t.cancelable || t.cancelable));
            u === qU && (t = oY(0, t, e, p, qU));
            let s = !1;
            if ((!i || i(t)) && (!f || f(e)) && v.length) {
              const e = m.reduce((t, e) => ((t[e.id()] = e.output()), t), {});
              v.forEach(i => {
                i.callback && i.signal
                  ? i.signal.set(i.callback(t, e)) && (this.commit(i.signal), (s = !0))
                  : i.callback
                  ? i.callback(t, e)
                  : (this.commit(i.signal), (s = !0));
              });
            }
            n && t.preventDefault(), a && t.stopPropagation(), s && this.runAsync();
          },
          { throttle: s, debounce: r }
        );
      var _;
      if (u === ZU) {
        if (
          (function (t, e, i) {
            const n = null == t ? void 0 : t[e];
            return !(!1 === n || (c(n) && !n[i]));
          })(this._eventConfig, ZU, p)
        )
          return (
            this.addEventListener(p, y, JU),
            () => {
              this.removeEventListener(p, y);
            }
          );
      } else if (u === qU)
        return (
          gN.addEventListener(p, y),
          this._eventListeners.push({ type: p, source: gN, handler: y }),
          () => {
            gN.removeEventListener(p, y);
            const t = this._eventListeners.findIndex(t => t.type === p && t.source === gN && t.handler === y);
            t >= 0 && this._eventListeners.splice(t, 1);
          }
        );
    }
    event(t) {
      if ('between' in t) {
        const [e, i] = t.between,
          n = `${e.type}-${t.type}-${i.type}`;
        let s;
        this.bindEvents(
          Object.assign({}, e, {
            callback: () => {
              if ((this._eventCache || (this._eventCache = {}), !this._eventCache[n])) {
                const e = this.bindEvents(t);
                this._eventCache[n] = e;
              }
              s ||
                (s = this.bindEvents(
                  Object.assign({}, i, {
                    callback: () => {
                      this._eventCache[n] && (this._eventCache[n](), (this._eventCache[n] = null));
                    }
                  })
                ));
            }
          })
        );
      } else
        'merge' in t
          ? t.merge.forEach(e => {
              const i = Object.assign({}, t);
              g(e) ? (i.type = e) : c(e) && Object.assign(i, e), (i.debounce = 50), this.bindEvents(i);
            })
          : this.bindEvents(t);
    }
    hover(t) {
      const e = t || 'hover';
      return (
        this.addEventListener('pointerover', t => {
          t.element && t.element.addState(e);
        }),
        this.addEventListener('pointerout', t => {
          t.element && t.element.removeState(e);
        }),
        this
      );
    }
    cursor() {
      (this._cursorValue = { user: QU, element: null }),
        this.addEventListener('mousemove', t => {
          var e, i, n;
          const s =
              null === (i = null === (e = null == t ? void 0 : t.element) || void 0 === e ? void 0 : e.graphicItem) ||
              void 0 === i
                ? void 0
                : i.cursor,
            r = this._cursorValue,
            a = r ? (g(r) ? r : r.user) : QU,
            o = r && a === r.user && (s === r.element || (l(s) && l(r.element))) ? r : { user: a, element: s };
          o !== r &&
            ((this._cursorValue = o),
            this.setCursor(o.user && o.user !== QU ? o.user : null !== (n = o.element) && void 0 !== n ? n : o.user));
        });
    }
    initEvent() {
      const t = this.renderer.stage();
      t && t.on('*', this.delegateEvent);
    }
    addEventListener(t, e, i) {
      let n = e;
      return (
        (i && !1 === i.trap) || ((n = e), (n.raw = e)), i && i.target && (n.target = i.target), this.on(t, n), this
      );
    }
    removeEventListener(t, e) {
      return e ? this.off(t, e) : this.off(t), this;
    }
    setCursor(t) {
      if (this._options.domBridge && this._options.domBridge.setCursor)
        return void this._options.domBridge.setCursor(t);
      const e = this.globalCursor() ? !l(document) && document.body : this.container;
      return e ? (l(t) ? e.style.removeProperty('cursor') : (e.style.cursor = t)) : void 0;
    }
    globalCursor(t) {
      if (arguments.length) {
        if (this._globalCursor !== !!t) {
          const e = this.setCursor(null);
          (this._globalCursor = !!t), e && this.setCursor(e);
        }
        return this;
      }
      return this._globalCursor;
    }
    initializeRenderer() {
      const t = this._options.width,
        e = this._options.height;
      (this.renderer = new LK(this)),
        this.renderer.initialize(t, e, this._options, this._eventConfig).background(this._background);
    }
    initializeBuiltEvents() {
      this._options.cursor && this.cursor(), this._options.hover && this.hover(), this._bindResizeEvent();
    }
    initialize() {
      var t, e;
      (this.grammars = new Eq(
        t => t.id(),
        (t, e) => this.logger.warn(`Grammar id '${t}' has been occupied`, e)
      )),
        (this._cachedGrammars = new Pq(t => t.id())),
        this._options.logger && Ze.setInstance(this._options.logger),
        (this.logger = Ze.getInstance(null !== (t = this._options.logLevel) && void 0 !== t ? t : 0)),
        (this._dataflow = new IK()),
        (this.animate = new Rq(this)),
        (this._morph = new Cq()),
        (this._theme = zq.getDefaultTheme()),
        this._options.hooks &&
          (Object.keys(this._options.hooks).forEach(t => {
            this.on(t, this._options.hooks[t]);
          }),
          (this.hooks = this._options.hooks)),
        (this.container = null),
        (this.renderer = null),
        (this._globalCursor = !1),
        (this._eventListeners = []),
        (this._eventConfig = (function (t) {
          const e = Object.assign({ defaults: {} }, t),
            i = (t, e) => {
              e.forEach(e => {
                f(t[e]) && (t[e] = t[e].reduce((t, e) => ((t[e] = !0), t), {}));
              });
            };
          return i(e.defaults, ['prevent', 'allow']), i(e, [ZU, qU]), e;
        })(this._options.eventConfig)),
        this.globalCursor(this._eventConfig.globalCursor),
        (this._theme = zq.getDefaultTheme()),
        this.parseBuiltIn(),
        (e = this._options).mode && gN.setEnv(e.mode, e.modeParams || {}),
        this.initializeRenderer(),
        this._eventConfig.disable || this.initEvent(),
        this.initializeBuiltEvents(),
        (this._currentDataflow = null),
        (this._needBuildLayoutTree = !0),
        (this._layoutState = QW.before),
        this.theme(this._theme);
    }
    normalBrowserEnv() {
      return 'browser' === this._options.mode;
    }
    pauseProgressive() {
      return !1;
    }
    resumeProgressive() {
      return !1;
    }
    restartProgressive() {
      return !1;
    }
    findProgressiveMarks() {
      const t = [];
      return (
        this.traverseMarkTree(
          e => {
            t.push(e);
          },
          t => t.markType !== GW.group && t.isProgressive()
        ),
        t.length
          ? ((this._progressiveMarks = t), this.renderer && this.renderer.combineIncrementalLayers(), t)
          : ((this._progressiveMarks = null), null)
      );
    }
    doPreProgressive() {
      if (this._progressiveMarks && this._progressiveMarks.some(t => t.isDoingProgressive())) {
        const t = gN.getRequestAnimationFrame();
        this._progressiveRafId = t(this.handleProgressiveFrame);
      }
    }
    clearProgressive() {
      this._progressiveRafId && gN.getCancelAnimationFrame()(this._progressiveRafId),
        this._progressiveMarks &&
          this._progressiveMarks.length &&
          (this._progressiveMarks.forEach(t => {
            t.clearProgressive();
          }),
          (this._progressiveMarks = null));
    }
    release() {
      var t, e, i;
      this._unBindResizeEvent(),
        this.clearProgressive(),
        _W(),
        this.animate.stop(),
        this.grammars.release(),
        this._cachedGrammars.release(),
        (this._dataflow = null),
        null === (e = null === (t = this.renderer) || void 0 === t ? void 0 : t.release) || void 0 === e || e.call(t),
        (this.renderer = null),
        this.removeAllListeners(),
        null === (i = this._eventListeners) ||
          void 0 === i ||
          i.forEach(t => {
            t.source.removeEventListener(t.type, t.handler);
          }),
        (this._eventListeners = null);
    }
  }
  const Vq = function () {
    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
    e.forEach(t => {
      Object.keys(t).forEach(e => {
        yW(e, t[e], !0);
      });
    });
  };
  Vq(UG);
  const Wq = [
    'pointerdown',
    'pointerup',
    'pointerupoutside',
    'pointertap',
    'pointerover',
    'pointermove',
    'pointerenter',
    'pointerleave',
    'pointerout',
    'mousedown',
    'mouseup',
    'mouseupoutside',
    'rightdown',
    'rightup',
    'rightupoutside',
    'click',
    'dblclick',
    'mousemove',
    'mouseover',
    'mouseout',
    'mouseenter',
    'mouseleave',
    'wheel',
    'touchstart',
    'touchend',
    'touchendoutside',
    'touchmove',
    'touchcancel',
    'tap',
    'dragstart',
    'drag',
    'dragenter',
    'dragleave',
    'dragover',
    'dragend',
    'drop',
    'pan',
    'panstart',
    'panend',
    'press',
    'pressup',
    'pressend',
    'pinch',
    'pinchstart',
    'pinchend',
    'swipe'
  ];
  var Gq, Uq, Yq;
  !(function (t) {
    (t.initialized = 'initialized'),
      (t.rendered = 'rendered'),
      (t.renderFinished = 'renderFinished'),
      (t.animationFinished = 'animationFinished'),
      (t.regionSeriesDataFilterOver = 'regionSeriesDataFilterOver'),
      (t.afterInitData = 'afterInitData'),
      (t.afterInitEvent = 'afterInitEvent'),
      (t.afterInitMark = 'afterInitMark'),
      (t.rawDataUpdate = 'rawDataUpdate'),
      (t.rawDataStatisticsUpdate = 'rawDataStatisticsUpdate'),
      (t.viewDataFilterOver = 'viewDataFilterOver'),
      (t.viewDataUpdate = 'viewDataUpdate'),
      (t.viewDataStatisticsUpdate = 'viewDataStatisticsUpdate'),
      (t.markDeltaYUpdate = 'markDeltaYUpdate'),
      (t.viewDataLabelUpdate = 'viewDataLabelUpdate'),
      (t.scaleDomainUpdate = 'scaleDomainUpdate'),
      (t.scaleUpdate = 'scaleUpdate'),
      (t.dataZoomChange = 'dataZoomChange'),
      (t.drill = 'drill'),
      (t.layoutStart = 'layoutStart'),
      (t.layoutEnd = 'layoutEnd'),
      (t.layoutRectUpdate = 'layoutRectUpdate'),
      (t.playerPlay = 'playerPlay'),
      (t.playerPause = 'playerPause'),
      (t.playerEnd = 'playerEnd'),
      (t.playerChange = 'playerChange'),
      (t.playerForward = 'playerForward'),
      (t.playerBackward = 'playerBackward'),
      (t.scrollBarChange = 'scrollBarChange'),
      (t.brushStart = 'brushStart'),
      (t.brushChange = 'brushChange'),
      (t.brushEnd = 'brushEnd'),
      (t.legendSelectedDataChange = 'legendSelectedDataChange'),
      (t.legendFilter = 'legendFilter'),
      (t.legendItemClick = 'legendItemClick'),
      (t.legendItemHover = 'legendItemHover'),
      (t.legendItemUnHover = 'legendItemUnHover'),
      (t.tooltipShow = 'tooltipShow'),
      (t.tooltipHide = 'tooltipHide'),
      (t.tooltipRelease = 'tooltipRelease');
  })(Gq || (Gq = {})),
    (function (t) {
      (t.chart = 'chart'), (t.window = 'window'), (t.canvas = 'canvas');
    })(Uq || (Uq = {})),
    (function (t) {
      (t.vchart = 'vchart'), (t.chart = 'chart'), (t.model = 'model'), (t.mark = 'mark');
    })(Yq || (Yq = {}));
  const $q = `${UV}_waterfall_default_seriesField`,
    Xq = `${UV}_DEFAULT_DATA_INDEX`,
    Kq = `${UV}_DEFAULT_DATA_KEY`,
    qq = `${UV}_DEFAULT_DATA_SERIES_FIELD`,
    Zq = `${UV}_DEFAULT_SERIES_STYLE_NAME`;
  var Jq;
  !(function (t) {
    (t[(t.Default = 0)] = 'Default'),
      (t[(t.Theme = 1)] = 'Theme'),
      (t[(t.Chart = 2)] = 'Chart'),
      (t[(t.Base_Series = 3)] = 'Base_Series'),
      (t[(t.Series = 4)] = 'Series'),
      (t[(t.Mark = 5)] = 'Mark'),
      (t[(t.User_Chart = 6)] = 'User_Chart'),
      (t[(t.User_Series = 7)] = 'User_Series'),
      (t[(t.User_Mark = 8)] = 'User_Mark'),
      (t[(t.Built_In = 99)] = 'Built_In');
  })(Jq || (Jq = {}));
  const Qq = `${UV}_STACK_START`,
    tZ = `${UV}_STACK_END`,
    eZ = `${UV}_STACK_START_PERCENT`,
    iZ = `${UV}_STACK_END_PERCENT`,
    nZ = `${UV}_STACK_START_OffsetSilhouette`,
    sZ = `${UV}_STACK_END_OffsetSilhouette`,
    rZ = `${UV}_STACK_TOTAL`,
    aZ = `${UV}_STACK_TOTAL_PERCENT`,
    oZ = `${UV}_STACK_TOTAL_TOP`,
    lZ = `${UV}_SEGMENT_START`,
    hZ = `${UV}_SEGMENT_END`;
  var cZ, dZ;
  !(function (t) {
    (t[(t.Axis_Grid = 50)] = 'Axis_Grid'),
      (t[(t.CrossHair_Grid = 100)] = 'CrossHair_Grid'),
      (t[(t.Region = 450)] = 'Region'),
      (t[(t.Mark = 300)] = 'Mark'),
      (t[(t.Node = 400)] = 'Node'),
      (t[(t.Axis = 100)] = 'Axis'),
      (t[(t.MarkLine = 500)] = 'MarkLine'),
      (t[(t.MarkArea = 100)] = 'MarkArea'),
      (t[(t.MarkPoint = 500)] = 'MarkPoint'),
      (t[(t.DataZoom = 500)] = 'DataZoom'),
      (t[(t.ScrollBar = 500)] = 'ScrollBar'),
      (t[(t.Player = 500)] = 'Player'),
      (t[(t.Legend = 500)] = 'Legend'),
      (t[(t.CrossHair = 500)] = 'CrossHair'),
      (t[(t.Indicator = 500)] = 'Indicator'),
      (t[(t.Title = 500)] = 'Title'),
      (t[(t.Label = 500)] = 'Label'),
      (t[(t.Brush = 500)] = 'Brush'),
      (t[(t.CustomMark = 500)] = 'CustomMark');
  })(cZ || (cZ = {})),
    (function (t) {
      (t[(t.Indicator = 10)] = 'Indicator'),
        (t[(t.Region = 20)] = 'Region'),
        (t[(t.Axis = 30)] = 'Axis'),
        (t[(t.DataZoom = 40)] = 'DataZoom'),
        (t[(t.Player = 40)] = 'Player'),
        (t[(t.ScrollBar = 40)] = 'ScrollBar'),
        (t[(t.Legend = 50)] = 'Legend'),
        (t[(t.Title = 70)] = 'Title'),
        (t[(t.CustomMark = 70)] = 'CustomMark');
    })(dZ || (dZ = {}));
  const uZ = ['linear', 'radial', 'conical'],
    pZ = {
      linear: { x0: 0, y0: 0, x1: 1, y1: 1 },
      radial: { x0: 0, y0: 0, x1: 1, y1: 1, r0: 0, r1: 1 },
      conical: { x: 0.5, y: 0.5, startAngle: 0, endAngle: 2 * Math.PI }
    },
    gZ = {
      innerRadius: 0,
      outerRadius: 1,
      startAngle: pW,
      endAngle: gW,
      gap: 0,
      labelLayout: { align: 'center', offset: 0, rotate: 'radial' },
      sunburst: { style: { stroke: { type: 'palette', key: 'backgroundColor' }, fillOpacity: 1, cursor: 'pointer' } },
      label: {
        visible: !0,
        style: {
          cursor: 'pointer',
          fill: { type: 'palette', key: 'primaryFontColor' },
          fontSize: OV,
          lineHeight: BV,
          fontFamily: AV
        }
      }
    };
  var fZ, vZ;
  !(function (t) {
    (t.middle = 'middle'), (t.start = 'start'), (t.end = 'end'), (t.bothEnd = 'bothEnd');
  })(fZ || (fZ = {})),
    (function (t) {
      (t.middle = 'middle'), (t.start = 'start'), (t.end = 'end');
    })(vZ || (vZ = {}));
  const mZ = {
      scatter: {
        point: { style: { size: 8, symbolType: 'circle', lineWidth: 0, fillOpacity: 0.8 } },
        label: { visible: !1, offset: 5, position: 'top', style: { lineWidth: 2, stroke: 'white' } }
      },
      line: {
        label: { visible: !1, position: 'top', offset: 5, style: { lineWidth: 2, stroke: 'white' } },
        point: { style: { symbolType: 'circle' } }
      },
      area: {
        label: { visible: !1, offset: 5, position: 'top', style: { stroke: 'white', lineWidth: 2 } },
        point: { style: { symbolType: 'circle' } }
      },
      bar: { label: { visible: !1, position: 'outside', offset: 5, style: { lineWidth: 2, stroke: 'white' } } },
      bar3d: { bar3d: { style: { length: 3 } }, label: { visible: !1, style: { offset: 12, position: 'outside' } } },
      pie: {
        outerRadius: 0.6,
        pie: { style: { fillOpacity: 1 } },
        label: { visible: !1, position: 'outside', style: { fontWeight: 'normal', fillOpacity: 1 } }
      },
      pie3d: {
        outerRadius: 0.6,
        pie3d: { style: { height: 10, fillOpacity: 1 } },
        label: { visible: !1, position: 'outside' }
      },
      map: VV,
      radar: {
        label: { visible: !1, offset: 5, style: { lineWidth: 2, stroke: 'white' } },
        point: { style: { symbolType: 'circle' } }
      },
      dot: FV,
      link: { arrow: { style: { size: 10 } } },
      wordCloud: { word: { padding: 1, style: { textAlign: 'center', textBaseline: 'alphabetic' } } },
      wordCloud3d: { word: { padding: 1, style: { textAlign: 'center', textBaseline: 'alphabetic' } } },
      funnel: jV,
      funnel3d: zV,
      linearProgress: {
        bandWidth: 30,
        progress: { style: { fillOpacity: 1 } },
        track: { style: { fill: '#E7EBED', fillOpacity: 1 } }
      },
      circularProgress: {
        outerRadius: 0.8,
        innerRadius: 0.6,
        progress: { style: { fillOpacity: 1 } },
        track: { style: { fillOpacity: 0.2 } }
      },
      waterfall: WV,
      gauge: { outerRadius: 0.8, innerRadius: 0.6, padAngle: 0.02, segment: { style: { fillOpacity: 1 } } },
      gaugePointer: NV,
      treemap: GV,
      sunburst: gZ,
      rangeColumn: {
        label: {
          visible: !1,
          offset: 5,
          position: 'inside',
          style: { fill: { type: 'palette', key: 'labelReverseFontColor' } },
          minLabel: { position: vZ.end },
          maxLabel: { position: vZ.start }
        }
      },
      circlePacking: {
        layoutPadding: 5,
        circlePacking: {
          visible: !0,
          style: { cursor: 'pointer', stroke: { type: 'palette', key: 'backgroundColor' } }
        },
        label: {
          visible: !0,
          style: {
            cursor: 'pointer',
            fill: 'black',
            stroke: 'white',
            lineWidth: 2,
            fontSize: OV,
            lineHeight: BV,
            fontFamily: AV
          }
        }
      },
      heatmap: { cell: { style: { shape: 'square', fillOpacity: 1 } }, cellBackground: { visible: !1 } },
      sankey: { link: { style: { fillOpacity: 0.15, round: !0 } } },
      rose: { rose: { style: { fillOpacity: 1 } }, label: { style: { textAlign: 'center', textBaseline: 'middle' } } },
      boxPlot: { boxPlot: { style: { lineWidth: 1 } } }
    },
    yZ = { text: { style: { fontSize: PV, lineHeight: RV, fontFamily: AV, fontWeight: 'normal', fillOpacity: 1 } } },
    _Z = {
      label: { style: { fontSize: PV, fontFamily: AV, fontWeight: 'normal', fillOpacity: 1 } },
      area: { style: { fillOpacity: LV } },
      line: { style: { lineWidth: 2, lineCap: 'round', lineJoin: 'round' } },
      point: { style: { size: 8, stroke: { type: 'palette', key: 'backgroundColor' }, lineWidth: 1, fillOpacity: 1 } },
      word: { style: { fontSize: null } },
      fillingWord: { style: { fontSize: null } },
      sunburst: { style: { lineWidth: 1, stroke: { type: 'palette', key: 'backgroundColor' } } },
      circlePacking: { style: { lineWidth: 1, stroke: { type: 'palette', key: 'backgroundColor' } } },
      funnel3d: { style: { stroke: !1 } }
    },
    bZ = {
      domainLine: {
        visible: !0,
        style: { lineWidth: 1, stroke: { type: 'palette', key: 'axisDomainColor' }, strokeOpacity: 1 }
      },
      grid: {
        visible: !0,
        style: { lineWidth: 1, stroke: { type: 'palette', key: 'axisGridColor' }, strokeOpacity: 1, lineDash: [] }
      },
      subGrid: {
        visible: !1,
        style: { lineWidth: 1, stroke: { type: 'palette', key: 'axisGridColor' }, strokeOpacity: 1, lineDash: [4, 4] }
      },
      tick: {
        visible: !0,
        tickSize: DV,
        style: { lineWidth: 1, stroke: { type: 'palette', key: 'axisDomainColor' }, strokeOpacity: 1 }
      },
      subTick: {
        visible: !1,
        tickSize: DV / 2,
        style: { lineWidth: 1, stroke: { type: 'palette', key: 'axisDomainColor' }, strokeOpacity: 1 }
      },
      label: {
        visible: !0,
        space: 10,
        style: {
          fontSize: OV,
          fontFamily: AV,
          fill: { type: 'palette', key: 'axisFontColor' },
          fontWeight: 'normal',
          fillOpacity: 1
        }
      },
      title: {
        space: 10,
        style: {
          fontSize: OV,
          lineHeight: BV,
          fontFamily: AV,
          fill: { type: 'palette', key: 'secondaryFontColor' },
          fontWeight: 'normal',
          fillOpacity: 1
        }
      }
    },
    xZ = () => ({
      visible: !1,
      style: {
        fontWeight: 'normal',
        fill: { type: 'palette', key: 'labelReverseFontColor' },
        fontSize: OV,
        fontFamily: AV
      },
      labelBackground: {
        padding: { bottom: 0, top: 0, left: 2, right: 2 },
        style: {
          fill: { type: 'palette', key: 'primaryFontColor' },
          outerBorder: { stroke: { type: 'palette', key: 'primaryFontColor' }, distance: 0, lineWidth: 3 },
          cornerRadius: 1
        }
      }
    }),
    SZ = {
      trigger: 'hover',
      bandField: {
        visible: !1,
        line: {
          type: 'rect',
          visible: !0,
          style: { fill: { type: 'palette', key: 'axisGridColor' }, opacity: 0.7, lineDash: [] }
        },
        label: xZ()
      },
      linearField: {
        visible: !1,
        line: {
          type: 'line',
          visible: !0,
          style: { stroke: { type: 'palette', key: 'secondaryFontColor' }, opacity: 0.7, lineDash: [2, 3] }
        },
        label: xZ()
      }
    },
    wZ = {
      padding: [12, 0],
      showDetail: 'auto',
      brushSelect: !1,
      middleHandler: {
        visible: !1,
        background: {
          size: 6,
          style: { stroke: { type: 'palette', key: 'dataZoomHandlerStrokeColor' }, cornerRadius: 2 }
        },
        icon: {
          style: {
            size: 4,
            fill: { type: 'palette', key: 'dataZoomHandlerFillColor' },
            stroke: { type: 'palette', key: 'dataZoomHandlerStrokeColor' },
            symbolType:
              'M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z',
            lineWidth: 0.5
          }
        }
      },
      background: { size: 20, style: { fill: { type: 'palette', key: 'dataZoomBackgroundColor' }, lineWidth: 0 } },
      selectedBackground: {
        style: {
          fill: { type: 'palette', key: 'dataZoomSelectedColor' },
          fillOpacity: 0.1,
          outerBorder: {
            stroke: { type: 'palette', key: 'dataZoomSelectedColor' },
            strokeOpacity: 0.2,
            distance: -0.5,
            lineWidth: 1
          }
        }
      },
      selectedBackgroundChart: {
        area: { style: { visible: !1, stroke: !1, fill: { type: 'palette', key: 'dataZoomChartColor' } } },
        line: { style: { visible: !1, stroke: { type: 'palette', key: 'dataZoomChartColor' }, lineWidth: 1 } }
      },
      startHandler: {
        style: {
          symbolType:
            'M-0.5-2.4h0.9c0.4,0,0.7,0.3,0.7,0.7v3.3c0,0.4-0.3,0.7-0.7,0.7h-0.9c-0.4,0-0.7-0.3-0.7-0.7v-3.3\n      C-1.2-2-0.9-2.4-0.5-2.4z M-0.4-1.4L-0.4-1.4c0,0,0,0.1,0,0.1v2.6c0,0.1,0,0.1,0,0.1l0,0c0,0,0-0.1,0-0.1v-2.6\n      C-0.4-1.4-0.4-1.4-0.4-1.4z M0.3-1.4L0.3-1.4c0,0,0,0.1,0,0.1v2.6c0,0.1,0,0.1,0,0.1l0,0c0,0,0-0.1,0-0.1v-2.6\n      C0.3-1.4,0.3-1.4,0.3-1.4z',
          fill: { type: 'palette', key: 'dataZoomHandlerFillColor' },
          scaleX: 1.2,
          scaleY: 1.2,
          stroke: { type: 'palette', key: 'dataZoomHandlerStrokeColor' },
          lineWidth: 1,
          zIndex: 100
        }
      },
      endHandler: {
        style: {
          symbolType:
            'M-0.5-2.4h0.9c0.4,0,0.7,0.3,0.7,0.7v3.3c0,0.4-0.3,0.7-0.7,0.7h-0.9c-0.4,0-0.7-0.3-0.7-0.7v-3.3\n      C-1.2-2-0.9-2.4-0.5-2.4z M-0.4-1.4L-0.4-1.4c0,0,0,0.1,0,0.1v2.6c0,0.1,0,0.1,0,0.1l0,0c0,0,0-0.1,0-0.1v-2.6\n      C-0.4-1.4-0.4-1.4-0.4-1.4z M0.3-1.4L0.3-1.4c0,0,0,0.1,0,0.1v2.6c0,0.1,0,0.1,0,0.1l0,0c0,0,0-0.1,0-0.1v-2.6\n      C0.3-1.4,0.3-1.4,0.3-1.4z',
          fill: { type: 'palette', key: 'dataZoomHandlerFillColor' },
          scaleX: 1.2,
          scaleY: 1.2,
          stroke: { type: 'palette', key: 'dataZoomHandlerStrokeColor' },
          lineWidth: 1,
          zIndex: 100
        }
      },
      startText: {
        padding: 8,
        style: {
          fontSize: OV,
          lineHeight: BV,
          fontFamily: AV,
          fill: { type: 'palette', key: 'secondaryFontColor', default: '#89909d' }
        }
      },
      endText: {
        padding: 8,
        style: {
          fontSize: OV,
          lineHeight: BV,
          fontFamily: AV,
          fill: { type: 'palette', key: 'secondaryFontColor', default: '#89909d' }
        }
      },
      backgroundChart: {
        area: { style: { stroke: !1, fill: { type: 'palette', key: 'dataZoomChartColor' } } },
        line: { style: { stroke: { type: 'palette', key: 'dataZoomChartColor' }, lineWidth: 1 } }
      }
    },
    AZ = {
      title: {
        visible: !0,
        autoLimit: !1,
        autoFit: !1,
        style: {
          fontSize: MV,
          fontFamily: AV,
          fill: { type: 'palette', key: ['titleFontColor', 'primaryFontColor'] },
          fontWeight: 'normal',
          fillOpacity: 1,
          textBaseline: 'top',
          textAlign: 'center'
        }
      },
      content: {
        visible: !0,
        style: {
          fontSize: TV,
          fontFamily: AV,
          fill: { type: 'palette', key: 'secondaryFontColor' },
          fontWeight: 'normal',
          fillOpacity: 1,
          textBaseline: 'top',
          textAlign: 'center'
        }
      }
    },
    kZ = {
      orient: 'right',
      position: 'middle',
      padding: [16, 24],
      title: {
        visible: !1,
        padding: 0,
        textStyle: {
          fontSize: OV,
          lineHeight: BV,
          fontFamily: AV,
          fontWeight: 'normal',
          fill: { type: 'palette', key: ['titleFontColor', 'primaryFontColor'] }
        },
        space: 12
      },
      handler: { visible: !0 },
      startText: {
        style: {
          fontSize: OV,
          lineHeight: BV,
          fontFamily: AV,
          fontWeight: 'normal',
          fill: { type: 'palette', key: 'secondaryFontColor', default: '#89909d' }
        },
        space: 6
      },
      endText: {
        style: {
          fontSize: OV,
          lineHeight: BV,
          fontFamily: AV,
          fontWeight: 'normal',
          fill: { type: 'palette', key: 'secondaryFontColor', default: '#89909d' }
        },
        space: 6
      },
      handlerText: {
        style: {
          fontSize: OV,
          lineHeight: BV,
          fontFamily: AV,
          fontWeight: 'normal',
          fill: { type: 'palette', key: 'secondaryFontColor', default: '#89909d' }
        },
        space: 6
      }
    },
    MZ = {
      style: {
        symbolType: 'circle',
        lineWidth: 0,
        outerBorder: { lineWidth: 2, distance: 0.8, stroke: '#ffffff' },
        shadowBlur: 12,
        shadowOffsetX: 0,
        shadowOffsetY: 4,
        shadowColor: { type: 'palette', key: 'shadowColor', a: 0.3 }
      }
    },
    TZ = {
      horizontal: Object.assign(Object.assign({}, kZ), {
        rail: { width: 200, height: 8, style: { fill: { type: 'palette', key: 'dataZoomBackgroundColor' } } },
        handler: MZ
      }),
      vertical: Object.assign(Object.assign({}, kZ), {
        rail: { width: 8, height: 200, style: { fill: { type: 'palette', key: 'dataZoomBackgroundColor' } } },
        handler: MZ
      })
    },
    CZ = {
      orient: 'bottom',
      position: 'middle',
      padding: [16, 24],
      title: {
        visible: !1,
        padding: 0,
        textStyle: {
          fontSize: OV,
          lineHeight: BV,
          fontFamily: AV,
          fill: { type: 'palette', key: ['titleFontColor', 'primaryFontColor'] },
          fontWeight: 'normal'
        },
        space: 12
      },
      item: {
        visible: !0,
        spaceCol: 10,
        spaceRow: 6,
        padding: 2,
        background: {
          state: {
            selectedHover: { fill: { type: 'palette', key: 'axisGridColor' } },
            unSelectedHover: { fill: { type: 'palette', key: 'axisGridColor' } }
          }
        },
        shape: { space: 6, style: { lineWidth: 0, fillOpacity: 1 }, state: { unSelected: { fillOpacity: 0.5 } } },
        label: {
          space: 6,
          style: {
            fill: { type: 'palette', key: 'secondaryFontColor', default: '#89909d' },
            fontSize: OV,
            lineHeight: BV,
            fontFamily: AV
          },
          state: { unSelected: { fill: { type: 'palette', key: 'disableFontColor' } } }
        }
      },
      allowAllCanceled: !1
    },
    EZ = {
      style: {
        symbolType: 'circle',
        lineWidth: 0,
        outerBorder: { lineWidth: 2, distance: 0.8, stroke: { type: 'palette', key: 'dataZoomSelectedColor' } },
        fill: { type: 'palette', key: 'dataZoomHandlerFillColor' }
      }
    },
    PZ = {
      horizontal: Object.assign(Object.assign({}, kZ), {
        sizeBackground: { fill: { type: 'palette', key: 'dataZoomChartColor' } },
        track: { style: { fill: { type: 'palette', key: 'dataZoomSelectedColor', a: 0.8 } } },
        rail: { width: 200, height: 4, style: { fill: { type: 'palette', key: 'dataZoomBackgroundColor' } } },
        handler: EZ
      }),
      vertical: Object.assign(Object.assign({}, kZ), {
        sizeBackground: { fill: { type: 'palette', key: 'dataZoomChartColor' } },
        track: { style: { fill: { type: 'palette', key: 'dataZoomSelectedColor', a: 0.8 } } },
        rail: { width: 4, height: 200, style: { fill: { type: 'palette', key: 'dataZoomBackgroundColor' } } },
        handler: EZ
      })
    },
    RZ = {
      name: 'light',
      background: { type: 'palette', key: 'backgroundColor' },
      padding: 20,
      fontFamily: AV,
      colorScheme: wV,
      mark: yZ,
      markByName: _Z,
      series: mZ,
      component: {
        discreteLegend: CZ,
        colorLegend: TZ,
        sizeLegend: PZ,
        axis: bZ,
        axisBand: {
          domainLine: { visible: !0 },
          grid: { visible: !1 },
          subGrid: { visible: !1 },
          tick: { visible: !0 },
          subTick: { visible: !1 }
        },
        axisLinear: {
          domainLine: { visible: !1 },
          grid: { visible: !0 },
          subGrid: { visible: !1 },
          tick: { visible: !1 },
          subTick: { visible: !1 }
        },
        axisX: { label: { space: 8 }, title: { space: 8 }, maxHeight: '30%' },
        axisY: { label: { space: 12, autoLimit: !0 }, title: { space: 12, autoRotate: !0 }, maxWidth: '30%' },
        axisAngle: { grid: { visible: !0, style: { lineDash: [6, 6] } }, label: { space: 8 } },
        axisRadius: { grid: { smooth: !0, visible: !0 }, subGrid: { smooth: !0, visible: !1 } },
        markLine: {
          line: { style: { lineDash: [3, 3], stroke: 'rgba(46, 47, 50)' } },
          startSymbol: {
            visible: !1,
            symbolType: 'triangle',
            style: { stroke: null, lineWidth: 0, fill: 'rgba(46, 47, 50)', size: 10 }
          },
          endSymbol: {
            visible: !0,
            symbolType: 'triangle',
            style: { stroke: null, lineWidth: 0, fill: 'rgba(46, 47, 50)', size: 10 }
          },
          label: {
            refY: 5,
            style: {
              fontSize: PV,
              fontFamily: AV,
              fontWeight: 'normal',
              fontStyle: 'normal',
              fill: { type: 'palette', key: 'labelReverseFontColor' },
              stroke: { type: 'palette', key: 'labelReverseFontColor' },
              lineWidth: 0
            },
            labelBackground: {
              padding: { top: 2, bottom: 2, right: 4, left: 4 },
              style: { cornerRadius: 0, fill: 'rgb(48, 115, 242)' }
            }
          }
        },
        markArea: {
          area: { style: { fill: 'rgba(46, 47, 50, 0.1)' } },
          label: {
            style: {
              fontSize: PV,
              fontFamily: AV,
              fontWeight: 'normal',
              fontStyle: 'normal',
              fill: { type: 'palette', key: 'labelReverseFontColor' },
              stroke: { type: 'palette', key: 'labelReverseFontColor' },
              lineWidth: 0
            },
            labelBackground: {
              padding: { top: 2, bottom: 2, right: 4, left: 4 },
              style: { cornerRadius: 0, fill: '#F68484' }
            }
          }
        },
        markPoint: {
          itemLine: {
            decorativeLine: { visible: !1 },
            startSymbol: { size: 5, visible: !0, style: { fill: '#eee' } },
            line: { style: { stroke: '#eee' } }
          },
          itemContent: { offsetY: -50 }
        },
        tooltip: {
          offset: { x: 10, y: 10 },
          panel: {
            padding: { top: 10, left: 10, right: 10, bottom: 10 },
            backgroundColor: { type: 'palette', key: 'tooltipBackgroundColor' },
            border: { color: { type: 'palette', key: 'tooltipBackgroundColor' }, width: 0, radius: 3 },
            shadow: { x: 0, y: 4, blur: 12, spread: 0, color: { type: 'palette', key: 'shadowColor', a: 0.1 } }
          },
          spaceRow: 6,
          titleLabel: {
            fontSize: PV,
            lineHeight: RV,
            fontFamily: AV,
            fontColor: { type: 'palette', key: ['titleFontColor', 'primaryFontColor'] },
            fontWeight: 'bold',
            textAlign: 'left',
            textBaseline: 'middle',
            spacing: 0
          },
          shape: { size: 8, spacing: 6 },
          keyLabel: {
            fontSize: PV,
            lineHeight: RV,
            fontFamily: AV,
            fontColor: { type: 'palette', key: 'secondaryFontColor' },
            textAlign: 'left',
            textBaseline: 'middle',
            spacing: 26
          },
          valueLabel: {
            fontSize: PV,
            lineHeight: RV,
            fontFamily: AV,
            fontColor: { type: 'palette', key: ['titleFontColor', 'primaryFontColor'] },
            textBaseline: 'middle',
            spacing: 0
          }
        },
        dataZoom: wZ,
        crosshair: SZ,
        player: {
          visible: !0,
          position: 'start',
          padding: { top: 20, bottom: 20 },
          slider: {
            space: 10,
            trackStyle: { fill: { type: 'palette', key: 'dataZoomSelectedColor' }, fillOpacity: 0.8 },
            railStyle: { fill: { type: 'palette', key: 'dataZoomBackgroundColor' } },
            handlerStyle: {
              size: 15,
              stroke: { type: 'palette', key: 'backgroundColor' },
              lineWidth: 2,
              fill: { type: 'palette', key: 'dataZoomSelectedColor' }
            }
          },
          controller: {
            start: {
              order: 0,
              space: 0,
              style: { size: 25, fill: { type: 'palette', key: 'dataZoomSelectedColor' }, fillOpacity: 0.8 }
            },
            pause: {
              order: 0,
              space: 0,
              style: { size: 25, fill: { type: 'palette', key: 'dataZoomSelectedColor' }, fillOpacity: 0.8 }
            },
            backward: {
              order: 0,
              space: 10,
              position: 'start',
              style: { size: 12, fill: { type: 'palette', key: 'dataZoomSelectedColor' }, fillOpacity: 0.8 }
            },
            forward: {
              order: 0,
              space: 10,
              position: 'end',
              style: { size: 12, fill: { type: 'palette', key: 'dataZoomSelectedColor' }, fillOpacity: 0.8 }
            }
          }
        },
        brush: {
          style: { fill: '#B0C8F9', fillOpacity: 0.2, stroke: '#B0C8F9', lineWidth: 2 },
          brushMode: 'single',
          brushType: 'rect',
          brushMoved: !0,
          removeOnClick: !0,
          delayType: 'throttle',
          delayTime: 0
        },
        indicator: AZ,
        title: {
          padding: { top: 4, bottom: 20 },
          textStyle: {
            fontSize: CV,
            lineHeight: EV,
            fontFamily: AV,
            fill: { type: 'palette', key: ['titleFontColor', 'primaryFontColor'] }
          },
          subtextStyle: {
            fontSize: PV,
            lineHeight: RV,
            fontFamily: AV,
            fill: { type: 'palette', key: 'secondaryFontColor' }
          }
        },
        mapLabel: {
          visible: !0,
          offset: 12,
          position: 'top',
          space: 10,
          nameLabel: {
            visible: !0,
            style: { textBaseline: 'middle', textAlign: 'left', fill: 'black', fontSize: IV, fontFamily: AV }
          },
          valueLabel: {
            visible: !0,
            style: { textBaseline: 'middle', textAlign: 'left', fill: 'black', fontSize: IV, fontFamily: AV }
          },
          background: {
            visible: !0,
            padding: { top: 4, bottom: 4, left: 6, right: 6 },
            style: { cornerRadius: 2, lineWidth: 1, fill: 'white', stroke: 'grey' }
          },
          leader: { visible: !1, style: { lineWidth: 1, stroke: 'red' } }
        },
        poptip: {
          visible: !0,
          position: 'auto',
          padding: 8,
          titleStyle: {
            fontSize: OV,
            fontFamily: AV,
            fontWeight: 'bold',
            fill: { type: 'palette', key: ['titleFontColor', 'primaryFontColor'] }
          },
          contentStyle: { fontSize: OV, fontFamily: AV, fill: { type: 'palette', key: 'secondaryFontColor' } },
          panel: {
            visible: !0,
            fill: { type: 'palette', key: 'tooltipBackgroundColor' },
            cornerRadius: 3,
            lineWidth: 0,
            shadowBlur: 12,
            shadowOffsetX: 0,
            shadowOffsetY: 4,
            shadowColor: { type: 'palette', key: 'shadowColor', a: 0.1 },
            size: 0,
            space: 12
          }
        },
        totalLabel: {
          visible: !1,
          offset: 5,
          overlap: { clampForce: !0, strategy: [] },
          smartInvert: !1,
          animation: !1,
          style: {
            fontSize: PV,
            fontFamily: AV,
            fill: { type: 'palette', key: ['titleFontColor', 'primaryFontColor'] }
          }
        },
        scrollBar: { slider: { style: { fill: { type: 'palette', key: 'scrollBarSliderColor' }, fillOpacity: 0.5 } } }
      },
      animationThreshold: 2e3
    },
    OZ = {
      orient: 'right',
      position: 'middle',
      padding: 30,
      title: {
        visible: !1,
        padding: 0,
        textStyle: { fontSize: kV, fontWeight: 'normal', fill: { type: 'palette', key: 'titleFontColor' } },
        space: 12
      },
      handler: { visible: !0 },
      startText: { style: { fontSize: kV, fontWeight: 'normal', fill: { type: 'palette', key: 'labelFontColor' } } },
      endText: { style: { fontSize: kV, fontWeight: 'normal', fill: { type: 'palette', key: 'labelFontColor' } } },
      handlerText: { style: { fontSize: kV, fontWeight: 'normal', fill: { type: 'palette', key: 'labelFontColor' } } }
    },
    BZ = {
      style: {
        symbolType: 'circle',
        lineWidth: 4,
        outerBorder: { distance: 2, lineWidth: 1, stroke: '#ccc' },
        size: 10,
        stroke: '#fff'
      }
    };
  Object.assign(Object.assign({}, OZ), {
    rail: { width: 200, height: 8, style: { fill: 'rgba(0,0,0,0.04)' } },
    handler: BZ
  }),
    Object.assign(Object.assign({}, OZ), {
      rail: { width: 8, height: 200, style: { fill: 'rgba(0,0,0,0.04)' } },
      handler: BZ
    });
  const IZ = t => ({
    style: { symbolType: BX(t), fill: '#fff', lineWidth: 1, size: 10, stroke: '#ccc', outerBorder: !1 }
  });
  var DZ, LZ;
  Object.assign(Object.assign({}, OZ), {
    sizeBackground: { fill: '#cdcdcd' },
    track: { style: { fill: 'rgba(20,20,20,0.1)' } },
    rail: { width: 200, height: 4, style: { fill: 'rgba(0,0,0,0.04)' } },
    handler: IZ('top')
  }),
    Object.assign(Object.assign({}, OZ), {
      sizeBackground: { fill: '#cdcdcd' },
      track: { style: { fill: 'rgba(20,20,20,0.1)' } },
      rail: { width: 4, height: 200, style: { fill: 'rgba(0,0,0,0.04)' } },
      handler: IZ('right')
    }),
    (function (t) {
      (t.area = 'area'),
        (t.line = 'line'),
        (t.bar = 'bar'),
        (t.bar3d = 'bar3d'),
        (t.rangeColumn = 'rangeColumn'),
        (t.rangeColumn3d = 'rangeColumn3d'),
        (t.rangeArea = 'rangeArea'),
        (t.dot = 'dot'),
        (t.geo = 'geo'),
        (t.link = 'link'),
        (t.map = 'map'),
        (t.pie = 'pie'),
        (t.pie3d = 'pie3d'),
        (t.radar = 'radar'),
        (t.rose = 'rose'),
        (t.scatter = 'scatter'),
        (t.circularProgress = 'circularProgress'),
        (t.wordCloud = 'wordCloud'),
        (t.wordCloud3d = 'wordCloud3d'),
        (t.funnel = 'funnel'),
        (t.funnel3d = 'funnel3d'),
        (t.linearProgress = 'linearProgress'),
        (t.boxPlot = 'boxPlot'),
        (t.sankey = 'sankey'),
        (t.gaugePointer = 'gaugePointer'),
        (t.gauge = 'gauge'),
        (t.treemap = 'treemap'),
        (t.sunburst = 'sunburst'),
        (t.circlePacking = 'circlePacking'),
        (t.waterfall = 'waterfall'),
        (t.heatmap = 'heatmap');
    })(DZ || (DZ = {})),
    (function (t) {
      (t.label = 'label'),
        (t.point = 'point'),
        (t.line = 'line'),
        (t.area = 'area'),
        (t.bar = 'bar'),
        (t.bar3d = 'bar3d'),
        (t.boxPlot = 'boxPlot'),
        (t.outlier = 'outlier'),
        (t.circlePacking = 'circlePacking'),
        (t.group = 'group'),
        (t.gridBackground = 'gridBackground'),
        (t.grid = 'grid'),
        (t.dot = 'dot'),
        (t.title = 'title'),
        (t.subTitle = 'subTitle'),
        (t.symbol = 'symbol'),
        (t.funnel = 'funnel'),
        (t.funnel3d = 'funnel3d'),
        (t.transform = 'transform'),
        (t.transform3d = 'transform3d'),
        (t.transformLabel = 'transformLabel'),
        (t.outerLabel = 'outerLabel'),
        (t.outerLabelLine = 'outerLabelLine'),
        (t.pin = 'pin'),
        (t.pinBackground = 'pinBackground'),
        (t.pointer = 'pointer'),
        (t.segment = 'segment'),
        (t.track = 'track'),
        (t.cell = 'cell'),
        (t.cellBackground = 'cellBackground'),
        (t.link = 'link'),
        (t.arrow = 'arrow'),
        (t.pie = 'pie'),
        (t.pie3d = 'pie3d'),
        (t.labelLine = 'labelLine'),
        (t.progress = 'progress'),
        (t.minLabel = 'minLabel'),
        (t.maxLabel = 'maxLabel'),
        (t.rose = 'rose'),
        (t.node = 'node'),
        (t.sunburst = 'sunburst'),
        (t.nonLeaf = 'nonLeaf'),
        (t.leaf = 'leaf'),
        (t.nonLeafLabel = 'nonLeafLabel'),
        (t.leaderLine = 'leaderLine'),
        (t.stackLabel = 'stackLabel'),
        (t.word = 'word'),
        (t.fillingWord = 'fillingWord');
    })(LZ || (LZ = {}));
  const FZ = new Set(Object.values(LZ));
  var jZ;
  !(function (t) {
    (t.group = 'group'),
      (t.symbol = 'symbol'),
      (t.rule = 'rule'),
      (t.line = 'line'),
      (t.text = 'text'),
      (t.rect = 'rect'),
      (t.rect3d = 'rect3d'),
      (t.image = 'image'),
      (t.path = 'path'),
      (t.area = 'area'),
      (t.arc = 'arc'),
      (t.arc3d = 'arc3d'),
      (t.polygon = 'polygon'),
      (t.pyramid3d = 'pyramid3d'),
      (t.boxPlot = 'boxPlot'),
      (t.linkPath = 'linkPath'),
      (t.progressArc = 'progressArc'),
      (t.cell = 'cell'),
      (t.component = 'component'),
      (t.label = 'label');
  })(jZ || (jZ = {}));
  const zZ = { [LZ.label]: { name: LZ.label, type: jZ.text } },
    HZ = Object.assign(Object.assign({}, zZ), { [LZ.bar]: { name: LZ.bar, type: jZ.rect } }),
    NZ = Object.assign(Object.assign({}, zZ), { [LZ.bar3d]: { name: LZ.bar3d, type: jZ.rect3d } }),
    VZ = { [LZ.point]: { name: LZ.point, type: jZ.symbol }, [LZ.line]: { name: LZ.line, type: jZ.line } },
    WZ = Object.assign(Object.assign({}, zZ), VZ),
    GZ = Object.assign(Object.assign({}, zZ), { [LZ.point]: { name: LZ.point, type: jZ.symbol } }),
    UZ = Object.assign(Object.assign(Object.assign({}, zZ), VZ), { [LZ.area]: { name: LZ.area, type: jZ.area } }),
    YZ = Object.assign(Object.assign(Object.assign({}, zZ), VZ), { [LZ.area]: { name: LZ.area, type: jZ.area } }),
    $Z = Object.assign(Object.assign({}, zZ), {
      [LZ.pie]: { name: LZ.pie, type: jZ.arc },
      [LZ.labelLine]: { name: LZ.labelLine, type: jZ.path }
    }),
    XZ = Object.assign(Object.assign({}, zZ), {
      [LZ.pie3d]: { name: LZ.pie3d, type: jZ.arc3d },
      [LZ.labelLine]: { name: LZ.labelLine, type: jZ.path }
    }),
    KZ = Object.assign(Object.assign({}, zZ), { [LZ.rose]: { name: LZ.rose, type: jZ.arc } }),
    qZ = Object.assign(Object.assign({}, zZ), { [LZ.area]: { name: LZ.area, type: jZ.path } }),
    ZZ = Object.assign(Object.assign({}, zZ), {
      [LZ.track]: { name: LZ.track, type: jZ.progressArc },
      [LZ.progress]: { name: LZ.progress, type: jZ.progressArc }
    }),
    JZ = Object.assign(Object.assign({}, zZ), {
      [LZ.group]: { name: LZ.group, type: jZ.group },
      [LZ.link]: { name: LZ.link, type: jZ.rule },
      [LZ.arrow]: { name: LZ.arrow, type: jZ.symbol }
    }),
    QZ = Object.assign(Object.assign({}, zZ), {
      [LZ.group]: { name: LZ.group, type: jZ.group },
      [LZ.grid]: { name: LZ.grid, type: jZ.rule },
      [LZ.gridBackground]: { name: LZ.gridBackground, type: jZ.rect },
      [LZ.dot]: { name: LZ.dot, type: jZ.symbol },
      [LZ.title]: { name: LZ.title, type: jZ.text },
      [LZ.subTitle]: { name: LZ.subTitle, type: jZ.text },
      [LZ.symbol]: { name: LZ.symbol, type: jZ.symbol }
    }),
    tJ = Object.assign(Object.assign({}, zZ), {
      [LZ.word]: { name: LZ.word, type: jZ.text },
      [LZ.fillingWord]: { name: LZ.fillingWord, type: jZ.text }
    }),
    eJ = Object.assign(Object.assign({}, zZ), {
      [LZ.funnel]: { name: LZ.funnel, type: jZ.polygon },
      [LZ.transform]: { name: LZ.transform, type: jZ.polygon },
      [LZ.transformLabel]: { name: LZ.transformLabel, type: jZ.text },
      [LZ.outerLabel]: { name: LZ.outerLabel, type: jZ.text },
      [LZ.outerLabelLine]: { name: LZ.outerLabelLine, type: jZ.rule }
    }),
    iJ = Object.assign(Object.assign({}, zZ), {
      [LZ.funnel3d]: { name: LZ.funnel3d, type: jZ.pyramid3d },
      [LZ.transform3d]: { name: LZ.transform3d, type: jZ.pyramid3d },
      [LZ.transformLabel]: { name: LZ.transformLabel, type: jZ.text },
      [LZ.outerLabel]: { name: LZ.outerLabel, type: jZ.text },
      [LZ.outerLabelLine]: { name: LZ.outerLabelLine, type: jZ.rule }
    }),
    nJ = Object.assign(Object.assign({}, zZ), {
      [LZ.track]: { name: LZ.track, type: jZ.rect },
      [LZ.progress]: { name: LZ.progress, type: jZ.rect },
      [LZ.group]: { name: LZ.group, type: jZ.group }
    }),
    sJ = Object.assign(Object.assign({}, HZ), {
      [LZ.leaderLine]: { name: LZ.leaderLine, type: jZ.rule },
      [LZ.stackLabel]: { name: LZ.stackLabel, type: jZ.text }
    }),
    rJ = Object.assign(Object.assign({}, zZ), {
      [LZ.boxPlot]: { name: LZ.boxPlot, type: jZ.boxPlot },
      [LZ.outlier]: { name: LZ.outlier, type: jZ.symbol }
    }),
    aJ = Object.assign(Object.assign({}, zZ), {
      [LZ.nonLeaf]: { name: LZ.nonLeaf, type: jZ.rect },
      [LZ.leaf]: { name: LZ.leaf, type: jZ.rect },
      [LZ.nonLeafLabel]: { name: LZ.nonLeafLabel, type: jZ.text }
    }),
    oJ = Object.assign(Object.assign({}, zZ), {
      [LZ.node]: { name: LZ.node, type: jZ.rect },
      [LZ.link]: { name: LZ.link, type: jZ.linkPath }
    }),
    lJ = Object.assign(Object.assign({}, zZ), {
      [LZ.segment]: { name: LZ.segment, type: jZ.progressArc },
      [LZ.track]: { name: LZ.track, type: jZ.progressArc }
    }),
    hJ = Object.assign(Object.assign({}, zZ), {
      [LZ.pin]: { name: LZ.pin, type: jZ.path },
      [LZ.pinBackground]: { name: LZ.pinBackground, type: jZ.path },
      [LZ.pointer]: { name: LZ.pointer, type: [jZ.path, jZ.rect] }
    }),
    cJ = Object.assign(Object.assign({}, zZ), { [LZ.sunburst]: { name: LZ.sunburst, type: jZ.arc } }),
    dJ = Object.assign(Object.assign({}, HZ), {
      [LZ.minLabel]: { name: LZ.minLabel, type: jZ.text },
      [LZ.maxLabel]: { name: LZ.maxLabel, type: jZ.text }
    }),
    uJ = Object.assign(Object.assign({}, NZ), {
      [LZ.minLabel]: { name: LZ.minLabel, type: jZ.text },
      [LZ.maxLabel]: { name: LZ.maxLabel, type: jZ.text }
    }),
    pJ = Object.assign(Object.assign({}, zZ), { [LZ.circlePacking]: { name: LZ.circlePacking, type: jZ.arc } }),
    gJ = Object.assign(Object.assign({}, zZ), {
      [LZ.cell]: { name: LZ.cell, type: jZ.cell },
      [LZ.cellBackground]: { name: LZ.cellBackground, type: jZ.cell }
    }),
    fJ = {
      [DZ.bar]: HZ,
      [DZ.bar3d]: NZ,
      [DZ.line]: WZ,
      [DZ.scatter]: GZ,
      [DZ.area]: UZ,
      [DZ.radar]: YZ,
      [DZ.pie]: $Z,
      [DZ.pie3d]: XZ,
      [DZ.rose]: KZ,
      [DZ.map]: qZ,
      [DZ.circularProgress]: ZZ,
      [DZ.link]: JZ,
      [DZ.dot]: QZ,
      [DZ.wordCloud]: tJ,
      [DZ.wordCloud3d]: tJ,
      [DZ.funnel]: eJ,
      [DZ.funnel3d]: iJ,
      [DZ.linearProgress]: nJ,
      [DZ.waterfall]: sJ,
      [DZ.boxPlot]: rJ,
      [DZ.treemap]: aJ,
      [DZ.sankey]: oJ,
      [DZ.gauge]: lJ,
      [DZ.gaugePointer]: hJ,
      [DZ.sunburst]: cJ,
      [DZ.rangeColumn]: dJ,
      [DZ.circlePacking]: pJ,
      [DZ.heatmap]: gJ
    };
  function vJ(t, e, i = !1) {
    if (e) {
      if (t === e) return;
      if (h(e) && 'object' == typeof e) {
        const n = Object(e),
          s = [];
        for (const t in n) s.push(t);
        let { length: r } = s,
          a = -1;
        for (; r--; ) {
          const r = s[++a];
          h(n[r]) && 'object' == typeof n[r] && !f(t[r]) ? mJ(t, e, r, i) : yJ(t, r, n[r]);
        }
      }
    }
  }
  function mJ(t, e, i, n = !1) {
    const s = t[i],
      r = e[i];
    let a = e[i],
      o = !0;
    if (f(r)) {
      if (n) a = [];
      else if (f(s)) a = s;
      else if (v(s)) {
        a = new Array(s.length);
        let t = -1;
        const e = s.length;
        for (; ++t < e; ) a[t] = s[t];
      }
    } else u(r) ? ((a = s), ('function' != typeof s && 'object' == typeof s) || (a = {})) : (o = !1);
    o && vJ(a, r, n), yJ(t, i, a);
  }
  function yJ(t, e, i) {
    ((void 0 !== i &&
      !(function (t, e) {
        return t === e || (Number.isNaN(t) && Number.isNaN(e));
      })(t[e], i)) ||
      (void 0 === i && !(e in t))) &&
      (t[e] = i);
  }
  function _J(t, ...e) {
    let i = -1;
    const n = e.length;
    for (; ++i < n; ) {
      vJ(t, e[i], !0);
    }
    return t;
  }
  function bJ(t, e, i, n) {
    Object.keys(t).forEach(s => {
      if (c(e))
        e.type === s &&
          (f(t[s])
            ? t[s].length >= e.index && (t[s][e.index] = n ? _J({}, t[s][e.index], i) : i)
            : (t[s] = n ? _J({}, t[s], i) : i));
      else if (f(t[s])) {
        const r = t[s].findIndex(t => t.id === e);
        r >= 0 && (t[s][r] = n ? _J({}, t[s][r], i) : i);
      } else t.id === e && (t[s] = n ? _J({}, t[s], i) : i);
    });
  }
  function xJ(t, ...e) {
    return _J(SJ(t), ...e.map(SJ));
  }
  function SJ(t) {
    if (!t) return t;
    let { colorScheme: e } = t;
    e &&
      (e = Object.keys(e).reduce((t, i) => {
        const n = e[i];
        return (
          (t[i] = (function (t) {
            return f(t) ? { dataScheme: t } : t;
          })(n)),
          t
        );
      }, {}));
    let { series: i } = t;
    const { mark: n, markByName: s } = t;
    return (
      (n || s) &&
        (i = Object.keys(fJ).reduce((t, e) => {
          var r;
          const a = null !== (r = null == i ? void 0 : i[e]) && void 0 !== r ? r : {},
            o = {};
          return (
            Object.values(fJ[e]).forEach(({ type: t, name: e }) => {
              var i, r;
              o[e] = _J(
                {},
                null !== (i = null == n ? void 0 : n[V(t)[0]]) && void 0 !== i ? i : {},
                null !== (r = null == s ? void 0 : s[e]) && void 0 !== r ? r : {},
                a[e]
              );
            }),
            (t[e] = Object.assign(Object.assign({}, a), o)),
            t
          );
        }, {})),
      Object.assign(Object.assign({}, t), { colorScheme: e, series: i })
    );
  }
  const wJ = {
      name: 'dark',
      colorScheme: {
        default: {
          dataScheme: SV,
          palette: {
            backgroundColor: '#202226',
            borderColor: '#404349',
            shadowColor: '#000000',
            primaryFontColor: '#fdfdfd',
            secondaryFontColor: '#888c93',
            axisFontColor: '#bbbdc3',
            disableFontColor: '#55595f',
            labelReverseFontColor: '#202226',
            axisGridColor: '#404349',
            axisDomainColor: '#4b4f54',
            axisLabelFontColor: '#bbbdc3',
            dataZoomHandlerStrokeColor: '#888c93',
            dataZoomHandlerFillColor: '#202226',
            dataZoomBackgroundColor: '#404349',
            dataZoomChartColor: '#55595F',
            dataZoomSelectedColor: '#4284FF',
            scrollBarSliderColor: '#ffffff',
            tooltipBackgroundColor: '#404349',
            titleFontColor: '#fdfdfd',
            labelFontColor: '#bbbdc3'
          }
        }
      },
      component: {
        dataZoom: { selectedBackground: { style: { fillOpacity: 0.4, outerBorder: { strokeOpacity: 0.4 } } } }
      }
    },
    AJ = new Map([
      [RZ.name, RZ],
      [wJ.name, wJ]
    ]),
    kJ = RZ.name,
    MJ = new Map([[kJ, AJ.get(kJ)]]),
    TJ = t => xJ({}, AJ.get(kJ), t);
  AJ.forEach((t, e) => {
    e !== kJ && MJ.set(e, TJ(t));
  });
  class CJ {
    static registerInstance(t) {
      CJ.instances.set(t.id, t);
    }
    static unregisterInstance(t) {
      CJ.instances.delete(t.id);
    }
    static getInstance(t) {
      return CJ.instances.get(t);
    }
    static instanceExist(t) {
      return CJ.instances.has(t);
    }
    static forEach(t, e = [], i) {
      const n = V(e);
      return CJ.instances.forEach((e, i, s) => {
        n.includes(i) || t(e, i, s);
      }, i);
    }
  }
  CJ.instances = new Map();
  class EJ {
    static registerTheme(t, e) {
      t && EJ.themes.set(t, TJ(e));
    }
    static getTheme(t) {
      return EJ.themes.get(t) || EJ.getDefaultTheme();
    }
    static removeTheme(t) {
      return EJ.themes.delete(t);
    }
    static themeExist(t) {
      return !!g(t) && EJ.themes.has(t);
    }
    static getDefaultTheme() {
      return EJ.themes.get(kJ);
    }
    static setCurrentTheme(t) {
      EJ.themeExist(t) && ((EJ._currentThemeName = t), CJ.forEach(e => (null == e ? void 0 : e.setCurrentTheme(t))));
    }
    static getCurrentTheme() {
      return EJ.getTheme(EJ._currentThemeName);
    }
    static getCurrentThemeName() {
      return EJ._currentThemeName;
    }
  }
  function PJ(t) {
    return t instanceof yo;
  }
  function RJ(t) {
    try {
      return t instanceof Element;
    } catch (e) {
      const i = ['children', 'innerHTML', 'classList', 'setAttribute', 'tagName', 'getBoundingClientRect'],
        n = Object.keys(t);
      return i.every(t => n.includes(t));
    }
  }
  function OJ(t) {
    return g(t) ? (EJ.themeExist(t) ? EJ.getTheme(t) : {}) : c(t) ? t : {};
  }
  function BJ(t) {
    const e = t;
    let i;
    if (!h(e) || 'object' != typeof e) return e;
    if (PJ(e) || RJ(e)) return e;
    const n = f(e),
      s = e.length;
    i = n ? new Array(s) : 'object' == typeof e ? {} : a(e) || y(e) || g(e) ? e : m(e) ? new Date(+e) : void 0;
    const r = n ? void 0 : Object.keys(Object(e));
    let o = -1;
    if (i)
      for (; ++o < (r || e).length; ) {
        const t = r ? r[o] : o,
          n = e[t];
        i[t] = BJ(n);
      }
    return i;
  }
  function IJ(t, e, i, n) {
    if (f(e)) return e.map(e => (c(e) && !o(e) ? IJ(t, e, i, n) : e));
    const s = {};
    return (
      Object.keys(e).forEach(r => {
        const a = e[r];
        if (r.includes('data')) s[r] = a;
        else if (c(a)) {
          if (o(a) || PJ(a) || RJ(a)) return void (s[r] = a);
          oV(a)
            ? (s[r] = aV(a, i, n))
            : (s[r] = IJ(FZ.has(r) ? (t.includes('spec') ? 'mark-spec' : 'mark-theme') : t, a, i, n));
        } else if (t.includes('mark') || 'padding' !== r)
          if (!t.includes('theme') && 'lineHeight' === r && g(a) && '%' === a[a.length - 1]) {
            if (h(e.fontSize)) {
              const t = Number.parseFloat(a.substring(0, a.length - 1)) / 100,
                i = e.fontSize * t;
              _(i) && (s[r] = i);
            }
          } else s[r] = a;
        else s[r] = _V(a);
      }),
      s
    );
  }
  function DJ(t, e = { data: t => t }) {
    if (!t) return t;
    if (t.constructor === Object) {
      const i = {};
      for (const n in t)
        if (Object.prototype.hasOwnProperty.call(t, n)) {
          if (e[n]) {
            i[n] = e[n](t[n]);
            continue;
          }
          i[n] = DJ(t[n], e);
        }
      return i;
    }
    return f(t) ? t.map(t => DJ(t, e)) : t;
  }
  (EJ.themes = MJ), (EJ._currentThemeName = kJ);
  function LJ(t, e) {
    for (let i = 0; i < e.length; i++) {
      const n = e[i],
        s = FJ(t, n.key);
      s ? (s.operations = [...new Set(s.operations.concat(n.operations))]) : t.push(n);
    }
    return t;
  }
  function FJ(t, e) {
    return t.find(t => t.key === e);
  }
  function jJ(t, e) {
    var i;
    if (!t) return null != e ? e : null;
    const n = t.getFields();
    return n && n[e] ? (null !== (i = n[e].alias) && void 0 !== i ? i : e) : null != e ? e : null;
  }
  const zJ = (t, e, i = 'key', n = 'children') => {
      for (let s = 0; s < t.length; s++) {
        const r = t[s];
        if (r[i] === e) return r;
        if (r[n]) {
          const t = zJ(r[n], e, i, n);
          if (t) return t;
        }
      }
      return null;
    },
    HJ = (t, e, i = 'key', n = 'children') => {
      for (let s = 0; s < t.length; s++) {
        const r = t[s];
        if (r[n])
          for (let t = 0; t < r[n].length; t++) {
            const s = r[n][t];
            if (s[i] === e) return r;
            const a = HJ([s], e, i, n);
            if (a) return a;
          }
      }
      return null;
    };
  function NJ(t = {}) {
    const e = Object.assign({}, t);
    if (
      (o(t.style) ? (e.style = (e, i, n, s) => GJ(t.style(e, i, n, s))) : T(t.style) || (e.style = GJ(t.style)),
      !T(t.state))
    ) {
      const i = {};
      Object.keys(t.state).forEach(e => {
        o(t.state[e]) ? (i[e] = (i, n, s, r) => GJ(t.state[e](i, n, s, r))) : T(t.state[e]) || (i[e] = GJ(t.state[e]));
      }),
        (e.state = i);
    }
    return e;
  }
  function VJ(t) {
    if (T(t)) return null;
    const e = {};
    return (
      Object.keys(t).forEach(i => {
        o(t[i]) ? (e[i] = (e, n, s, r) => GJ(t[i](e, n, s, r))) : T(t[i]) || (e[i] = GJ(t[i]));
      }),
      e
    );
  }
  function WJ(t) {
    if (T(t)) return null;
    const e = {};
    return (
      Object.keys(t).forEach(i => {
        o(t[i]) ? (e[i] = (e, n, s, r) => GJ(t[i](e.rawValue, n, e, s, r))) : T(t[i]) || (e[i] = GJ(t[i]));
      }),
      e
    );
  }
  function GJ(t) {
    return (null == t ? void 0 : t.angle) && (t.angle = qt(t.angle)), t;
  }
  class UJ {
    static registerChart(t, e) {
      UJ._charts[t] = e;
    }
    static registerSeries(t, e) {
      UJ._series[t] = e;
    }
    static registerComponent(t, e) {
      UJ._components[t] = e;
    }
    static registerMark(t, e) {
      UJ._marks[t] = e;
    }
    static registerRegion(t, e) {
      UJ._regions[t] = e;
    }
    static registerTransform(t, e) {
      UJ.transforms[t] = e;
    }
    static registerLayout(t, e) {
      UJ._layout[t] = e;
    }
    static createChart(t, e, i) {
      if (!UJ._charts[t]) return null;
      return new (0, UJ._charts[t])(e, i);
    }
    static createRegion(t, e, i) {
      if (!UJ._regions[t]) return null;
      return new (0, UJ._regions[t])(e, i);
    }
    static createSeries(t, e, i) {
      if (!UJ._series[t]) return null;
      return new (0, UJ._series[t])(e, i);
    }
    static createMark(t, e, i) {
      if (!UJ._marks[t]) return null;
      const n = new (0, UJ._marks[t])(e, i);
      return n.type === jZ.group && n.setInteractive(!1), n;
    }
    static getComponents() {
      return Object.values(UJ._components);
    }
    static getComponentInKey(t) {
      return UJ._components[t];
    }
    static getLayout(t) {
      return UJ._layout[t];
    }
    static getSeries(t) {
      return UJ._series[t];
    }
  }
  (UJ._charts = {}),
    (UJ._series = {}),
    (UJ._components = {}),
    (UJ._marks = {}),
    (UJ._regions = {}),
    (UJ.transforms = {
      simplify: Pa,
      fields: Oa,
      filter: (t, e) => {
        const { callback: i } = e;
        return i && (t = t.filter(i)), t;
      },
      fold: (t, e) => {
        const { fields: i, key: n, value: s, retains: r } = e,
          a = [];
        for (let e = 0; e < t.length; e++)
          i.forEach(o => {
            const l = {};
            if (((l[n] = o), (l[s] = t[e][o]), r))
              r.forEach(i => {
                l[i] = t[e][i];
              });
            else for (const n in t[e]) -1 === i.indexOf(n) && (l[n] = t[e][n]);
            a.push(l);
          });
        return a;
      }
    }),
    (UJ.dataParser = { csv: Ga, dsv: Wa, tsv: Ua }),
    (UJ._layout = {});
  const YJ = (t, e, i) => {
      const n = t.getRegionsInIds(V(e.layoutBindRegionID));
      return null == n
        ? void 0
        : n.some(t => {
            const e = t.getLayoutRect(),
              n = t.getLayoutStartPoint();
            return ((t, e, i) => t.x >= e.x && t.x <= i.x && t.y >= e.y && t.y <= i.y)(
              i,
              { x: n.x, y: n.y },
              { x: e.width + n.x, y: e.height + n.y }
            );
          });
    },
    $J = (t, e) => {
      var i, n;
      return (
        t === e ||
        (!l(t) &&
          !l(e) &&
          t.value === e.value &&
          (null === (i = t.axis) || void 0 === i ? void 0 : i.id) ===
            (null === (n = e.axis) || void 0 === n ? void 0 : n.id))
      );
    },
    XJ = (t, e, i, n) => {
      var s;
      const r = Qo(e.getScale().type),
        a = [],
        o = e.getRegions();
      for (const e of o) {
        const o = e.getSeries();
        for (const e of o)
          if (e.coordinate === i) {
            const i = V(n(e)),
              o = null === (s = e.getViewData()) || void 0 === s ? void 0 : s.latestData;
            if (i && o)
              if (r)
                a.push({
                  series: e,
                  datum: o.filter(e => {
                    var n;
                    return (
                      (null === (n = e[i[0]]) || void 0 === n ? void 0 : n.toString()) ===
                      (null == t ? void 0 : t.toString())
                    );
                  })
                });
              else if (h(i[1]))
                a.push({
                  series: e,
                  datum: o.filter(e => {
                    var n;
                    return (
                      (null === (n = e[i[0]]) || void 0 === n ? void 0 : n.toString()) ===
                        (null == t ? void 0 : t.toString()) ||
                      (h(e[i[0]]) && h(e[i[1]]) && t >= e[i[0]] && t < e[i[1]])
                    );
                  })
                });
              else {
                let n = 1 / 0,
                  s = [],
                  r = 0;
                o.forEach(e => {
                  if (h(e[i[0]])) {
                    const a = Math.abs(e[i[0]] - t),
                      o = Math.sign(e[i[0]] - t);
                    a < n ? ((n = a), (s = [e]), (r = o)) : a === n && o === r && s.push(e);
                  }
                }),
                  a.push({ series: e, datum: s });
              }
          }
      }
      return a;
    },
    KJ = 'monotone',
    qJ = 'linearClosed';
  var ZJ;
  !(function (t) {
    (t.circle = 'circle'),
      (t.triangle = 'triangle'),
      (t.triangleUp = 'triangleUp'),
      (t.triangleLeft = 'triangleLeft'),
      (t.triangleRight = 'triangleRight'),
      (t.triangleDown = 'triangleDown'),
      (t.thinTriangle = 'thinTriangle'),
      (t.rect = 'rect'),
      (t.diamond = 'diamond'),
      (t.square = 'square'),
      (t.arrowLeft = 'arrowLeft'),
      (t.arrow2Left = 'arrow2Left'),
      (t.arrowRight = 'arrowRight'),
      (t.arrow2Right = 'arrow2Right'),
      (t.cross = 'cross'),
      (t.wedge = 'wedge'),
      (t.star = 'star'),
      (t.wye = 'wye');
  })(ZJ || (ZJ = {}));
  var JJ, QJ;
  function tQ(t) {
    return 'bottom' === t || 'top' === t;
  }
  function eQ(t) {
    return 'left' === t || 'right' === t;
  }
  function iQ(t) {
    return 'z' === t;
  }
  function nQ(t, e) {
    return gV(t.orient) || (e && e.includes(t.orient)) ? t.orient : 'left';
  }
  !(function (t) {
    (t.vertical = 'vertical'), (t.horizontal = 'horizontal');
  })(JJ || (JJ = {})),
    (function (t) {
      (t.top = 'top'), (t.left = 'left'), (t.right = 'right'), (t.bottom = 'bottom'), (t.inside = 'inside');
    })(QJ || (QJ = {}));
  const sQ = (t, e, i) => {
      const n = t
        .getAllComponents()
        .filter(
          n =>
            'axes' === n.specKey &&
            ('x' === e
              ? 'bottom' === n.getOrient() || 'top' === n.getOrient()
              : 'left' === n.getOrient() || 'right' === n.getOrient()) &&
            YJ(t, n, i)
        );
      return n.length ? n : null;
    },
    rQ = t => t.fieldX[0],
    aQ = t => t.fieldY[0],
    oQ = t => [t.fieldX[0], t.fieldX2],
    lQ = t => [t.fieldY[0], t.fieldY2],
    hQ = (t, e) => {
      var i, n;
      if (!t) return null;
      const s = (t => {
        const e = t.getRegionsInIndex();
        for (let t = 0; t < e.length; t++) {
          const i = e[t].getSeries();
          for (let t = 0; t < i.length; t++) {
            const e = i[t];
            if ('cartesian' === e.coordinate) return e;
          }
        }
        return null;
      })(t);
      if (!s) return null;
      const { x: r, y: a } = e,
        o = null !== (i = sQ(t, 'x', e)) && void 0 !== i ? i : [],
        l = null !== (n = sQ(t, 'y', e)) && void 0 !== n ? n : [],
        h = new Set(),
        c = new Set();
      [o, l].forEach(t =>
        t.forEach(t => {
          Qo(t.getScale().type) ? h.add(t) : c.add(t);
        })
      );
      const d = [],
        u = (t, e) => {
          ('x' === t ? o : l).forEach(i => {
            if ((e ? h : c).has(i)) {
              const n = cQ(i, 'x' === t ? r : a, t, 'x' === t ? (e ? rQ : oQ) : e ? aQ : lQ);
              n && d.push(n);
            }
          });
        };
      return (
        t.getSpec().direction === JJ.horizontal
          ? (u('y', h.size > 0), 0 === d.length && u('x', h.size > 0))
          : (u('x', h.size > 0), 0 === d.length && u('y', h.size > 0)),
        d.length ? d : null
      );
    },
    cQ = (t, e, i, n) => {
      const s = t.getScale(),
        r = e - t.getLayoutStartPoint()[i];
      if ((r - s.range()[0]) * (r - s.range()[1]) > 0) return null;
      const a = s.invert(r);
      return dQ(t, a, n);
    },
    dQ = (t, e, i) => {
      const n = t.getScale();
      if (l(e)) return null;
      let s = n.domain().findIndex(t => (null == t ? void 0 : t.toString()) === e.toString());
      s < 0 && (s = void 0);
      const r = XJ(e, t, 'cartesian', null != i ? i : tQ(t.getOrient()) ? rQ : aQ);
      return { index: s, value: e, axis: t, data: r };
    },
    uQ = (t, e, i) => {
      const n = t.getAllComponents().filter(n => 'axes' === n.specKey && n.getOrient() === e && YJ(t, n, i));
      return n.length ? n : null;
    },
    pQ = (t, e) => {
      if (!t) return null;
      const i = (t => {
        const e = t.getRegionsInIndex();
        for (let t = 0; t < e.length; t++) {
          const i = e[t].getSeries();
          for (let t = 0; t < i.length; t++) {
            const e = i[t];
            if ('polar' === e.coordinate) return e;
          }
        }
        return null;
      })(t);
      if (!i) return null;
      const { x: n, y: s } = e,
        r = uQ(t, 'angle', e),
        a = uQ(t, 'radius', e),
        o = [],
        h = t => t.getDimensionField()[0];
      return (
        r &&
          r.forEach(t => {
            var e;
            const i = t.getScale(),
              r = null == i ? void 0 : i.domain(),
              c = null == i ? void 0 : i.range();
            if (i && Qo(i.type)) {
              const d = t.getCenter(),
                u = { x: n - t.getLayoutStartPoint().x - d.x, y: s - t.getLayoutStartPoint().y - d.y };
              let p = JN({ x: 1, y: 0 }, u);
              p = ((t, e) => {
                const i = 2 * Math.PI,
                  n = Math.min(...e),
                  s = Math.max(...e);
                return t < n ? (t += Math.ceil((n - t) / i) * i) : t > s && (t -= Math.ceil((t - s) / i) * i), t;
              })(p, c);
              const g = QN(u),
                f = null === (e = a[0]) || void 0 === e ? void 0 : e.getScale(),
                v = null == f ? void 0 : f.range();
              if (
                (p - (null == c ? void 0 : c[0])) * (p - (null == c ? void 0 : c[1])) > 0 ||
                (g - (null == v ? void 0 : v[0])) * (g - (null == v ? void 0 : v[1])) > 0
              )
                return;
              const m = Math.abs(c[0] - c[1]) / r.length / 2,
                y = i.invert(p + m);
              if (l(y)) return;
              let _ = i.domain().findIndex(t => (null == t ? void 0 : t.toString()) === y.toString());
              _ < 0 && (_ = void 0);
              const b = XJ(y, t, 'polar', h);
              o.push({ index: _, value: y, axis: t, data: b });
            }
          }),
        a &&
          a.forEach(t => {
            var e;
            const i = t.getScale(),
              a = null == i ? void 0 : i.range();
            if (i && Qo(i.type)) {
              const c = t.getCenter(),
                d = { x: n - t.getLayoutStartPoint().x - c.x, y: s - t.getLayoutStartPoint().y - c.y };
              let u = JN({ x: 1, y: 0 }, d);
              u < -Math.PI / 2 && (u = 2 * Math.PI + u);
              const p = QN(d),
                g = null === (e = r[0]) || void 0 === e ? void 0 : e.getScale(),
                f = null == g ? void 0 : g.range();
              if (
                (u - (null == f ? void 0 : f[0])) * (u - (null == f ? void 0 : f[1])) > 0 ||
                (p - (null == a ? void 0 : a[0])) * (p - (null == a ? void 0 : a[1])) > 0
              )
                return;
              const v = i.invert(p);
              if (l(v)) return;
              let m = i.domain().findIndex(t => (null == t ? void 0 : t.toString()) === v.toString());
              m < 0 && (m = void 0);
              const y = XJ(v, t, 'polar', h);
              o.push({ index: m, value: v, axis: t, data: y });
            }
          }),
        o.length ? o : null
      );
    };
  class gQ {
    constructor(t, e) {
      var i, n;
      (this._eventDispatcher = t),
        (this._mode = e),
        (this._chart =
          null === (n = (i = this._eventDispatcher.globalInstance).getChart) || void 0 === n ? void 0 : n.call(i));
    }
    register(t, e) {
      var i, n;
      (null !== (n = null === (i = this._chart) || void 0 === i ? void 0 : i.getOption().onError) && void 0 !== n
        ? n
        : wo)('Method not implemented.');
    }
    unregister() {
      var t, e;
      (null !== (e = null === (t = this._chart) || void 0 === t ? void 0 : t.getOption().onError) && void 0 !== e
        ? e
        : wo)('Method not implemented.');
    }
    getTargetDimensionInfo(t, e) {
      var i, n;
      const s = null !== (i = hQ(this._chart, { x: t, y: e })) && void 0 !== i ? i : [],
        r = null !== (n = pQ(this._chart, { x: t, y: e })) && void 0 !== n ? n : [],
        a = [].concat(s, r);
      return 0 === a.length ? null : a;
    }
    dispatch(t, e) {
      var i;
      const n =
          null === (i = this._chart) || void 0 === i
            ? void 0
            : i.getAllComponents().filter(t => {
                if ('axes' !== t.specKey) return !1;
                return !!Qo(t.getScale().type) && (!(null == e ? void 0 : e.filter) || e.filter(t));
              }),
        s = [];
      return (
        n.forEach(e => {
          const i = dQ(e, t);
          i && s.push(i);
        }),
        this._callback.call(null, { action: 'enter', dimensionInfo: s }),
        s
      );
    }
  }
  var fQ;
  !(function (t) {
    (t.dimensionHover = 'dimensionHover'), (t.dimensionClick = 'dimensionClick');
  })(fQ || (fQ = {}));
  const vQ = {
    [fQ.dimensionHover]: class extends gQ {
      constructor() {
        super(...arguments),
          (this._cacheDimensionInfo = null),
          (this.onMouseMove = t => {
            if (!t) return;
            const e = t.event.viewX,
              i = t.event.viewY,
              n = this.getTargetDimensionInfo(e, i);
            null === n && null !== this._cacheDimensionInfo
              ? (this._callback.call(
                  null,
                  Object.assign(Object.assign({}, t), { action: 'leave', dimensionInfo: [...this._cacheDimensionInfo] })
                ),
                (this._cacheDimensionInfo = n))
              : null === n ||
                (null !== this._cacheDimensionInfo &&
                  n.length === this._cacheDimensionInfo.length &&
                  !n.some((t, e) => !$J(t, this._cacheDimensionInfo[e])))
              ? null !== n &&
                this._callback.call(
                  null,
                  Object.assign(Object.assign({}, t), { action: 'move', dimensionInfo: [...n] })
                )
              : (this._callback.call(
                  null,
                  Object.assign(Object.assign({}, t), { action: 'enter', dimensionInfo: [...n] })
                ),
                (this._cacheDimensionInfo = n));
          }),
          (this.onMouseOut = t => {
            t &&
              (this._callback.call(
                null,
                Object.assign(Object.assign({}, t), {
                  action: 'leave',
                  dimensionInfo: this._cacheDimensionInfo ? [...this._cacheDimensionInfo] : []
                })
              ),
              (this._cacheDimensionInfo = null));
          });
      }
      register(t, e) {
        (this._callback = e.callback),
          this._eventDispatcher.register('pointermove', {
            query: Object.assign(Object.assign({}, e.query), { source: Uq.chart }),
            callback: this.onMouseMove
          }),
          this._eventDispatcher.register('pointerout', {
            query: Object.assign(Object.assign({}, e.query), { source: Uq.canvas }),
            callback: this.onMouseOut
          }),
          Co(this._mode) &&
            this._eventDispatcher.register('pointerdown', {
              query: Object.assign(Object.assign({}, e.query), { source: Uq.chart }),
              callback: this.onMouseMove
            });
      }
      unregister() {
        this._eventDispatcher.unregister('pointermove', { query: null, callback: this.onMouseMove }),
          Co(this._mode) &&
            this._eventDispatcher.unregister('pointerdown', { query: null, callback: this.onMouseMove });
      }
    },
    [fQ.dimensionClick]: class extends gQ {
      constructor() {
        super(...arguments),
          (this.onClick = t => {
            if (!t) return;
            const e = t.event.viewX,
              i = t.event.viewY,
              n = this.getTargetDimensionInfo(e, i);
            n &&
              this._callback.call(
                null,
                Object.assign(Object.assign({}, t), { action: 'click', dimensionInfo: [...n] })
              );
          });
      }
      register(t, e) {
        (this._callback = e.callback),
          this._eventDispatcher.register('pointertap', {
            query: Object.assign(Object.assign({}, e.query), { source: Uq.chart }),
            callback: this.onClick
          });
      }
      unregister() {
        this._eventDispatcher.unregister('pointertap', { query: null, callback: this.onClick });
      }
    }
  };
  let mQ = class {
    getComposedEventMap() {
      return this._composedEventMap;
    }
    constructor(t, e) {
      (this._composedEventMap = new Map()), (this._eventDispatcher = t), (this._mode = e);
    }
    on(t, e, i) {
      const n = 'function' == typeof e ? { query: null, callback: e } : { query: e, callback: i };
      if (vQ[t]) {
        const e = new vQ[t](this._eventDispatcher, this._mode);
        e.register(t, n), this._composedEventMap.set(i, { eventType: t, event: e });
      } else this._eventDispatcher.register(t, n);
      return this;
    }
    off(t, e, i) {
      var n, s;
      const r = null != i ? i : e;
      if (vQ[t])
        if (r)
          null === (n = this._composedEventMap.get(r)) || void 0 === n || n.event.unregister(),
            this._composedEventMap.delete(r);
        else
          for (const e of this._composedEventMap.entries())
            e[1].eventType === t &&
              (null === (s = this._composedEventMap.get(e[0])) || void 0 === s || s.event.unregister(),
              this._composedEventMap.delete(e[0]));
      else if (r) {
        const i = {
          callback: r,
          query: null,
          filter: { nodeName: null, type: t, level: null, source: e.source, markName: null, filter: null, userId: null }
        };
        this._eventDispatcher.unregister(t, i);
      } else this._eventDispatcher.unregister(t);
      return this;
    }
    emit(t, e, i) {
      return this._eventDispatcher.dispatch(t, e, i), this;
    }
    release() {
      this._eventDispatcher.release(), this._composedEventMap.clear();
    }
  };
  class yQ {
    constructor() {
      (this._map = new Map()),
        (this._levelNodes = new Map()),
        this._levelNodes.set(Yq.vchart, []),
        this._levelNodes.set(Yq.chart, []),
        this._levelNodes.set(Yq.model, []),
        this._levelNodes.set(Yq.mark, []);
    }
    addHandler(t, e) {
      var i;
      const n = { level: e, handler: t };
      return null === (i = this._levelNodes.get(e)) || void 0 === i || i.push(n), this._map.set(t.callback, n), this;
    }
    removeHandler(t) {
      const e = this._map.get(t.callback);
      if (!e) return this;
      this._map.delete(t.callback);
      const i = this._levelNodes.get(e.level),
        n = null == i ? void 0 : i.findIndex(e => e.handler.callback === t.callback);
      return void 0 !== n && n >= 0 && (null == i || i.splice(n, 1)), this;
    }
    getHandlers(t) {
      var e;
      return (null === (e = this._levelNodes.get(t)) || void 0 === e ? void 0 : e.map(t => t.handler)) || [];
    }
    getCount() {
      return this._map.size;
    }
    release() {
      this._map.clear(), this._levelNodes.clear();
    }
  }
  const _Q = {
    cartesianAxis: 'axis',
    'cartesianAxis-band': 'axis',
    'cartesianAxis-linear': 'axis',
    'cartesianAxis-time': 'axis',
    polarAxis: 'axis',
    'polarAxis-band': 'axis',
    'polarAxis-linear': 'axis',
    discreteLegend: 'legend',
    continuousLegend: 'legend',
    colorLegend: 'legend',
    sizeLegend: 'legend',
    label: 'label'
  };
  class bQ {
    constructor(t, e) {
      (this._viewBubbles = new Map()),
        (this._windowBubbles = new Map()),
        (this._canvasBubbles = new Map()),
        (this._viewListeners = new Map()),
        (this._windowListeners = new Map()),
        (this._canvasListeners = new Map()),
        (this.globalInstance = t),
        (this._compiler = e);
    }
    register(t, e) {
      var i, n, s, r;
      this._parseQuery(e);
      const a = this.getEventBubble((null === (i = e.filter) || void 0 === i ? void 0 : i.source) || Uq.chart),
        o = this.getEventListeners((null === (n = e.filter) || void 0 === n ? void 0 : n.source) || Uq.chart);
      a.get(t) || a.set(t, new yQ());
      if (
        (a.get(t).addHandler(e, null === (s = e.filter) || void 0 === s ? void 0 : s.level),
        this._isValidEvent(t) && !o.has(t))
      ) {
        const i = this._onDelegate.bind(this);
        this._compiler.addEventListener(null === (r = e.filter) || void 0 === r ? void 0 : r.source, t, i), o.set(t, i);
      }
      return this;
    }
    unregister(t, e) {
      var i, n, s, r;
      let a = !1;
      const o = this.getEventBubble(
          (null === (i = null == e ? void 0 : e.filter) || void 0 === i ? void 0 : i.source) || Uq.chart
        ),
        l = this.getEventListeners(
          (null === (n = null == e ? void 0 : e.filter) || void 0 === n ? void 0 : n.source) || Uq.chart
        );
      if (e) {
        const i = o.get(t);
        null == i || i.removeHandler(e),
          0 === (null == i ? void 0 : i.getCount()) && (null == i || i.release(), o.delete(t), (a = !0)),
          (null === (s = null == e ? void 0 : e.wrappedCallback) || void 0 === s ? void 0 : s.cancel) &&
            e.wrappedCallback.cancel();
      } else {
        const e = o.get(t);
        null == e || e.release(), o.delete(t), (a = !0);
      }
      if (a && this._isValidEvent(t)) {
        const i = l.get(t);
        this._compiler.removeEventListener(
          (null === (r = null == e ? void 0 : e.filter) || void 0 === r ? void 0 : r.source) || Uq.chart,
          t,
          i
        ),
          l.delete(t);
      }
      return this;
    }
    dispatch(t, e, i) {
      const n = this.getEventBubble(e.source || Uq.chart).get(t);
      if (!n) return this;
      let s = !1;
      if (i) {
        const r = n.getHandlers(i);
        s = this._invoke(r, t, e);
      } else {
        const i = n.getHandlers(Yq.mark);
        if (((s = this._invoke(i, t, e)), !s)) {
          const i = n.getHandlers(Yq.model);
          s = this._invoke(i, t, e);
        }
        if (!s) {
          const i = n.getHandlers(Yq.chart);
          s = this._invoke(i, t, e);
        }
        if (!s) {
          const i = n.getHandlers(Yq.vchart);
          s = this._invoke(i, t, e);
        }
      }
      return this;
    }
    release() {
      for (const t of this._viewListeners.entries()) this._compiler.removeEventListener(Uq.chart, t[0], t[1]);
      this._viewListeners.clear();
      for (const t of this._windowListeners.entries()) this._compiler.removeEventListener(Uq.window, t[0], t[1]);
      this._windowListeners.clear();
      for (const t of this._canvasListeners.entries()) this._compiler.removeEventListener(Uq.canvas, t[0], t[1]);
      this._canvasListeners.clear();
      for (const t of this._viewBubbles.values()) t.release();
      this._viewBubbles.clear();
      for (const t of this._windowBubbles.values()) t.release();
      this._windowBubbles.clear();
      for (const t of this._canvasBubbles.values()) t.release();
      this._canvasBubbles.clear();
    }
    _filter(t, e, i) {
      var n, s, r;
      if (o(t.filter) && !t.filter(i)) return !1;
      if (t.nodeName && C(i, 'node.name') !== t.nodeName) return !1;
      if (t.markName && (null === (n = null == i ? void 0 : i.mark) || void 0 === n ? void 0 : n.name) !== t.markName)
        return !1;
      let a = null === (s = i.model) || void 0 === s ? void 0 : s.type;
      return (
        _Q[a] && (a = _Q[a]),
        (!t.type || a === t.type) &&
          !('mark' === t.level && !t.type && !(null == i ? void 0 : i.mark)) &&
          !('model' === t.level && !t.type && !(null == i ? void 0 : i.model)) &&
          (!h(t.userId) || (null === (r = i.model) || void 0 === r ? void 0 : r.userId) === t.userId)
      );
    }
    _prepareParams(t, e) {
      if (t.markName && e.mark && e.itemMap) {
        const t = e.mark.getProductId(),
          i = e.itemMap.get(t),
          n = null == i ? void 0 : i.getDatum();
        return Object.assign(Object.assign({}, e), { item: i, datum: n });
      }
      return Object.assign({}, e);
    }
    _onDelegate(t) {
      var e;
      const i = this.globalInstance.getChart(),
        n = (h(t.modelId) && (null == i ? void 0 : i.getModelById(t.modelId))) || void 0,
        s = (h(t.markId) && (null == i ? void 0 : i.getMarkById(t.markId))) || null,
        r = new Map();
      let a = null === (e = t.item) || void 0 === e ? void 0 : e.mark;
      for (a && h(a.id()) && r.set(a.id(), t.item); null == a ? void 0 : a.elements; ) {
        const t = a.id();
        h(t) && !r.has(t) && r.set(t, a.elements[0]), (a = a.group);
      }
      const o = {
        event: t.event,
        item: t.item,
        datum: t.datum,
        source: t.source,
        itemMap: r,
        chart: i,
        model: n,
        mark: null != s ? s : void 0,
        node: C(t.event, 'target')
      };
      this.dispatch(t.type, o);
    }
    _invoke(t, e, i) {
      const n = t.map(t => {
        var n, s, r;
        const a = t.filter;
        if (!t.query || this._filter(a, e, i)) {
          let e = (t.wrappedCallback || t.callback).call(null, this._prepareParams(a, i));
          return (
            (null === (n = t.query) || void 0 === n ? void 0 : n.consume) &&
              ((e = !0),
              null === (s = i.event) || void 0 === s || s.stopPropagation(),
              null === (r = i.event) || void 0 === r || r.preventDefault()),
            e
          );
        }
      });
      return n.some(t => !0 === t);
    }
    _getQueryLevel(t) {
      return t ? (t.level ? t.level : h(t.id) ? Yq.model : Yq.vchart) : Yq.vchart;
    }
    _parseQuery(t) {
      var e;
      const i = t.query;
      (null == i ? void 0 : i.throttle)
        ? (t.wrappedCallback = yt(t.callback, i.throttle))
        : (null == i ? void 0 : i.debounce) && (t.wrappedCallback = mt(t.callback, i.debounce));
      let n = this._getQueryLevel(i),
        s = null,
        r = Uq.chart,
        a = null,
        o = null,
        l = null;
      return (
        (null == i ? void 0 : i.nodeName) && (a = i.nodeName),
        (null == i ? void 0 : i.markName) && (o = i.markName),
        !(null == i ? void 0 : i.type) || (n !== Yq.model && n !== Yq.mark) || (s = i.type),
        (null == i ? void 0 : i.source) && (r = i.source),
        h(null == i ? void 0 : i.id) && ((l = null == i ? void 0 : i.id), (n = Yq.model)),
        (t.filter = {
          level: n,
          markName: o,
          type: s,
          source: r,
          nodeName: a,
          userId: l,
          filter: null !== (e = null == i ? void 0 : i.filter) && void 0 !== e ? e : null
        }),
        t
      );
    }
    getEventBubble(t) {
      switch (t) {
        case Uq.chart:
          return this._viewBubbles;
        case Uq.window:
          return this._windowBubbles;
        case Uq.canvas:
          return this._canvasBubbles;
        default:
          return this._viewBubbles;
      }
    }
    getEventListeners(t) {
      switch (t) {
        case Uq.chart:
          return this._viewListeners;
        case Uq.window:
          return this._windowListeners;
        case Uq.canvas:
          return this._canvasListeners;
        default:
          return this._viewListeners;
      }
    }
    _isValidEvent(t) {
      return Wq.includes(t) || Object.values(tG).includes(t) || Object.values(Gq).includes(t);
    }
  }
  function xQ(t, e, i) {
    t.getTransform(e) || t.registerTransform(e, i);
  }
  function SQ(t, e, i) {
    t.getParser(e) || t.registerParser(e, i);
  }
  const wQ = new Map();
  let AQ;
  function kQ(t, e, i = { type: 'geojson', centroid: !0 }) {
    wQ.has(t) && So(`map type of '${t}' already exists, will be overwritten.`),
      AQ || ((AQ = new vo()), SQ(AQ, 'geojson', ho), SQ(AQ, 'topojson', uo), xQ(AQ, 'simplify', Pa));
    const n = new yo(AQ),
      s = D({}, { centroid: !0, simplify: !1 }, i);
    'topojson' === i.type ? n.parse(e, { type: 'topojson', options: s }) : n.parse(e, { type: 'geojson', options: s }),
      !0 === i.simplify && n.transform({ type: 'simplify' }),
      wQ.set(t, n);
  }
  function MQ(t, e = !1) {
    let i = e;
    return t.latestData instanceof yo && (i = !1), i ? R(t.latestData) : t.latestData.slice();
  }
  const TQ = (t, e) =>
    0 === t.length
      ? []
      : 1 === t.length
      ? MQ(t[0], null == e ? void 0 : e.deep)
      : t.map(t => MQ(t, null == e ? void 0 : e.deep));
  function CQ(t, e, i) {
    xQ((e = e instanceof vo ? e : t.dataSet), 'copyDataView', TQ);
    const n = new yo(e, i);
    return n.parse([t], { type: 'dataview' }), n.transform({ type: 'copyDataView' }), n;
  }
  function EQ(t, e, i = [], n = {}) {
    var s, r, a, o;
    if (t instanceof yo) return t;
    const { id: l, values: h = [], fromDataIndex: c, fromDataId: d, transforms: u = [], fields: p } = t,
      f = null !== (s = t.parser) && void 0 !== s ? s : { clone: !0 };
    let v;
    f.clone = !(!1 === f.clone);
    const m = i.find(t => t.name === l);
    if (m) v = m;
    else {
      const t = { name: l };
      if ((p && (t.fields = p), (v = new yo(e, t)), 'string' == typeof d)) {
        const t = i.find(t => t.name === d);
        if (!t) return (null !== (r = n.onError) && void 0 !== r ? r : wo)(`no data matches fromDataId ${d}`), null;
        v.parse([t], { type: 'dataview' }), v.transform({ type: 'copyDataView' });
      } else if ('number' == typeof c) {
        const t = i[c];
        if (!t) return (null !== (a = n.onError) && void 0 !== a ? a : wo)(`no data matches fromDataIndex ${c}`), null;
        v.parse([t], { type: 'dataview' }), v.transform({ type: 'copyDataView' });
      } else
        Array.isArray(h)
          ? v.parse(h, f)
          : !g(h) || (f && !['csv', 'dsv', 'tsv'].includes(f.type))
          ? (v.parse([]), So('values should be array'))
          : v.parse(h, null !== (o = f) && void 0 !== o ? o : { type: 'csv' });
      u &&
        u.length &&
        u.forEach(t => {
          e.getTransform(t.type) && v.transform(t);
        });
    }
    return v;
  }
  const PQ = (t, e) => {
    const i = { nodes: {} },
      { fields: n } = e;
    if (!(null == n ? void 0 : n.length)) return i;
    const s = n.length - 1;
    let r,
      a,
      o = i;
    return (
      t.forEach(t => {
        t.latestData.forEach(t => {
          o = i;
          for (let e = 0; e < n.length; e++) {
            const i = t[n[e]];
            if (l(i)) break;
            o.nodes[i] || (e === s ? (o.nodes[i] = { values: [] }) : ((r = { nodes: {} }), (o.nodes[i] = r))),
              e === s ? ((a = o.nodes[i]), a.values.push(t)) : (o = o.nodes[i]);
          }
        });
      }),
      i
    );
  };
  var RQ, OQ, BQ, IQ, DQ;
  function LQ(e) {
    switch (e) {
      case t.RenderModeEnum['desktop-browser']:
      case t.RenderModeEnum['mobile-browser']:
        return 'browser';
      case t.RenderModeEnum.node:
      case t.RenderModeEnum.worker:
        return 'node';
      case t.RenderModeEnum.miniApp:
      case t.RenderModeEnum['desktop-miniApp']:
        return 'feishu';
      case t.RenderModeEnum.lynx:
        return 'lynx';
      case t.RenderModeEnum.wx:
        return 'wx';
    }
    return 'browser';
  }
  !(function (t) {
    (t.appear = 'appear'),
      (t.disappear = 'disappear'),
      (t.enter = 'enter'),
      (t.update = 'update'),
      (t.state = 'state'),
      (t.exit = 'exit'),
      (t.normal = 'normal'),
      (t.none = 'none');
  })(RQ || (RQ = {})),
    (function (t) {
      (t.data = 'data'), (t.signal = 'signal'), (t.mark = 'mark');
    })(OQ || (OQ = {})),
    Vq(UG);
  class FQ {
    getVGrammarView() {
      return this._view;
    }
    getModel() {
      return this._model;
    }
    constructor(t, e) {
      (this._viewListeners = new Map()),
        (this._windowListeners = new Map()),
        (this._canvasListeners = new Map()),
        (this.isInited = !1),
        (this.isReleased = !1),
        (this._model = { [OQ.signal]: {}, [OQ.data]: {}, [OQ.mark]: {} }),
        (this._compileChart = null),
        (this._container = t),
        (this._option = e);
    }
    getRenderer() {
      var t;
      return null === (t = this._view) || void 0 === t ? void 0 : t.renderer;
    }
    getCanvas() {
      var t;
      return null === (t = this._view) || void 0 === t ? void 0 : t.renderer.canvas();
    }
    getStage() {
      var t;
      return null === (t = this._view) || void 0 === t ? void 0 : t.renderer.stage();
    }
    initView() {
      var t, e, i, n;
      if (this.isReleased) return;
      if (((this.isInited = !0), this._view)) return;
      const s = new Ze(null !== (t = this._option.logLevel) && void 0 !== t ? t : qe.Error);
      (null === (e = this._option) || void 0 === e ? void 0 : e.onError) &&
        s.addErrorHandler((...t) => {
          this._option.onError(...t);
        }),
        (this._view = new Nq(
          Object.assign(
            Object.assign(
              {
                width: this._width,
                height: this._height,
                hover: !1,
                select: !1,
                container: null !== (i = this._container.dom) && void 0 !== i ? i : null,
                renderCanvas: null !== (n = this._container.canvas) && void 0 !== n ? n : null,
                hooks: this._option.performanceHook,
                cursor: !1
              },
              this._option
            ),
            {
              mode: LQ(this._option.mode),
              autoFit: !1,
              eventConfig: { gesture: Co(this._option.mode), disable: !1 === this._option.interactive },
              doLayout: () => {
                var t;
                null === (t = this._compileChart) || void 0 === t || t.onLayout(this._view);
              },
              logger: s,
              logLevel: s.level()
            }
          )
        )),
        this._setCanvasStyle();
      !1 !== this._option.interactive &&
        this._viewListeners.forEach(t => {
          var e;
          null === (e = this._view) || void 0 === e || e.addEventListener(t.type, t.callback);
        });
    }
    _setCanvasStyle() {
      if (this._view && this._container.dom && !g(this._container.dom)) {
        (this._container.dom.style.display = 'block'), (this._container.dom.style.position = 'relative');
        const t = this.getCanvas();
        t && (t.style.display = 'block');
      }
    }
    compile(t, e) {
      const { chart: i } = t;
      (this._compileChart = i), this.initView(), this._view && (i.compile(), i.afterCompile(), this.updateDepend());
    }
    clear(t) {
      const { chart: e } = t;
      e.clear(), this.releaseGrammar();
    }
    renderAsync(t) {
      var e;
      return yn(this, void 0, void 0, function* () {
        return (
          this.initView(),
          this._view
            ? (yield null === (e = this._view) || void 0 === e ? void 0 : e.runNextTick(t), this)
            : Promise.reject('srView init fail')
        );
      });
    }
    renderSync(t) {
      var e;
      this.initView(), this._view && (null === (e = this._view) || void 0 === e || e.runSync(t));
    }
    updateViewBox(t, e = !0) {
      this._view && this._view.renderer.setViewBox(t, e);
    }
    resize(t, e) {
      return this._view
        ? ((this._width = t), (this._height = e), this._view.resize(t, e), this.renderAsync({ morph: !1 }))
        : Promise.reject();
    }
    setBackground(t) {
      var e;
      null === (e = this._view) || void 0 === e || e.background(t);
    }
    setSize(t, e) {
      (this._width = t), (this._height = e), this._view && (this._view.width(t), this._view.height(e));
    }
    setViewBox(t, e = !0) {
      this._view && this._view.renderer.setViewBox(t, e);
    }
    addEventListener(t, e, i) {
      var n, s;
      if (!1 !== this._option.interactive)
        if (t === Uq.chart) {
          const s = function (n, s) {
            var r, a, o;
            const l =
                null !== (a = null === (r = null == s ? void 0 : s.mark) || void 0 === r ? void 0 : r.context) &&
                void 0 !== a
                  ? a
                  : {},
              c = h(l.modelId) ? l.modelId : null,
              d = h(l.markId) ? l.markId : null,
              u = h(l.modelUserId) ? l.modelUserId : null,
              p = h(l.markUserId) ? l.markUserId : null,
              g = {
                event: n,
                type: e,
                source: t,
                item: s,
                datum: (null === (o = null == s ? void 0 : s.getDatum) || void 0 === o ? void 0 : o.call(s)) || null,
                markId: d,
                modelId: c,
                markUserId: p,
                modelUserId: u
              };
            i.call(null, g);
          }.bind(this);
          this._viewListeners.set(i, { type: e, callback: s }),
            null === (n = this._view) || void 0 === n || n.addEventListener(e, s);
        } else if (t === Uq.window) {
          const n = function (n) {
            const s = {
              event: n,
              type: e,
              source: t,
              item: null,
              datum: null,
              markId: null,
              modelId: null,
              markUserId: null,
              modelUserId: null
            };
            i.call(null, s);
          }.bind(this);
          this._windowListeners.set(i, { type: e, callback: n });
          const s = this._getGlobalThis();
          null == s || s.addEventListener(e, n);
        } else if (t === Uq.canvas) {
          const n = function (n) {
            const s = {
              event: n,
              type: e,
              source: t,
              item: null,
              datum: null,
              markId: null,
              modelId: null,
              markUserId: null,
              modelUserId: null
            };
            i.call(null, s);
          }.bind(this);
          this._canvasListeners.set(i, { type: e, callback: n });
          const r = null === (s = this.getStage()) || void 0 === s ? void 0 : s.window;
          null == r || r.addEventListener(e, n);
        }
    }
    removeEventListener(t, e, i) {
      var n, s, r, a;
      if (!1 !== this._option.interactive)
        if (t === Uq.chart) {
          const t = null === (n = this._viewListeners.get(i)) || void 0 === n ? void 0 : n.callback;
          t && (null === (s = this._view) || void 0 === s || s.removeEventListener(e, t)),
            this._viewListeners.delete(i);
        } else if (t === Uq.window) {
          const t = this._getGlobalThis(),
            n = null === (r = this._windowListeners.get(i)) || void 0 === r ? void 0 : r.callback;
          n && (null == t || t.removeEventListener(e, n)), this._windowListeners.delete(i);
        } else if (t === Uq.canvas) {
          const t = this._getGlobalThis(),
            n = null === (a = this._canvasListeners.get(i)) || void 0 === a ? void 0 : a.callback;
          n && (null == t || t.removeEventListener(e, n)), this._canvasListeners.delete(i);
        }
    }
    releaseEvent() {
      this._viewListeners.clear(), this._windowListeners.clear(), this._canvasListeners.clear();
    }
    release() {
      var t;
      this.releaseEvent(),
        (this._option = this._container = null),
        this._releaseModel(),
        null === (t = this._view) || void 0 === t || t.release(),
        (this._view = null),
        (this.isInited = !1),
        (this._rafId = null),
        (this.isReleased = !0);
    }
    releaseGrammar() {
      var t;
      this._releaseModel(), null === (t = this._view) || void 0 === t || t.removeAllGrammars();
    }
    _releaseModel() {
      Object.keys(this._model).forEach(t => {
        Object.values(this._model[t]).forEach(t => {
          Object.values(t).forEach(t => {
            t.removeProduct(!0);
          });
        }),
          (this._model[t] = {});
      });
    }
    addGrammarItem(t) {
      const e = t.getProduct();
      if (l(e)) return;
      const i = e.id(),
        n = t.grammarType;
      l(this._model[n][i]) && (this._model[n][i] = {}), (this._model[n][i][t.id] = t);
    }
    removeGrammarItem(t, e) {
      var i;
      const n = t.getProduct();
      if (l(n)) return;
      const s = n.id(),
        r = t.grammarType,
        a = this._model[r][s];
      h(a) && (delete a[t.id], 0 === Object.keys(a).length && delete this._model[r][s]),
        e || null === (i = this._view) || void 0 === i || i.removeGrammar(n);
    }
    updateDepend(t) {
      return h(t) && t.length > 0
        ? t.every(t => t.updateDepend())
        : (Object.values(this._model).forEach(t => {
            Object.values(t).forEach(t => {
              const e = Object.values(t),
                i = e[0].getProduct(),
                n = e
                  .reduce((t, e) => (e.getDepend().length > 0 ? t.concat(e.getDepend()) : t), [])
                  .filter(t => !!t)
                  .map(t => t.getProduct());
              i.depend(n);
            });
          }),
          !0);
    }
    _getGlobalThis() {
      var t;
      return To(this._option.mode) ? globalThis : null === (t = this.getStage()) || void 0 === t ? void 0 : t.window;
    }
  }
  function jQ(t, e) {
    var i;
    return yn(this, void 0, void 0, function* () {
      if (!t) return '';
      try {
        if (void 0 !== OffscreenCanvas && t instanceof OffscreenCanvas)
          return (function (t) {
            return new Promise(e => {
              t.convertToBlob().then(t => {
                const i = new FileReader();
                i.readAsDataURL(t),
                  (i.onload = () => {
                    e(i.result);
                  });
              });
            });
          })(t);
      } catch (t) {
        (null !== (i = null == e ? void 0 : e.onError) && void 0 !== i
          ? i
          : wo)(`getCanvasDataURL error : ${t.toString()}`);
      }
      return t.toDataURL();
    });
  }
  function zQ(t) {
    t.crosshair = V(t.crosshair || {}).map(e =>
      _J(
        { [t.direction === JJ.horizontal ? 'yField' : 'xField']: { visible: !0, line: { visible: !0, type: 'rect' } } },
        e
      )
    );
  }
  function HQ(t, e) {
    var i;
    const { width: n, height: s } = t;
    if (h(n) && h(s)) return { width: n, height: s };
    let r = YV,
      a = $V;
    const o = e.container,
      l = e.canvas;
    if (o) {
      const { width: t, height: e } = cn(o, YV, $V);
      (r = t), (a = e);
    } else if (l && To(e.mode)) {
      let t;
      t = g(l) ? (null === document || void 0 === document ? void 0 : document.getElementById(l)) : l;
      const { width: e, height: i } = cn(t, YV, $V);
      (r = e), (a = i);
    } else if (Eo(e.mode) && (null === (i = e.modeParams) || void 0 === i ? void 0 : i.domref)) {
      const t = e.modeParams.domref;
      (r = t.width), (a = t.height);
    }
    return (r = null != n ? n : r), (a = null != s ? s : a), { width: r, height: a };
  }
  class NQ {
    static useChart(t) {
      t.forEach(t => UJ.registerChart(t.type, t));
    }
    static useSeries(t) {
      t.forEach(t => UJ.registerSeries(t.type, t));
    }
    static useComponent(t) {
      t.forEach(t => UJ.registerComponent(t.type, t));
    }
    static useMark(t) {
      t.forEach(t => {
        var e;
        return UJ.registerMark(null !== (e = t.constructorType) && void 0 !== e ? e : t.type, t);
      });
    }
    static useLayout(t) {
      t.forEach(t => UJ.registerLayout(t.type, t));
    }
    static registerDataSetTransform(t, e) {
      UJ.registerTransform(t, e);
    }
    static registerMap(t, e, i) {
      kQ(t, e, i);
    }
    static unregisterMap(t) {
      !(function (t) {
        wQ.has(t) ? wQ.delete(t) : So(`map type of '${t}' does not exists.`);
      })(t);
    }
    static getMap(t) {
      return (e = t), wQ.get(e);
      var e;
    }
    static hideTooltip(t = []) {
      CJ.forEach(t => {
        var e;
        return null === (e = null == t ? void 0 : t.hideTooltip) || void 0 === e ? void 0 : e.call(t);
      }, t);
    }
    static getLogger() {
      return Ze.getInstance();
    }
    getDataSet() {
      return this._dataSet;
    }
    constructor(e, i) {
      var n, s, r, a, o, l;
      (this.id = Ro()),
        (this._userEvents = []),
        (this._autoSize = !0),
        (this._option = { mode: t.RenderModeEnum['desktop-browser'], animation: !0, onError: t => {} }),
        (this._observer = null),
        (this._context = {}),
        (this._onResize = mt((...t) => {
          var e, i;
          const { width: n, height: s } = cn(this._container, YV, $V),
            r = null !== (e = this._spec.width) && void 0 !== e ? e : n,
            a = null !== (i = this._spec.height) && void 0 !== i ? i : s;
          (this._curSize.width === r && this._curSize.height === a) ||
            (this.resize(r, a), (this._curSize = { width: r, height: a }));
        }, 100)),
        (this._option = D(this._option, i)),
        (this._onError = null === (n = this._option) || void 0 === n ? void 0 : n.onError);
      const h = this._option,
        { dom: c, renderCanvas: d, mode: u, stage: p, poptip: f } = h,
        v = mn(h, ['dom', 'renderCanvas', 'mode', 'stage', 'poptip']);
      c &&
        (this._container = g(c) ? (null === document || void 0 === document ? void 0 : document.getElementById(c)) : c),
        d && (this._canvas = d),
        p && (this._stage = p),
        'node' === u || this._container || this._canvas || this._stage
          ? ((this._viewBox = this._option.viewBox),
            (this._currentThemeName = EJ.getCurrentThemeName()),
            this._setSpec(e),
            this._updateCurrentTheme(),
            (this._curSize = HQ(this._spec, {
              container: this._container,
              canvas: this._canvas,
              mode: this._option.mode || t.RenderModeEnum['desktop-browser'],
              modeParams: this._option.modeParams
            })),
            (this._compiler = new FQ(
              { dom: null !== (r = this._container) && void 0 !== r ? r : 'none', canvas: d },
              Object.assign(
                Object.assign({ mode: this._option.mode, stage: p, pluginList: !1 !== f ? ['poptipForText'] : [] }, v),
                { background: this._getBackground(), onError: this._onError }
              )
            )),
            this._compiler.setSize(this._curSize.width, this._curSize.height),
            (this._eventDispatcher = new bQ(this, this._compiler)),
            (this._event = new mQ(this._eventDispatcher, u)),
            this._compiler.initView(),
            null === (a = this.getStage()) ||
              void 0 === a ||
              a.setTheme({ text: { fontFamily: this._currentTheme.fontFamily } }),
            this._initDataSet(this._option.dataSet),
            (this._autoSize =
              !!To(u) &&
              (null === (l = null !== (o = e.autoFit) && void 0 !== o ? o : this._option.autoFit) ||
                void 0 === l ||
                l)),
            this._bindResizeEvent(),
            this._bindVGrammarViewEvent(),
            this._event.emit(Gq.initialized, {}),
            CJ.registerInstance(this))
          : null === (s = this._option) || void 0 === s || s.onError('please specify container or renderCanvas!');
    }
    _setSpec(t) {
      t && (this._spec = DJ(g(t) ? JSON.parse(t) : t));
    }
    _initData() {
      var t;
      if (l(this._dataSet)) return void So('dataSet is not initialized');
      const e = V(this._spec.data),
        i = [];
      for (let n = 0; n < e.length; n++) {
        const s = e[n];
        i.push(EQ(s, this._dataSet, i, { onError: null === (t = this._option) || void 0 === t ? void 0 : t.onError }));
      }
      this._spec.data = i;
    }
    _initChart(e) {
      var i, n;
      if (!this._compiler)
        return void (null === (i = this._option) || void 0 === i || i.onError('compiler is not initialized'));
      this._initData();
      const s = UJ.createChart(e.type, e, {
        globalInstance: this,
        eventDispatcher: this._eventDispatcher,
        dataSet: this._dataSet,
        container: this._container,
        canvas: this._canvas,
        map: new Map(),
        mode: this._option.mode || t.RenderModeEnum['desktop-browser'],
        modeParams: this._option.modeParams,
        getCompiler: () => this._compiler,
        performanceHook: this._option.performanceHook,
        viewBox: this._viewBox,
        animation: this._option.animation,
        getTheme: () => this._currentTheme,
        layout: this._option.layout,
        onError: this._onError
      });
      s
        ? ((this._chart = s),
          this._chart.setCanvasRect(this._curSize.width, this._curSize.height),
          this._chart.created(),
          this._chart.init({}))
        : null === (n = this._option) || void 0 === n || n.onError('init chart fail');
    }
    _releaseData() {
      this._dataSet && ((this._dataSet.dataViewMap = {}), (this._dataSet = null));
    }
    _bindVGrammarViewEvent() {
      this._compiler &&
        !this._compiler.isReleased &&
        (this._compiler.getVGrammarView().addEventListener(tG.ALL_ANIMATION_END, () => {
          this._event.emit(Gq.animationFinished, {});
        }),
        this._compiler.getVGrammarView().addEventListener(tG.AFTER_VRENDER_NEXT_RENDER, () => {
          this._event.emit(Gq.renderFinished, {});
        }));
    }
    _bindResizeEvent() {
      var t;
      if (this._autoSize) {
        if (this._container) {
          const e = window.ResizeObserver;
          (this._observer = new e(this._onResize)),
            null === (t = this._observer) || void 0 === t || t.observe(this._container);
        }
        window.addEventListener('resize', this._onResize);
      }
    }
    _unBindResizeEvent() {
      this._autoSize &&
        (window.removeEventListener('resize', this._onResize),
        this._observer && (this._observer.disconnect(), (this._observer = null)));
    }
    _initDataSet(t) {
      (this._dataSet = t instanceof vo ? t : new vo()),
        SQ(this._dataSet, 'dataview', po),
        SQ(this._dataSet, 'array', _n),
        xQ(this._dataSet, 'stackSplit', PQ),
        xQ(this._dataSet, 'copyDataView', TQ);
      for (const t in UJ.transforms) xQ(this._dataSet, t, UJ.transforms[t]);
      for (const t in UJ.dataParser) SQ(this._dataSet, t, UJ.dataParser[t]);
    }
    updateCustomConfigAndRerender(t, e) {
      return yn(this, void 0, void 0, function* () {
        const i = t();
        return h(i) ? (this._reCompile(i), yield this.renderAsync(e), this) : this;
      });
    }
    updateCustomConfigAndRerenderSync(t, e) {
      const i = t();
      return h(i) ? (this._reCompile(i), this.renderSync(e), this) : this;
    }
    _reCompile(t) {
      var e, i, n;
      t.reMake
        ? (this._releaseData(),
          this._initDataSet(),
          this._chart.release(),
          (this._chart = null),
          null === (e = this._compiler) || void 0 === e || e.releaseGrammar(),
          this._userEvents.forEach(t => this.on(t.eType, t.query, t.callback)))
        : t.reCompile &&
          (null === (i = this._compiler) || void 0 === i || i.clear({ chart: this._chart, vChart: this }),
          null === (n = this._compiler) || void 0 === n || n.compile({ chart: this._chart, vChart: this }, {}));
    }
    renderSync(t) {
      var e, i, n, s, r, a, o, l, h, c, d;
      if (!this._chart) {
        if (
          (null ===
            (i = null === (e = this._option.performanceHook) || void 0 === e ? void 0 : e.beforeInitializeChart) ||
            void 0 === i ||
            i.call(e),
          this._initChart(this._spec),
          null ===
            (s = null === (n = this._option.performanceHook) || void 0 === n ? void 0 : n.afterInitializeChart) ||
            void 0 === s ||
            s.call(n),
          !this._chart || !this._compiler)
        )
          return this;
        null ===
          (a = null === (r = this._option.performanceHook) || void 0 === r ? void 0 : r.beforeCompileToVGrammar) ||
          void 0 === a ||
          a.call(r),
          this._compiler.compile(
            { chart: this._chart, vChart: this },
            { performanceHook: this._option.performanceHook }
          ),
          null ===
            (l = null === (o = this._option.performanceHook) || void 0 === o ? void 0 : o.afterCompileToVGrammar) ||
            void 0 === l ||
            l.call(o);
      }
      return (
        null === (h = this._compiler) || void 0 === h || h.renderSync(t),
        this._option.animation &&
          (null === (c = this._chart) ||
            void 0 === c ||
            c.getAllRegions().forEach(t => {
              var e;
              null === (e = t.animate) || void 0 === e || e.updateAnimateState(RQ.update, !0);
            }),
          null === (d = this._chart) ||
            void 0 === d ||
            d.getAllComponents().forEach(t => {
              var e;
              null === (e = t.animate) || void 0 === e || e.updateAnimateState(RQ.update, !0);
            })),
        this._event.emit(Gq.rendered, {}),
        this
      );
    }
    renderAsync(t) {
      var e, i, n, s, r, a, o, l, h, c, d;
      return yn(this, void 0, void 0, function* () {
        if (!this._chart) {
          if (
            (null ===
              (i = null === (e = this._option.performanceHook) || void 0 === e ? void 0 : e.beforeInitializeChart) ||
              void 0 === i ||
              i.call(e),
            this._initChart(this._spec),
            null ===
              (s = null === (n = this._option.performanceHook) || void 0 === n ? void 0 : n.afterInitializeChart) ||
              void 0 === s ||
              s.call(n),
            !this._chart || !this._compiler)
          )
            return this;
          null ===
            (a = null === (r = this._option.performanceHook) || void 0 === r ? void 0 : r.beforeCompileToVGrammar) ||
            void 0 === a ||
            a.call(r),
            this._compiler.compile(
              { chart: this._chart, vChart: this },
              { performanceHook: this._option.performanceHook }
            ),
            null ===
              (l = null === (o = this._option.performanceHook) || void 0 === o ? void 0 : o.afterCompileToVGrammar) ||
              void 0 === l ||
              l.call(o);
        }
        return (
          yield null === (h = this._compiler) || void 0 === h ? void 0 : h.renderAsync(t),
          this._option.animation &&
            (null === (c = this._chart) ||
              void 0 === c ||
              c.getAllRegions().forEach(t => {
                var e;
                null === (e = t.animate) || void 0 === e || e.updateAnimateState(RQ.update, !0);
              }),
            null === (d = this._chart) ||
              void 0 === d ||
              d.getAllComponents().forEach(t => {
                var e;
                null === (e = t.animate) || void 0 === e || e.updateAnimateState(RQ.update, !0);
              })),
          this._event.emit(Gq.rendered, {}),
          this
        );
      });
    }
    release() {
      var t, e, i, n;
      (null === (t = this._onResize) || void 0 === t ? void 0 : t.cancel) && this._onResize.cancel(),
        null === (e = this._chart) || void 0 === e || e.release(),
        null === (i = this._compiler) || void 0 === i || i.release(),
        null === (n = this._eventDispatcher) || void 0 === n || n.release(),
        (this._userEvents.length = 0),
        this._unBindResizeEvent(),
        this._releaseData(),
        (this._chart = null),
        (this._compiler = null),
        (this._spec = null),
        (this._userEvents = null),
        (this._event = null),
        (this._eventDispatcher = null),
        CJ.unregisterInstance(this);
    }
    updateData(t, e, i) {
      return yn(this, void 0, void 0, function* () {
        if (l(this._dataSet)) return this;
        if (this._chart) return this._chart.updateData(t, e, !0, i), yield this._compiler.renderAsync(), this;
        this._spec.data = V(this._spec.data);
        const n = this._spec.data.find(e => e.name === t || e.id === t);
        return (
          n
            ? n.id === t
              ? (n.values = e)
              : n.name === t && n.parse(e, i)
            : f(e)
            ? this._spec.data.push({ id: t, values: e })
            : this._spec.data.push(e),
          this
        );
      });
    }
    updateDataInBatches(t) {
      return yn(this, void 0, void 0, function* () {
        return this._chart
          ? (t.forEach(({ id: t, data: e, options: i }) => {
              this._chart.updateData(t, e, !1, i);
            }),
            this._chart.updateGlobalScaleDomain(),
            yield this._compiler.renderAsync(),
            this)
          : (t.forEach(({ id: t, data: e, options: i }) => {
              const n = this._spec.data.find(e => e.name === t);
              if (n) n.parse(e, i);
              else {
                const n = new yo(this._dataSet, { name: t });
                n.parse(e, i), this._spec.data.push(n);
              }
            }),
            this);
      });
    }
    updateDataSync(t, e, i) {
      if (l(this._dataSet)) return this;
      if (this._chart) return this._chart.updateData(t, e, !0, i), this._compiler.renderSync(), this;
      const n = this._spec.data.find(e => e.name === t);
      if (n) n.parse(e, i);
      else {
        const n = new yo(this._dataSet, { name: t });
        n.parse(e, i), this._spec.data.push(n);
      }
      return this;
    }
    updateFullDataSync(t, e = !0) {
      if (this._chart) return this._chart.updateFullData(t), e && this._compiler.renderSync(), this;
      return (
        V(t).forEach(t => {
          var e;
          const { id: i, values: n, parser: s, fields: r } = t,
            a = this._spec.data.find(t => t.name === i);
          if (a) a.setFields(r), a.parse(n, s);
          else {
            const i = EQ(t, this._dataSet, this._spec.data, {
              onError: null === (e = this._option) || void 0 === e ? void 0 : e.onError
            });
            this._spec.data.push(i);
          }
        }),
        this
      );
    }
    updateFullData(t, e = !0) {
      return yn(this, void 0, void 0, function* () {
        if (this._chart) return this._chart.updateFullData(t), e && (yield this._compiler.renderAsync()), this;
        return (
          V(t).forEach(t => {
            var e;
            const { id: i, values: n, parser: s, fields: r } = t,
              a = this._spec.data.find(t => t.name === i);
            if (a) a.setFields(r), a.parse(n, s);
            else {
              const i = EQ(t, this._dataSet, this._spec.data, {
                onError: null === (e = this._option) || void 0 === e ? void 0 : e.onError
              });
              this._spec.data.push(i);
            }
          }),
          this
        );
      });
    }
    updateSpec(t, e = !1, i) {
      return yn(this, void 0, void 0, function* () {
        return t
          ? (g(t) && (t = JSON.parse(t)),
            e && (t = _J({}, this._spec, t)),
            yield this.updateCustomConfigAndRerender(() => {
              var e, n;
              return (
                (t = DJ(t)),
                (this._spec = t),
                this._updateCurrentTheme(),
                null === (n = null === (e = this._compiler) || void 0 === e ? void 0 : e.getVGrammarView()) ||
                  void 0 === n ||
                  n.updateLayoutTag(),
                this._chart.updateSpec(t, i)
              );
            }, i),
            this)
          : this;
      });
    }
    updateSpecSync(t, e = !1, i) {
      return t
        ? (g(t) && (t = JSON.parse(t)),
          e && (t = _J({}, this._spec, t)),
          this.updateCustomConfigAndRerenderSync(() => {
            var e, n, s;
            return (
              ((t = DJ(t)).data = null !== (e = t.data) && void 0 !== e ? e : []),
              (this._spec = t),
              this._updateCurrentTheme(),
              null === (s = null === (n = this._compiler) || void 0 === n ? void 0 : n.getVGrammarView()) ||
                void 0 === s ||
                s.updateLayoutTag(),
              this._chart.updateSpec(t, i)
            );
          }, i),
          this)
        : this;
    }
    updateModelSpec(t, e, i = !1, n) {
      return yn(this, void 0, void 0, function* () {
        if (!e || !this._spec) return this;
        if ((g(e) && (e = JSON.parse(e)), o(t) || bJ(this._spec, t, e, i), this._chart)) {
          const s = this._chart.getModelInFilter(t);
          if (s) return this._updateModelSpec(s, e, !1, i, n);
        }
        return this;
      });
    }
    updateModelSpecSync(t, e, i = !1, n) {
      if (!e || !this._spec) return this;
      if ((g(e) && (e = JSON.parse(e)), o(t) || bJ(this._spec, t, e, i), this._chart)) {
        const s = this._chart.getModelInFilter(t);
        if (s) return this._updateModelSpec(s, e, !0, i, n);
      }
      return this;
    }
    _updateModelSpec(t, e, i = !1, n = !1, s) {
      n && (e = _J({}, t.getSpec(), e));
      const r = () => {
        const i = t.updateSpec(e);
        return (
          t.reInit(),
          (i.change || i.reCompile || i.reMake || i.reMakeData || i.reSize || i.reRender) && this._chart.reDataFlow(),
          i
        );
      };
      return i ? this.updateCustomConfigAndRerenderSync(r, s) : this.updateCustomConfigAndRerender(r, s);
    }
    resize(t, e) {
      var i, n, s, r, a, o;
      return yn(this, void 0, void 0, function* () {
        if (!this._chart || !this._compiler) return this;
        const l = this._chart.getCanvasRect();
        return (
          (l && l.width === t && l.height === e) ||
            (null ===
              (n = null === (i = this._option.performanceHook) || void 0 === i ? void 0 : i.beforeResizeWithUpdate) ||
              void 0 === n ||
              n.call(i),
            this._chart.onResize(t, e),
            null ===
              (r = null === (s = this._option.performanceHook) || void 0 === s ? void 0 : s.afterResizeWithUpdate) ||
              void 0 === r ||
              r.call(s),
            yield null === (o = (a = this._compiler).resize) || void 0 === o ? void 0 : o.call(a, t, e)),
          this
        );
      });
    }
    updateViewBox(t, e = !0, i = !0) {
      var n;
      return this._chart && this._compiler
        ? ((this._viewBox = t),
          this._chart.updateViewBox(t, i),
          i && (this._compiler.renderSync(), null === (n = this._chart) || void 0 === n || n.onEvaluateEnd()),
          this._compiler.updateViewBox(t, e),
          this)
        : this;
    }
    on(t, e, i) {
      var n;
      this._userEvents.push({ eType: t, query: e, callback: i }),
        null === (n = this._event) || void 0 === n || n.on(t, e, i);
    }
    off(t, e) {
      var i;
      const n = this._userEvents.findIndex(i => i.eType === t && i.callback === e);
      n >= 0 && this._userEvents.splice(n, 1), null === (i = this._event) || void 0 === i || i.off(t, e);
    }
    updateState(t, e) {
      this._chart && this._chart.updateState(t, e);
    }
    setSelected(t, e, i) {
      this._chart && this._chart.setSelected(t, e, i);
    }
    setHovered(t, e, i) {
      this._chart && this._chart.setHovered(t, e, i);
    }
    _updateCurrentTheme(t) {
      var e, i, n;
      let s,
        r = this._option.theme,
        a = null === (e = this._spec) || void 0 === e ? void 0 : e.theme;
      if (EJ.themeExist(t)) {
        const e = EJ.getTheme(t);
        (r = !r || g(r) ? {} : r), (a = !a || g(a) ? {} : a), (s = xJ({}, e, r, a)), (this._currentThemeName = t);
      } else if (g(a) && EJ.themeExist(a)) (s = xJ({}, EJ.getTheme(a))), (this._currentThemeName = a);
      else if (g(r) && EJ.themeExist(r)) (s = xJ({}, EJ.getTheme(r), OJ(a))), (this._currentThemeName = r);
      else {
        s = xJ({}, OJ(this._currentThemeName), OJ(r), OJ(a));
      }
      var o;
      (this._currentTheme = IJ('theme', s, s.colorScheme)),
        (o = IJ('mark-theme', _J({}, null === (i = this._currentTheme.component) || void 0 === i ? void 0 : i.poptip))),
        D(jY.poptip, FY, o),
        null === (n = this._compiler) || void 0 === n || n.setBackground(this._getBackground());
    }
    _getBackground() {
      return (
        ('string' == typeof this._spec.background ? this._spec.background : null) ||
        this._currentTheme.background ||
        this._option.background
      );
    }
    getCurrentTheme() {
      return this._currentTheme;
    }
    getCurrentThemeName() {
      return this._currentThemeName;
    }
    setCurrentTheme(t) {
      return yn(this, void 0, void 0, function* () {
        return EJ.themeExist(t)
          ? (yield this.updateCustomConfigAndRerender(() => {
              var e;
              return (
                this._updateCurrentTheme(t),
                null === (e = this._chart) || void 0 === e || e.setCurrentTheme(this._currentTheme, !0),
                { change: !0, reMake: !1 }
              );
            }),
            this)
          : this;
      });
    }
    setCurrentThemeSync(t) {
      return EJ.themeExist(t)
        ? (this.updateCustomConfigAndRerenderSync(() => {
            var e;
            return (
              this._updateCurrentTheme(t),
              null === (e = this._chart) || void 0 === e || e.setCurrentTheme(this._currentTheme, !0),
              { change: !0, reMake: !1 }
            );
          }),
          this)
        : this;
    }
    _getTooltipComponent() {
      var t;
      const e =
        null === (t = this._chart) || void 0 === t ? void 0 : t.getAllComponents().find(t => t.type === xn.tooltip);
      return e;
    }
    setTooltipHandler(t) {
      var e, i;
      this._context.tooltipHandler = t;
      const n = this._getTooltipComponent();
      n &&
        (null === (i = null === (e = n.tooltipHandler) || void 0 === e ? void 0 : e.release) ||
          void 0 === i ||
          i.call(e),
        (n.tooltipHandler = t));
    }
    getTooltipHandlerByUser() {
      var t;
      return null === (t = this._context) || void 0 === t ? void 0 : t.tooltipHandler;
    }
    getTooltipHandler() {
      const t = this._getTooltipComponent();
      return t ? t.tooltipHandler : this._context.tooltipHandler;
    }
    showTooltip(t, e) {
      var i;
      const n = this._getTooltipComponent();
      return null !== (i = h(t) && 'none' !== (null == n ? void 0 : n.showTooltip(t, e))) && void 0 !== i && i;
    }
    hideTooltip() {
      var t;
      const e = this._getTooltipComponent();
      return null !== (t = null == e ? void 0 : e.hideTooltip()) && void 0 !== t && t;
    }
    getLegendDataById(t) {
      var e;
      const i = null === (e = this._chart) || void 0 === e ? void 0 : e.getComponentByUserId(t);
      return i ? i.getLegendData() : [];
    }
    getLegendDataByIndex(t = 0) {
      var e;
      const i =
        null === (e = this._chart) || void 0 === e
          ? void 0
          : e.getAllComponents().filter(t => t.type === xn.discreteLegend);
      return i[t] ? i[t].getLegendData() : [];
    }
    getLegendSelectedDataById(t) {
      var e;
      const i = null === (e = this._chart) || void 0 === e ? void 0 : e.getComponentByUserId(t);
      return i ? i.getSelectedData() : [];
    }
    getLegendSelectedDataByIndex(t = 0) {
      var e;
      const i =
        null === (e = this._chart) || void 0 === e
          ? void 0
          : e.getAllComponents().filter(t => t.type === xn.discreteLegend);
      return i[t] ? i[t].getSelectedData() : [];
    }
    setLegendSelectedDataById(t, e) {
      var i;
      const n = null === (i = this._chart) || void 0 === i ? void 0 : i.getComponentByUserId(t);
      n && n.setSelectedData(e);
    }
    setLegendSelectedDataByIndex(t = 0, e) {
      var i;
      const n =
        null === (i = this._chart) || void 0 === i
          ? void 0
          : i.getAllComponents().filter(t => t.type === xn.discreteLegend);
      n[t] && n[t].setSelectedData(e);
    }
    getDataURL() {
      var t;
      return yn(this, void 0, void 0, function* () {
        const e = this.getStage();
        if (this._chart && e) {
          e.render();
          const t = this._chart.getCanvas();
          return yield jQ(t, { onError: this._onError });
        }
        return (
          null === (t = this._option) || void 0 === t || t.onError(new ReferenceError('render is not defined')), null
        );
      });
    }
    exportImg(t) {
      var e, i;
      return yn(this, void 0, void 0, function* () {
        if (!To(this._option.mode))
          return void (
            null === (e = this._option) ||
            void 0 === e ||
            e.onError(new TypeError('non-browser environment can not export img'))
          );
        const n = yield this.getDataURL();
        n
          ? (function (t = 'vchart', e) {
              const i = document.createElement('a');
              i.setAttribute('href', e),
                i.setAttribute('target', '_blank'),
                i.setAttribute('download', `${t}.png`),
                i.dispatchEvent(new MouseEvent('click'));
            })(t, n)
          : null === (i = this._option) || void 0 === i || i.onError(new ReferenceError('render is not defined'));
      });
    }
    getImageBuffer() {
      var t, e;
      if ('node' !== this._option.mode)
        return void (
          null === (t = this._option) ||
          void 0 === t ||
          t.onError(new TypeError('getImageBuffer() now only support node environment.'))
        );
      const i = this.getStage();
      if (i) {
        i.render();
        return i.window.getImageBuffer();
      }
      return (
        null === (e = this._option) || void 0 === e || e.onError(new ReferenceError('render is not defined')), null
      );
    }
    setLayout(t) {
      var e;
      (this._option.layout = t), null === (e = this._chart) || void 0 === e || e.setLayout(t);
    }
    reLayout() {
      var t;
      null === (t = this._chart) || void 0 === t || t.setLayoutTag(!0);
    }
    getCompiler() {
      return this._compiler;
    }
    getChart() {
      return this._chart;
    }
    getStage() {
      return this._compiler.getStage();
    }
    getCanvas() {
      var t;
      return null === (t = this._compiler) || void 0 === t ? void 0 : t.getCanvas();
    }
    getContainer() {
      var t;
      if (h(this._container)) return this._container;
      let e;
      return (
        (e = g(this._canvas)
          ? null === document || void 0 === document
            ? void 0
            : document.getElementById(this._canvas)
          : this._canvas),
        h(e) ? e.parentElement : null === (t = this.getCanvas()) || void 0 === t ? void 0 : t.parentElement
      );
    }
    getComponents() {
      return this._chart.getAllComponents();
    }
    setDimensionIndex(t, e = {}) {
      var i;
      return null === (i = this._chart) || void 0 === i ? void 0 : i.setDimensionIndex(t, e);
    }
    stopAnimation() {
      var t, e, i;
      null ===
        (i =
          null === (e = null === (t = this._compiler) || void 0 === t ? void 0 : t.getVGrammarView()) || void 0 === e
            ? void 0
            : e.animate) ||
        void 0 === i ||
        i.stop();
    }
    pauseAnimation() {
      var t, e, i;
      null ===
        (i =
          null === (e = null === (t = this._compiler) || void 0 === t ? void 0 : t.getVGrammarView()) || void 0 === e
            ? void 0
            : e.animate) ||
        void 0 === i ||
        i.pause();
    }
    resumeAnimation() {
      var t, e, i;
      null ===
        (i =
          null === (e = null === (t = this._compiler) || void 0 === t ? void 0 : t.getVGrammarView()) || void 0 === e
            ? void 0
            : e.animate) ||
        void 0 === i ||
        i.resume();
    }
    convertDatumToPosition(t, e = {}, i = !1) {
      var n;
      if (!this._chart) return null;
      if (T(t)) return null;
      const { seriesId: s, seriesIndex: r = 0 } = e;
      let a;
      if (
        (h(s)
          ? (a = this._chart.getSeriesInUserId(s))
          : h(r) && (a = null === (n = this._chart.getSeriesInIndex([r])) || void 0 === n ? void 0 : n[0]),
        a)
      ) {
        const e = Object.keys(t),
          n = a.getViewData().latestData.find(i => e.every(e => i[e] == t[e])),
          s = a.getLayoutStartPoint();
        let r;
        return (r = n ? a.dataToPosition(n) : a.dataToPosition(t)), bV(r, s, i);
      }
      return null;
    }
    convertValueToPosition(t, e, i = !1) {
      var n, s;
      if (!this._chart || l(t) || T(e)) return null;
      if (!f(t)) {
        const { axisId: s, axisIndex: r } = e;
        let a;
        if (
          (h(s)
            ? (a = this._chart.getComponentsByKey('axes').find(t => t.userId === s))
            : h(r) && (a = null === (n = this._chart.getComponentsByKey('axes')) || void 0 === n ? void 0 : n[r]),
          !a)
        )
          return So('Please check whether the `axisId` or `axisIndex` is set!'), null;
        const o = null == a ? void 0 : a.valueToPosition(t);
        if (i) {
          const t = a.getLayoutStartPoint(),
            e = a.getOrient();
          return o + ('bottom' === e || 'top' === e ? t.x : t.y);
        }
        return o;
      }
      const { seriesId: r, seriesIndex: a } = e;
      let o;
      return (
        h(r)
          ? (o = this._chart.getSeriesInUserId(r))
          : h(a) && (o = null === (s = this._chart.getSeriesInIndex([a])) || void 0 === s ? void 0 : s[0]),
        o
          ? bV(o.valueToPosition(t[0], t[1]), o.getLayoutStartPoint(), i)
          : (So('Please check whether the `seriesId` or `seriesIndex` is set!'), null)
      );
    }
  }
  (NQ.InstanceManager = CJ),
    (NQ.ThemeManager = EJ),
    (NQ.globalConfig = { uniqueTooltip: !0 }),
    (function (t) {
      (t.STATE_NORMAL = 'normal'),
        (t.STATE_HOVER = 'hover'),
        (t.STATE_HOVER_REVERSE = 'hover_reverse'),
        (t.STATE_DIMENSION_HOVER = 'dimension_hover'),
        (t.STATE_DIMENSION_HOVER_REVERSE = 'dimension_hover_reverse'),
        (t.STATE_SELECTED = 'selected'),
        (t.STATE_SELECTED_REVERSE = 'selected_reverse');
    })(BQ || (BQ = {})),
    (function (t) {
      (t.STATE_HOVER_REVERSE = 'hover_reverse'),
        (t.STATE_DIMENSION_HOVER_REVERSE = 'dimension_hover_reverse'),
        (t.STATE_SELECTED_REVERSE = 'selected_reverse');
    })(IQ || (IQ = {})),
    (function (t) {
      (t[(t.NORMAL = 0)] = 'NORMAL'),
        (t[(t.DIMENSION_SELECTED = 1)] = 'DIMENSION_SELECTED'),
        (t[(t.RELATIONAL_SELECTED = 2)] = 'RELATIONAL_SELECTED'),
        (t[(t.SELECTED = 3)] = 'SELECTED'),
        (t[(t.DIMENSION_HOVER = 4)] = 'DIMENSION_HOVER'),
        (t[(t.RELATIONAL_HOVER = 5)] = 'RELATIONAL_HOVER'),
        (t[(t.HOVER = 6)] = 'HOVER');
    })(DQ || (DQ = {}));
  class VQ {
    constructor() {
      (this._children = []), (this._markNameMap = {}), (this._infoMap = new Map());
    }
    getMarkNameMap() {
      return this._markNameMap;
    }
    addMark(t, e) {
      l(t) ||
        (this._children.push(t), (this._markNameMap[t.name] = t), this._infoMap.set(t, D({}, VQ.defaultMarkInfo, e)));
    }
    removeMark(t) {
      const e = this._children.findIndex(e => e.name === t);
      e >= 0 && (this._infoMap.delete(this._children[e]), delete this._markNameMap[t], this._children.splice(e, 1));
    }
    clear() {
      (this._children = []), (this._markNameMap = {}), this._infoMap.clear();
    }
    forEach(t) {
      this._children.forEach(t);
    }
    includes(t, e) {
      return this._children.includes(t, e);
    }
    get(t) {
      return isNaN(Number(t)) ? this._markNameMap[t] : this._children[t];
    }
    getMarks() {
      return [...this._children];
    }
    getMarksInType(t) {
      const e = V(t);
      return this._children.filter(t => e.includes(t.type));
    }
    getMarkInId(t) {
      return this._children.find(e => e.id === t);
    }
    getMarkWithInfo(t) {
      return this._children.find(e => Object.keys(t).every(i => t[i] === this._infoMap.get(e)[i]));
    }
  }
  VQ.defaultMarkInfo = {};
  class WQ {
    get hover() {
      return this._hover;
    }
    get select() {
      return this._select;
    }
    constructor(t) {
      (this._marks = new VQ()),
        (this._markReverse = new VQ()),
        (this._lastDimensionEvent = null),
        (this.onHover = t => {
          const e = this.getEventElement(t);
          switch (t.action) {
            case 'enter':
              this.interaction.getEventElement(BQ.STATE_DIMENSION_HOVER).forEach(t => {
                this.interaction.addEventElement(BQ.STATE_DIMENSION_HOVER_REVERSE, t);
              }),
                this.interaction.clearEventElement(BQ.STATE_DIMENSION_HOVER, !1),
                e.forEach(({ el: t, mark: e }) => {
                  this.interaction.addEventElement(BQ.STATE_DIMENSION_HOVER, t);
                }),
                this.interaction.reverseEventElement(BQ.STATE_DIMENSION_HOVER);
              break;
            case 'leave':
              this.interaction.clearEventElement(BQ.STATE_DIMENSION_HOVER, !0), (t = null);
          }
          this._lastDimensionEvent = t;
        }),
        (this._option = t),
        (this.event = this._option.model.getOption().getChart().getEvent()),
        (this.interaction = t.interaction),
        this.initConfig(t.mode);
    }
    setStateKeys(t) {}
    registerMark(t) {
      T(t.stateStyle[BQ.STATE_DIMENSION_HOVER]) || this._marks.addMark(t),
        T(t.stateStyle[BQ.STATE_DIMENSION_HOVER_REVERSE]) || this._markReverse.addMark(t);
    }
    init() {
      this.initEvent();
    }
    release() {
      this.releaseEvent();
    }
    initEvent() {
      this.event.on(fQ.dimensionHover, this.onHover);
    }
    releaseEvent() {
      this.event.release();
    }
    initConfig(t) {}
    getEventElement(t, e = !1) {
      const i = [];
      return (
        t.dimensionInfo.forEach(t => {
          t.data.forEach(t => {
            const n = (e ? this._markReverse : this._marks)
              .getMarks()
              .filter(e => e.model === t.series && e.getVisible());
            n.forEach(n => {
              const s = n
                .getProduct()
                .elements.filter(i => {
                  const n = i.getDatum();
                  let s;
                  return (s = f(n) ? n.every((e, i) => e === t.datum[i]) : t.datum.some(t => t === n)), e ? !s : s;
                })
                .map(t => ({ el: t, mark: n }));
              i.push(...s);
            });
          });
        }),
        i
      );
    }
    dimensionDataEqual(t) {
      if (this._lastDimensionEvent === t) return !0;
      if (!this._lastDimensionEvent || !t) return !1;
      if (this._lastDimensionEvent.dimensionInfo.length !== t.dimensionInfo.length) return !1;
      for (let e = 0; e < this._lastDimensionEvent.dimensionInfo.length; e++) {
        const i = this._lastDimensionEvent.dimensionInfo[e],
          n = t.dimensionInfo[e];
        if (i.value !== n.value) return !1;
        if (i.axis !== n.axis) return !1;
        if (i.data.length !== n.data.length) return !1;
        for (let t = 0; t < i.data.length; t++) {
          const e = i.data[t],
            s = n.data[t];
          if (e.series !== s.series) return !1;
          if (e.datum.length !== s.datum.length) return !1;
          for (let t = 0; t < e.datum.length; t++) if (e.datum[t] !== s.datum[t]) return !1;
        }
      }
      return !0;
    }
  }
  class GQ {
    getOption() {
      return this._option;
    }
    constructor(t) {
      (this._option = t), (this.getCompiler = this._option.getCompiler);
    }
    getVGrammarView() {
      var t;
      return null === (t = this.getCompiler()) || void 0 === t ? void 0 : t.getVGrammarView();
    }
    release() {
      this._option = null;
    }
  }
  class UQ extends GQ {
    constructor() {
      super(...arguments),
        (this.layoutClip = !1),
        (this._autoIndent = !0),
        (this._layoutStartPoint = { x: 0, y: 0 }),
        (this._layoutRect = { width: 0, height: 0 }),
        (this._minWidth = null),
        (this._maxWidth = null),
        (this._minHeight = null),
        (this._maxHeight = null),
        (this._layoutRectLevelMap = { width: 0, height: 0 }),
        (this._lastComputeRect = null),
        (this._lastComputeOutBounds = { x1: 0, x2: 0, y1: 0, y2: 0 }),
        (this._forceLayoutTag = !1),
        (this.getLayoutRect = () => this._layoutRect),
        (this.layoutType = 'normal'),
        (this._layoutOrient = 'left'),
        (this.layoutPaddingLeft = 0),
        (this.layoutPaddingTop = 0),
        (this.layoutPaddingRight = 0),
        (this.layoutPaddingBottom = 0),
        (this.layoutOffsetX = 0),
        (this.layoutOffsetY = 0),
        (this.layoutLevel = dZ.Region),
        (this.layoutZIndex = 0);
    }
    getSpec() {
      return this._spec;
    }
    getAutoIndent() {
      return this._autoIndent;
    }
    getLayoutStartPoint() {
      return this._layoutStartPoint;
    }
    getLastComputeOutBounds() {
      return this._lastComputeOutBounds;
    }
    get layoutOrient() {
      return this._layoutOrient;
    }
    set layoutOrient(t) {
      this._layoutOrient = t;
    }
    getVisible() {
      var t;
      return !1 !== (null === (t = this._spec) || void 0 === t ? void 0 : t.visible);
    }
    _setLayoutAttributeFromSpec(t, e) {
      if (!1 !== this._spec.visible) {
        const i = yV(_V(t.padding), e, e);
        (this.layoutPaddingLeft = i.left),
          (this.layoutPaddingRight = i.right),
          (this.layoutPaddingTop = i.top),
          (this.layoutPaddingBottom = i.bottom),
          (this._minHeight = l(t.minHeight) ? null : mV(t.minHeight, e.height, e)),
          (this._maxHeight = l(t.maxHeight) ? null : mV(t.maxHeight, e.height, e)),
          (this._minWidth = l(t.minWidth) ? null : mV(t.minWidth, e.width, e)),
          (this._maxWidth = l(t.maxWidth) ? null : mV(t.maxWidth, e.width, e)),
          t.width && this.setLayoutRect({ width: mV(t.width, e.width, e) }, { width: 9 }),
          t.height && this.setLayoutRect({ height: mV(t.height, e.height, e) }, { height: 9 }),
          l(t.offsetX) || (this.layoutOffsetX = mV(t.offsetX, e.width, e)),
          l(t.offsetY) || (this.layoutOffsetY = mV(t.offsetY, e.height, e));
      }
    }
    setAttrFromSpec(t, e) {
      var i, n, s, r, a;
      (this.layoutType = null !== (i = t.layoutType) && void 0 !== i ? i : this.layoutType),
        (this.layoutLevel = null !== (n = t.layoutLevel) && void 0 !== n ? n : this.layoutLevel),
        (this.layoutOrient = null !== (s = t.orient) && void 0 !== s ? s : this.layoutOrient),
        this._setLayoutAttributeFromSpec(t, e),
        (this.layoutClip = null !== (r = t.clip) && void 0 !== r ? r : this.layoutClip),
        (this.layoutZIndex = null !== (a = t.zIndex) && void 0 !== a ? a : this.layoutZIndex);
    }
    onLayoutStart(t, e, i) {
      this._setLayoutAttributeFromSpec(this._spec, e);
    }
    _getAbsoluteSpecValue(t) {
      const e = { top: null, bottom: null, left: null, right: null };
      return (
        ['top', 'bottom', 'left', 'right'].forEach(i => {
          l(this._spec[i]) || (e[i] = mV(this._spec[i], 'top' === i || 'bottom' === i ? t.height : t.width, t));
        }),
        e
      );
    }
    absoluteLayoutInRect(t) {
      const { top: e, bottom: i, left: n, right: s } = this._getAbsoluteSpecValue(t),
        r = {
          width: t.width - this.layoutPaddingLeft - this.layoutPaddingRight,
          height: t.height - this.layoutPaddingTop - this.layoutPaddingBottom
        };
      l(n) || (r.width -= n),
        l(s) || (r.width -= s),
        l(e) || (r.height -= e),
        l(i) || (r.height -= i),
        this.setLayoutRect(r);
      const { width: a, height: o } = this.computeBoundsInRect(this.getLayoutRect());
      this.setLayoutRect({ width: a, height: o });
      const h = { x: t.x, y: t.y };
      !0 === this._spec.center
        ? ((h.x = t.x + 0.5 * t.width - 0.5 * a), (h.y = t.y + 0.5 * t.height - 0.5 * o))
        : (l(n)
            ? l(s) || (h.x = t.x + t.width - this.layoutPaddingRight - s - a)
            : (h.x = t.x + n + this.layoutPaddingLeft),
          l(e)
            ? l(i) || (h.y = t.y + t.height - this.layoutPaddingBottom - i - o)
            : (h.y = t.y + e + this.layoutPaddingTop)),
        this.setLayoutStartPosition(h);
    }
    setLayoutStartPosition({ x: t, y: e }) {
      _(t) && (this._layoutStartPoint.x = t), _(e) && (this._layoutStartPoint.y = e);
    }
    setLayoutRect({ width: t, height: e }, i) {
      var n, s, r, a;
      _(t) &&
        (null !== (n = null == i ? void 0 : i.width) && void 0 !== n ? n : 0) >= this._layoutRectLevelMap.width &&
        ((this._layoutRect.width = t),
        (this._layoutRectLevelMap.width = null !== (s = null == i ? void 0 : i.width) && void 0 !== s ? s : 0)),
        _(e) &&
          (null !== (r = null == i ? void 0 : i.height) && void 0 !== r ? r : 0) >= this._layoutRectLevelMap.height &&
          ((this._layoutRect.height = e),
          (this._layoutRectLevelMap.height = null !== (a = null == i ? void 0 : i.height) && void 0 !== a ? a : 0)),
        this._setRectInSpec(this._layoutRect);
    }
    mergeLayoutRect({ width: t, height: e }) {
      const i = { width: t, height: e };
      return (
        this._layoutRectLevelMap.width > 0 && (i.width = this._layoutRect.width),
        this._layoutRectLevelMap.height > 0 && (i.height = this._layoutRect.height),
        i
      );
    }
    getOrientPosAttribute() {
      return 'bottom' === this._layoutOrient || 'top' === this._layoutOrient ? 'x' : 'y';
    }
    getOrientSizeAttribute() {
      return 'bottom' === this._layoutOrient || 'top' === this._layoutOrient ? 'width' : 'height';
    }
    changeBoundsBySetting(t) {
      return (
        this._layoutRectLevelMap.width > 0 && (t.x2 = t.x1 + this._layoutRect.width),
        this._layoutRectLevelMap.height > 0 && (t.y2 = t.y1 + this._layoutRect.height),
        (t.x1 -= this._layoutStartPoint.x),
        (t.x2 -= this._layoutStartPoint.x),
        (t.y1 -= this._layoutStartPoint.y),
        (t.y2 -= this._layoutStartPoint.y),
        t
      );
    }
    _setRectInSpec(t) {
      const e = Object.assign({}, t);
      return (
        this._layoutRectLevelMap.width < 9
          ? (l(this._minWidth) || (e.width = Math.max(e.width, this._minWidth)),
            l(this._maxWidth) || (e.width = Math.min(e.width, this._maxWidth)))
          : (e.width = this._layoutRect.width),
        this._layoutRectLevelMap.height < 9
          ? (l(this._minHeight) || (e.height = Math.max(e.height, this._minHeight)),
            l(this._maxHeight) || (e.height = Math.min(e.height, this._maxHeight)))
          : (e.height = this._layoutRect.height),
        e
      );
    }
    computeBoundsInRect(t) {
      this._lastComputeRect = t;
      const e = Object.assign({}, this._boundsInRect(this._setRectInSpec(t), t));
      return (
        this.changeBoundsBySetting(e),
        this._autoIndent &&
          ((this._lastComputeOutBounds.x1 = Math.ceil(-e.x1)),
          (this._lastComputeOutBounds.x2 = Math.ceil(e.x2 - t.width)),
          (this._lastComputeOutBounds.y1 = Math.ceil(-e.y1)),
          (this._lastComputeOutBounds.y2 = Math.ceil(e.y2 - t.height))),
        this._setRectInSpec(
          (function (t, e) {
            return t
              ? { width: Math.ceil(Math.min(t.x2 - t.x1, e.width)), height: Math.ceil(Math.min(t.y2 - t.y1, e.height)) }
              : { width: 0, height: 0 };
          })(e, t)
        )
      );
    }
    _boundsInRect(t, e) {
      return { x1: 0, y1: 0, x2: t.width, y2: t.height };
    }
    updateLayoutAttribute() {}
    compile() {}
  }
  class YQ extends GQ {
    constructor() {
      super(...arguments), (this.id = Ro()), (this._compiledProductId = null), (this._depend = []);
    }
    getProduct() {
      if (h(this._product)) return this._product;
      const t = this.getVGrammarView(),
        e = this.getProductId();
      return h(e) && h(t) && (this._product = this._lookupGrammar(e)), this._product;
    }
    getProductId() {
      var t;
      return null !== (t = this._compiledProductId) && void 0 !== t ? t : this.generateProductId();
    }
    getDepend() {
      return this._depend;
    }
    setDepend(...t) {
      this._depend = t;
    }
    compile(t) {
      this._compileProduct(t), this._afterCompile(t);
    }
    _afterCompile(t) {
      var e;
      h(this._product) && (null === (e = this.getCompiler()) || void 0 === e || e.addGrammarItem(this));
    }
    updateDepend() {
      if (h(this._product)) {
        const t = this.getDepend()
          .map(t => t.getProduct())
          .filter(h);
        return this._product.depend(t), t.length === this.getDepend().length;
      }
      return !1;
    }
    release() {
      this.removeProduct(), super.release(), (this._depend = []);
    }
    removeProduct(t) {
      this.getCompiler().removeGrammarItem(this, t), (this._product = null), (this._compiledProductId = null);
    }
  }
  class $Q extends YQ {
    getValue() {
      return this._value;
    }
    getUpdateFunc() {
      return this._updateFunc;
    }
    constructor(t, e, i, n) {
      super(t), (this.grammarType = OQ.signal), (this.name = e), (this._value = i), (this._updateFunc = n);
    }
    updateSignal(t, e) {
      (this._value = t), (this._updateFunc = e), this.compile();
    }
    _compileProduct() {
      const t = this.getVGrammarView();
      if (!t) return;
      if (!this.getProduct()) {
        const e = this.getProductId();
        (this._product = t.signal().id(e)), (this._compiledProductId = e);
      }
      h(this._value) && this._product.value(this._value), h(this._updateFunc) && this._product.update(this._updateFunc);
    }
    generateProductId() {
      return this.name;
    }
    _lookupGrammar(t) {
      var e;
      return null === (e = this.getCompiler().getVGrammarView()) || void 0 === e ? void 0 : e.getSignalById(t);
    }
  }
  class XQ extends GQ {
    constructor() {
      super(...arguments), (this._signalMap = {});
    }
    getSignalMap() {
      return this._signalMap;
    }
    getSignal(t) {
      return this._signalMap[t];
    }
    updateSignal(t, e, i) {
      this._signalMap[t]
        ? this._signalMap[t].updateSignal(e, i)
        : ((this._signalMap[t] = new $Q(this._option, t, e, i)), this._signalMap[t].compile());
    }
    compile() {
      Object.values(this._signalMap).forEach(t => {
        t.compile();
      });
    }
    release() {
      super.release(),
        Object.values(this._signalMap).forEach(t => {
          t.release();
        }),
        (this._signalMap = {});
    }
  }
  class KQ extends XQ {
    getStateMap() {
      return this._stateMap;
    }
    _getDefaultStateMap() {
      return {};
    }
    constructor(t) {
      super(t),
        t.stateKeyToSignalName
          ? (this.stateKeyToSignalName = t.stateKeyToSignalName)
          : (this.stateKeyToSignalName = () => 'state_signal'),
        this.initStateMap();
    }
    initStateMap(t) {
      this._stateMap = null != t ? t : this._getDefaultStateMap();
    }
    compile(t) {
      const e = null != t ? t : this._stateMap;
      Object.keys(e).forEach(t => {
        const i = this.stateKeyToSignalName(t),
          n = e[t];
        this.updateSignal(i, n);
      });
    }
    updateState(t, e) {
      return t
        ? (D(this._stateMap, t), this.compile(t), e ? Promise.resolve() : this.getCompiler().renderAsync())
        : Promise.resolve();
    }
  }
  class qQ extends KQ {
    _getDefaultStateMap() {
      return { layoutUpdateRank: 1 };
    }
    updateLayoutState() {
      return this._stateMap.layoutUpdateRank++, this.updateState({ layoutUpdateRank: this._stateMap.layoutUpdateRank });
    }
  }
  class ZQ extends UQ {
    getData() {
      return this._data;
    }
    getSpecIndex() {
      return this._specIndex;
    }
    getOption() {
      return this._option;
    }
    getMarks() {
      var t, e;
      return null !== (e = null === (t = this._marks) || void 0 === t ? void 0 : t.getMarks()) && void 0 !== e ? e : [];
    }
    getMarkNameMap() {
      var t;
      return null === (t = this._marks) || void 0 === t ? void 0 : t.getMarkNameMap();
    }
    getMarkSet() {
      return this._marks;
    }
    getMarkInfoList() {
      return this.getMarks().map(t => ({ type: t.type, name: t.name }));
    }
    getChart() {
      return this._option.getChart();
    }
    getState() {
      return this.state._stateMap;
    }
    get tooltipHelper() {
      return this._tooltipHelper;
    }
    constructor(t, e) {
      var i, n, s;
      super(e),
        (this.type = 'null'),
        (this.modelType = 'null'),
        (this.userId = void 0),
        (this._data = null),
        (this._specIndex = 0),
        (this.specKey = ''),
        (this._marks = new VQ()),
        (this._lastLayoutRect = null),
        (this._isLayout = !0),
        (this.id = Ro()),
        (this._originalSpec = t),
        (this._spec = BJ(t)),
        (this.userId = t.id),
        (this._specIndex = null !== (i = e.specIndex) && void 0 !== i ? i : 0),
        (this.specKey = null !== (n = e.specKey) && void 0 !== n ? n : ''),
        (this.effect = {}),
        (this.event = new mQ(e.eventDispatcher, e.mode)),
        null === (s = e.map) || void 0 === s || s.set(this.id, this),
        (this._sceneNodeMap = new Map()),
        (this.state = new qQ(
          Object.assign(Object.assign({}, e), { stateKeyToSignalName: this.stateKeyToSignalName.bind(this) })
        ));
    }
    _releaseEvent() {
      this.event.release();
    }
    created() {
      this._initTheme(), this.setAttrFromSpec();
    }
    updateState(t) {
      return this.state.updateState(t);
    }
    init(t) {}
    afterInit() {}
    onLayoutStart(t, e, i) {
      super.onLayoutStart(t, e, i), (this._isLayout = !0);
    }
    onLayoutEnd(t) {
      const e = this.getLayoutRect();
      (!this._forceLayoutTag && z(this._lastLayoutRect, e)) || this.updateLayoutAttribute(),
        (this._forceLayoutTag = !1),
        this.getMarks().forEach(t => t.updateLayoutState(!0, !0)),
        (this._isLayout = !1);
    }
    _forceLayout() {
      var t;
      this._isLayout ||
        ((this._forceLayoutTag = !0),
        null === (t = this._option.globalInstance.getChart()) || void 0 === t || t.setLayoutTag(!0));
    }
    onEvaluateEnd(t) {}
    onDataUpdate() {}
    release() {
      var t;
      this._releaseEvent(),
        (this._originalSpec = {}),
        (this._spec = void 0),
        this.getMarks().forEach(t => t.release()),
        this.state.release(),
        null === (t = this._data) || void 0 === t || t.release(),
        (this._data = this._specIndex = this._sceneNodeMap = null),
        this._marks.clear(),
        super.release();
    }
    updateSpec(t) {
      (this._originalSpec = t), (this._spec = BJ(t));
      return { change: !1, reMake: !1, reMakeData: !1, reRender: !1, reSize: !1, reCompile: !1 };
    }
    reInit(t) {
      this._initTheme(t), this.setAttrFromSpec();
    }
    _initTheme(t) {
      (this._theme = t), this._mergeMarkTheme();
    }
    _mergeMarkTheme() {
      var t, e;
      const i = null === (e = (t = this._option).getTheme) || void 0 === e ? void 0 : e.call(t);
      if (l(i) || l(this._theme)) return;
      const { mark: n, markByName: s } = i;
      this.getMarkInfoList().forEach(({ type: t, name: e }) => {
        var i, r;
        this._theme[e] = _J(
          {},
          null !== (i = null == n ? void 0 : n[V(t)[0]]) && void 0 !== i ? i : {},
          null !== (r = null == s ? void 0 : s[e]) && void 0 !== r ? r : {},
          this._theme[e]
        );
      });
    }
    _mergeThemeToSpec() {
      if (this._shouldMergeThemeToSpec()) {
        const t = this._getDefaultSpecFromChart(this.getChart().getSpec()),
          e = e => _J({}, this._theme, this._prepareSpecBeforeMergingTheme(t), this._prepareSpecBeforeMergingTheme(e));
        f(this._originalSpec) ? (this._spec = this._originalSpec.map(t => e(t))) : (this._spec = e(this._originalSpec));
      }
      this._prepareSpecAfterMergingTheme();
    }
    _getDefaultSpecFromChart(t) {
      return {};
    }
    _shouldMergeThemeToSpec() {
      return !0;
    }
    _prepareSpecBeforeMergingTheme(t) {
      return t;
    }
    _prepareSpecAfterMergingTheme(t) {
      var e, i, n;
      arguments.length || (t = this._spec);
      const s = IJ(
        'spec',
        t,
        null === (n = null === (i = (e = this._option).getTheme) || void 0 === i ? void 0 : i.call(e)) || void 0 === n
          ? void 0
          : n.colorScheme,
        'series' === this.modelType ? this.type : void 0
      );
      return arguments.length || (this._spec = s), s;
    }
    setCurrentTheme(t, e) {}
    updateLayoutAttribute() {}
    setAttrFromSpec() {
      super.setAttrFromSpec(this._spec, this._option.getChartViewRect());
    }
    _convertMarkStyle(t) {
      return Object.assign({}, t);
    }
    setMarkStyle(t, e, i, n) {
      h(t) && h(e) && t.setStyle(this._convertMarkStyle(e), i, n);
    }
    initMarkStyleWithSpec(t, e, i) {
      if (!h(t) || !h(e)) return;
      const { style: n, state: s } = e,
        r = Object.assign({}, e);
      n && (r.style = this._convertMarkStyle(n)),
        s &&
          ((r.state = {}),
          Object.keys(s).forEach(t => {
            r.state[t] = this._convertMarkStyle(s[t]);
          })),
        t.initStyleWithSpec(r, i);
    }
    stateKeyToSignalName(t, e) {
      let i = `${UV}_${this.modelType}_${this.type}_${this.id}_${t}`;
      return e && (i += `_${e}`), i;
    }
    compileData() {
      var t;
      null === (t = this._data) || void 0 === t || t.compile();
    }
    compileMarks(t) {
      this.getMarks().forEach(e => {
        e.compile({ group: t });
      });
    }
    compileSignal() {
      var t;
      null === (t = this.state) || void 0 === t || t.compile();
    }
    bindSceneNode(t) {
      this._sceneNodeMap.set(t.mark.id(), t);
    }
    getSceneNodes() {
      return Array.from(this._sceneNodeMap.values());
    }
    getSceneNodeMarks() {
      return this.getSceneNodes().map(t => t.mark);
    }
    _createMark(t, e = {}) {
      const { type: i, name: n } = t,
        s = UJ.createMark(
          i,
          n,
          Object.assign(
            {
              model: this,
              map: this._option.map,
              getCompiler: this.getCompiler,
              globalScale: this._option.globalScale
            },
            e
          )
        );
      return null == s || s.created(), s;
    }
    _getDataIdKey() {}
  }
  const JQ = {
      arrowLeft: 'M 0.25 -0.5 L -0.25 0 l 0.5 0.5',
      arrowRight: 'M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5',
      rect: 'M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z',
      rectRound:
        'M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z'
    },
    QQ = {
      symbol: function (t, e) {
        var i;
        switch (t) {
          case 'shape':
          case 'symbolType':
            return null !== (i = JQ[e]) && void 0 !== i ? i : e;
          default:
            return e;
        }
      }
    },
    t0 = { symbol: { shape: !0, symbolType: !0 } };
  const e0 = {};
  Object.values(BQ).forEach(t => {
    e0[t] = !0;
  });
  const i0 = {
    [BQ.STATE_HOVER]: BQ.STATE_HOVER_REVERSE,
    [BQ.STATE_SELECTED]: BQ.STATE_SELECTED_REVERSE,
    [BQ.STATE_DIMENSION_HOVER]: BQ.STATE_DIMENSION_HOVER_REVERSE
  };
  function n0(t) {
    return i0[t];
  }
  class s0 {
    constructor() {
      (this._stateMarks = new Map()), (this._stateElements = new Map());
    }
    static markStateEnable(t, e) {
      return !T(t.stateStyle[e]);
    }
    registerMark(t, e) {
      var i;
      this._stateMarks.has(t) || this._stateMarks.set(t, []),
        null === (i = this._stateMarks.get(t)) || void 0 === i || i.push(e);
    }
    getStateMark(t) {
      return this._stateMarks.get(t);
    }
    filterEventMark(t, e) {
      var i;
      return !(!t.mark || !(null === (i = this._stateMarks.get(e)) || void 0 === i ? void 0 : i.includes(t.mark)));
    }
    getEventElement(t) {
      var e;
      return null !== (e = this._stateElements.get(t)) && void 0 !== e ? e : [];
    }
    getEventElementData(t) {
      return this.getEventElement(t).map(t => t.getDatum());
    }
    exchangeEventElement(t, e) {
      var i;
      const n = n0(t);
      null === (i = this._stateElements.get(t)) ||
        void 0 === i ||
        i.forEach(e => {
          e.removeState(t), n && this.addEventElement(n, e);
        }),
        e.getStates().includes(t) || (e.addState(t), n && e.removeState(n)),
        this._stateElements.set(t, [e]);
    }
    removeEventElement(t, e) {
      var i, n;
      e.removeState(t);
      const s =
        null !== (n = null === (i = this._stateElements.get(t)) || void 0 === i ? void 0 : i.filter(t => t !== e)) &&
        void 0 !== n
          ? n
          : [];
      this._stateElements.set(t, s);
      const r = n0(t);
      r && (0 === s.length ? this.clearEventElement(r, !1) : this.addEventElement(r, e));
    }
    addEventElement(t, e) {
      var i;
      e.getStates().includes(t) || e.addState(t);
      const n = null !== (i = this._stateElements.get(t)) && void 0 !== i ? i : [];
      n.push(e), this._stateElements.set(t, n);
    }
    clearEventElement(t, e) {
      var i;
      if (
        (null === (i = this._stateElements.get(t)) ||
          void 0 === i ||
          i.forEach(e => {
            e.removeState(t);
          }),
        this._stateElements.set(t, []),
        e)
      ) {
        const e = n0(t);
        e && this.clearEventElement(e, !1);
      }
    }
    reverseEventElement(t) {
      const e = n0(t);
      if (!e) return;
      const i = this.getStateMark(e);
      if (!i) return;
      const n = this.getEventElement(t);
      if (!n.length) return;
      this.getEventElement(e).length ||
        (1 === n.length
          ? i.forEach(t => {
              t.getProduct()
                .elements.filter(t => t !== n[0])
                .forEach(t => {
                  this.addEventElement(e, t);
                });
            })
          : i.forEach(t => {
              t.getProduct()
                .elements.filter(t => !n.includes(t))
                .forEach(t => {
                  this.addEventElement(e, t);
                });
            }));
    }
  }
  class r0 extends KQ {
    constructor() {
      super(...arguments), (this.id = Ro()), (this.stateKeyToSignalName = t => `${UV}_animate_${this.id}_${t}`);
    }
    getAnimationStateSignalName() {
      return this.stateKeyToSignalName('animationState');
    }
    updateAnimateState(t, e) {
      t === RQ.update
        ? this.updateState({ animationState: { callback: (t, e) => e.diffState } }, e)
        : t === RQ.appear
        ? this.updateState(
            { animationState: { callback: (t, e) => ('exit' === e.diffState ? RQ.none : RQ.appear) } },
            e
          )
        : this.updateState({ animationState: { callback: (e, i) => t } }, e);
    }
    _getDefaultStateMap() {
      return { animationState: { callback: (t, e) => ('exit' === e.diffState ? RQ.none : RQ.appear) } };
    }
  }
  class a0 extends ZQ {
    getGroupMark() {
      return this._groupMark;
    }
    constructor(t, e) {
      var i;
      super(t, e),
        (this.modelType = 'region'),
        (this.type = a0.type),
        (this._series = []),
        (this.layoutType = 'region'),
        (this.layoutZIndex = cZ.Region),
        (this.interaction = new s0()),
        (this.seriesDataFilterOver = () => {
          this.event.emit(Gq.regionSeriesDataFilterOver, { model: this }),
            this._series.forEach(t => t.reTransformViewData());
        }),
        (this.userId = t.id),
        (this.coordinate = null !== (i = t.coordinate) && void 0 !== i ? i : 'cartesian'),
        this._option.animation && (this.animate = new r0({ getCompiler: e.getCompiler })),
        h(t.zIndex) && (this.layoutZIndex = t.zIndex);
    }
    _getClipDefaultValue() {
      var t, e, i, n;
      const s = this._option.getChart().getSpec(),
        r =
          null === (e = null === (t = s.dataZoom) || void 0 === t ? void 0 : t.some) || void 0 === e
            ? void 0
            : e.call(t, t => 'axis' === t.filterMode),
        a =
          null === (n = null === (i = s.scrollBar) || void 0 === i ? void 0 : i.some) || void 0 === n
            ? void 0
            : n.call(i, t => 'axis' === t.filterMode);
      return !(!r && !a) || this.layoutClip;
    }
    created() {
      var t, e;
      super.created(),
        (this._groupMark = this._createMark({ type: jZ.group, name: 'regionGroup' })),
        this._groupMark.setUserId(this.userId),
        this._groupMark.setZIndex(this.layoutZIndex);
      const i = null !== (t = this._spec.clip) && void 0 !== t ? t : this._getClipDefaultValue();
      this.setMarkStyle(
        this._groupMark,
        {
          x: () => this.getLayoutStartPoint().x,
          y: () => this.getLayoutStartPoint().y,
          width: () => this.getLayoutRect().width,
          height: () => this.getLayoutRect().height,
          clip: i
        },
        'normal',
        Jq.Built_In
      ),
        this.setMarkStyle(
          this._groupMark,
          { cornerRadius: null === (e = this._spec.style) || void 0 === e ? void 0 : e.cornerRadius },
          'normal',
          Jq.User_Mark
        ),
        this._marks.addMark(this._groupMark),
        this._spec.style &&
          ((this._backgroundMark = this._createMark({ type: jZ.rect, name: 'regionBackground' })),
          i && (this._foregroundMark = this._createMark({ type: jZ.rect, name: 'regionForeground' })),
          [this._backgroundMark, this._foregroundMark].forEach(t => {
            t &&
              (t.created(),
              this.setMarkStyle(
                t,
                { width: () => this.getLayoutRect().width, height: () => this.getLayoutRect().height },
                'normal',
                Jq.Built_In
              ),
              this._groupMark.addMark(t));
          }),
          this._backgroundMark && this._backgroundMark.setZIndex(0),
          this._foregroundMark && this._foregroundMark.setZIndex(cZ.Mark + 1)),
        this.createTrigger();
    }
    init(t) {
      super.init(t), this.initMark(), this.initSeriesDataflow(), this.initInteraction(), this.initTrigger();
    }
    initMark() {
      this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
    }
    _initBackgroundMarkStyle() {
      var t, e;
      this._backgroundMark &&
        (this.setMarkStyle(
          this._backgroundMark,
          Object.assign(
            { fillOpacity: (null === (t = this._spec.style) || void 0 === t ? void 0 : t.fill) ? 1 : 0 },
            this._spec.style
          ),
          'normal',
          Jq.User_Mark
        ),
        (null !== (e = this._spec.clip) && void 0 !== e ? e : this._getClipDefaultValue()) &&
          this.setMarkStyle(this._backgroundMark, { strokeOpacity: 0 }, 'normal', Jq.Built_In));
    }
    _initForegroundMarkStyle() {
      this._foregroundMark &&
        this.setMarkStyle(
          this._foregroundMark,
          Object.assign(Object.assign({}, this._spec.style), { fillOpacity: 0 }),
          'normal',
          Jq.User_Mark
        );
    }
    updateSpec(t) {
      const e = this._originalSpec,
        i = super.updateSpec(t);
      return (e.style && !(null == t ? void 0 : t.style)) || (!e.style && (null == t ? void 0 : t.style))
        ? ((i.reMake = !0), i)
        : i;
    }
    reInit(t) {
      super.reInit(t), this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
    }
    addSeries(t) {
      t && (this._series.includes(t) || this._series.push(t));
    }
    removeSeries(t) {
      if (!t) return;
      const e = this._series.findIndex(e => e === t);
      e >= 0 && this._series.splice(e, 1);
    }
    getSeries(t = {}) {
      return this._series.filter(e => {
        var i, n;
        return (
          (!t.name || (null == e ? void 0 : e.name) === t.name) &&
          (!t.userId || !e.userId || V(t.userId).includes(e.userId)) &&
          (!h(t.specIndex) || !e.getSpecIndex || V(t.specIndex).includes(e.getSpecIndex())) &&
          (!t.id || e.id === t.id) &&
          (!t.type || e.type === t.type) &&
          (!t.coordinateType || e.coordinate === t.coordinateType) &&
          (!t.dataName ||
            (null === (n = null === (i = e.getRawData) || void 0 === i ? void 0 : i.call(e)) || void 0 === n
              ? void 0
              : n.name) === t.dataName)
        );
      });
    }
    getSeriesInName(t) {
      return this.getSeries({ name: t })[0];
    }
    getSeriesInUserId(t) {
      return this.getSeries({ userId: t })[0];
    }
    getSeriesInId(t) {
      return this.getSeries({ id: t })[0];
    }
    getSeriesInType(t) {
      return this.getSeries({ type: t });
    }
    getSeriesInCoordinateType(t) {
      return this.getSeries({ coordinateType: t });
    }
    getSeriesInDataName(t) {
      return this.getSeries({ dataName: t });
    }
    onRender(t) {}
    initSeriesDataflow() {
      const t = this._series.map(t => t.getViewDataFilter()).filter(t => !!t);
      this._option.dataSet.multipleDataViewAddListener(t, 'change', this.seriesDataFilterOver);
    }
    release() {
      super.release(), (this._series = []);
    }
    createTrigger() {
      const t = Object.assign(Object.assign({}, this._option), { model: this, interaction: this.interaction });
      this._trigger = new WQ(t);
    }
    initTrigger() {
      this._series.forEach(t => {
        t.getMarksWithoutRoot().forEach(t => {
          this._trigger.registerMark(t);
        });
      }),
        this._trigger.init();
    }
    initInteraction() {
      this._series.forEach(t => {
        t.getMarksWithoutRoot().forEach(t => {
          for (const e in IQ) T(t.stateStyle[IQ[e]]) || this.interaction.registerMark(IQ[e], t);
        });
      });
    }
    compileMarks(t) {
      this.getMarks().forEach(e => {
        var i;
        e.compile({ group: t }),
          null === (i = e.getProduct()) ||
            void 0 === i ||
            i.configure({ context: { model: this } }).layout((t, e, i, n) => {});
      });
    }
    compileSignal() {
      var t;
      super.compileSignal(), null === (t = this.animate) || void 0 === t || t.compile();
    }
    compile() {
      this.compileSignal(), this.compileMarks();
    }
    bindSceneNode(t) {
      this._sceneNodeMap.set('default', t);
    }
  }
  a0.type = 'region';
  class o0 {
    constructor(t, e) {
      (this._leftCurrent = 0),
        (this._topCurrent = 0),
        (this._rightCurrent = 0),
        (this._bottomCurrent = 0),
        (this._onError = null == e ? void 0 : e.onError);
    }
    layoutItems(t, e, i, n) {
      (this._chartLayoutRect = i),
        (this._chartViewBox = n),
        (this._leftCurrent = i.x),
        (this._topCurrent = i.y),
        (this._rightCurrent = i.x + i.width),
        (this._bottomCurrent = i.height + i.y),
        e.sort((t, e) => e.layoutLevel - t.layoutLevel),
        this.layoutNormalInlineItems(e.filter(t => 'normal-inline' === t.layoutType)),
        this.layoutNormalItems(e.filter(t => 'normal' === t.layoutType));
      const s = this._leftCurrent,
        r = this._topCurrent,
        a = this._rightCurrent,
        o = this._bottomCurrent,
        l = e.filter(t => 'region' === t.layoutType),
        h = e.filter(t => 'region-relative' === t.layoutType);
      if ((this.layoutRegionItems(l, h), h.some(t => t.getAutoIndent()))) {
        const { top: t, bottom: e, left: i, right: n } = this._checkAutoIndent(h);
        (t || e || i || n) &&
          ((this._topCurrent = r + t),
          (this._bottomCurrent = o - e),
          (this._leftCurrent = s + i),
          (this._rightCurrent = a - n),
          this.layoutRegionItems(l, h));
      }
      this.layoutAbsoluteItems(e.filter(t => 'absolute' === t.layoutType));
    }
    layoutNormalItems(t) {
      t.forEach(t => {
        const e = this.getItemComputeLayoutRect(t),
          i = t.computeBoundsInRect(e);
        t.setLayoutRect(i),
          'left' === t.layoutOrient
            ? (t.setLayoutStartPosition({
                x: this._leftCurrent + t.layoutOffsetX + t.layoutPaddingLeft,
                y: this._topCurrent + t.layoutOffsetY + t.layoutPaddingTop
              }),
              (this._leftCurrent += i.width + t.layoutPaddingLeft + t.layoutPaddingRight))
            : 'top' === t.layoutOrient
            ? (t.setLayoutStartPosition({
                x: this._leftCurrent + t.layoutOffsetX + t.layoutPaddingLeft,
                y: this._topCurrent + t.layoutOffsetY + t.layoutPaddingTop
              }),
              (this._topCurrent += i.height + t.layoutPaddingTop + t.layoutPaddingBottom))
            : 'right' === t.layoutOrient
            ? (t.setLayoutStartPosition({
                x: this._rightCurrent + t.layoutOffsetX - i.width - t.layoutPaddingRight,
                y: this._topCurrent + t.layoutOffsetY + t.layoutPaddingTop
              }),
              (this._rightCurrent -= i.width + t.layoutPaddingLeft + t.layoutPaddingRight))
            : 'bottom' === t.layoutOrient &&
              (t.setLayoutStartPosition({
                x: this._leftCurrent + t.layoutOffsetX + t.layoutPaddingRight,
                y: this._bottomCurrent + t.layoutOffsetY - i.height - t.layoutPaddingBottom
              }),
              (this._bottomCurrent -= i.height + t.layoutPaddingTop + t.layoutPaddingBottom));
      });
    }
    layoutNormalInlineItems(t) {
      const e = t.filter(t => 'left' === t.layoutOrient),
        i = t.filter(t => 'right' === t.layoutOrient),
        n = t.filter(t => 'top' === t.layoutOrient),
        s = t.filter(t => 'bottom' === t.layoutOrient),
        r = this._chartLayoutRect.width + this._chartLayoutRect.x,
        a = this._chartLayoutRect.height + this._chartLayoutRect.y;
      let o = 0,
        l = this._leftCurrent,
        h = this._topCurrent;
      e.forEach((t, e) => {
        const i = this.getItemComputeLayoutRect(t),
          n = t.computeBoundsInRect(i);
        t.setLayoutRect(n);
        const s = n.height + t.layoutPaddingTop + t.layoutPaddingBottom,
          r = n.width + t.layoutPaddingLeft + t.layoutPaddingRight;
        t.setLayoutStartPosition({
          x: l + t.layoutOffsetX + t.layoutPaddingLeft,
          y: h + t.layoutOffsetY + t.layoutPaddingTop
        }),
          (o = Math.max(o, r)),
          (h += s),
          h > a &&
            ((l += o),
            (o = r),
            (h = this._topCurrent + s),
            t.setLayoutStartPosition({
              x: l + t.layoutOffsetX + t.layoutPaddingLeft,
              y: this._topCurrent + t.layoutOffsetY + t.layoutPaddingTop
            }));
      }),
        (this._leftCurrent = l + o);
      let c = 0;
      (l = this._leftCurrent),
        (h = this._topCurrent),
        n.forEach((t, e) => {
          const i = this.getItemComputeLayoutRect(t),
            n = t.computeBoundsInRect(i);
          t.setLayoutRect(n);
          const s = n.height + t.layoutPaddingTop + t.layoutPaddingBottom,
            a = n.width + t.layoutPaddingLeft + t.layoutPaddingRight;
          t.setLayoutStartPosition({
            x: l + t.layoutOffsetX + t.layoutPaddingLeft,
            y: h + t.layoutOffsetY + t.layoutPaddingTop
          }),
            (c = Math.max(c, s)),
            (l += a),
            l > r &&
              ((l = this._leftCurrent + a),
              (h += c),
              (c = s),
              t.setLayoutStartPosition({
                x: this._leftCurrent + t.layoutOffsetX + t.layoutPaddingLeft,
                y: h + t.layoutOffsetY + t.layoutPaddingTop
              }));
        }),
        (this._topCurrent = h + c),
        (o = 0);
      let d = this._rightCurrent;
      (h = this._topCurrent),
        i.forEach((t, e) => {
          const i = this.getItemComputeLayoutRect(t),
            n = t.computeBoundsInRect(i);
          t.setLayoutRect(n);
          const s = n.height + t.layoutPaddingTop + t.layoutPaddingBottom,
            r = n.width + t.layoutPaddingLeft + t.layoutPaddingRight;
          t.setLayoutStartPosition({
            x: d + t.layoutOffsetX - n.width - t.layoutPaddingRight,
            y: h + t.layoutOffsetY + t.layoutPaddingTop
          }),
            (o = Math.max(o, r)),
            (h += s),
            h > a &&
              ((d -= o),
              (o = r),
              (h = this._topCurrent + s),
              t.setLayoutStartPosition({
                x: d + t.layoutOffsetX - n.width - t.layoutPaddingRight,
                y: this._topCurrent + t.layoutOffsetY + t.layoutPaddingTop
              }));
        }),
        (this._rightCurrent = d - o),
        (c = 0),
        (l = this._leftCurrent);
      let u = this._bottomCurrent;
      s.forEach((t, e) => {
        const i = this.getItemComputeLayoutRect(t),
          n = t.computeBoundsInRect(i);
        t.setLayoutRect(n);
        const s = n.height + t.layoutPaddingTop + t.layoutPaddingBottom,
          a = n.width + t.layoutPaddingLeft + t.layoutPaddingRight;
        t.setLayoutStartPosition({
          x: l + t.layoutOffsetX + t.layoutPaddingLeft,
          y: u + t.layoutOffsetY - n.height - t.layoutPaddingBottom
        }),
          (c = Math.max(c, s)),
          (l += a),
          l > r &&
            ((l = this._leftCurrent + a),
            (u -= c),
            (c = s),
            t.setLayoutStartPosition({
              x: this._leftCurrent + t.layoutOffsetX + t.layoutPaddingLeft,
              y: u + t.layoutOffsetY - n.height - t.layoutPaddingBottom
            }));
      }),
        (this._bottomCurrent = u - c);
    }
    layoutRegionItems(t, e) {
      let i = this._rightCurrent - this._leftCurrent,
        n = this._bottomCurrent - this._topCurrent;
      e
        .filter(t => 'left' === t.layoutOrient || 'right' === t.layoutOrient)
        .forEach(t => {
          const e = this.getItemComputeLayoutRect(t),
            i = t.computeBoundsInRect(e);
          t.setLayoutRect({ width: i.width }),
            'left' === t.layoutOrient
              ? (t.setLayoutStartPosition({ x: this._leftCurrent + t.layoutOffsetX + t.layoutPaddingLeft }),
                (this._leftCurrent += i.width + t.layoutPaddingLeft + t.layoutPaddingRight))
              : 'right' === t.layoutOrient &&
                ((this._rightCurrent -= i.width + t.layoutPaddingLeft + t.layoutPaddingRight),
                t.setLayoutStartPosition({ x: this._rightCurrent + t.layoutOffsetX + t.layoutPaddingLeft }));
        }),
        (i = this._rightCurrent - this._leftCurrent),
        e
          .filter(t => 'top' === t.layoutOrient || 'bottom' === t.layoutOrient)
          .forEach(t => {
            const e = this.getItemComputeLayoutRect(t),
              i = t.computeBoundsInRect(e);
            t.setLayoutRect({ height: i.height }),
              'top' === t.layoutOrient
                ? (t.setLayoutStartPosition({ y: this._topCurrent + t.layoutOffsetY + t.layoutPaddingTop }),
                  (this._topCurrent += i.height + t.layoutPaddingTop + t.layoutPaddingBottom))
                : 'bottom' === t.layoutOrient &&
                  ((this._bottomCurrent -= i.height + t.layoutPaddingTop + t.layoutPaddingBottom),
                  t.setLayoutStartPosition({ y: this._bottomCurrent + t.layoutOffsetY + t.layoutPaddingTop }));
          }),
        (n = this._bottomCurrent - this._topCurrent),
        t.forEach(t => {
          t.setLayoutRect({ width: i, height: n }),
            t.setLayoutStartPosition({
              x: this._leftCurrent + t.layoutOffsetX + t.layoutPaddingLeft,
              y: this._topCurrent + t.layoutOffsetY + t.layoutPaddingTop
            });
        }),
        e.forEach(e => {
          if (['left', 'right'].includes(e.layoutOrient)) {
            const i = this.filterRegionsWithID(t, e.layoutBindRegionID[0]);
            e.setLayoutRect({ height: i.getLayoutRect().height }),
              e.setLayoutStartPosition({ y: i.getLayoutStartPoint().y + e.layoutOffsetY + e.layoutPaddingTop });
          } else if (['top', 'bottom'].includes(e.layoutOrient)) {
            const i = this.filterRegionsWithID(t, e.layoutBindRegionID[0]);
            e.setLayoutRect({ width: i.getLayoutRect().width }),
              e.setLayoutStartPosition({ x: i.getLayoutStartPoint().x + e.layoutOffsetX + e.layoutPaddingLeft });
          }
        });
    }
    layoutAbsoluteItems(t) {
      t.forEach(t => {
        t.absoluteLayoutInRect(this._chartLayoutRect);
      });
    }
    filterRegionsWithID(t, e) {
      var i;
      const n = t.find(t => t.id === e);
      return (
        n || (null !== (i = this._onError) && void 0 !== i ? i : wo)('can not find target region item, invalid id'), n
      );
    }
    getItemComputeLayoutRect(t) {
      return {
        width: this._rightCurrent - this._leftCurrent - t.layoutPaddingLeft - t.layoutPaddingRight,
        height: this._bottomCurrent - this._topCurrent - t.layoutPaddingTop - t.layoutPaddingBottom
      };
    }
    _checkAutoIndent(t) {
      const e = { top: 0, left: 0, bottom: 0, right: 0 },
        i = this._chartViewBox.x2 - this._chartViewBox.x1 - this._rightCurrent,
        n = this._chartViewBox.y2 - this._chartViewBox.y1 - this._bottomCurrent;
      return (
        t.forEach(t => {
          if (!t.getVisible() || !t.getAutoIndent()) return;
          const s = 'left' === t.layoutOrient || 'right' === t.layoutOrient,
            r = t.getLastComputeOutBounds();
          s
            ? ((e.top = Math.max(e.top, r.y1 - this._topCurrent)), (e.bottom = Math.max(e.bottom, r.y2 - n)))
            : ((e.left = Math.max(e.left, r.x1 - this._leftCurrent)), (e.right = Math.max(e.right, r.x2 - i)));
        }),
        e
      );
    }
  }
  const l0 = [jZ.line, jZ.area, 'trail'];
  function h0(t) {
    return l0.includes(t);
  }
  class c0 extends KQ {
    getStateInfoList() {
      return this._stateInfoList;
    }
    constructor(t, e) {
      super(t), (this._stateInfoList = []), (this._mark = e);
    }
    _getDefaultStateMap() {
      return { markUpdateRank: 1 };
    }
    getStateInfo(t) {
      return this._stateInfoList.find(e => e.stateValue === t);
    }
    addStateInfo(t) {
      if (this.getStateInfo(t.stateValue)) return;
      t.level = t.level || 0;
      let e = !0;
      for (let i = 0; i < this._stateInfoList.length; i++) {
        const n = this._stateInfoList[i].level;
        if (n && n > t.level) {
          this._stateInfoList.splice(i, 0, t), (e = !1);
          break;
        }
      }
      e && this._stateInfoList.push(t);
    }
    _clearStateBeforeSet(t) {
      (t.datums = null), (t.items = null), (t.fields = null), (t.filter = null);
    }
    changeStateInfo(t) {
      const e = this.getStateInfo(t.stateValue);
      if (e) {
        if (
          (void 0 !== t.datums && (this._clearStateBeforeSet(e), (e.datums = t.datums), (e.datumKeys = t.datumKeys)),
          void 0 !== t.items && (this._clearStateBeforeSet(e), (e.items = t.items)),
          void 0 !== t.fields)
        )
          if ((this._clearStateBeforeSet(e), null === t.fields)) e.fields = t.fields;
          else {
            e.fields = e.fields || {};
            for (const i in t.fields) {
              const n = t.fields[i];
              e.fields[i] = e.fields[i] || {};
              const s = e.fields[i];
              h(n.domain) && (s.domain = n.domain), h(n.type) && (s.type = n.type);
            }
          }
        t.filter && (this._clearStateBeforeSet(e), (e.filter = t.filter));
      } else this.addStateInfo(t);
    }
    clearStateInfo(t) {
      t.forEach(t => {
        this.getStateInfo(t) &&
          this.changeStateInfo({
            stateValue: t,
            datumKeys: null,
            datums: null,
            fields: null,
            items: null,
            filter: null,
            cache: {}
          });
      });
    }
    checkOneState(t, e, i, n) {
      var s;
      n = a(h0) ? n : !t.mark || h0(t.mark.markType);
      let r = !1,
        o = !1;
      if (h(i.datums) && i.datums.length > 0) (r = this.checkDatumState(i, e, n)), (o = !0);
      else if (i.items) (r = null !== (s = this.checkItemsState(i, t)) && void 0 !== s && s), (o = !0);
      else if (i.fields) (r = this.checkFieldsState(i, e, t, n)), (o = !0);
      else if (!r && i.filter) {
        const n = { mark: this._mark, renderNode: t, type: t.mark.markType };
        (r = i.filter(e, n)), (o = !0);
      }
      return o ? (r ? 'in' : 'out') : 'skip';
    }
    checkState(t, e) {
      const i = t
          .getStates()
          .filter(t => !!e0[t])
          .map(t => [t, 10]),
        n = !t.mark || h0(t.mark.markType);
      for (let s = 0; s < this._stateInfoList.length; s++) {
        const r = this._stateInfoList[s],
          a = this.checkOneState(t, e, r, n);
        'skip' !== a && 'in' === a && i.push([r.stateValue, r.level]);
      }
      return i.map(t => t[0]);
    }
    checkDatumState(t, e, i) {
      let n = !1;
      const s = i ? e[0] : e;
      if (f(t.datums)) {
        const e = t.datumKeys || Object.keys(t.datums[0]).filter(t => !t.startsWith(UV));
        n = t.datums.some(t =>
          i && f(null == t ? void 0 : t.items)
            ? e.every(e => {
                var i, n;
                return (
                  (null === (n = null === (i = null == t ? void 0 : t.items) || void 0 === i ? void 0 : i[0]) ||
                  void 0 === n
                    ? void 0
                    : n[e]) === (null == s ? void 0 : s[e])
                );
              })
            : e.every(e => (null == t ? void 0 : t[e]) === (null == s ? void 0 : s[e]))
        );
      } else if (c(t.datums)) {
        const e = t.datumKeys || Object.keys(t.datums).filter(t => !t.startsWith(UV));
        n = e.every(e => {
          var n, r;
          return i
            ? (null === (n = t.datums.items) || void 0 === n ? void 0 : n[0][e]) === s[e]
            : (null === (r = t.datums) || void 0 === r ? void 0 : r[e]) === s[e];
        });
      } else n = e === t.datums;
      return n;
    }
    checkItemsState(t, e) {
      var i;
      return null === (i = t.items) || void 0 === i ? void 0 : i.includes(e);
    }
    checkFieldsState(t, e, i, n) {
      var s;
      let r = !0;
      for (const a in t.fields) {
        const o = t.fields[a],
          l = o.type,
          h = o.domain,
          c = n ? (null === (s = e[0]) || void 0 === s ? void 0 : s[a]) : e[a];
        if (Zo(l) && h.length > 1) {
          if (this.checkLinearFieldState(h, a, e, i, n)) {
            r = !1;
            break;
          }
          r = !0;
        } else {
          if (!h.some(t => t === c)) {
            r = !1;
            break;
          }
          r = !0;
        }
      }
      return r;
    }
    checkLinearFieldState(t, e, i, n, s) {
      var r;
      const a = s ? (null === (r = i[0]) || void 0 === r ? void 0 : r[e]) : i[e];
      return a < t[0] || a > t[t.length - 1];
    }
    updateLayoutState(t) {
      return this._stateMap.markUpdateRank++, this.updateState({ markUpdateRank: this._stateMap.markUpdateRank }, t);
    }
    compileState(t) {
      t.state({ callback: (t, e) => this.checkState(e, t) });
    }
  }
  class d0 extends YQ {
    getDataView() {
      return this._data;
    }
    setDataView(t) {
      this._data = t;
    }
    getLatestData() {
      var t;
      return null === (t = this._data) || void 0 === t ? void 0 : t.latestData;
    }
    constructor(t, e) {
      super(t), (this.grammarType = OQ.data), (this._data = null), (this._data = e);
    }
    release() {
      super.release(), (this._data = null);
    }
    updateData(t) {
      const e = this.getProduct(),
        i = this.getLatestData();
      return e && i && (e.values(i), !t) ? this.getCompiler().renderAsync() : Promise.resolve();
    }
    _compileProduct() {
      const t = this.getLatestData();
      l(t) || (l(this.getProduct()) ? this._initProduct(t) : this._product.values(t));
    }
    _initProduct(t) {
      const e = this.getVGrammarView();
      if (!e || !t) return;
      const i = this.getProductId();
      (this._product = e.data(t).id(i)), (this._compiledProductId = i);
    }
    generateProductId() {
      var t;
      return `${null === (t = this.getDataView()) || void 0 === t ? void 0 : t.name}`;
    }
    _lookupGrammar(t) {
      var e;
      return null === (e = this.getCompiler().getVGrammarView()) || void 0 === e ? void 0 : e.getDataById(t);
    }
  }
  class u0 extends d0 {
    constructor(t) {
      super(t), (this._mark = t.mark);
    }
    setCompiledProductId(t) {
      this._compiledProductId = t;
    }
    generateProductId() {
      const t = super.generateProductId();
      return h(t) ? t : `${UV}_markData_${this._mark.id}`;
    }
    _compileProduct() {
      var t;
      const e = null === (t = this._data) || void 0 === t ? void 0 : t.latestData;
      l(e) || h(this.getProduct()) || this._initProduct(e);
    }
  }
  class p0 extends YQ {
    getSupport3d() {
      return this._support3d;
    }
    setSupport3d(t) {
      this._support3d = t;
    }
    getFacet() {
      return this._facet;
    }
    setFacet(t) {
      this._facet = t;
    }
    getInteractive() {
      return this._interactive;
    }
    setInteractive(t) {
      this._interactive = t;
    }
    getZIndex() {
      return this._zIndex;
    }
    setZIndex(t) {
      this._zIndex = t;
    }
    getVisible() {
      return this._visible;
    }
    setVisible(t) {
      this._visible = t;
    }
    getUserId() {
      return this._userId;
    }
    setUserId(t) {
      h(t) && (this._userId = t);
    }
    getDataView() {
      var t;
      return null === (t = this._data) || void 0 === t ? void 0 : t.getDataView();
    }
    setDataView(t, e) {
      l(this._data) && this.initMarkData(Object.assign(Object.assign({}, this._option), { mark: this })),
        h(e) && this._data.setCompiledProductId(e),
        this._data.setDataView(t);
    }
    getData() {
      return this._data;
    }
    setData(t) {
      this._data = t;
    }
    hasState(t) {
      return t in this.state.getStateMap();
    }
    getState(t) {
      return this.state.getStateMap()[t];
    }
    getAnimationConfig() {
      return this._animationConfig;
    }
    setAnimationConfig(t) {
      this._animationConfig = t;
    }
    setSkipBeforeLayouted(t) {
      this._skipBeforeLayouted = t;
    }
    getSkipBeforeLayouted() {
      return this._skipBeforeLayouted;
    }
    getMorph() {
      return this._morph;
    }
    setMorph(t) {
      this._morph = t;
    }
    getMorphKey() {
      return this._morphKey;
    }
    setMorphKey(t) {
      this._morphKey = t;
    }
    getMorphElementKey() {
      return this._morphElementKey;
    }
    setMorphElementKey(t) {
      this._morphElementKey = t;
    }
    getGroupKey() {
      return this._groupKey;
    }
    setGroupKey(t) {
      this._groupKey = t;
    }
    getLabelSpec() {
      return this._label;
    }
    addLabelSpec(t) {
      this._label || (this._label = []), this._label.push(t);
    }
    getProgressiveConfig() {
      return this._progressiveConfig;
    }
    setProgressiveConfig(t) {
      this._progressiveConfig = t;
    }
    constructor(t, e, i) {
      super(t),
        (this.grammarType = OQ.mark),
        (this.type = void 0),
        (this.name = 'mark'),
        (this._interactive = !0),
        (this._zIndex = cZ.Mark),
        (this._visible = !0),
        (this.stateStyle = {}),
        (this._unCompileChannel = {}),
        (this._skipBeforeLayouted = !1),
        (this._morph = !1),
        (this.name = e),
        (this.model = i),
        (this.key = t.key),
        (this.state = new c0(
          Object.assign(Object.assign({}, t), { stateKeyToSignalName: this.stateKeyToSignalName.bind(this) }),
          this
        )),
        this._option.support3d && this.setSupport3d(!0),
        (this._event = new mQ(i.getOption().eventDispatcher, i.getOption().mode));
    }
    setTransform(t) {
      this._transform = t;
    }
    initMarkData(t) {
      this._data = new u0(t);
    }
    stateKeyToSignalName(t) {
      return `${UV}_${this.type}_${this.id}_${t}`;
    }
    getAttribute(t, e, i, n) {}
    _compileProduct(t) {
      const e = this.getProduct();
      if (!this.getVisible()) return void (h(e) && this.removeProduct());
      if (h(e)) return;
      this.getCompiler().isInited &&
        (this._initProduct(null == t ? void 0 : t.group),
        l(this._product) ||
          (this.compileSignal(),
          this.compileData(),
          this.compileState(),
          this.compileEncode(),
          this.compileAnimation(),
          this.compileContext(),
          this.compileTransform()));
    }
    _initProduct(t) {
      const e = this.getVGrammarView(),
        i = this.getProductId();
      (this._product = e.mark(this.type, null != t ? t : e.rootMark).id(i)), (this._compiledProductId = i);
    }
    generateProductId() {
      return this._userId ? `${this._userId}` : `${this.name}_${this.id}`;
    }
    compileData() {
      var t;
      if (l(this._data)) return;
      this._data.compile();
      const e = this._data.getProduct();
      h(this._product) &&
        h(e) &&
        this._product.join(e, this.key, void 0, null !== (t = this._groupKey) && void 0 !== t ? t : this._facet);
    }
    updateStaticEncode() {
      if (!this._product) return;
      const { enterStyles: t } = this._separateStyle();
      this._product.encodeState(this._facet ? 'group' : 'enter', t);
    }
    _separateStyle() {
      const t = this.stateStyle,
        e = BQ.STATE_NORMAL,
        i = t[e];
      mn(t, ['symbol' == typeof e ? e : e + '']);
      const n = {},
        s = {};
      return (
        Object.keys(i).forEach(t => {
          this._unCompileChannel[t] ||
            (!(function (t, e, i) {
              var n;
              const s = null === (n = e[t]) || void 0 === n ? void 0 : n.style,
                r = (function (t, e) {
                  return (
                    ('fill' === t || 'stroke' === t) &&
                    (null == e ? void 0 : e.gradient) &&
                    (null == e ? void 0 : e.stops)
                  );
                })(t, s);
              return !!r || !!o(s) || !(!(null == s ? void 0 : s.scale) || s.field === i);
            })(t, i, this.getFacet())
              ? (n[t] = this.compileCommonAttributeCallback(t, 'normal'))
              : (s[t] = {
                  callback: this.compileCommonAttributeCallback(t, 'normal'),
                  dependency: [this.stateKeyToSignalName('markUpdateRank')]
                }));
        }),
        { enterStyles: n, updateStyles: s }
      );
    }
    compileEncode() {
      const t = this.stateStyle,
        e = BQ.STATE_NORMAL;
      t[e];
      const i = mn(t, ['symbol' == typeof e ? e : e + '']),
        { enterStyles: n, updateStyles: s } = this._separateStyle();
      this._product.encode(s),
        this._product.encodeState(this._facet ? 'group' : 'enter', n),
        Object.keys(i).forEach(t => {
          const e = {};
          Object.keys(i[t]).forEach(i => {
            this._unCompileChannel[i] ||
              (e[i] = {
                callback: this.compileCommonAttributeCallback(i, t),
                dependency: [this.stateKeyToSignalName('markUpdateRank')]
              });
          }),
            this._product.encodeState(t, e);
        }),
        this._skipBeforeLayouted && this._product.layout({ skipBeforeLayouted: this._skipBeforeLayouted });
    }
    compileState() {
      this.state.compileState(this._product);
    }
    compileAnimation() {
      var t, e;
      if (this._animationConfig) {
        let i;
        if ('component' === this.type)
          i = null === (t = this.model.animate) || void 0 === t ? void 0 : t.getAnimationStateSignalName();
        else {
          const t = this.model.getRegion();
          i = null === (e = t.animate) || void 0 === e ? void 0 : e.getAnimationStateSignalName();
        }
        this._product.animation(this._animationConfig),
          this._product.animationState({
            callback: (t, e, n) => {
              var s;
              return null === (s = n[i]) || void 0 === s ? void 0 : s.callback(t, e);
            },
            dependency: i
          }),
          this._animationConfig.normal &&
            this._event.on(tG.ANIMATION_END, ({ event: t }) => {
              t.mark === this.getProduct() && t.animationState === RQ.appear && this.runAnimationByState(RQ.normal);
            });
      }
    }
    compileContext() {
      const t = {
        interactive: this.getInteractive(),
        zIndex: this.getZIndex(),
        context: { markId: this.id, modelId: this.model.id, markUserId: this._userId, modelUserId: this.model.userId },
        support3d: this.getSupport3d()
      };
      this._progressiveConfig &&
        ((t.progressiveStep = this._progressiveConfig.progressiveStep),
        (t.progressiveThreshold = this._progressiveConfig.progressiveThreshold),
        (t.large = this._progressiveConfig.large),
        (t.largeThreshold = this._progressiveConfig.largeThreshold)),
        this._morph &&
          this._morphKey &&
          ((t.morph = this._morph), (t.morphKey = this._morphKey), (t.morphElementKey = this._morphElementKey)),
        this._product.configure(t);
    }
    compileSignal() {
      this.state.compile();
    }
    compileCommonAttributeCallback(t, e) {
      const i = ((n = this.type), (s = t), !(t0[n] && t0[n][s]));
      var n, s;
      const r = { mark: null, parent: null, element: null };
      return (n, s) => (
        (r.mark = s.mark),
        (r.parent = s.mark.group),
        (r.element = s),
        i
          ? this.getAttribute(t, n, e, r)
          : (function (t, e, i) {
              return QQ[t] ? QQ[t](e, i) : i;
            })(this.type, t, this.getAttribute(t, n, e, r))
      );
    }
    compileTransform() {
      var t;
      (null === (t = this._transform) || void 0 === t ? void 0 : t.length) &&
        this.getProduct().transform(this._transform);
    }
    _lookupGrammar(t) {
      var e;
      return null === (e = this.getCompiler().getVGrammarView()) || void 0 === e ? void 0 : e.getMarkById(t);
    }
    updateState(t, e) {
      return this.state.updateState(t, e);
    }
    updateLayoutState(t, e) {
      return (
        e && this.getMarks().length > 0 && this.getMarks().forEach(t => t.state.updateLayoutState(!0)),
        this.state.updateLayoutState(t)
      );
    }
    updateMarkState(t) {
      if (!this._product) return;
      const e = this.state.getStateInfo(t);
      this._product.elements.forEach(i => {
        'in' === this.state.checkOneState(i, i.getDatum(), e) ? i.addState(t) : i.removeState(t);
      });
    }
    getMarks() {
      return [];
    }
    runAnimationByState(t) {
      var e, i;
      return null === (i = null === (e = this.getProduct()) || void 0 === e ? void 0 : e.animate) || void 0 === i
        ? void 0
        : i.runAnimationByState(t);
    }
    stopAnimationByState(t) {
      var e, i;
      return null === (i = null === (e = this.getProduct()) || void 0 === e ? void 0 : e.animate) || void 0 === i
        ? void 0
        : i.stopAnimationByState(t);
    }
    pauseAnimationByState(t) {
      var e, i;
      return null === (i = null === (e = this.getProduct()) || void 0 === e ? void 0 : e.animate) || void 0 === i
        ? void 0
        : i.pauseAnimationByState(t);
    }
    resumeAnimationByState(t) {
      var e, i;
      return null === (i = null === (e = this.getProduct()) || void 0 === e ? void 0 : e.animate) || void 0 === i
        ? void 0
        : i.resumeAnimationByState(t);
    }
    release() {
      super.release(), this.state.release();
    }
  }
  class g0 extends p0 {
    constructor(t, e) {
      var i;
      super(e, t, e.model),
        (this._extensionChannel = {}),
        (this._computeExChannel = {}),
        (this._attributeContext = e.attributeContext),
        null === (i = e.map) || void 0 === i || i.set(this.id, this);
    }
    created() {
      this._initStyle();
    }
    initStyleWithSpec(t, e) {
      t &&
        (h(t.id) && (this._userId = t.id),
        a(t.interactive) && (this._interactive = t.interactive),
        h(t.zIndex) && this.setZIndex(t.zIndex),
        a(t.visible) && this.setVisible(t.visible),
        this._initSpecStyle(t, this.stateStyle, e));
    }
    convertAngleToRadian(t) {
      if (y(t)) return qt(t);
      if (t.scale) {
        const e = t.scale.range();
        return t.scale.range(e.map(qt)), t;
      }
      return 'function' == typeof t ? (e, i, n, s) => qt(t(e, i, n, s)) : t;
    }
    isUserLevel(t) {
      return [Jq.User_Mark, Jq.User_Series, Jq.User_Chart].includes(t);
    }
    setStyle(t, e = 'normal', i = 0, n = this.stateStyle) {
      if (l(t)) return;
      (t = this._filterStyle(t, e, i, n)), void 0 === n[e] && (n[e] = {});
      const s = this.isUserLevel(i);
      Object.keys(t).forEach(r => {
        let a = t[r];
        l(a) || ((a = this._filterAttribute(r, a, e, i, s, n)), this.setAttribute(r, a, e, i, n));
      });
    }
    getStyle(t, e = 'normal') {
      var i;
      return null === (i = this.stateStyle[e][t]) || void 0 === i ? void 0 : i.style;
    }
    _filterStyle(t, e, i, n = this.stateStyle) {
      return t;
    }
    _filterAttribute(t, e, i, n, s, r = this.stateStyle) {
      let a = this._styleConvert(e);
      return s && 'angle' === t && (a = this.convertAngleToRadian(a)), a;
    }
    setReferer(t, e, i, n = this.stateStyle) {
      var s;
      if (t)
        if (e && i) {
          const r = null !== (s = n[i]) && void 0 !== s ? s : { [e]: {} };
          n[i][e] = Object.assign(Object.assign({}, r[e]), { referer: t });
        } else
          Object.entries(n).forEach(([e, i]) => {
            Object.entries(i).forEach(([i, s]) => {
              n[e][i].referer = t;
            });
          });
    }
    setPostProcess(t, e, i = 'normal') {
      var n;
      (null === (n = this.stateStyle[i]) || void 0 === n ? void 0 : n[t]) && (this.stateStyle[i][t].postProcess = e);
    }
    getAttribute(t, e, i = 'normal', n) {
      return this._computeAttribute(t, e, i, n);
    }
    setAttribute(t, e, i = 'normal', n = 0, s = this.stateStyle) {
      var r;
      void 0 === s[i] && (s[i] = {}), void 0 === s[i][t] && (s[i][t] = { level: n, style: e, referer: void 0 });
      const a = null === (r = s[i][t]) || void 0 === r ? void 0 : r.level;
      h(a) && a <= n && _J(s[i][t], { style: e, level: n }),
        'normal' !== i &&
          t in this._extensionChannel &&
          this._extensionChannel[t].forEach(t => {
            void 0 === s[i][t] && (s[i][t] = s.normal[t]);
          });
    }
    _getDefaultStyle() {
      return { visible: !0, x: 0, y: 0 };
    }
    _styleConvert(t) {
      if (!t) return t;
      if (Jo(t.type) || t.scale) {
        const e = (function (t, e) {
          if ('scale' in t && t.scale)
            return g(t.scale) && (null == e ? void 0 : e.globalScale)
              ? e.globalScale.registerMarkAttributeScale(t, e.dataStatistics)
              : t.scale;
          const i = dV(t.type);
          return (
            i &&
              (function (t, e) {
                t &&
                  e &&
                  (e.domain && t.domain(e.domain),
                  e.range && t.range(e.range),
                  e.specified && t.specified && t.specified(e.specified));
              })(i, t),
            i
          );
        })(t, { globalScale: this._option.globalScale, dataStatistics: this._option.dataStatistics });
        if (e) return { scale: e, field: t.field, changeDomain: t.changeDomain };
      }
      return t;
    }
    _computeAttribute(t, e, i, n) {
      var s;
      let r = null === (s = this.stateStyle[i]) || void 0 === s ? void 0 : s[t];
      r || (r = this.stateStyle.normal[t]);
      let a = this._computeStateAttribute(r, t, e, i, n);
      return (
        o(null == r ? void 0 : r.postProcess) &&
          (a = r.postProcess(a, e, this._attributeContext, n, this.getDataView())),
        t in this._computeExChannel ? this._computeExChannel[t](t, e, i, n, a) : a
      );
    }
    _computeStateAttribute(t, e, i, n, s) {
      var r;
      if (t)
        return t.referer
          ? t.referer.getAttribute(e, i, n, s)
          : 'function' == typeof t.style
          ? t.style(i, this._attributeContext, s, this.getDataView())
          : uZ.includes(t.style.gradient)
          ? this._computeGradientAttr(t.style, i, s)
          : ['outerBorder', 'innerBorder'].includes(e)
          ? this._computeBorderAttr(t.style, i, s)
          : 'threshold' === t.style.type
          ? this._computeThresholdAttr(t.style)
          : Jo(null === (r = t.style.scale) || void 0 === r ? void 0 : r.type)
          ? t.style.scale.scale(i[t.style.field])
          : t.style;
    }
    _initStyle() {
      const t = this._getDefaultStyle();
      this.setStyle(t, 'normal', 0);
    }
    _initSpecStyle(t, e, i) {
      t.style && this.setStyle(t.style, 'normal', Jq.User_Mark, e);
      const n = t.state;
      n &&
        Object.keys(n).forEach(t => {
          const i = n[t];
          if ('style' in i) {
            const n = i.style;
            let s = { stateValue: t };
            'level' in i && (s.level = i.level),
              'filter' in i &&
                (s = o(i.filter)
                  ? Object.assign({ filter: i.filter }, s)
                  : Object.assign(Object.assign({}, i.filter), s)),
              this.state.addStateInfo(s),
              this.setStyle(n, t, Jq.User_Mark, e);
          } else this.setStyle(i, t, Jq.User_Mark, e);
        });
    }
    _computeGradientAttr(t, e, i) {
      var n, s;
      const { gradient: r, scale: a, field: l } = t,
        c = mn(t, ['gradient', 'scale', 'field']),
        d = this.getDataView();
      let u = a,
        p = l;
      if (!((a && l) || 'series' !== this.model.modelType)) {
        const { scale: t, field: e } = this.model.getColorAttribute();
        a || (u = t), p || (p = e);
      }
      const g = sV(
          nV(
            null === (s = null === (n = this.model.getOption()) || void 0 === n ? void 0 : n.getTheme()) || void 0 === s
              ? void 0
              : s.colorScheme,
            'series' === this.model.modelType ? this.model.type : void 0
          ),
          this.model.getDefaultColorDomain()
        ),
        f = {},
        v = Object.assign(Object.assign({}, pZ[r]), c);
      return (
        Object.keys(v).forEach(t => {
          const n = v[t];
          'stops' === t
            ? (f.stops = n.map(t => {
                const { opacity: n, color: s, offset: r } = t;
                let a = null != s ? s : null == u ? void 0 : u.scale(e[p]);
                return (
                  o(s) && (a = s(e, this._attributeContext, i, d)),
                  h(n) && (a = xo.SetOpacity(a, n)),
                  { offset: o(r) ? r(e, this._attributeContext, i, d) : r, color: a || g[0] }
                );
              }))
            : o(n)
            ? (f[t] = n(e, this._attributeContext, i, d))
            : (f[t] = n);
        }),
        (f.gradient = r),
        f
      );
    }
    _computeBorderAttr(t, e, i) {
      var n, s, r;
      const { scale: a, field: l } = t,
        h = mn(t, ['scale', 'field']),
        c = {};
      if (
        (Object.keys(h).forEach(t => {
          const n = h[t];
          o(n) ? (c[t] = n(e, this._attributeContext, i, this.getDataView())) : (c[t] = n);
        }),
        'stroke' in c)
      )
        uZ.includes(null === (r = h.stroke) || void 0 === r ? void 0 : r.gradient) &&
          (c.stroke = this._computeGradientAttr(h.stroke, e, i));
      else {
        const t = sV(
          nV(
            null === (s = null === (n = this.model.getOption()) || void 0 === n ? void 0 : n.getTheme()) || void 0 === s
              ? void 0
              : s.colorScheme,
            'series' === this.model.modelType ? this.model.type : void 0
          ),
          this.model.getDefaultColorDomain()
        );
        let i = a,
          r = l;
        if (!((a && l) || 'series' !== this.model.modelType)) {
          const { scale: n, field: s } = this.model.getColorAttribute();
          a || (i = n), r || (r = s), (c.stroke = (null == i ? void 0 : i.scale(e[r])) || t[0]);
        }
      }
      return c;
    }
    _computeThresholdAttr(t) {
      return new Zl().domain(t.domain).range(t.range).scale(this.getDataView().latestData[0].value);
    }
  }
  class f0 extends g0 {
    constructor() {
      super(...arguments), (this.type = f0.type), (this._marks = []);
    }
    getMarks() {
      return this._marks;
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), { clip: !1 });
    }
    isMarkExist(t) {
      return void 0 !== this._marks.find(e => e.id === t.id || e.name === t.name);
    }
    addMark(t) {
      return this.isMarkExist(t) ? (So('Mark already exists, add mark failed.'), !1) : (this._marks.push(t), !0);
    }
    removeMark(t) {
      const e = this._marks.findIndex(e => e.id === t.id || e.name === t.name);
      return -1 === e ? (So('Mark does not exists, removeMark failed.'), !1) : (this._marks.splice(e, 1), !0);
    }
    getMarkInType(t) {
      return this._marks.filter(e => e.type === t);
    }
    getMarkInId(t) {
      return this._marks.find(e => e.id === t);
    }
    getMarkInName(t) {
      return this._marks.find(e => e.name === t);
    }
    _compileProduct(t) {
      super._compileProduct(t),
        this._product.configure({ zIndex: this.getZIndex() }),
        (null == t ? void 0 : t.ignoreChildren) ||
          this.getMarks().forEach(t => {
            t.getProduct() && t.removeProduct(), t.compile({ group: this._product });
          });
    }
  }
  f0.type = jZ.group;
  class v0 extends g0 {
    constructor(t, e) {
      super(t, e), (this.type = 'component'), (this._componentType = e.componentType), (this._mode = e.mode);
    }
    _initProduct(t) {
      const e = this.getVGrammarView(),
        i = this.getProductId();
      (this._product = e
        .mark(GW.component, null != t ? t : e.rootMark, { componentType: this._componentType, mode: this._mode })
        .id(i)),
        (this._compiledProductId = i);
    }
  }
  v0.type = jZ.component;
  class m0 extends g0 {
    constructor() {
      super(...arguments), (this.type = m0.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), {
        width: void 0,
        height: void 0,
        lineWidth: 0
      });
    }
  }
  (m0.type = jZ.image), NQ.useMark([v0, f0, m0]), UJ.registerRegion('region', a0), UJ.registerLayout('base', o0);
  Ze.getInstance(qe.Error);
  const y0 = { type: 'clipIn' },
    _0 = { type: 'fadeIn' };
  function b0(t, e) {
    if (!1 === e) return {};
    switch (e) {
      case 'grow':
        return (t => ({
          type: t.direction === JJ.horizontal ? 'growPointsXIn' : 'growPointsYIn',
          options: { orient: t.direction === JJ.horizontal ? 'positive' : 'negative' }
        }))(t);
      case 'fadeIn':
        return _0;
      default:
        return y0;
    }
  }
  function x0(t, e = !0) {
    return (i, n, s) => {
      const r = 'vertical' === t.direction ? t.yField : t.xField,
        a = null == i ? void 0 : i[r];
      return 'vertical' === t.direction
        ? { overall: e ? t.growFrom() : e, orient: a > 0 ? 'negative' : 'positive' }
        : { overall: !!e && t.growFrom(), orient: a > 0 ? 'positive' : 'negative' };
    };
  }
  const S0 = (t, e = !0) => ({
      type: t.direction === JJ.horizontal ? 'growWidthIn' : 'growHeightIn',
      options: x0(t, e)
    }),
    w0 = (t, e = !0) => ({ type: t.direction === JJ.horizontal ? 'growWidthOut' : 'growHeightOut', options: x0(t, e) }),
    A0 = { type: 'fadeIn' },
    k0 = { type: 'growCenterIn' };
  function M0(t, e) {
    if (!1 === e) return {};
    switch (e) {
      case 'fadeIn':
        return A0;
      case 'scaleIn':
        return k0;
      default:
        return S0(t);
    }
  }
  const T0 = { type: 'clipIn' },
    C0 = { type: 'fadeIn' };
  function E0(t, e) {
    switch (e) {
      case 'grow':
        return (t => ({
          type: t.direction === JJ.horizontal ? 'growPointsXIn' : 'growPointsYIn',
          options: { orient: t.direction === JJ.horizontal ? 'positive' : 'negative' }
        }))(t);
      case 'fadeIn':
        return C0;
      default:
        return T0;
    }
  }
  function P0(t, e, i) {
    return (n, s, r) =>
      e ? ('radius' === t.growField ? { overall: 0 } : { overall: t.growFrom(n, s, i) }) : { overall: !1 };
  }
  const R0 = t => ({ type: 'radius' === t.growField ? 'growRadiusIn' : 'growAngleIn', options: P0(t, !0, RQ.appear) }),
    O0 = { type: 'fadeIn' },
    B0 = t => ({
      type: 'radius' === t.growField ? 'growRadiusIn' : 'growAngleIn',
      easing: 'linear',
      options: P0(t, !0, RQ.enter)
    }),
    I0 = t => ({
      type: 'radius' === t.growField ? 'growRadiusOut' : 'growAngleOut',
      easing: 'linear',
      options: P0(t, !0, RQ.exit)
    }),
    D0 = t => ({ type: 'radius' === t.growField ? 'growRadiusOut' : 'growAngleOut', options: P0(t, !0, RQ.exit) });
  function L0(t, e) {
    if (!1 === e) return {};
    switch (e) {
      case 'fadeIn':
        return O0;
      case 'growRadius':
        return R0(Object.assign(Object.assign({}, t), { growField: 'radius' }));
      default:
        return R0(Object.assign(Object.assign({}, t), { growField: 'angle' }));
    }
  }
  const F0 = { type: 'fadeIn' };
  function j0(t, e) {
    return 'fadeIn' === e ? F0 : (t => ({ type: 'growAngleIn', options: { overall: t.startAngle } }))(t);
  }
  function z0(t) {
    return () => ('vertical' === t.direction ? { orient: 'negative' } : { orient: 'positive' });
  }
  const H0 = t => ({ type: t.direction === JJ.horizontal ? 'growWidthOut' : 'growHeightOut', options: z0(t) }),
    N0 = { type: 'fadeIn' };
  function V0(t, e) {
    return !1 === e
      ? {}
      : 'fadeIn' === e
      ? N0
      : (t => ({ type: t.direction === JJ.horizontal ? 'growWidthIn' : 'growHeightIn', options: z0(t) }))(t);
  }
  const W0 = t => ({ type: 'in' === t ? 'fadeIn' : 'fadeOut' });
  function G0(t, e, i) {
    return 'fadeIn' === e
      ? W0(i)
      : ((t, e) => ({ type: 'in' === e ? 'growPointsIn' : 'growPointsOut', options: () => ({ center: t.center() }) }))(
          t,
          i
        );
  }
  function U0(t, e, i) {
    return 'fadeIn' === e
      ? W0(i)
      : ((t, e) => {
          const i = () => {
              var e;
              return null === (e = t.center()) || void 0 === e ? void 0 : e.x;
            },
            n = (t, e) => e.getGraphicAttribute('x'),
            s = () => {
              var e;
              return null === (e = t.center()) || void 0 === e ? void 0 : e.y;
            },
            r = (t, e) => e.getGraphicAttribute('y');
          return 'in' === e
            ? { channel: { x: { from: i, to: n }, y: { from: s, to: r } } }
            : { channel: { x: { from: n, to: i }, y: { from: r, to: s } } };
        })(t, i);
  }
  const Y0 = (t, e) => ({
    custom: KM,
    customParameters: (i, n) => {
      var s;
      return {
        group: n.getGraphicItem(),
        startAngle: null !== (s = t.startAngle) && void 0 !== s ? s : Math.PI / 2,
        orient: 'clockwise',
        center: t.center(),
        radius: t.radius(),
        animationType: e
      };
    }
  });
  class $0 extends wM {
    constructor(t, e, i, n, s) {
      super(t, e, i, n, s);
      const r = this.params.pointToCoord,
        a = this.params.coordToPoint;
      (o(r) && o(a)) || (this.valid = !1), (this._pointToCoord = r), (this._coordToPoint = a);
    }
    getEndProps() {
      return !1 === this.valid ? {} : this._coordToPoint({ angle: this._toAngle, radius: this._toRadius });
    }
    onBind() {
      const { angle: t, radius: e } = this._pointToCoord(this.from);
      _(t * e) || (this.valid = !1), (this._fromAngle = t), (this._fromRadius = e);
      const { angle: i, radius: n } = this._pointToCoord(this.to);
      _(i * n) || (this.valid = !1), (this._toAngle = i), (this._toRadius = n);
    }
    onUpdate(t, e, i) {
      if (!1 !== this.valid)
        if (t) {
          const { x: t, y: e } = this.getEndProps();
          (i.x = t), (i.y = e);
        } else {
          const { x: t, y: n } = this._coordToPoint({
            angle: this._fromAngle + (this._toAngle - this._fromAngle) * e,
            radius: this._fromRadius + (this._toRadius - this._fromRadius) * e
          });
          (i.x = t), (i.y = n);
        }
    }
  }
  class X0 extends $M {
    constructor(t, e, i, n, s) {
      super(t, e, i, n, s);
      const r = this.params.pointToCoord,
        a = this.params.coordToPoint;
      (this._pointToCoord = r), (this._coordToPoint = a);
    }
    onUpdate(t, e, i) {
      (this.points = this.points.map((t, i) => {
        const n = this.polarPointInterpolation(this.interpolatePoints[i][0], this.interpolatePoints[i][1], e);
        return (n.context = t.context), n;
      })),
        (i.points = this.points);
    }
    polarPointInterpolation(t, e, i) {
      const n = this._pointToCoord(t),
        s = this._pointToCoord({ x: t.x1, y: t.y1 }),
        r = this._pointToCoord(e),
        a = this._pointToCoord({ x: e.x1, y: e.y1 }),
        o = n.angle + (r.angle - n.angle) * i,
        l = n.radius + (r.radius - n.radius) * i,
        h = s.angle + (a.angle - s.angle) * i,
        c = s.radius + (a.radius - s.radius) * i,
        { x: d, y: u } = this._coordToPoint({ angle: o, radius: l }),
        { x: p, y: g } = this._coordToPoint({ angle: h, radius: c }),
        f = new Ut(d, u, p, g);
      return (f.defined = e.defined), f;
    }
  }
  const K0 = t => {
      const e = 'angle' === t.growField ? 0 : t.innerRadius;
      return 'angle' === t.growField
        ? { type: 'angle' === t.growField ? 'growAngleIn' : 'growRadiusIn' }
        : {
            channel: {
              innerRadius: { from: e, to: (t, e) => e.getGraphicAttribute('innerRadius') },
              outerRadius: { from: e, to: (t, e) => e.getGraphicAttribute('outerRadius') }
            }
          };
    },
    q0 = { type: 'fadeIn' },
    Z0 = t => ({ type: 'angle' === t.growField ? 'growAngleIn' : 'growRadiusIn' }),
    J0 = t => ({ type: 'angle' === t.growField ? 'growAngleOut' : 'growRadiusOut' }),
    Q0 = t => ({ type: 'angle' === t.growField ? 'growAngleOut' : 'growRadiusOut' });
  function t1(t, e) {
    if (!1 === e) return {};
    switch (e) {
      case 'fadeIn':
        return q0;
      case 'growAngle':
        return K0(Object.assign(Object.assign({}, t), { growField: 'angle' }));
      default:
        return K0(Object.assign(Object.assign({}, t), { growField: 'radius' }));
    }
  }
  const e1 = { type: 'fadeIn' },
    i1 = { type: 'growCenterIn' };
  function n1(t, e) {
    switch (e) {
      case 'fadeIn':
        return e1;
      case 'scaleIn':
        return i1;
      default:
        return S0(t, !1);
    }
  }
  const s1 = (t, e) => ('fadeIn' === e ? { type: 'fadeIn' } : { type: 'scaleIn' }),
    r1 = t => ({ type: 'growCenterIn', options: { direction: 'horizontal' === t.direction ? 'x' : 'y' } }),
    a1 = { type: 'fadeIn' },
    o1 = t => ({ type: 'growCenterOut', options: { direction: 'horizontal' === t.direction ? 'x' : 'y' } });
  function l1(t, e) {
    return 'fadeIn' === e ? a1 : r1(t);
  }
  const h1 = t => ({ custom: ZM, customParameters: (e, i) => t, easing: 'linear', loop: 1 / 0, duration: 6e3 }),
    c1 = (t, e) => {
      switch (e) {
        case 'fadeIn':
          return { type: 'fadeIn' };
        case 'growAngle':
          return { type: 'growAngleIn' };
        default:
          return { type: 'growRadiusIn' };
      }
    },
    d1 = (t, e) => {
      const i = (t - e[0]) / (e[1] - e[0] || 1);
      return Math.max(0, Math.min(1, i));
    },
    u1 = t => {
      const e = t.mark.elements.filter(t => t.diffState === WW.update),
        i = Math.min(
          ...e.map(t => {
            var e;
            return null === (e = null == t ? void 0 : t.data) || void 0 === e ? void 0 : e[0].depth;
          })
        );
      return e.filter(t => {
        var e;
        return (null === (e = null == t ? void 0 : t.data) || void 0 === e ? void 0 : e[0].depth) === i;
      });
    },
    p1 = (t, e, i) => {
      if (T(t)) return [e, i];
      const n = Math.min(...t.map(t => t.getGraphicAttribute('startAngle', !1))),
        s = Math.max(...t.map(t => t.getGraphicAttribute('endAngle', !1)));
      return [n, s];
    },
    g1 = t => ({
      channel: {
        startAngle: {
          from: (e, i) => {
            const { startAngle: n, endAngle: s } = t.animationInfo(),
              r = u1(i),
              a = p1(r, n, s);
            return d1(e.startAngle, a) * (s - n) + n;
          },
          to: t => t.startAngle
        },
        endAngle: {
          from: (e, i) => {
            const { startAngle: n, endAngle: s } = t.animationInfo(),
              r = u1(i),
              a = p1(r, n, s);
            return d1(e.endAngle, a) * (s - n) + n;
          },
          to: t => t.endAngle
        },
        outerRadius: { from: t => t.innerRadius, to: t => t.outerRadius },
        innerRadius: { from: t => t.innerRadius, to: t => t.innerRadius }
      }
    }),
    f1 = t => {
      const e = Math.min(...t.map(t => t.getGraphicAttribute('startAngle', !1))),
        i = Math.max(...t.map(t => t.getGraphicAttribute('endAngle', !1)));
      return [e, i];
    },
    v1 = t => ({
      channel: {
        startAngle: {
          from: (t, e) => e.getGraphicAttribute('startAngle', !1),
          to: (e, i) => {
            const { startAngle: n, endAngle: s } = t.animationInfo(),
              r = u1(i),
              a = f1(r);
            return d1(i.getGraphicAttribute('startAngle', !1), a) * (s - n) + n;
          }
        },
        endAngle: {
          from: (t, e) => e.getGraphicAttribute('endAngle', !1),
          to: (e, i) => {
            const { startAngle: n, endAngle: s } = t.animationInfo(),
              r = u1(i),
              a = f1(r);
            return d1(i.getGraphicAttribute('endAngle', !1), a) * (s - n) + n;
          }
        },
        outerRadius: {
          from: (t, e) => e.getGraphicAttribute('outerRadius', !1),
          to: () => t.animationInfo().innerRadius
        },
        innerRadius: {
          from: (t, e) => e.getGraphicAttribute('innerRadius', !1),
          to: () => t.animationInfo().innerRadius
        }
      }
    }),
    m1 = (t, e) => ('fadeIn' === e ? { type: 'fadeIn' } : { type: 'growRadiusIn' }),
    y1 = { type: 'fadeIn' };
  function _1(t) {
    return !1 === t ? {} : y1;
  }
  const b1 = {
      appear: { duration: 1e3, easing: 'cubicOut' },
      update: { type: 'update', duration: 300, easing: 'linear' },
      enter: { duration: 300, easing: 'linear' },
      exit: { duration: 300, easing: 'linear' },
      disappear: { duration: 500, easing: 'cubicIn' }
    },
    x1 = {
      bar: (t, e) => ({ appear: M0(t, e), enter: S0(t, !1), exit: w0(t, !1), disappear: w0(t) }),
      bar3d: (t, e) => ({ appear: M0(t, e), enter: S0(t, !1), exit: w0(t, !1), disappear: w0(t) }),
      line: (t, e) => ({
        appear: E0(t, e),
        enter: { type: 'fadeIn' },
        exit: { type: 'fadeOut' },
        update: [
          { options: { excludeChannels: 'points' } },
          { channel: ['points'], custom: $M, duration: b1.update.duration, easing: b1.update.easing }
        ],
        disappear: { type: 'clipOut' }
      }),
      area: (t, e) => ({
        appear: b0(t, e),
        enter: { type: 'fadeIn' },
        exit: { type: 'fadeOut' },
        disappear: { type: 'clipOut' }
      }),
      pie: (t, e) => ({ appear: L0(t, e), enter: B0(t), exit: I0(t), disappear: D0(t) }),
      pie3d: (t, e) => ({ appear: L0(t, e), enter: B0(t), exit: I0(t), disappear: D0(t) }),
      rose: (t, e) => ({ appear: t1(t, e), enter: Z0(t), exit: J0(t), disappear: Q0(t) }),
      radar: (t, e) => ({
        appear: 'clipIn' === e ? void 0 : G0(t, e, 'in'),
        enter: G0(t, e, 'in'),
        exit: G0(t, e, 'out'),
        disappear: 'clipIn' === e ? void 0 : G0(t, e, 'out'),
        update: [
          { options: { excludeChannels: 'points' } },
          {
            channel: ['points'],
            custom: X0,
            customParameters: t,
            duration: b1.update.duration,
            easing: b1.update.easing
          }
        ]
      }),
      radarSymbol: (t, e) => ({
        appear: 'clipIn' === e ? void 0 : U0(t, e, 'in'),
        enter: { type: 'scaleIn' },
        exit: { type: 'scaleOut' },
        disappear: 'clipIn' === e ? void 0 : U0(t, e, 'out'),
        update: [
          { options: { excludeChannels: ['x', 'y'] } },
          {
            channel: ['x', 'y'],
            custom: $0,
            customParameters: t,
            duration: b1.update.duration,
            easing: b1.update.easing
          }
        ]
      }),
      radarGroup: (t, e) => ({ appear: Y0(t, 'in'), disappear: Y0(t, 'out') }),
      circularProgress: (t, e) => ({
        appear: j0(t, e),
        enter: { type: 'growAngleIn' },
        disappear: { type: 'growAngleOut' }
      }),
      scatter: (t, e) => ({
        appear: s1(0, e),
        enter: { type: 'scaleIn' },
        exit: { type: 'scaleOut' },
        disappear: { type: 'scaleOut' }
      }),
      progressBackground: () => ({
        appear: { type: 'fadeIn' },
        enter: { type: 'fadeIn' },
        exit: { type: 'fadeOut' },
        disappear: { type: 'fadeOut' }
      }),
      linearProgress: (t, e) => ({ appear: V0(t, e), enter: { type: 'grow' }, disappear: H0(t) }),
      symbol: () => ({
        appear: { type: 'scaleIn' },
        enter: { type: 'scaleIn' },
        exit: { type: 'scaleOut' },
        disappear: { type: 'scaleOut' }
      }),
      label: () => ({
        appear: { type: 'fadeIn' },
        enter: { type: 'fadeIn' },
        exit: { type: 'fadeOut' },
        disappear: { type: 'fadeOut' }
      }),
      path: () => ({
        appear: { type: 'fadeIn' },
        enter: { type: 'fadeIn' },
        exit: { type: 'fadeOut' },
        disappear: { type: 'fadeOut' }
      }),
      funnel: (t, e) => ({
        appear: 'clipIn' === e ? void 0 : { type: 'fadeIn' },
        enter: { type: 'fadeIn' },
        exit: { type: 'fadeOut' },
        disappear: { type: 'fadeOut' }
      }),
      funnel3d: () => ({
        appear: { type: 'fadeIn' },
        enter: { type: 'fadeIn' },
        exit: { type: 'fadeOut' },
        disappear: { type: 'fadeOut' }
      }),
      cartesianGroup: t => ({
        appear: {
          custom: qM,
          customParameters: (e, i) => ({
            animationType: 'in',
            group: i.getGraphicItem(),
            direction: t.direction(),
            width: t.width(),
            height: t.height(),
            orient: t.orient()
          })
        },
        disappear: {
          custom: qM,
          customParameters: (e, i) => ({
            animationType: 'out',
            group: i.getGraphicItem(),
            direction: t.direction(),
            width: t.width(),
            height: t.height(),
            orient: t.orient()
          })
        }
      }),
      wordCloud: () => ({
        appear: { type: 'fadeIn' },
        enter: { type: 'fadeIn' },
        exit: { type: 'fadeOut' },
        disappear: { type: 'fadeOut' }
      }),
      wordCloud3d: t => ({ appear: h1(t) }),
      rangeColumn: (t, e) => ({ appear: l1(t, e), enter: r1(t), exit: o1(t), disappear: o1(t) }),
      waterfall: (t, e) => ({ appear: n1(t, e), enter: S0(t, !1), exit: w0(t, !1), disappear: w0(t, !1) }),
      boxPlot: () => ({
        appear: { type: 'scaleIn' },
        enter: { type: 'scaleIn' },
        exit: { type: 'scaleOut' },
        disappear: { type: 'scaleOut' }
      }),
      treemap: () => ({
        appear: { type: 'growCenterIn' },
        enter: { type: 'growCenterIn' },
        exit: { type: 'growCenterOut' },
        disappear: { type: 'growCenterOut' }
      }),
      sankeyNode: () => ({
        appear: { type: 'fadeIn' },
        enter: { type: 'fadeIn' },
        exit: { type: 'fadeOut' },
        disappear: { type: 'fadeOut' }
      }),
      sankeyLinkPath: () => ({
        appear: { type: 'linkPathGrowIn' },
        enter: { type: 'linkPathGrowIn' },
        exit: { type: 'linkPathGrowOut' },
        disappear: { type: 'linkPathGrowOut' }
      }),
      sunburst: (t, e) => ({ appear: c1(0, e), enter: g1(t), exit: v1(t), disappear: v1(t) }),
      circlePacking: (t, e) => ({
        appear: m1(0, e),
        enter: { type: 'growRadiusIn' },
        exit: { type: 'growRadiusOut' },
        disappear: { type: 'growRadiusOut' }
      }),
      heatmap: (t, e) => ({
        appear: _1(e),
        enter: { type: 'fadeIn' },
        exit: { type: 'fadeOut' },
        disappear: { type: 'fadeOut' }
      }),
      axis: () => ({ appear: { custom: Y$ }, update: { custom: U$ }, exit: { custom: JM } })
    },
    S1 = ['appear', 'enter', 'update', 'exit', 'disappear', 'normal'];
  function w1(t, e, i) {
    var n;
    const s = {};
    for (let r = 0; r < S1.length; r++) {
      const a = S1[r];
      if (!1 === (null == e ? void 0 : e[a])) continue;
      if ('normal' === a) {
        e.normal && (s.normal = e.normal);
        continue;
      }
      let o, l;
      if (
        (f(t[a])
          ? (o = t[a])
          : ((o = [Object.assign(Object.assign({}, b1[a]), t[a])]),
            'exit' === a && (o[0].controlOptions = { stopWhenStateChange: !0 })),
        null == e ? void 0 : e[a])
      ) {
        if (f(e[a])) l = e[a];
        else {
          let t = _J({}, o[0], e[a]);
          C1(t) && delete t.type,
            t.oneByOne && (t = k1(t, null !== (n = null == i ? void 0 : i.dataIndex) && void 0 !== n ? n : M1)),
            (l = [t]);
        }
        s[a] = l;
      } else s[a] = o;
    }
    return (s.state = s.update), s;
  }
  function A1(t, e) {
    var i, n, s, r, a, o, l, h, c, d, u;
    return {
      appear:
        null !== (n = null === (i = e.animationAppear) || void 0 === i ? void 0 : i[t]) && void 0 !== n
          ? n
          : e.animationAppear,
      disappear:
        null !== (r = null === (s = e.animationDisappear) || void 0 === s ? void 0 : s[t]) && void 0 !== r
          ? r
          : e.animationDisappear,
      enter:
        null !== (o = null === (a = e.animationEnter) || void 0 === a ? void 0 : a[t]) && void 0 !== o
          ? o
          : e.animationEnter,
      exit:
        null !== (h = null === (l = e.animationExit) || void 0 === l ? void 0 : l[t]) && void 0 !== h
          ? h
          : e.animationExit,
      update:
        null !== (d = null === (c = e.animationUpdate) || void 0 === c ? void 0 : c[t]) && void 0 !== d
          ? d
          : e.animationUpdate,
      normal: null === (u = e.animationNormal) || void 0 === u ? void 0 : u[t]
    };
  }
  function k1(t, e) {
    const { oneByOne: i, duration: n } = t;
    return (
      (t.delay = (t, s, r) => {
        const a = e(t),
          l = o(n) ? n(t, s, r) : _(n) ? n : 0;
        let h = o(i) ? i(t, s, r) : i;
        return !1 === h ? 0 : ((h = !0 === h ? 0 : h), a * (l + h));
      }),
      delete t.oneByOne,
      t
    );
  }
  function M1(t) {
    return null == t ? void 0 : t[Xq];
  }
  function T1(t, e, i) {
    return (
      !1 !== t &&
      !1 !== (null == i ? void 0 : i.appear) &&
      !1 !== (null == i ? void 0 : i.update) &&
      !1 !== (null == e ? void 0 : e.enable)
    );
  }
  function C1(t) {
    return (
      !(function (t) {
        return h(t.timeSlices);
      })(t) && h(t.channel)
    );
  }
  class E1 {
    initLineMark(t, e) {
      return (
        (this._lineMark = this._createMark(VZ.line, {
          defaultMorphElementKey: this.getDimensionField()[0],
          groupKey: this._seriesField,
          isSeriesMark: null == e || e,
          progressive: t
        })),
        this._lineMark
      );
    }
    initLineMarkStyle(t, e) {
      var i, n, s;
      const r = this._lineMark;
      if (r) {
        if (
          (this.setMarkStyle(r, { stroke: this.getColorAttribute() }, 'normal', Jq.Series),
          'zero' !== this._invalidType &&
            this.setMarkStyle(
              r,
              { defined: this._getInvalidDefined, connectedType: this._getInvalidConnectType() },
              'normal',
              Jq.Series
            ),
          this.event.on(Gq.viewDataStatisticsUpdate, { filter: t => t.model === this }, () => {
            this.encodeDefined(r, 'defined');
          }),
          'polar' === this.coordinate)
        )
          this.setMarkStyle(r, { lineJoin: 'bevel', curveType: qJ }, 'normal', Jq.Series);
        else {
          const s =
              null != e
                ? e
                : null === (n = null === (i = this.getSpec().line) || void 0 === i ? void 0 : i.style) || void 0 === n
                ? void 0
                : n.curveType,
            a = s === KJ ? (t === JJ.vertical ? 'monotoneX' : 'monotoneY') : s;
          this.setMarkStyle(r, { curveType: a }, 'normal', Jq.Built_In);
        }
        this.setMarkStyle(
          r,
          {
            x: this.dataToPositionX.bind(this),
            y: this.dataToPositionY.bind(this),
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
          },
          'normal',
          Jq.Series
        ),
          this._trigger.registerMark(r),
          null === (s = this._tooltipHelper) || void 0 === s || s.activeTriggerSet.dimension.add(r);
      }
      return r;
    }
    _getEventElement(t, e = !1) {
      let i = [];
      return t.dimensionInfo.some(t => (t.data.some(t => t.series === this && ((i = t.datum), !0)), !i.length)), i;
    }
    _dimensionTrigger(t) {
      const e = this._getEventElement(t);
      switch (t.action) {
        case 'enter':
          this._symbolActiveMark.getDataView().parse(e), this._symbolActiveMark.getData().updateData(!1);
          break;
        case 'leave':
          this._symbolActiveMark.getDataView().parse([]), this._symbolActiveMark.getData().updateData(!1);
      }
    }
    initSymbolMark(t, e) {
      if (
        ((this._symbolMark = this._createMark(VZ.point, {
          morph: T1(this._spec.animation, this._spec.morph, A1('point', this._spec)),
          defaultMorphElementKey: this.getDimensionField()[0],
          groupKey: this._seriesField,
          label: _J({ animation: this._spec.animation }, this._spec.label),
          progressive: t,
          isSeriesMark: !!e
        })),
        !0 === this._spec.activePoint)
      ) {
        const t = new yo(this._option.dataSet, { name: `${UV}_series_${this.id}_active_point` });
        t.parse([]),
          (this._symbolActiveMark = this._createMark(
            { name: 'active_point', type: jZ.symbol },
            { morph: !1, groupKey: this._seriesField, label: null, isSeriesMark: !1, dataView: t }
          )),
          this._symbolActiveMark.setVisible(!1);
      }
      return this._symbolMark;
    }
    initSymbolMarkStyle() {
      var t;
      const e = this._symbolMark;
      if (!e) return e;
      if (
        (this.setMarkStyle(e, { fill: this.getColorAttribute() }, 'normal', Jq.Series),
        'zero' !== this._invalidType && this.setMarkStyle(e, { visible: this._getInvalidDefined }, 'normal', Jq.Series),
        this.event.on(Gq.viewDataStatisticsUpdate, { filter: t => t.model === this }, () => {
          this.encodeDefined(e, 'visible');
        }),
        this.setMarkStyle(
          e,
          {
            x: this.dataToPositionX.bind(this),
            y: this.dataToPositionY.bind(this),
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
          },
          'normal',
          Jq.Series
        ),
        this._trigger.registerMark(e),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(e),
        this._symbolActiveMark && this._symbolMark.stateStyle.dimension_hover)
      ) {
        this._symbolActiveMark.setVisible(!0), this.event.on(fQ.dimensionHover, this._dimensionTrigger.bind(this));
        for (const t in this._symbolMark.stateStyle) {
          this._symbolActiveMark.stateStyle[t] = {};
          for (const i in this._symbolMark.stateStyle[t])
            this._symbolActiveMark.stateStyle[t][i] = { style: null, level: Jq.Series, referer: e };
        }
        this._symbolActiveMark.state.changeStateInfo({ stateValue: BQ.STATE_DIMENSION_HOVER, filter: () => !0 });
      }
      return e;
    }
    initLabelMarkStyle(t) {
      t &&
        (this.setMarkStyle(t, {
          fill: this.getColorAttribute(),
          text: t => t[this.getStackValueField()],
          z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }),
        'zero' !== this._invalidType && this.setMarkStyle(t, { visible: this._getInvalidDefined }, 'normal', Jq.Series),
        this.event.on(Gq.viewDataStatisticsUpdate, { filter: t => t.model === this }, () => {
          this.encodeDefined(t, 'visible');
        }));
    }
    encodeDefined(t, e) {
      var i, n;
      if (!t) return;
      const s =
        null === (n = null === (i = this.getViewDataStatistics()) || void 0 === i ? void 0 : i.latestData) ||
        void 0 === n
          ? void 0
          : n[this.getStackValueField()];
      'zero' === this._invalidType || (s && (null == s ? void 0 : s.allValid))
        ? this.setMarkStyle(t, { [e]: !0 }, 'normal', Jq.Series)
        : this.setMarkStyle(t, { [e]: this._getInvalidDefined }, 'normal', Jq.Series);
    }
  }
  const P1 = (t, e) => {
      const i = e.beforeCall();
      return t.forEach((t, n) => e.call(t, n, i)), i.keyMap && (i.keyMap.clear(), (i.keyMap = null)), t;
    },
    R1 = {
      [t.RenderModeEnum['desktop-miniApp']]: {
        hover: { enable: !0, trigger: 'pointermove', triggerOff: ['pointermove', 'pointerleave'] },
        select: { enable: !0, trigger: 'pointertap' }
      },
      [t.RenderModeEnum['desktop-browser']]: {
        hover: { enable: !0, trigger: 'pointermove', triggerOff: ['pointermove', 'pointerleave'] },
        select: { enable: !0, trigger: 'pointertap' }
      },
      [t.RenderModeEnum['mobile-browser']]: {
        hover: { enable: !0, trigger: 'pointerover', triggerOff: 'pointerout' },
        select: { enable: !0, trigger: 'tap' }
      },
      [t.RenderModeEnum.miniApp]: {
        hover: { enable: !0, trigger: 'pointerover', triggerOff: 'pointerout' },
        select: { enable: !0, trigger: 'tap' }
      },
      [t.RenderModeEnum.lynx]: {
        hover: { enable: !0, trigger: 'pointerover', triggerOff: 'pointerout' },
        select: { enable: !0, trigger: 'tap' }
      }
    };
  class O1 {
    get hover() {
      return this._hover;
    }
    get select() {
      return this._select;
    }
    constructor(t, e) {
      (this._fields = null),
        (this._marks = new VQ()),
        (this._markReverse = new VQ()),
        (this.onHover = t => {
          this.filterEventMark(t) && this.hoverItem(t);
        }),
        (this.onUnHover = t => {
          this.filterEventMark(t) ||
            this.interaction.filterEventMark(t, BQ.STATE_HOVER) ||
            (this.interaction.getEventElement(BQ.STATE_HOVER)[0] && this.unhoverItem());
        }),
        (this.onSelect = t => {
          this.handleSingleEventSelect(t);
        }),
        (this.onUnSelect = t => {
          this.interaction.filterEventMark(t, BQ.STATE_SELECTED) || this.clearSelectedItems();
        }),
        (this._spec = t),
        (this._option = e),
        (this.event = new mQ(e.eventDispatcher, e.mode)),
        (this.interaction = e.interaction),
        this.initConfig(e.mode);
    }
    setStateKeys(t) {
      this._fields = [...t];
    }
    registerMark(t) {
      this._marks.addMark(t),
        this._hover.enable && this.interaction.registerMark(BQ.STATE_HOVER, t),
        this._select.enable && this.interaction.registerMark(BQ.STATE_SELECTED, t);
    }
    init() {
      this.initEvent();
    }
    release() {
      this.releaseEvent(), this._marks.clear();
    }
    initEvent() {
      const t = this.event,
        { enable: e, trigger: i, triggerOff: n } = this._hover,
        { enable: s, trigger: r, triggerOff: a } = this._select;
      e &&
        (V(i).forEach(e => {
          t.on(e, { level: Yq.chart }, this.onHover);
        }),
        n &&
          'none' !== n &&
          V(n).forEach(e => {
            t.on(e, { level: Yq.vchart, source: Uq.chart }, this.onUnHover);
          })),
        s &&
          (V(r).forEach(e => {
            t.on(e, { level: Yq.mark }, this.onSelect);
          }),
          a &&
            'none' !== a &&
            V(a).forEach(e => {
              t.on(e, { level: Yq.mark }, this.onUnSelect);
            }),
          a ||
            V(null != a ? a : r).forEach(e => {
              t.on(e, { level: Yq.vchart }, this.onUnSelect);
            }));
    }
    releaseEvent() {
      this.event.release();
    }
    initConfig(t) {
      const e = R1[t];
      (this._hover = Object.assign({}, null == e ? void 0 : e.hover)),
        (this._select = Object.assign({}, null == e ? void 0 : e.select));
      const i = this._spec.hover;
      a(i) ? (this._hover.enable = i) : c(i) && ((this._hover.enable = !0), (this._hover = _J(this._hover, i)));
      const n = this._spec.select;
      a(n) ? (this._select.enable = n) : c(n) && ((this._select.enable = !0), (this._select = _J(this._select, n)));
    }
    hoverItem(t) {
      const { datum: e } = t,
        i = this.interaction.getEventElement(BQ.STATE_HOVER)[0];
      t.item !== i &&
        (this.interaction.exchangeEventElement(BQ.STATE_HOVER, t.item),
        this.interaction.reverseEventElement(BQ.STATE_HOVER),
        this.event.emit('hovered', { model: this._option.model, value: [e] }));
    }
    unhoverItem() {
      const t = this.interaction.getEventElementData(BQ.STATE_HOVER);
      this.interaction.clearEventElement(BQ.STATE_HOVER, !0),
        this.event.emit('unhovered', { model: this._option.model, value: t });
    }
    handleSingleEventHover(t) {
      this.filterEventMark(t)
        ? this.hoverItem(t)
        : this.interaction.getEventElement(BQ.STATE_HOVER)[0] &&
          !this.interaction.filterEventMark(t, BQ.STATE_HOVER) &&
          this.unhoverItem();
    }
    selectItems(t) {
      this.event.emit('selected', { model: this._option.model, value: t });
    }
    clearSelectedItems() {
      const t = this.interaction.getEventElementData(BQ.STATE_SELECTED);
      this.interaction.clearEventElement(BQ.STATE_SELECTED, !0),
        this.event.emit('unselected', { model: this._option.model, value: t });
    }
    unselectItems(t) {
      this.interaction.removeEventElement(BQ.STATE_SELECTED, t.item),
        this.event.emit('unselected', { model: this._option.model, value: t.item });
    }
    handleSingleEventSelect(t) {
      if (this.filterEventMark(t))
        if (t.item.getStates().includes(BQ.STATE_SELECTED)) this.unselectItems(t);
        else {
          if ('multiple' === this._select.mode) this.interaction.addEventElement(BQ.STATE_SELECTED, t.item);
          else this.interaction.exchangeEventElement(BQ.STATE_SELECTED, t.item);
          this.interaction.reverseEventElement(BQ.STATE_SELECTED);
          const e = this.interaction.getEventElementData(BQ.STATE_SELECTED);
          this.selectItems(e);
        }
      else this.interaction.filterEventMark(t, BQ.STATE_SELECTED) || this.clearSelectedItems();
    }
    filterEventMark(t) {
      return !(!t.mark || !this._marks.includes(t.mark));
    }
    isDatumEqual(t, e) {
      return (this._fields ? this._fields : Object.keys(t)).every(i => t[i] === e[i]);
    }
  }
  class B1 {
    constructor() {
      (this.activeTriggerSet = { mark: new Set(), dimension: new Set() }),
        (this.ignoreTriggerSet = { mark: new Set(), dimension: new Set() });
    }
  }
  const I1 = (t, e) => (h(e) ? t.map(t => e[t]) : void 0),
    D1 = (t, e) => i => t.every((t, n) => i[t] === (null == e ? void 0 : e[n])),
    L1 = t => !l(t) && (f(t) ? t.length > 0 && t.every(h) : Object.keys(t).length > 0);
  function F1(t, e, i, n) {
    var s, r, a, o, c;
    const d = Object.assign({ regionIndex: 0 }, e),
      u = n.getRegionsInUserIdOrIndex(
        h(d.regionId) ? [d.regionId] : void 0,
        h(d.regionIndex) ? [d.regionIndex] : void 0
      )[0];
    if (!u) return 'none';
    const p = u.getSeries(),
      g = [];
    p.forEach(e => {
      var i, n, s, r, a, o, c, d;
      const u = e.getDimensionField(),
        p = e.getMeasureField(),
        f = e.getSeriesField(),
        v = h(f) ? t[f] : void 0,
        m =
          h(f) &&
          null !==
            (r =
              null ===
                (s =
                  null === (n = null === (i = e.getViewDataStatistics) || void 0 === i ? void 0 : i.call(e)) ||
                  void 0 === n
                    ? void 0
                    : n.latestData[f]) || void 0 === s
                ? void 0
                : s.values) &&
          void 0 !== r
            ? r
            : [],
        y = I1(u, t);
      let _ = I1(p, t);
      const b = L1(_),
        x = !b && h(f) && l(v) && m.length > 0;
      if ('cartesian' === e.coordinate) {
        const t = e,
          i = u.map((t, e) => [t, e]).filter(([, t]) => l(null == y ? void 0 : y[t]));
        let n = [null != y ? y : []];
        i.length > 0 &&
          i.forEach(([t, i]) => {
            var s, r, a, o;
            const l =
                null !==
                  (o =
                    null ===
                      (a =
                        null === (r = null === (s = e.getViewDataStatistics) || void 0 === s ? void 0 : s.call(e)) ||
                        void 0 === r
                          ? void 0
                          : r.latestData[t]) || void 0 === a
                      ? void 0
                      : a.values) && void 0 !== o
                  ? o
                  : [],
              h = [];
            n.forEach(t => {
              l.forEach(e => {
                const n = [...(null != t ? t : [])];
                (n[i] = e), h.push(n);
              });
            }),
              (n = h);
          }),
          n.forEach(i => {
            var n, s;
            if (x) {
              const s = null === (n = t.getViewData()) || void 0 === n ? void 0 : n.latestData.filter(D1(u, i));
              m.forEach(n => {
                const r = s.find(t => t[f] === n);
                if (((_ = I1(p, r)), !L1(_))) return;
                const a = t.dataToPosition(r);
                l(a) ||
                  isNaN(a.x) ||
                  isNaN(a.y) ||
                  g.push({
                    pos: a,
                    data: {
                      dimensionFields: u,
                      dimensionData: i,
                      measureFields: p,
                      measureData: _,
                      hasMeasureData: b,
                      groupField: f,
                      groupData: n
                    },
                    series: e
                  });
              });
            } else {
              const n = null === (s = t.getViewData()) || void 0 === s ? void 0 : s.latestData.find(D1(u, i));
              if (!b && ((_ = I1(p, n)), !L1(_))) return;
              const r = t.dataToPosition(n);
              if (l(r) || isNaN(r.x) || isNaN(r.y)) return;
              g.push({
                pos: r,
                data: {
                  dimensionFields: u,
                  dimensionData: i,
                  measureFields: p,
                  measureData: _,
                  hasMeasureData: b,
                  groupField: f,
                  groupData: v
                },
                series: e
              });
            }
          });
      } else if ('polar' === e.coordinate)
        if (e.type === DZ.pie) {
          const t = e,
            i = null === (a = t.getViewData()) || void 0 === a ? void 0 : a.latestData.find(D1(u, y));
          if (!b && ((_ = I1(p, i)), !L1(_))) return;
          const n = t.dataToCentralPosition(i);
          if (l(n) || isNaN(n.x) || isNaN(n.y)) return;
          g.push({
            pos: n,
            data: {
              dimensionFields: u,
              dimensionData: y,
              measureFields: p,
              measureData: _,
              hasMeasureData: b,
              groupField: f,
              groupData: v
            },
            series: e
          });
        } else {
          const t = e;
          if (x) {
            const i = (null === (o = t.getViewData()) || void 0 === o ? void 0 : o.latestData.filter(D1(u, y))).find(
              t => t[f] === v
            );
            m.forEach(n => {
              if (((_ = I1(p, i)), !L1(_))) return;
              const s = t.dataToPosition(i);
              l(s) ||
                isNaN(s.x) ||
                isNaN(s.y) ||
                g.push({
                  pos: s,
                  data: {
                    dimensionFields: u,
                    dimensionData: y,
                    measureFields: p,
                    measureData: _,
                    hasMeasureData: b,
                    groupField: f,
                    groupData: n
                  },
                  series: e
                });
            });
          } else {
            const i = null === (c = t.getViewData()) || void 0 === c ? void 0 : c.latestData.find(D1(u, y));
            if (!b && ((_ = I1(p, i)), !L1(_))) return;
            const n = t.dataToPosition(i);
            if (l(n) || isNaN(n.x) || isNaN(n.y)) return;
            g.push({
              pos: n,
              data: {
                dimensionFields: u,
                dimensionData: y,
                measureFields: p,
                measureData: _,
                hasMeasureData: b,
                groupField: f,
                groupData: v
              },
              series: e
            });
          }
        }
      else if ('geo' === e.coordinate) {
        const t = e,
          i = null === (d = t.getViewData()) || void 0 === d ? void 0 : d.latestData.find(D1(u, y));
        if (!b && ((_ = I1(p, i)), !L1(_))) return;
        const n = t.dataToPosition(i);
        if (l(n) || isNaN(n.x) || isNaN(n.y)) return;
        g.push({
          pos: n,
          data: {
            dimensionFields: u,
            dimensionData: y,
            measureFields: p,
            measureData: _,
            hasMeasureData: b,
            groupField: f,
            groupData: v
          },
          series: e
        });
      }
    });
    const f = null !== (s = d.activeType) && void 0 !== s ? s : g.length > 1 ? 'dimension' : 'mark',
      v = u.getLayoutStartPoint(),
      m = u.getLayoutRect(),
      y = n.globalInstance.getContainer(),
      _ = Object.assign(
        { x: 0, y: 0 },
        y
          ? (function (t) {
              const { x: e, y: i } = t.getBoundingClientRect();
              return { x: e, y: i };
            })(y)
          : {}
      ),
      b = t => {
        var e;
        const {
            dimensionFields: i,
            dimensionData: n,
            measureFields: s,
            measureData: r,
            groupField: a,
            groupData: o
          } = t.data,
          h =
            null === (e = t.series.getViewData()) || void 0 === e
              ? void 0
              : e.latestData.find(t => D1(i, n)(t) && D1(s, r)(t) && (l(a) || D1([a], [o])(t)));
        return h;
      },
      x = t => {
        var e, i;
        const n = (t => ({ x: Math.min(Math.max(t.x, 0), m.width), y: Math.min(Math.max(t.y, 0), m.height) }))(t),
          s = null !== (e = d.x) && void 0 !== e ? e : v.x + n.x,
          r = null !== (i = d.y) && void 0 !== i ? i : v.y + n.y;
        return { canvasX: s, canvasY: r, clientX: _.x + s, clientY: _.y + r };
      };
    if ('dimension' === f) {
      const e = g[0];
      if (!e) return 'none';
      const s = new Map();
      g.forEach(t => {
        var e;
        s.has(t.series) || s.set(t.series, []), null === (e = s.get(t.series)) || void 0 === e || e.push(t);
      });
      const o = [
          {
            value: t[e.data.dimensionFields[0]],
            data: [...s.keys()].map(t => {
              var e, i;
              return {
                series: t,
                datum:
                  null !== (i = null === (e = s.get(t)) || void 0 === e ? void 0 : e.map(t => b(t))) && void 0 !== i
                    ? i
                    : []
              };
            })
          }
        ],
        l = {
          changePositionOnly: !1,
          dimensionInfo: o,
          chart: null !== (r = n.globalInstance.getChart()) && void 0 !== r ? r : void 0,
          datum: void 0,
          model: void 0,
          source: Uq.chart,
          event: x({
            x: g.reduce((t, e) => t + e.pos.x, 0) / g.length,
            y: g.reduce((t, e) => t + e.pos.y, 0) / g.length
          }),
          item: void 0,
          itemMap: new Map()
        };
      null === (a = null == i ? void 0 : i.showTooltip) || void 0 === a || a.call(i, f, o, l);
      const h = n.globalInstance;
      return NQ.globalConfig.uniqueTooltip && NQ.hideTooltip(h.id), f;
    }
    if ('mark' === f) {
      const e = g[0];
      if (!e) return 'none';
      const s = Object.assign(Object.assign({}, b(e)), t),
        r = {
          changePositionOnly: !1,
          chart: null !== (o = n.globalInstance.getChart()) && void 0 !== o ? o : void 0,
          datum: s,
          model: e.series,
          source: Uq.chart,
          event: x(e.pos),
          item: void 0,
          itemMap: new Map()
        };
      null === (c = null == i ? void 0 : i.showTooltip) ||
        void 0 === c ||
        c.call(i, f, [{ datum: [s], series: e.series }], r);
      const a = n.globalInstance;
      return NQ.globalConfig.uniqueTooltip && NQ.hideTooltip(a.id), f;
    }
    return 'none';
  }
  const j1 = t => {
    var e, i;
    if (!1 === (null == t ? void 0 : t.visible)) return [];
    const n = {
      mark: !1 !== (null === (e = null == t ? void 0 : t.mark) || void 0 === e ? void 0 : e.visible),
      dimension: !1 !== (null === (i = null == t ? void 0 : t.dimension) || void 0 === i ? void 0 : i.visible)
    };
    return (
      h(null == t ? void 0 : t.activeType) &&
        Object.keys(n).forEach(e => {
          var i;
          n[e] = null === (i = null == t ? void 0 : t.activeType) || void 0 === i ? void 0 : i.includes(e);
        }),
      Object.keys(n).filter(t => n[t])
    );
  };
  class z1 extends B1 {
    constructor(t) {
      super(),
        (this._getSeriesCacheInfo = () => {
          var t, e, i;
          const { series: n } = this,
            s = n.getSeriesField();
          return {
            seriesFields: h(s) ? V(s) : null !== (t = n.getSeriesKeys()) && void 0 !== t ? t : [],
            dimensionFields: null !== (e = n.getDimensionField()) && void 0 !== e ? e : [],
            measureFields: null !== (i = n.getMeasureField()) && void 0 !== i ? i : [],
            type: n.type
          };
        }),
        (this._getDimensionData = t => {
          const { dimensionFields: e } = this._seriesCacheInfo;
          return e[0] && (null == t ? void 0 : t[e[0]]);
        }),
        (this._getMeasureData = t => {
          const { measureFields: e } = this._seriesCacheInfo;
          return e[0] && (null == t ? void 0 : t[e[0]]);
        }),
        (this._getSeriesStyle = (t, e, i) => {
          var n;
          for (const i of V(e)) {
            const e = null === (n = this.series.getSeriesStyle(t)) || void 0 === n ? void 0 : n(i);
            if (h(e)) return e;
          }
          return i;
        }),
        (this.contentKeyCallback = (t, e) => {
          const { dimensionFields: i, seriesFields: n } = this._seriesCacheInfo,
            s = i[i.length - 1];
          return h(n[0]) && (null == t ? void 0 : t[n[0]])
            ? null == t
              ? void 0
              : t[n[0]]
            : (i.length > 1 && (0 === n.length || this.series.getSeriesKeys().length), null == t ? void 0 : t[s]);
        }),
        (this.contentValueCallback = (t, e) => this._getMeasureData(t)),
        (this.contentShapeTypeCallback = (t, e) => {
          var i;
          return null !== (i = this._getSeriesStyle(t, 'shape', null)) && void 0 !== i
            ? i
            : this._getSeriesStyle(t, 'symbolType', this.series.getDefaultShapeType());
        }),
        (this.contentShapeColorCallback = (t, e) => this._getSeriesStyle(t, ['fill', 'stroke'])),
        (this.titleValueCallback = (t, e) => this._getDimensionData(t)),
        (this.series = t),
        this.updateTooltipSpec();
    }
    updateTooltipSpec() {
      var t, e, i, n;
      const s =
          null !== (e = null === (t = this.series.getSpec()) || void 0 === t ? void 0 : t.tooltip) && void 0 !== e
            ? e
            : {},
        r =
          null !== (n = null === (i = this.series.getChart().getSpec()) || void 0 === i ? void 0 : i.tooltip) &&
          void 0 !== n
            ? n
            : {},
        a = Object.assign(Object.assign({}, r), s);
      ['mark', 'dimension'].forEach(t => {
        const e = a[t];
        h(e) &&
          (a[t] = Object.assign(Object.assign({}, e), {
            title: h(e.title)
              ? o(e.title)
                ? e.title
                : Object.assign(Object.assign({}, e.title), { seriesId: this.series.id })
              : void 0,
            content: h(e.content)
              ? o(e.content)
                ? e.content
                : V(e.content).map(t => (o(t) ? t : Object.assign(Object.assign({}, t), { seriesId: this.series.id })))
              : void 0
          }));
      }),
        (this.spec = a),
        (this.activeType = j1(a)),
        (this._seriesCacheInfo = this._getSeriesCacheInfo());
    }
    getDefaultTooltipPattern(t, e) {
      if ('mark' === t)
        return {
          visible: !0,
          activeType: t,
          title: { key: void 0, value: this.titleValueCallback, hasShape: !1 },
          content: [
            {
              seriesId: this.series.id,
              key: this.contentKeyCallback,
              value: this.contentValueCallback,
              hasShape: !0,
              shapeType: this.contentShapeTypeCallback,
              shapeColor: this.contentShapeColorCallback,
              shapeHollow: !1
            }
          ]
        };
      if ('dimension' === t && e) {
        const i = { key: void 0, value: this._getDimensionData, hasShape: !1 },
          n = [];
        return (
          e.forEach(({ data: t }) =>
            t.forEach(({ series: t }) => {
              n.push({
                seriesId: t.id,
                key: this.contentKeyCallback,
                value: this.contentValueCallback,
                hasShape: !0,
                shapeType: this.contentShapeTypeCallback,
                shapeColor: this.contentShapeColorCallback,
                shapeHollow: !1
              });
            })
          ),
          { visible: !0, activeType: t, title: i, content: n }
        );
      }
      return null;
    }
  }
  const H1 = {
      min: t => (t.length ? Math.min.apply(null, t) : 0),
      max: t => (t.length ? Math.max.apply(null, t) : 0),
      'array-min': t => (t.length ? Math.min.apply(null, t) : 0),
      'array-max': t => (t.length ? Math.max.apply(null, t) : 0),
      values: t => {
        const e = {},
          i = [];
        for (const n of t) e[n] || (i.push(n), (e[n] = 1));
        return i;
      }
    },
    N1 = (t, e) => {
      var i, n, s;
      const r = {};
      let a = e.fields;
      if ((o(a) && (a = a()), !(null == a ? void 0 : a.length) || !(null == t ? void 0 : t.length))) return r;
      const h = null === (i = e.sourceStatistics) || void 0 === i ? void 0 : i.call(e),
        c = e.fieldFollowSource;
      a = LJ([], a);
      const d = 'parser' === e.target ? 'parserData' : 'latestData',
        u = t[0][d] ? t[0][d] : t || [],
        p = null === (s = (n = t[0]).getFields) || void 0 === s ? void 0 : s.call(n);
      return (
        a.forEach(t => {
          const e = t.key;
          r[e] = {};
          const i = null == p ? void 0 : p[e];
          if (h && c && c(e) && h[e]) return void (r[e] = h[e]);
          const n = t.operations,
            s = n.some(t => 'min' === t || 'max' === t || 'allValid' === t);
          let a = !0,
            o = u.reduce((t, i) => (i && t.push(i[e]), t), []);
          const d = o.length;
          s
            ? ((o = o.filter(Oo)), (a = o.length === d))
            : (o = n.some(t => 'array-min' === t || 'array-max' === t)
                ? o.reduce(
                    (t, e) => (
                      e &&
                        e.forEach(e => {
                          Oo(e) && t.push(e);
                        }),
                      t
                    ),
                    []
                  )
                : o.filter(t => void 0 !== t)),
            n.forEach(n => {
              if (t.customize) r[e][n] = t.customize;
              else {
                if (i && i.lockStatisticsByDomain && !l(i.domain)) {
                  if ('values' === n) return void (r[e][n] = [...i.domain]);
                } else if ('allValid' === n) return;
                (r[e][n] = H1[n](o)),
                  'array-max' === n && (r[e].max = r[e][n]),
                  'array-min' === n && (r[e].min = r[e][n]);
              }
            }),
            s && (r[e].allValid = a);
        }),
        r
      );
    },
    V1 = (t, e) => {
      const { config: i } = e;
      if (!i) return t;
      const { invalidType: n, checkField: s } = i();
      return (
        'zero' !== n ||
          t.forEach(t => {
            Oo(t[s]) || (t[s] = 0);
          }),
        t
      );
    };
  class W1 extends d0 {
    _compileProduct() {
      var t;
      const e = null === (t = this._data) || void 0 === t ? void 0 : t.latestData;
      l(e) || h(this.getProduct()) || this._initProduct([]);
    }
    generateProductId() {
      var t;
      return null === (t = this._data) || void 0 === t ? void 0 : t.name;
    }
  }
  const G1 = `${UV}_HIERARCHY_DEPTH`,
    U1 = `${UV}_HIERARCHY_ROOT`,
    Y1 = `${UV}_HIERARCHY_ROOT_INDEX`,
    $1 = () => ({ keyMap: new Map() });
  function X1(t, e, i) {
    t &&
      (this._seriesField || (t[qq] = this.getSeriesKeys()[0]),
      (t[Xq] = e),
      (t[Kq] = this.generateDefaultDataKey(this._spec.dataKey, t, e, i)));
  }
  function K1(t, e, i, n = 0, s, r) {
    void 0 === r && (r = e),
      X1.bind(this)(t, e, i),
      (t[G1] = n),
      (t[U1] = s || t[this.getCategoryField()]),
      (t[Y1] = r),
      t.children && t.children.length && t.children.forEach((e, n) => K1.bind(this)(e, n, i, t[G1] + 1, t[U1], r));
  }
  class q1 extends ZQ {
    getTrigger() {
      return this._trigger;
    }
    getRegion() {
      return this._region;
    }
    getRootMark() {
      return this._rootMark;
    }
    getRawData() {
      return this._rawData;
    }
    getRawDataStatistics() {
      return this._rawDataStatistics;
    }
    getViewDataFilter() {
      return this._viewDataFilter;
    }
    getViewData() {
      var t;
      return null === (t = this._data) || void 0 === t ? void 0 : t.getDataView();
    }
    getViewDataProductId() {
      var t;
      return null === (t = this._data) || void 0 === t ? void 0 : t.getProductId();
    }
    getViewDataStatistics() {
      return this._viewDataStatistics;
    }
    getViewStackData() {
      return this._viewStackData;
    }
    getSeriesField() {
      return this._seriesField;
    }
    setSeriesField(t) {
      h(t) &&
        ((this._seriesField = t),
        this.getMarks()
          .filter(t => t.getDataView() === this.getViewData())
          .forEach(t => {
            t.setFacet(this._seriesField);
          }));
    }
    getGroups() {
      return this._groups;
    }
    getStack() {
      return this._stack;
    }
    getPercent() {
      return this._percent;
    }
    getStackOffsetSilhouette() {
      return this._stackOffsetSilhouette;
    }
    get tooltipHelper() {
      return this._tooltipHelper;
    }
    getInvalidType() {
      return this._invalidType;
    }
    setInvalidType(t) {
      var e;
      (this._invalidType = t), null === (e = this.getViewData()) || void 0 === e || e.reRunAllTransform();
    }
    constructor(t, e) {
      var i;
      super(t, Object.assign({}, e)),
        (this.type = 'series'),
        (this.layoutType = 'absolute'),
        (this.modelType = 'series'),
        (this.name = void 0),
        (this.coordinate = 'none'),
        (this._region = null),
        (this._rootMark = null),
        (this._seriesMark = null),
        (this._viewDataMap = new Map()),
        (this._viewDataFilter = null),
        (this._data = null),
        (this._stack = !1),
        (this._percent = !1),
        (this._stackOffsetSilhouette = !1),
        (this._invalidType = 'break'),
        (this._getInvalidDefined = t => Oo(t[this.getStackValueField()])),
        (this._region = e.region),
        (this._dataSet = e.dataSet),
        (null === (i = this._spec) || void 0 === i ? void 0 : i.name) && (this.name = this._spec.name);
    }
    created() {
      super.created(),
        this._buildMarkAttributeContext(),
        this.initData(),
        this.initGroups(),
        this.initStatisticalData(),
        this.event.emit(Gq.afterInitData, { model: this }),
        this.initTrigger(),
        this.initTooltip(),
        this.initRootMark(),
        this.initMark(),
        this._initExtensionMark(),
        this.initMarkStyle(),
        this.initMarkState(),
        !1 !== this._spec.animation && h(this._region.animate) && this.initAnimation(),
        this.afterInitMark(),
        this.initEvent(),
        this.event.emit(Gq.afterInitEvent, { model: this });
    }
    _buildMarkAttributeContext() {
      this._markAttributeContext = {
        vchart: this._option.globalInstance,
        globalScale: (t, e) => {
          var i;
          return null === (i = this._option.globalScale.getScale(t)) || void 0 === i ? void 0 : i.scale(e);
        },
        seriesColor: t => {
          var e;
          return (
            l(t) && (t = this.getSeriesKeys()[0]),
            null === (e = this._option.globalScale.getScale('color')) || void 0 === e ? void 0 : e.scale(t)
          );
        },
        getRegion: () => this._region
      };
    }
    setAttrFromSpec() {
      var t;
      super.setAttrFromSpec(),
        this.setSeriesField(this._spec.seriesField),
        a(this._spec.stack) && (this._stack = this._spec.stack),
        a(this._spec.percent) &&
          ((this._percent = this._spec.percent), (this._stack = this._spec.percent || this._stack)),
        a(this._spec.stackOffsetSilhouette) &&
          ((this._stackOffsetSilhouette = this._spec.stackOffsetSilhouette),
          (this._stack = this._spec.stackOffsetSilhouette || this._stack)),
        h(this._spec.invalidType) && (this._invalidType = this._spec.invalidType),
        null === (t = this._tooltipHelper) || void 0 === t || t.updateTooltipSpec();
    }
    initData() {
      var t, e, i;
      if (
        ((this._rawData = this._spec.data),
        null === (t = this._rawData) || void 0 === t || t.target.addListener('change', this.rawDataUpdate.bind(this)),
        this._addDataIndexAndKey(),
        this._rawData)
      ) {
        this._viewDataFilter = CQ(this._rawData, this._dataSet, { name: `${UV}_series_${this.id}_viewDataFilter` });
        const t = CQ(this._viewDataFilter, this._dataSet, { name: `${UV}_series_${this.id}_viewData` });
        (this._data = new W1(this._option, t)),
          this._viewDataFilter.target.removeListener('change', t.reRunAllTransform);
      }
      'zero' === this._invalidType &&
        (null === (e = this._rawData) || void 0 === e ? void 0 : e.dataSet) &&
        (xQ(this._rawData.dataSet, 'invalidTravel', V1),
        null === (i = this._rawData) ||
          void 0 === i ||
          i.transform(
            {
              type: 'invalidTravel',
              options: { config: () => ({ invalidType: this._invalidType, checkField: this.getStackValueField() }) }
            },
            !1
          ));
    }
    initGroups() {
      const t = this.getGroupFields();
      t && t.length && (this._groups = { fields: t });
    }
    initStatisticalData() {
      this._rawData && this._statisticRawData(), this._data && this._statisticViewData();
    }
    _statisticRawData() {
      xQ(this._dataSet, 'dimensionStatistics', N1);
      const t = `${UV}_series_${this.id}_rawDataStatic`;
      (this._rawDataStatistics = new yo(this._dataSet, { name: t })),
        this._rawDataStatistics.parse([this._rawData], { type: 'dataview' }),
        this._rawDataStatistics.transform(
          {
            type: 'dimensionStatistics',
            options: {
              operations: ['max', 'min', 'values'],
              fields: () => {
                var t;
                const e = LJ(
                  this.getStatisticFields(),
                  null !== (t = this._option.globalScale.getStatisticalFields(this._rawData.name)) && void 0 !== t
                    ? t
                    : []
                );
                return (
                  this._seriesField && LJ(e, [{ key: this._seriesField, operations: ['values'] }]),
                  e.filter(t => t.key !== eZ && t.key !== iZ && t.key !== tZ && t.key !== Qq)
                );
              },
              target: 'latest'
            }
          },
          !1
        ),
        this._rawData.target.removeListener('change', this._rawDataStatistics.reRunAllTransform);
    }
    _statisticViewData() {
      xQ(this._dataSet, 'dimensionStatistics', N1);
      const t = `${UV}_series_${this.id}_viewDataStatic`;
      (this._viewDataStatistics = new yo(this._dataSet, { name: t })),
        this._viewDataStatistics.parse([this._data.getDataView()], { type: 'dataview' }),
        this._viewDataStatistics.transform(
          {
            type: 'dimensionStatistics',
            options: {
              fieldFollowSource: t => this._viewDataFilter.transformsArr.length <= 1,
              sourceStatistics: () => this._rawDataStatistics.latestData,
              fields: () => {
                const t = this.getStatisticFields();
                return this._seriesField && LJ(t, [{ key: this._seriesField, operations: ['values'] }]), t;
              },
              target: 'latest'
            }
          },
          !1
        ),
        this._data.getDataView().target.removeListener('change', this._viewDataStatistics.reRunAllTransform),
        (this._stack || this._stackValue) && this.createdStackData();
    }
    createStatisticalData(t, e, i) {
      xQ(this._dataSet, 'dimensionStatistics', N1);
      const n = new yo(this._dataSet, { name: t });
      return (
        n.parse([e], { type: 'dataview' }),
        n.transform(
          {
            type: 'dimensionStatistics',
            options: {
              operations: ['max', 'min', 'values'],
              fields: () => {
                var t;
                const n = LJ(
                  this.getStatisticFields(),
                  null !== (t = null == i ? void 0 : i(e.name)) && void 0 !== t ? t : []
                );
                return this._seriesField && LJ(n, [{ key: this._seriesField, operations: ['values'] }]), n;
              },
              target: 'latest'
            }
          },
          !1
        ),
        n
      );
    }
    createdStackData() {
      var t, e;
      const i =
        null !== (e = null === (t = this._rawData) || void 0 === t ? void 0 : t.name) && void 0 !== e
          ? e
          : `${UV}_series_${this.id}_viewStackData`;
      (this._viewStackData = new yo(this._dataSet)),
        this._viewStackData.parse([this.getViewDataFilter()], { type: 'dataview' }),
        (this._viewStackData.name = i),
        this._viewStackData.transform({ type: 'stackSplit', options: { fields: this.getStackGroupFields() } }, !1);
    }
    _noAnimationDataKey(t, e, i) {
      return e;
    }
    generateDefaultDataKey(t, e, i, n) {
      var s;
      if (l(t)) {
        if (!1 === this._spec.animation) {
          const t = this._noAnimationDataKey(e, i, n);
          if (void 0 !== t) return t;
        }
        const { keyMap: t } = n,
          s = this._getSeriesDataKey(e);
        return void 0 === t.get(s) ? t.set(s, 0) : t.set(s, t.get(s) + 1), `${s}_${t.get(s)}`;
      }
      return g(t)
        ? e[t]
        : f(t) && t.every(t => g(t))
        ? t.map(t => e[t]).join('-')
        : o(t)
        ? t(e, i)
        : void (null === (s = this._option) || void 0 === s || s.onError(`invalid dataKey: ${t}`));
    }
    _addDataIndexAndKey() {
      var t;
      (null === (t = this._rawData) || void 0 === t ? void 0 : t.dataSet) &&
        (xQ(this._rawData.dataSet, 'addVChartProperty', P1),
        this._rawData.transform({ type: 'addVChartProperty', options: { beforeCall: $1, call: X1.bind(this) } }, !1));
    }
    updateRawData(t) {
      this._rawData && this._rawData.updateRawData(t);
    }
    rawDataUpdate(t) {
      var e;
      null === (e = this._rawDataStatistics) || void 0 === e || e.reRunAllTransform(),
        this.event.emit(Gq.rawDataUpdate, { model: this });
    }
    rawDataStatisticsUpdate(t) {
      this.event.emit(Gq.rawDataStatisticsUpdate, { model: this });
    }
    viewDataFilterOver(t) {
      this.event.emit(Gq.viewDataFilterOver, { model: this });
    }
    viewDataUpdate(t) {
      this.event.emit(Gq.viewDataUpdate, { model: this }),
        this._data.updateData(),
        this._viewDataStatistics.reRunAllTransform();
    }
    viewDataStatisticsUpdate(t) {
      this.event.emit(Gq.viewDataStatisticsUpdate, { model: this });
    }
    getDatumPositionValue(t, e) {
      return !t || l(e) ? null : t[e];
    }
    getDatumPositionValues(t, e) {
      return !t || l(e) ? [] : g(e) ? [t[e]] : e.map(e => t[e]);
    }
    initRootMark() {
      var t, e;
      (this._rootMark = this._createMark(
        { type: jZ.group, name: `seriesGroup_${this.type}_${this.id}` },
        { parent: null === (e = (t = this._region).getGroupMark) || void 0 === e ? void 0 : e.call(t), dataView: !1 }
      )),
        this._rootMark.setZIndex(this.layoutZIndex);
    }
    _initExtensionMark() {
      var t;
      this._spec.extensionMark &&
        (null === (t = this._spec.extensionMark) ||
          void 0 === t ||
          t.forEach((t, e) => {
            this._createExtensionMark(t, null, `${UV}_series_${this.id}_extensionMark`, e);
          }));
    }
    _createExtensionMark(t, e, i, n) {
      var s;
      const r = this._createMark({ type: t.type, name: `${i}_${n}` }, { markSpec: t, parent: e, dataView: !1 });
      if (r)
        if ('group' === t.type)
          (i = `${i}_${n}`),
            null === (s = t.children) ||
              void 0 === s ||
              s.forEach((t, e) => {
                this._createExtensionMark(t, r, i, e);
              });
        else if (!(e || (l(t.dataId) && l(t.dataIndex)))) {
          const e = this._option.getSeriesData(t.id, t.dataIndex);
          e === this._rawData ? r.setDataView(this.getViewData(), this.getViewDataProductId()) : r.setDataView(e);
        }
    }
    _updateExtensionMarkSpec(t) {
      var e;
      null === (e = this._spec.extensionMark) ||
        void 0 === e ||
        e.forEach((e, i) => {
          var n;
          const s = this._marks.getMarkWithInfo({ name: `${UV}_series_${this.id}_extensionMark_${i}` });
          (t && z(null === (n = t.extensionMark) || void 0 === n ? void 0 : n[i], e)) ||
            (this.initMarkStyleWithSpec(s, e), s.updateStaticEncode(), s.updateLayoutState());
        });
    }
    getStackData() {
      var t;
      return null === (t = this._viewStackData) || void 0 === t ? void 0 : t.latestData;
    }
    initTrigger() {
      const t = { hover: this._spec.hover, select: this._spec.select },
        e = Object.assign(Object.assign({}, this._option), { model: this, interaction: this._region.interaction });
      this._trigger = new O1(t, e);
    }
    initAnimation() {}
    initMarkState() {
      this.initSeriesStyleState();
    }
    initSeriesStyleState() {
      var t;
      const e = this._spec.seriesStyle;
      if (!e || !e.length) return;
      const i = null !== (t = this._seriesField) && void 0 !== t ? t : qq;
      this.getMarksWithoutRoot().forEach(t => {
        const n = {},
          s = {},
          r = {};
        e.forEach(e => {
          var i;
          const a = null === (i = e[t.name]) || void 0 === i ? void 0 : i.style;
          a &&
            ((n[e.name] = !0),
            (r[e.name] = r[e.name] || {}),
            Object.keys(a).forEach(t => {
              (s[t] = !0), (r[e.name][t] = a[t]);
            }));
        }),
          t.state.addStateInfo({
            stateValue: Zq,
            level: -1,
            filter: t => (Array.isArray(t) ? 0 !== t.length && !0 === n[t[0][i]] : !0 === n[t[i]])
          });
        const a = {};
        Object.keys(s).forEach(e => {
          a[e] = n => {
            var s, a;
            let o;
            if (Array.isArray(n)) {
              if (0 === n.length) return;
              o = null === (s = r[n[0][i]]) || void 0 === s ? void 0 : s[e];
            }
            return (o = null === (a = r[n[i]]) || void 0 === a ? void 0 : a[e]), o || t.getAttribute(e, n);
          };
        }),
          this.setMarkStyle(t, a, Zq);
      });
    }
    afterInitMark() {
      var t, e, i;
      this.event.emit(Gq.afterInitMark, { model: this }), this.setSeriesField(this._spec.seriesField);
      let n = null !== (t = this._spec.animationThreshold) && void 0 !== t ? t : Number.MAX_SAFE_INTEGER;
      this.getMarks().forEach(t => {
        var e, i;
        (null === (i = null === (e = t.stateStyle) || void 0 === e ? void 0 : e.normal) || void 0 === i
          ? void 0
          : i.lineWidth) && t.setAttribute('stroke', this.getColorAttribute(), 'normal', Jq.Base_Series);
        const s = t.getProgressiveConfig();
        s &&
          (s.large && s.largeThreshold && (n = Math.min(n, s.largeThreshold)),
          s.progressiveThreshold && (n = Math.min(n, s.progressiveThreshold)));
      }),
        (null === (i = null === (e = this._rawData) || void 0 === e ? void 0 : e.latestData) || void 0 === i
          ? void 0
          : i.length) >= n && (this._spec.animation = !1);
    }
    getMarksWithoutRoot() {
      return this.getMarks().filter(t => !t.name.includes('seriesGroup'));
    }
    getMarksInType(t) {
      return this._marks.getMarksInType(t);
    }
    getMarkInName(t) {
      return this._marks.get(t);
    }
    getMarkInId(t) {
      return this.getMarks().find(e => e.id === t);
    }
    initEvent() {
      var t, e, i, n;
      this._trigger.init(),
        null === (e = null === (t = this._data) || void 0 === t ? void 0 : t.getDataView()) ||
          void 0 === e ||
          e.target.addListener('change', this.viewDataUpdate.bind(this)),
        null === (i = this._viewDataStatistics) ||
          void 0 === i ||
          i.target.addListener('change', this.viewDataStatisticsUpdate.bind(this)),
        null === (n = this._rawDataStatistics) ||
          void 0 === n ||
          n.target.addListener('change', this.rawDataStatisticsUpdate.bind(this));
    }
    _releaseEvent() {
      super._releaseEvent(), this._trigger.release();
    }
    initTooltip() {
      this._tooltipHelper = new z1(this);
    }
    updateSpec(t) {
      var e, i;
      const n = this._spec,
        s = super.updateSpec(t);
      t.type !== this.type && (s.reMake = !0);
      const { invalidType: r } = this._originalSpec;
      return (
        t.invalidType !== r && (s.reMake = !0),
        (V(n.extensionMark).length !== V(this._spec.extensionMark).length ||
          (null === (e = n.extensionMark) || void 0 === e
            ? void 0
            : e.some(
                (t, e) => t.type !== this._spec.extensionMark[e].type || t.id !== this._spec.extensionMark[e].id
              ))) &&
          (s.reMake = !0),
        s.reMake ||
          (this._marks.getMarks().some(t => {
            var e, i;
            return (
              (null === (e = n[t.name]) || void 0 === e ? void 0 : e.visible) !==
              (null === (i = this._spec[t.name]) || void 0 === i ? void 0 : i.visible)
            );
          }) && (s.reCompile = !0),
          (null === (i = n.extensionMark) || void 0 === i
            ? void 0
            : i.some((t, e) => t.visible !== this._spec.extensionMark[e].visible)) && (s.reCompile = !0)),
        s
      );
    }
    reInit(t, e) {
      super.reInit(t),
        this.initMarkStyle(),
        this.getMarksWithoutRoot().forEach(t => {
          (e && z(e[t.name], this._spec[t.name])) ||
            (this._spec[t.name] && this.initMarkStyleWithSpec(t, this._spec[t.name]),
            t.updateStaticEncode(),
            t.updateLayoutState(!0));
        }),
        this._updateExtensionMarkSpec(e);
    }
    onEvaluateEnd(t) {
      this._data.updateData();
    }
    onRender(t) {}
    release() {
      var t;
      super.release(), this._viewDataMap.clear();
      const e = this._rawData.transformsArr.findIndex(t => 'addVChartProperty' === t.type);
      e >= 0 && this._rawData.transformsArr.splice(e, 1),
        null === (t = this._data) || void 0 === t || t.release(),
        (this._dataSet =
          this._data =
          this._rawData =
          this._rawDataStatistics =
          this._spec =
          this._region =
          this._viewDataStatistics =
          this._viewStackData =
            null);
    }
    onLayoutEnd(t) {
      const e = this.getRegion();
      this.setLayoutRect(e.getLayoutRect()), this.setLayoutStartPosition(e.getLayoutStartPoint()), super.onLayoutEnd(t);
    }
    getSeriesKeys() {
      var t, e, i;
      return this._seriesField
        ? null !==
            (i =
              null ===
                (e =
                  null === (t = this._rawDataStatistics) || void 0 === t ? void 0 : t.latestData[this._seriesField]) ||
              void 0 === e
                ? void 0
                : e.values) && void 0 !== i
          ? i
          : []
        : this.name
        ? [this.name]
        : this.userId
        ? [`${this.userId}`]
        : [`${this.type}_${this.id}`];
    }
    getSeriesStyle(t) {
      return e => {
        var i, n;
        return null !== (n = null === (i = this._seriesMark) || void 0 === i ? void 0 : i.getAttribute(e, t)) &&
          void 0 !== n
          ? n
          : null;
      };
    }
    _getSeriesInfo(t, e) {
      const i = this.getDefaultShapeType();
      return e.map(e => ({ key: e, style: this.getSeriesStyle({ [t]: e }), shapeType: i }));
    }
    getSeriesInfoInField(t) {
      var e, i;
      return this._getSeriesInfo(
        t,
        null !== (i = null === (e = this._rawDataStatistics.latestData[t]) || void 0 === e ? void 0 : e.values) &&
          void 0 !== i
          ? i
          : []
      );
    }
    getSeriesInfoList() {
      var t;
      return this._getSeriesInfo(null !== (t = this._seriesField) && void 0 !== t ? t : qq, this.getSeriesKeys());
    }
    getDefaultColorScale() {
      var t, e;
      const i = this.getDefaultColorDomain(),
        n = nV(this._option.getTheme().colorScheme, this.type);
      return null === (e = (t = new hV().domain(i)).range) || void 0 === e ? void 0 : e.call(t, n);
    }
    getDefaultColorDomain() {
      var t, e;
      return this._seriesField
        ? null ===
            (e = null === (t = this._viewDataStatistics) || void 0 === t ? void 0 : t.latestData[this._seriesField]) ||
          void 0 === e
          ? void 0
          : e.values
        : [];
    }
    getColorAttribute() {
      var t, e;
      return {
        scale:
          null !== (t = this._option.globalScale.getScale('color')) && void 0 !== t ? t : this.getDefaultColorScale(),
        field: null !== (e = this._seriesField) && void 0 !== e ? e : qq
      };
    }
    getDimensionField() {
      return [];
    }
    getMeasureField() {
      return [];
    }
    onMarkPositionUpdate() {
      this.onMarkTreePositionUpdate(this.getMarksWithoutRoot());
    }
    onMarkTreePositionUpdate(t) {}
    setCurrentTheme(t, e) {
      return yn(this, void 0, void 0, function* () {
        const i = () => (this.reInit(t), { change: !0, reMake: !1 });
        e ? i() : yield this._option.globalInstance.updateCustomConfigAndRerender(i);
      });
    }
    _initTheme(t) {
      var e;
      const i = this._option.getTheme();
      t ? super._initTheme(t) : super._initTheme(null !== (e = i.series[this.type]) && void 0 !== e ? e : {}),
        this._mergeThemeToSpec();
    }
    _createMark(t, e = {}) {
      var i, n, s, r;
      const {
          key: o,
          groupKey: c,
          skipBeforeLayouted: d,
          themeSpec: u = {},
          markSpec: p,
          dataView: g,
          dataProductId: f,
          parent: v,
          isSeriesMark: m,
          dataStatistics: y,
          depend: _,
          label: b,
          progressive: x,
          support3d: S = this._spec.support3d || !!this._spec.zField,
          morph: w = !1
        } = e,
        A = super._createMark(t, {
          key: null != o ? o : this._getDataIdKey(),
          support3d: S,
          dataStatistics: null != y ? y : this._rawDataStatistics,
          attributeContext: this._markAttributeContext
        });
      if (h(A)) {
        this._marks.addMark(A, { name: t.name }),
          m && (this._seriesMark = A),
          l(v) ? null === (i = this._rootMark) || void 0 === i || i.addMark(A) : !1 !== v && v.addMark(A),
          l(g)
            ? (A.setDataView(this.getViewData(), this.getViewDataProductId()), A.setSkipBeforeLayouted(!0))
            : !1 !== g && A.setDataView(g, f),
          a(d) && A.setSkipBeforeLayouted(d),
          h(_) && A.setDepend(...V(_)),
          h(b) && A.addLabelSpec(b);
        const o = this.getSpec() || {};
        A.setMorph(w),
          A.setMorphKey((null === (n = o.morph) || void 0 === n ? void 0 : n.morphKey) || `${this._specIndex}`),
          A.setMorphElementKey(
            null !== (r = null === (s = o.morph) || void 0 === s ? void 0 : s.morphElementKey) && void 0 !== r
              ? r
              : e.defaultMorphElementKey
          ),
          l(x) || A.setProgressiveConfig(x),
          l(c) || A.setGroupKey(c),
          this.initMarkStyleWithSpec(A, _J({}, u, p || o[A.name]));
      }
      return A;
    }
    _getDataIdKey() {
      var t;
      return null !== (t = super._getDataIdKey()) && void 0 !== t ? t : Kq;
    }
    _getSeriesDataKey(t) {
      let e = '';
      if (!t) return e;
      return (
        (e = this.getDimensionField()
          .map(e => t[e])
          .join('_')),
        this.getSeriesField() && (e += `_${t[this.getSeriesField()]}`),
        e
      );
    }
    addViewDataFilter(t) {
      var e;
      null === (e = this._viewDataFilter) || void 0 === e || e.transform(t, !1);
    }
    reFilterViewData() {
      var t;
      null === (t = this._viewDataFilter) || void 0 === t || t.reRunAllTransform();
    }
    reTransformViewData() {
      var t, e;
      null === (e = null === (t = this._data) || void 0 === t ? void 0 : t.getDataView()) ||
        void 0 === e ||
        e.reRunAllTransform();
    }
    fillData() {
      var t;
      null === (t = this.getRawData()) || void 0 === t || t.reRunAllTransform();
    }
    compile() {
      this.compileSignal(), this.compileData();
    }
    getDefaultShapeType() {
      return 'circle';
    }
    getFieldAlias(t) {
      var e;
      return (
        (t !== tZ && t !== iZ && t !== Qq && t !== eZ) || (t = this.getStackValueField()),
        null !== (e = jJ(this.getRawData(), t)) && void 0 !== e ? e : t
      );
    }
    getMarkInfoList() {
      var t;
      const e = super.getMarkInfoList();
      return e.length ? e : Object.values(null !== (t = fJ[this.type]) && void 0 !== t ? t : {});
    }
    _getInvalidConnectType() {
      return 'zero' === this._invalidType ? 'zero' : 'link' === this._invalidType ? 'connect' : 'none';
    }
  }
  function Z1(t, e, i) {
    const n = t.getScale(0),
      s = 'isInverse' in t && t.isInverse();
    Zo(n.type)
      ? i.sort((t, i) => (t[e] - i[e]) * (s ? -1 : 1))
      : i.sort((t, i) => (n._index.get(t[e]) - n._index.get(i[e])) * (s ? -1 : 1));
  }
  q1.mark = zZ;
  class J1 extends q1 {
    constructor() {
      super(...arguments),
        (this.coordinate = 'cartesian'),
        (this._bandPosition = 0.5),
        (this._scaleConfig = { bandPosition: this._bandPosition }),
        (this._direction = JJ.vertical),
        (this._sortDataByAxis = !1);
    }
    _buildScaleConfig() {
      this._scaleConfig = { bandPosition: this._bandPosition };
    }
    get fieldX() {
      return this._fieldX;
    }
    setFieldX(t) {
      this._fieldX = V(t);
    }
    get fieldY() {
      return this._fieldY;
    }
    setFieldY(t) {
      this._fieldY = V(t);
    }
    get fieldZ() {
      return this._fieldZ;
    }
    setFieldZ(t) {
      this._fieldZ = t && V(t);
    }
    get fieldX2() {
      return this._fieldX2;
    }
    setFieldX2(t) {
      this._fieldX2 = t;
    }
    get fieldY2() {
      return this._fieldY2;
    }
    setFieldY2(t) {
      this._fieldY2 = t;
    }
    get direction() {
      return this._direction;
    }
    get scaleX() {
      return this._scaleX;
    }
    setScaleX(t) {
      this._scaleX = t;
    }
    get scaleY() {
      return this._scaleY;
    }
    setScaleY(t) {
      this._scaleY = t;
    }
    get scaleZ() {
      return this._scaleZ;
    }
    setScaleZ(t) {
      this._scaleZ = t;
    }
    getXAxisHelper() {
      return this._xAxisHelper;
    }
    setXAxisHelper(t) {
      (this._xAxisHelper = t), this.onXAxisHelperUpdate();
    }
    getYAxisHelper() {
      return this._yAxisHelper;
    }
    setYAxisHelper(t) {
      (this._yAxisHelper = t), this.onYAxisHelperUpdate();
    }
    getZAxisHelper() {
      return this._zAxisHelper;
    }
    setZAxisHelper(t) {
      (this._zAxisHelper = t), this.onYAxisHelperUpdate();
    }
    get sortDataByAxis() {
      return this._sortDataByAxis;
    }
    getStatisticFields() {
      var t, e, i;
      const n = [];
      return (
        (null === (t = this.getXAxisHelper()) || void 0 === t ? void 0 : t.getScale) &&
          (this._fieldX2 ? [...this._fieldX, this._fieldX2] : this._fieldX).forEach(t => {
            const e = { key: t, operations: [] };
            Zo(this.getXAxisHelper().getScale(0).type) ? (e.operations = ['max', 'min']) : (e.operations = ['values']),
              n.push(e);
          }),
        (null === (e = this.getYAxisHelper()) || void 0 === e ? void 0 : e.getScale) &&
          (this._fieldY2 ? [...this._fieldY, this._fieldY2] : this._fieldY).forEach(t => {
            const e = { key: t, operations: [] };
            Zo(this.getYAxisHelper().getScale(0).type) ? (e.operations = ['max', 'min']) : (e.operations = ['values']),
              n.push(e);
          }),
        this._fieldZ &&
          (null === (i = this.getZAxisHelper()) || void 0 === i ? void 0 : i.getScale) &&
          this._fieldZ.forEach(t => {
            const e = { key: t, operations: [] };
            Zo(this.getZAxisHelper().getScale(0).type) ? (e.operations = ['max', 'min']) : (e.operations = ['values']),
              n.push(e);
          }),
        this.getStack() && n.push({ key: this.getStackValueField(), operations: ['allValid'] }),
        n
      );
    }
    getGroupFields() {
      return 'vertical' === this.direction ? this._fieldX : this._fieldY;
    }
    getStackGroupFields() {
      return this.getGroupFields();
    }
    getStackValueField() {
      return this.direction === JJ.vertical ? V(this._spec.yField)[0] : V(this._spec.xField)[0];
    }
    setValueFieldToStack() {
      this.direction === JJ.vertical
        ? (this.setFieldY(tZ), this.setFieldY2(Qq))
        : (this.setFieldX(tZ), this.setFieldX2(Qq));
    }
    setValueFieldToPercent() {
      this.direction === JJ.vertical
        ? (this.setFieldY(iZ), this.setFieldY2(eZ))
        : (this.setFieldX(iZ), this.setFieldX2(eZ));
    }
    setValueFieldToStackOffsetSilhouette() {
      this.direction === JJ.vertical
        ? (this.setFieldY(sZ), this.setFieldY2(nZ))
        : (this.setFieldX(sZ), this.setFieldX2(nZ));
    }
    onXAxisHelperUpdate() {
      this.onMarkPositionUpdate();
    }
    onYAxisHelperUpdate() {
      this.onMarkPositionUpdate();
    }
    onZAxisHelperUpdate() {
      this.onMarkPositionUpdate();
    }
    updateSpec(t) {
      const e = this._originalSpec,
        { xField: i, yField: n } = e,
        s = super.updateSpec(t);
      return (bo(t.xField, i) && bo(t.yField, n)) || ((s.change = !0), (s.reRender = !0), (s.reMake = !0)), s;
    }
    setAttrFromSpec() {
      var t, e;
      super.setAttrFromSpec(),
        this.setFieldX(this._spec.xField),
        this.setFieldY(this._spec.yField),
        this.setFieldZ(this._spec.zField),
        h(this._spec.direction) && (this._direction = this._spec.direction),
        this.setFieldX2(null === (t = this._spec) || void 0 === t ? void 0 : t.x2Field),
        this.setFieldY2(null === (e = this._spec) || void 0 === e ? void 0 : e.y2Field),
        this._stack && this.setValueFieldToStack(),
        this._percent && this.setValueFieldToPercent(),
        this._stackOffsetSilhouette && this.setValueFieldToStackOffsetSilhouette(),
        h(this._spec.sortDataByAxis) && (this._sortDataByAxis = !0 === this._spec.sortDataByAxis);
    }
    dataToPosition(t) {
      return t ? { x: this.dataToPositionX(t), y: this.dataToPositionY(t) } : null;
    }
    _buildMarkAttributeContext() {
      super._buildMarkAttributeContext(),
        (this._markAttributeContext.valueToX = this.valueToPositionX.bind(this)),
        (this._markAttributeContext.valueToY = this.valueToPositionY.bind(this)),
        (this._markAttributeContext.xBandwidth = (t = 0) => {
          var e, i, n;
          return null !==
            (n = null === (i = (e = this.getXAxisHelper()).getBandwidth) || void 0 === i ? void 0 : i.call(e, t)) &&
            void 0 !== n
            ? n
            : 0;
        }),
        (this._markAttributeContext.yBandwidth = (t = 0) => {
          var e, i, n;
          return null !==
            (n = null === (i = (e = this.getYAxisHelper()).getBandwidth) || void 0 === i ? void 0 : i.call(e, t)) &&
            void 0 !== n
            ? n
            : 0;
        }),
        (this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this));
    }
    valueToPosition(t, e) {
      return { x: this.valueToPositionX(t), y: this.valueToPositionY(e) };
    }
    _axisPosition(t, e, i) {
      return (
        (this._scaleConfig.datum = i),
        t.isContinuous ? t.valueToPosition(e, this._scaleConfig) : t.dataToPosition(V(e), this._scaleConfig)
      );
    }
    valueToPositionX(t, e) {
      return this._axisPosition(this._xAxisHelper, t, e);
    }
    valueToPositionY(t, e) {
      return this._axisPosition(this._yAxisHelper, t, e);
    }
    dataToPositionX(t) {
      if (!this._xAxisHelper) return Number.NaN;
      const e = this._xAxisHelper.getFields ? this._xAxisHelper.getFields() : this._fieldX;
      return e && 0 !== e.length
        ? this.valueToPositionX(
            this._xAxisHelper.isContinuous ? this.getDatumPositionValue(t, e[0]) : this.getDatumPositionValues(t, e),
            t
          )
        : null;
    }
    dataToPositionY(t) {
      if (!this._yAxisHelper) return Number.NaN;
      const e = this._yAxisHelper.getFields ? this._yAxisHelper.getFields() : this._fieldY;
      return e && 0 !== e.length
        ? this.valueToPositionY(
            this._yAxisHelper.isContinuous ? this.getDatumPositionValue(t, e[0]) : this.getDatumPositionValues(t, e),
            t
          )
        : null;
    }
    dataToPositionZ(t) {
      if (!this._zAxisHelper) return Number.NaN;
      const { dataToPosition: e } = this._zAxisHelper;
      return e(this.getDatumPositionValues(t, this._fieldZ), { bandPosition: this._bandPosition });
    }
    dataToPositionX1(t) {
      var e, i;
      return this._xAxisHelper
        ? this._fieldX2 && this._fieldX2 in t
          ? this.valueToPositionX(this.getDatumPositionValues(t, this._fieldX2))
          : null === (i = (e = this._xAxisHelper).getScale) || void 0 === i
          ? void 0
          : i.call(e, 0).range()[0]
        : Number.NaN;
    }
    dataToPositionY1(t) {
      var e, i;
      return this._yAxisHelper
        ? this._fieldY2 && this._fieldY2 in t
          ? this.valueToPositionY(this.getDatumPositionValues(t, this._fieldY2))
          : null === (i = (e = this._yAxisHelper).getScale) || void 0 === i
          ? void 0
          : i.call(e, 0).range()[0]
        : Number.NaN;
    }
    positionToData(t) {
      return t ? { x: this.positionToDataX(t.x), y: this.positionToDataY(t.y) } : null;
    }
    positionToDataX(t) {
      return this._scaleX ? this._scaleX.invert(t) : null;
    }
    positionToDataY(t) {
      return this._scaleY ? this._scaleY.invert(t) : null;
    }
    getRegionRectLeft() {
      if (!this._xAxisHelper) return Number.NaN;
      const { getScale: t } = this._xAxisHelper;
      return t(0).range()[0];
    }
    getRegionRectRight() {
      if (!this._xAxisHelper) return Number.NaN;
      const { getScale: t } = this._xAxisHelper;
      return t(0).range()[1];
    }
    afterInitMark() {
      super.afterInitMark(),
        this.setFieldX(this._fieldX),
        this.setFieldY(this._fieldY),
        this._trigger.setStateKeys([...this._fieldX, ...this._fieldY]),
        this._buildScaleConfig();
    }
    getDimensionField() {
      return this._direction === JJ.vertical ? this.fieldX : this.fieldY;
    }
    getMeasureField() {
      var t, e;
      return this._direction === JJ.vertical
        ? V(null !== (t = this._spec.yField) && void 0 !== t ? t : this.fieldY)
        : V(null !== (e = this._spec.xField) && void 0 !== e ? e : this.fieldX);
    }
    viewDataUpdate(t) {
      super.viewDataUpdate(t), this.sortDataByAxis && this._sortDataInAxisDomain();
    }
    _sortDataInAxisDomain() {
      var t, e;
      (null === (e = null === (t = this.getViewData()) || void 0 === t ? void 0 : t.latestData) || void 0 === e
        ? void 0
        : e.length) &&
        Z1(
          this._direction === JJ.horizontal ? this._yAxisHelper : this._xAxisHelper,
          this._direction === JJ.horizontal ? this._fieldY[0] : this._fieldX[0],
          this.getViewData().latestData
        );
    }
  }
  class Q1 extends g0 {
    setStyle(t, e = 'normal', i = 0, n = this.stateStyle) {
      if (l(t)) return;
      void 0 === n[e] && (n[e] = {});
      const s = this._getIgnoreAttributes(),
        r = [
          'strokeWidth',
          'lineWidth',
          'lineDash',
          'strokeDash',
          'lineJoin',
          'stroke',
          'strokeOpacity',
          'opacity',
          'fill',
          'fillOpacity',
          'texture',
          'texturePadding',
          'textureSize',
          'textureColor'
        ],
        a = this.isUserLevel(i);
      let h = !1;
      Object.keys(t).forEach(c => {
        const d = t[c];
        if (l(d) || s.includes(c)) return;
        a && r.includes(c) && (Jo(null == d ? void 0 : d.type) || (null == d ? void 0 : d.scale) || o(d)) && (h = !0);
        let u = this._styleConvert(d);
        a && 'angle' === c && (u = this.convertAngleToRadian(u)), this.setAttribute(c, u, e, i, n);
      }),
        h && this.setAttribute('enableSegments', !0, e, i, n);
    }
  }
  class t2 extends Q1 {
    constructor() {
      super(...arguments), (this.type = t2.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), { lineWidth: 1 });
    }
    _getIgnoreAttributes() {
      var t, e;
      return (null === (t = this.model) || void 0 === t ? void 0 : t.type) === DZ.radar &&
        'polar' === (null === (e = this.model) || void 0 === e ? void 0 : e.coordinate)
        ? []
        : ['fill', 'fillOpacity'];
    }
  }
  t2.type = jZ.line;
  class e2 extends Q1 {
    constructor() {
      super(...arguments), (this.type = e2.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), { lineWidth: 0 });
    }
    _getIgnoreAttributes() {
      return [];
    }
  }
  e2.type = jZ.area;
  class i2 extends g0 {
    constructor() {
      super(...arguments), (this.type = i2.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), {
        angle: 0,
        textAlign: 'center',
        lineWidth: 0
      });
    }
  }
  i2.type = jZ.text;
  class n2 extends g0 {
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), {
        size: 1,
        symbolType: ZJ.circle,
        fill: void 0,
        lineWidth: 0
      });
    }
  }
  class s2 extends n2 {
    constructor() {
      super(...arguments), (this.type = s2.type);
    }
  }
  s2.type = jZ.symbol;
  class r2 extends z1 {
    constructor() {
      super(...arguments),
        (this._getSeriesStyle = (t, e, i) => {
          var n, s, r, a;
          for (const i of V(e)) {
            let e = null === (n = this.series.getSeriesStyle(t)) || void 0 === n ? void 0 : n(i);
            if (
              (!1 !== e ||
                ('fill' !== i && 'stroke' !== i) ||
                (e =
                  'fill' === i
                    ? null ===
                        (r = null === (s = this.series.getSeriesStyle(t)) || void 0 === s ? void 0 : s('stroke')) ||
                      void 0 === r
                      ? void 0
                      : r[0]
                    : null === (a = this.series.getSeriesStyle(t)) || void 0 === a
                    ? void 0
                    : a('fill')),
              h(e))
            )
              return e;
          }
          return i;
        });
    }
  }
  NQ.useMark([t2, e2, i2, s2]);
  class a2 extends J1 {
    constructor() {
      super(...arguments), (this.type = DZ.area), (this._stack = !0), (this._sortDataByAxis = !1);
    }
    setAttrFromSpec() {
      var t, e, i, n, s, r, a, o, l, c, d;
      super.setAttrFromSpec();
      const u =
          !1 !== (null === (t = this._spec.area) || void 0 === t ? void 0 : t.visible) &&
          !1 !==
            (null === (i = null === (e = this._spec.area) || void 0 === e ? void 0 : e.style) || void 0 === i
              ? void 0
              : i.visible),
        p =
          !1 !== (null === (n = this._spec.line) || void 0 === n ? void 0 : n.visible) &&
          !1 !==
            (null === (r = null === (s = this._spec.line) || void 0 === s ? void 0 : s.style) || void 0 === r
              ? void 0
              : r.visible),
        g = null !== (a = this._spec.area) && void 0 !== a ? a : {},
        f = null !== (o = this._spec.line) && void 0 !== o ? o : {};
      (g.interactive = g.interactive || f.interactive),
        (g.support3d = g.support3d || f.support3d),
        (g.zIndex =
          h(g.zIndex) || h(f.zIndex)
            ? Math.max(null !== (l = g.zIndex) && void 0 !== l ? l : 0, null !== (c = f.zIndex) && void 0 !== c ? c : 0)
            : void 0),
        g.style && delete g.style.stroke,
        g.state &&
          Object.keys(g.state).forEach(t => {
            'style' in g.state[t] ? delete g.state[t].style.stroke : delete g.state[t].stroke;
          });
      let v = g,
        m = f;
      ('line' === (null !== (d = this._spec.seriesMark) && void 0 !== d ? d : 'area') || (p && !u)) &&
        ((v = f), (m = g)),
        (g.style = _J({}, m.style, v.style)),
        (g.state = _J({}, m.state, v.state)),
        u || (g.style.fill = !1),
        p || (g.style.stroke = !1),
        (g.visible = !(!u && !p));
    }
    initMark() {
      var t, e, i, n;
      const s = {
          progressiveStep: this._spec.progressiveStep,
          progressiveThreshold: this._spec.progressiveThreshold,
          large: this._spec.large,
          largeThreshold: this._spec.largeThreshold
        },
        r =
          !1 !== (null === (t = this._spec.area) || void 0 === t ? void 0 : t.visible) &&
          !1 !==
            (null === (i = null === (e = this._spec.area) || void 0 === e ? void 0 : e.style) || void 0 === i
              ? void 0
              : i.visible),
        a = null !== (n = this._spec.seriesMark) && void 0 !== n ? n : 'area';
      (this._areaMark = this._createMark(a2.mark.area, {
        groupKey: this._seriesField,
        defaultMorphElementKey: this.getDimensionField()[0],
        progressive: s,
        isSeriesMark: r && 'point' !== a
      })),
        this.initSymbolMark(s, 'point' === a);
    }
    initMarkStyle() {
      var t, e, i, n, s;
      const r =
          null !==
            (i =
              null === (e = null === (t = this.getSpec().area) || void 0 === t ? void 0 : t.style) || void 0 === e
                ? void 0
                : e.curveType) && void 0 !== i
            ? i
            : null === (s = null === (n = this.getSpec().line) || void 0 === n ? void 0 : n.style) || void 0 === s
            ? void 0
            : s.curveType,
        a = r === KJ ? (this._direction === JJ.vertical ? 'monotoneX' : 'monotoneY') : r,
        o = this._areaMark;
      o &&
        (this._direction === JJ.vertical
          ? this.setMarkStyle(
              this._areaMark,
              {
                x: this.dataToPositionX.bind(this),
                y1: t => {
                  var e, i;
                  return uV(
                    this.dataToPositionY1(t),
                    null === (i = null === (e = this._yAxisHelper) || void 0 === e ? void 0 : e.getScale) ||
                      void 0 === i
                      ? void 0
                      : i.call(e, 0)
                  );
                },
                y: this.dataToPositionY.bind(this),
                z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
              },
              'normal',
              Jq.Series
            )
          : this.setMarkStyle(
              this._areaMark,
              {
                x: this.dataToPositionX.bind(this),
                x1: t => {
                  var e, i;
                  return uV(
                    this.dataToPositionX1(t),
                    null === (i = null === (e = this._xAxisHelper) || void 0 === e ? void 0 : e.getScale) ||
                      void 0 === i
                      ? void 0
                      : i.call(e, 0)
                  );
                },
                y: this.dataToPositionY.bind(this),
                z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
                orient: this._direction
              },
              'normal',
              Jq.Series
            ),
        this.setMarkStyle(o, { fill: this.getColorAttribute(), stroke: this.getColorAttribute() }, 'normal', Jq.Series),
        'zero' !== this._invalidType &&
          this.setMarkStyle(
            o,
            { defined: this._getInvalidDefined, connectedType: this._getInvalidConnectType() },
            'normal',
            Jq.Series
          ),
        this.setMarkStyle(o, { curveType: a }, 'normal', Jq.Built_In),
        this._trigger.registerMark(o),
        this._tooltipHelper.activeTriggerSet.dimension.add(o),
        Object.keys(o.stateStyle).forEach(t => {
          o.stateStyle[t].stroke && o.setPostProcess('stroke', t => [t, !1, !1, !1], t);
        })),
        this.initLineMarkStyle(this._direction, r),
        this.initSymbolMarkStyle(),
        this.initLabelMarkStyle();
    }
    initAnimation() {
      var t, e;
      const i = { direction: this.direction },
        n =
          null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
            ? void 0
            : e.preset;
      this._lineMark && this._lineMark.setAnimationConfig(w1(x1.line(i, n), A1(LZ.line, this._spec))),
        this._areaMark && this._areaMark.setAnimationConfig(w1(x1.area(i, n), A1(LZ.area, this._spec))),
        this._symbolMark && this._symbolMark.setAnimationConfig(w1(x1.symbol(), A1(LZ.point, this._spec)));
    }
    initTooltip() {
      this._tooltipHelper = new r2(this);
    }
    viewDataStatisticsUpdate(t) {
      super.viewDataStatisticsUpdate(t), this.encodeDefined(this._areaMark, 'defined');
    }
    getDefaultShapeType() {
      return 'square';
    }
  }
  (a2.type = DZ.area), (a2.mark = UZ), N(a2, E1);
  class o2 {
    constructor(t, e) {
      (this._scaleSpecMap = new Map()),
        (this._scaleMap = new Map()),
        (this._modelScaleSpecMap = new Map()),
        (this._markAttributeScaleMap = new Map()),
        (this._spec = null),
        (this._chart = null),
        (this.getStatisticalFields = t => {
          const e = [];
          return (
            this._scaleSpecMap.forEach((i, n) => {
              Bo(i.domain) &&
                i.domain.forEach(n => {
                  n.dataId === t &&
                    n.fields.forEach(t => {
                      LJ(e, [{ key: t, operations: Zo(i.type) ? ['max', 'min'] : ['values'] }]);
                    });
                });
            }),
            this._markAttributeScaleMap.forEach((i, n) => {
              const s = this.getScale(n);
              i.forEach(i => {
                var n;
                (null === (n = i.dataStatistics) || void 0 === n ? void 0 : n.rawData[0].name) === t &&
                  i.field &&
                  LJ(e, [{ key: i.field, operations: Zo(s.type) ? ['max', 'min'] : ['values'] }]);
              });
            }),
            e
          );
        }),
        (this._spec = t),
        (this._chart = e),
        this._setAttrFromSpec();
    }
    _createFromSpec(t) {
      if (!t.id) return null;
      let e = this._scaleMap.get(t.id);
      return (
        e || (e = 'ordinal' === t.type && 'color' === t.id ? dV('colorOrdinal') : dV(t.type)),
        e
          ? (f(t.range) && e.range(t.range),
            f(t.domain) && (Bo(t.domain) || e.domain(t.domain)),
            t.specified && e.specified && e.specified(t.specified),
            e)
          : null
      );
    }
    _setAttrFromSpec() {
      var t;
      if (!(null === (t = this._spec) || void 0 === t ? void 0 : t.length)) return;
      const e = new Map(),
        i = new Map();
      this._spec.forEach(t => {
        const n = this._createFromSpec(t);
        n && (e.set(t.id, n), i.set(t.id, t));
      }),
        this._modelScaleSpecMap.forEach(t => {
          const n = this._createFromSpec(t);
          n && (e.set(t.id, n), i.set(t.id, t));
        }),
        (this._scaleSpecMap = i),
        (this._scaleMap = e);
    }
    updateSpec(t) {
      const e = { change: !1, reMake: !1, reRender: !1, reSize: !1, reCompile: !1 };
      if (z(t, this._spec)) return e;
      e.change = !0;
      for (let i = 0; i < t.length; i++) {
        const n = t[i],
          s = this._scaleMap.get(n.id);
        if (!s) return (e.reMake = !0), e;
        const r = this._spec.find(t => t.id === n.id);
        if (!r.id) return (e.reMake = !0), e;
        if (r.type !== n.type) return (e.reMake = !0), e;
        n.range && !z(n.range, s.range()) && (s.range(n.range), (e.reRender = !0)),
          Bo(n.domain) ? (e.reRender = !0) : z(n.domain, s.domain()) || (s.domain(n.domain), (e.reRender = !0)),
          this._scaleSpecMap.set(n.id, n);
      }
      return (this._spec = t), e;
    }
    registerModelScale(t) {
      const e = this._createFromSpec(t);
      e && (this._modelScaleSpecMap.set(t.id, t), this._scaleSpecMap.set(t.id, t), this._scaleMap.set(t.id, e));
    }
    removeModelScale(t) {
      this._modelScaleSpecMap.forEach(e => {
        t(e) && (this._modelScaleSpecMap.delete(e.id), this._scaleSpecMap.delete(e.id), this._scaleMap.delete(e.id));
      });
    }
    getScale(t) {
      return this._scaleMap.get(t);
    }
    getScaleSpec(t) {
      return this._scaleSpecMap.get(t);
    }
    _getStatistics(t) {
      const e = this._chart.getAllSeries();
      for (let i = 0; i < e.length; i++) {
        const n = e[i];
        if (n.getRawData().name === t) return n.getRawDataStatistics();
      }
      return null;
    }
    updateScaleDomain(t) {
      this._scaleSpecMap.forEach((e, i) => {
        const n = this._scaleMap.get(i);
        if (!n) return;
        if (!Bo(e.domain))
          return (e.domain && 0 !== e.domain.length) || n.domain(t), void this._updateMarkScale(i, n, [...n.domain()]);
        let s;
        (s = Zo(e.type) ? [null, null] : new Set()),
          e.domain.forEach(t => {
            const i = this._getStatistics(t.dataId);
            i &&
              t.fields.forEach(t => {
                Zo(e.type)
                  ? (l(s[0]) ? (s[0] = i.latestData[t].min) : (s[0] = Math.min(i.latestData[t].min, s[0])),
                    l(s[1]) ? (s[1] = i.latestData[t].max) : (s[1] = Math.max(i.latestData[t].max, s[1])))
                  : i.latestData[t].values.forEach(t => {
                      s.add(t);
                    });
              });
          });
        const r = s;
        Zo(e.type) || (s = Array.from(s)), n.domain(s), this._updateMarkScale(i, n, r);
      });
    }
    _updateMarkScale(t, e, i) {
      const n = this._markAttributeScaleMap.get(t);
      n &&
        0 !== n.length &&
        n.forEach(t => {
          if (t.field && t.markScale && t.markScale !== e) {
            if (
              !l(t.changeDomain) &&
              'none' !== t.changeDomain &&
              t.dataStatistics &&
              t.dataStatistics.latestData[t.field]
            )
              return 'expand' === t.changeDomain
                ? (Zo(e.type)
                    ? ((i[0] = Math.min(i[0], t.dataStatistics.latestData[t.field].min)),
                      (i[1] = Math.max(i[1], t.dataStatistics.latestData[t.field].max)))
                    : (t.dataStatistics.latestData[t.field].values.forEach(t => {
                        i.add(t);
                      }),
                      (i = Array.from(i))),
                  void t.markScale.domain(i))
                : void (
                    'replace' !== t.changeDomain ||
                    (Zo(e.type)
                      ? t.markScale.domain([
                          t.dataStatistics.latestData[t.field].min,
                          t.dataStatistics.latestData[t.field].max
                        ])
                      : t.markScale.domain(t.dataStatistics.latestData[t.field].values))
                  );
            Zo(e.type) ? t.markScale.domain(i) : e.domain(Array.from(i));
          }
        });
    }
    registerMarkAttributeScale(t, e) {
      const i = this._scaleMap.get(t.scale);
      let n = this._markAttributeScaleMap.get(t.scale);
      n || ((n = []), this._markAttributeScaleMap.set(t.scale, n));
      let s = i;
      return (
        (l(t.field) || (!l(t.changeDomain) && 'none' !== t.changeDomain && !l(e))) && (s = i.clone()),
        n.push(Object.assign(Object.assign({}, t), { dataStatistics: e, markScale: s })),
        s
      );
    }
  }
  class l2 {
    constructor(t) {
      (this.stackRegion = ({ model: t }) => {
        const e = { nodes: {} };
        t.getSeries().forEach(t => {
          const i = t.getStackData(),
            n = t.getStackValueField();
          i && n && this.stackGroup(i, e, n);
        });
        for (const t in e.nodes) this.stack(e.nodes[t]);
        for (const t in e.nodes) this.stackOffsetSilhouette(e.nodes[t]);
        t.getSeries().forEach(t => {
          const i = t.getStackData(),
            n = t.getStackValueField();
          i && n && this.stackTotal(e, n);
        });
      }),
        (this._chart = t);
    }
    init() {
      this._chart.getAllRegions().forEach(t => {
        t.event.on(
          Gq.regionSeriesDataFilterOver,
          { filter: ({ model: e }) => (null == e ? void 0 : e.id) === t.id },
          this.stackRegion
        );
      });
    }
    stackAll() {
      this._chart.getAllRegions().forEach(t => {
        this.stackRegion({ model: t });
      });
    }
    stackTotal(t, e) {
      if ('values' in t && t.values.length) {
        const i = KN(t.values, e),
          n = XN(t.values, iZ);
        t.values.forEach(t => {
          (t[rZ] = i), (t[aZ] = n), delete t[oZ];
        });
        const s = t.values.reduce((t, e) => (e[tZ] > t[tZ] ? e : t));
        s[oZ] = !0;
      } else for (const i in t.nodes) this.stackTotal(t.nodes[i], e);
    }
    stackOffsetSilhouette(t) {
      if (!t.values.length) return;
      const e = t.values[t.values.length - 1][tZ] / 2;
      for (let i = 0; i < t.values.length; i++)
        (t.values[i][nZ] = t.values[i][Qq] - e), (t.values[i][sZ] = t.values[i][tZ] - e);
    }
    stack(t) {
      if (t.values.length > 0) {
        let e = 0,
          i = 0,
          n = 1,
          s = 0;
        t.values.forEach(t => {
          (s = t[tZ]), s >= 0 ? ((t[Qq] = e), (e += t[tZ]), (t[tZ] = e)) : ((t[Qq] = i), (i += t[tZ]), (t[tZ] = i));
        }),
          t.values.forEach(t => {
            s = t[tZ];
            const r = s >= 0 ? e : i;
            (n = s >= 0 ? 1 : -1),
              (t[eZ] = 0 === r ? 0 : Math.min(1, t[Qq] / r) * n),
              (t[iZ] = 0 === r ? 0 : Math.min(1, t[tZ] / r) * n);
          });
      }
      for (const e in t.nodes) this.stack(t.nodes[e]);
    }
    stackGroup(t, e, i) {
      if ('values' in t)
        return (
          t.values.forEach(
            t =>
              (t[tZ] = (function (t) {
                if (_(t)) return t;
                const e = +t;
                return _(e) ? e : 0;
              })(t[i]))
          ),
          void e.values.push(...t.values)
        );
      for (const n in t.nodes)
        !e.nodes[n] && (e.nodes[n] = { values: [], nodes: {} }), this.stackGroup(t.nodes[n], e.nodes[n], i);
    }
  }
  class h2 extends GQ {
    getSpec() {
      return this._spec;
    }
    setSpec(t) {
      this.transformSpec(t), (this._spec = t);
    }
    getOption() {
      return this._option;
    }
    getLayoutRect() {
      return this._layoutRect;
    }
    getViewRect() {
      return this._viewRect;
    }
    getEvent() {
      return this._event;
    }
    getLayoutTag() {
      return this._layoutTag;
    }
    setLayoutTag(t, e, i = !0) {
      var n;
      return (
        (this._layoutTag = t),
        (null === (n = this.getCompiler()) || void 0 === n ? void 0 : n.getVGrammarView()) &&
          (this.getCompiler().getVGrammarView().updateLayoutTag(), t && i && this.getCompiler().renderAsync(e)),
        this._layoutTag
      );
    }
    constructor(t, e) {
      var i, n, s;
      super(e),
        (this.type = 'chart'),
        (this.id = Ro()),
        (this._regions = []),
        (this._series = []),
        (this._components = []),
        (this._layoutRect = { x: 0, y: 0, width: YV, height: $V }),
        (this._viewRect = { width: YV, height: $V }),
        (this._viewBox = { x1: 0, y1: 0, x2: YV, y2: $V }),
        (this._idMap = new Map()),
        (this._layoutTag = !0),
        (this.state = { layoutUpdateRank: 1 }),
        (this.padding = { top: 0, left: 0, right: 0, bottom: 0 }),
        (this.getAllSeries = () => {
          var t;
          return null !== (t = this._series) && void 0 !== t ? t : [];
        }),
        (this.getRegionsInIndex = t =>
          t && 0 !== t.length ? this._regions.filter((e, i) => t.includes(i)) : [this._regions[0]]),
        (this.getAllRegions = () => this._regions),
        (this.getRegionsInIds = t => (t ? this._regions.filter(e => t.includes(e.id)) : [])),
        (this.getRegionsInQuerier = t =>
          t
            ? this._regions.filter((e, i) =>
                V(t).some(t => (h(t.regionId) && t.regionId === e.userId) || t.regionIndex === i)
              )
            : this._regions),
        (this.getRegionsInUserId = t => {
          if (t) return this._regions.find(e => e.userId === t);
        }),
        (this.getRegionsInUserIdOrIndex = (t, e) =>
          this.getAllRegions().filter(i =>
            (null == t ? void 0 : t.length)
              ? i.userId && t.includes(i.userId)
              : !(null == e ? void 0 : e.length) || e.includes(i.getSpecIndex())
          )),
        (this.getComponents = () => this._components),
        (this.getSeriesInIndex = t =>
          t && 0 !== t.length ? this._series.filter((e, i) => t.includes(i)) : [this._series[0]]),
        (this.getSeriesInIds = t => (t ? this._series.filter(e => t.includes(e.id)) : [])),
        (this.getSeriesInUserId = t => {
          if (t) return this._series.find(e => e.userId === t);
        }),
        (this.getSeriesInUserIdOrIndex = (t, e) =>
          this.getAllSeries().filter(i =>
            (null == t ? void 0 : t.length)
              ? i.userId && t.includes(i.userId)
              : !(null == e ? void 0 : e.length) || e.includes(i.getSpecIndex())
          )),
        (this.getComponentByIndex = (t, e) => {
          const i = this._components.filter(e => e.specKey === t);
          if (i && 0 !== i.length) return i[e];
        }),
        (this.getComponentsByKey = t => this._components.filter(e => e.specKey === t)),
        (this.getComponentByUserId = t => {
          const e = this._components.find(e => e.userId === t);
          if (e) return e;
        }),
        (this._theme = e.getTheme()),
        (this._paddingSpec = _V(
          null !== (i = t.padding) && void 0 !== i ? i : null === (n = this._theme) || void 0 === n ? void 0 : n.padding
        )),
        (this._event = new mQ(e.eventDispatcher, e.mode)),
        (this._dataSet = e.dataSet),
        (this._modelOption = Object.assign(Object.assign({}, e), {
          mode: this._option.mode,
          map: this._idMap,
          getChartLayoutRect: () => this._layoutRect,
          getChartViewRect: () => this._viewRect,
          getChart: () => this,
          globalScale: this._globalScale,
          onError: null === (s = this._option) || void 0 === s ? void 0 : s.onError
        })),
        (this._stack = new l2(this)),
        (this._spec = t);
    }
    created() {
      this.transformSpec(this._spec),
        this.createGlobalScale(),
        this.createBackground(this._spec.background),
        this.createLayout(),
        this.createRegion(this._spec.region),
        this.createSeries(this._spec.series),
        this.createComponent(this._spec);
    }
    transformSpec(t) {
      (t.region && 0 !== t.region.length) || (t.region = [{}]), P(t, 'tooltip') || (t.tooltip = {});
    }
    init(t = {}) {
      this.initRegion(),
        this.initSeries(),
        this.initComponent(),
        this.initEvent(),
        this._stack.init(),
        this.reDataFlow();
    }
    reDataFlow() {
      this._series.forEach(t => {
        var e;
        return null === (e = t.getRawData()) || void 0 === e ? void 0 : e.markRunning();
      }),
        this._series.forEach(t => t.fillData()),
        this.updateGlobalScaleDomain();
    }
    onResize(t, e) {
      const i = { width: t, height: e };
      (this._canvasRect = i), this._updateLayoutRect(this._option.viewBox), this.setLayoutTag(!0);
    }
    updateViewBox(t, e) {
      this._updateLayoutRect(t), this.setLayoutTag(!0, null, e);
    }
    createBackground(t) {
      t &&
        'object' == typeof t &&
        ((this._backgroundMark = UJ.createMark(jZ.group, 'chart-background', {
          model: this,
          map: this._option.map,
          getCompiler: this.getCompiler,
          globalScale: this._globalScale
        })),
        this._backgroundMark.created(),
        this._backgroundMark.setStyle(
          (function (t) {
            if (!t) return null;
            if ('string' == typeof t) return { fill: t, fillOpacity: 1 };
            if ('object' != typeof t) return null;
            const { x: e, y: i, width: n, height: s, x1: r, y1: a, image: o } = t,
              l = mn(t, ['x', 'y', 'width', 'height', 'x1', 'y1', 'image']);
            return (l.background = o), l;
          })(t)
        ),
        this._backgroundMark.setStyle({
          x: () => this._viewBox.x1,
          y: () => this._viewBox.y1,
          width: () => this._viewBox.x2 - this._viewBox.x1,
          height: () => this._viewBox.y2 - this._viewBox.y1
        }));
    }
    createRegion(t) {
      t &&
        t.forEach((t, e) => {
          const i = UJ.createRegion(
            'region',
            t,
            Object.assign(Object.assign({}, this._modelOption), { specIndex: e, specKey: 'region' })
          );
          i && (i.created(), this._regions.push(i));
        });
    }
    initRegion() {
      this._regions.forEach(t => t.init({}));
    }
    createSeries(t) {
      t.forEach((t, e) => {
        var i;
        let n;
        if (
          (t.data
            ? (t.data = EQ(t.data, this._dataSet, this._spec.data, {
                onError: null === (i = this._option) || void 0 === i ? void 0 : i.onError
              }))
            : (t.data = this.getSeriesData(t.dataId, t.dataIndex)),
          !1 === this._option.animation && (t.animation = !1),
          h(t.regionId)
            ? (n = this.getRegionsInUserId(t.regionId))
            : h(t.regionIndex) && (n = this.getRegionsInIndex([t.regionIndex])[0]),
          n || (n = this._regions[0]),
          !n)
        )
          return;
        const s = UJ.createSeries(
          t.type,
          t,
          Object.assign(Object.assign({}, this._modelOption), {
            region: n,
            specIndex: e,
            specKey: 'series',
            getTheme: () => this._theme,
            globalScale: this._globalScale,
            getSeriesData: this.getSeriesData.bind(this)
          })
        );
        s && (s.created(), this._series.push(s), n.addSeries(s));
      });
    }
    initSeries() {
      this._series.forEach(t => t.init({}));
    }
    getSeriesById(t) {
      return this._series.find(e => e.id === t);
    }
    _createComponent(t, e) {
      const i = t.createComponent(
        e,
        Object.assign(Object.assign({}, this._modelOption), {
          getAllRegions: this.getAllRegions,
          getRegionsInIndex: this.getRegionsInIndex,
          getRegionsInIds: this.getRegionsInIds,
          getRegionsInUserIdOrIndex: this.getRegionsInUserIdOrIndex,
          getTheme: () => this._theme,
          getAllSeries: this.getAllSeries,
          getSeriesInIndex: this.getSeriesInIndex,
          getSeriesInIds: this.getSeriesInIds,
          getSeriesInUserIdOrIndex: this.getSeriesInUserIdOrIndex,
          getAllComponents: this.getComponents,
          getComponentByIndex: this.getComponentByIndex,
          getComponentByUserId: this.getComponentByUserId,
          getComponentsByKey: this.getComponentsByKey
        })
      );
      i &&
        V(i).forEach(t => {
          t.created(), this._components.push(t);
        });
    }
    createComponent(t) {
      const e = UJ.getComponents();
      let i, n;
      const s = [];
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        r.type.startsWith(xn.cartesianAxis) ? (i = r) : r.type.startsWith(xn.polarAxis) ? (n = r) : s.push(r);
      }
      i && this._createComponent(i, t),
        n && this._createComponent(n, t),
        s.forEach(e => {
          this._createComponent(e, t);
        });
    }
    initComponent() {
      this._components.forEach(t => t.init({ dataSet: this._dataSet }));
    }
    getAllComponents() {
      return this._components;
    }
    getAllModels() {
      return [].concat(this.getAllSeries(), this.getAllComponents(), this.getAllRegions());
    }
    getModelInFilter(t) {
      if (g(t)) return this.getAllModels().find(e => e.userId === t);
      if (o(t)) return this.getAllModels().find(e => t(e));
      let e = 0;
      return this.getAllModels().find(i => {
        if (i.specKey === t.type) {
          if (e === t.index) return !0;
          e++;
        }
        return !1;
      });
    }
    createLayout() {
      this._updateLayoutRect(this._option.viewBox), this._initLayoutFunc();
    }
    setLayout(t) {
      (this._option.layout = t), this._initLayoutFunc();
    }
    _initLayoutFunc() {
      var t, e, i;
      if (((this._layoutFunc = this._option.layout), !this._layoutFunc)) {
        let n = !1;
        (this._spec.zField || (this._spec.series && this._spec.series.some(t => t.zField))) && (n = !0);
        const s = new (UJ.getLayout(
          null !== (e = null === (t = this._spec.layout) || void 0 === t ? void 0 : t.type) && void 0 !== e
            ? e
            : n
            ? 'layout3d'
            : 'base'
        ))(this._spec.layout, { onError: null === (i = this._option) || void 0 === i ? void 0 : i.onError });
        this._layoutFunc = s.layoutItems.bind(s);
      }
    }
    layout(t) {
      var e, i, n, s;
      if (
        (null ===
          (i = null === (e = this._option.performanceHook) || void 0 === e ? void 0 : e.beforeLayoutWithSceneGraph) ||
          void 0 === i ||
          i.call(e),
        this.getLayoutTag())
      ) {
        this._event.emit(Gq.layoutStart, { chart: this }), this.onLayoutStart(t);
        const e = this.getLayoutElements();
        this._layoutFunc(this, e, this._layoutRect, this._viewBox),
          this.setLayoutTag(!1),
          this.onLayoutEnd(t),
          this._event.emit(Gq.layoutEnd, { chart: this });
      }
      null ===
        (s = null === (n = this._option.performanceHook) || void 0 === n ? void 0 : n.afterLayoutWithSceneGraph) ||
        void 0 === s ||
        s.call(n);
    }
    onLayoutStart(t) {
      this.getLayoutElements().forEach(e => e.onLayoutStart(this._layoutRect, this._viewRect, t));
    }
    onLayoutEnd(t) {
      this.getLayoutElements().forEach(e => e.onLayoutEnd(t));
    }
    onEvaluateEnd(t) {
      this.getLayoutElements().forEach(e => e.onEvaluateEnd(t));
    }
    getLayoutElements() {
      return [...this._components, ...this._regions, ...this._series];
    }
    getModelById(t) {
      const e = this._idMap.get(t);
      if (e && e instanceof ZQ) return e;
    }
    getModelByUserId(t) {
      const e = this._series.find(e => e.userId === t);
      if (e) return e;
      const i = this._regions.find(e => e.userId === t);
      if (i) return i;
      const n = this._components.find(e => e.userId === t);
      return n || void 0;
    }
    getAllMarks() {
      return Array.from(this._idMap.values()).filter(t => t && t instanceof g0);
    }
    getMarkById(t) {
      const e = this._idMap.get(t);
      if (e && e instanceof g0) return e;
    }
    updateParseData(t, e, i) {
      const n = this._dataSet.getDataView(t);
      n && n.updateRawData(e);
    }
    updateData(t, e, i = !0, n) {
      const s = this._dataSet.getDataView(t);
      s && s.parseNewData(e, n),
        i && this.updateGlobalScaleDomain(),
        this.getAllModels().forEach(t => t.onDataUpdate());
    }
    updateFullData(t, e = !0) {
      const i = [];
      V(t).forEach(t => {
        const e = this._dataSet.getDataView(t.id);
        e && (i.push({ d: t, dv: e }), e.markRunning());
      }),
        i.forEach(({ d: t, dv: e }) => {
          e.setFields(t.fields), e.parseNewData(t.values, t.parser);
        }),
        e && this.updateGlobalScaleDomain(),
        this.getAllModels().forEach(t => t.onDataUpdate());
    }
    onRender(t) {}
    setCanvasRect(t, e) {
      this._canvasRect = { width: t, height: e };
    }
    getCanvasRect() {
      return this._canvasRect || (this._canvasRect = HQ(this._spec, this._option)), this._canvasRect;
    }
    getSeriesData(t, e) {
      var i, n, s;
      if (!this._spec.data) return null === (i = this._option) || void 0 === i || i.onError('no data in spec!'), null;
      if ('string' == typeof t) {
        const e = this._spec.data.filter(e => e.name === t);
        return e[0]
          ? e[0]
          : (null === (n = this._option) || void 0 === n || n.onError(`no data matches dataId ${t}!`), null);
      }
      return 'number' == typeof e
        ? this._spec.data[e]
          ? this._spec.data[e]
          : (null === (s = this._option) || void 0 === s || s.onError(`no data matches dataIndex ${e}!`), null)
        : this._spec.data[0];
    }
    _transformSpecScale() {
      var t, e, i;
      const n = null !== (t = this._spec.scales) && void 0 !== t ? t : [];
      let s = n.find(t => 'color' === t.id);
      if (!s && ((s = { type: 'ordinal', id: 'color', domain: null, range: null }), n.push(s), this._spec.color)) {
        const t = this._spec.color;
        if (f(t))
          s.range = t.map(t => {
            var e;
            return aV(t, null === (e = this._theme) || void 0 === e ? void 0 : e.colorScheme);
          });
        else {
          const e = t;
          Object.prototype.hasOwnProperty.call(e, 'type') && (s.type = e.type),
            Object.prototype.hasOwnProperty.call(e, 'domain') && (s.domain = e.domain),
            Object.prototype.hasOwnProperty.call(e, 'range') && (s.range = e.range),
            Object.prototype.hasOwnProperty.call(e, 'specified') && (s.specified = e.specified);
        }
      }
      return (
        (null === (e = s.range) || void 0 === e ? void 0 : e.length) ||
          ((s.range = nV(null === (i = this._theme) || void 0 === i ? void 0 : i.colorScheme)), (s.rangeTheme = !0)),
        n
      );
    }
    createGlobalScale() {
      (this._globalScale = new o2(this._transformSpecScale(), this)),
        (this._modelOption.globalScale = this._globalScale);
    }
    updateGlobalScaleDomain() {
      const t = new Set();
      this._series.forEach(e => {
        const i = e.getSeriesKeys();
        i && i.forEach(e => t.add(e));
      });
      const e = Array.from(t);
      this._globalScale.updateScaleDomain(e);
    }
    updateGlobalScale(t) {
      this._mergeUpdateResult(t, this._globalScale.updateSpec(this._transformSpecScale()));
    }
    updateGlobalScaleTheme() {
      var t;
      const e = this._globalScale.getScaleSpec('color');
      e.rangeTheme &&
        ((e.range = nV(null === (t = this._theme) || void 0 === t ? void 0 : t.colorScheme)),
        this._globalScale.getScale('color').range(e.range));
    }
    updateSpec(t, e) {
      const i = { change: !1, reMake: !1, reRender: !1, reSize: !1, reCompile: !1 };
      if ((this.setLayoutTag(!0, e), t.type !== this.type)) return (i.reMake = !0), i;
      this.transformSpec(t);
      const n = Object.keys(this._spec).sort(),
        s = Object.keys(t).sort();
      return JSON.stringify(n) !== JSON.stringify(s)
        ? ((i.reMake = !0), i)
        : ((this._spec = t),
          this.updateGlobalScale(i),
          i.reMake
            ? i
            : (this.updateRegionSpec(i),
              i.reMake
                ? i
                : (this.updateComponentSpec(i),
                  i.reMake
                    ? i
                    : (this.updateSeriesSpec(i),
                      i.reMake ? i : (this.updateDataSpec(i), i.reMake || this.updateGlobalScaleDomain(), i)))));
    }
    updateDataSpec(t) {
      this._spec.data &&
        V(this._spec.data).forEach((e, i) => {
          const n = this._dataSet.getDataView(e.id);
          n
            ? (e.fields && n.setFields(e.fields),
              e.values ? n.parseNewData(e.values, e.parser) : e.latestData || n.updateRawData([]))
            : (t.reMakeData = !0);
        });
    }
    updateRegionSpec(t) {
      var e;
      (null === (e = this._spec) || void 0 === e ? void 0 : e.region) &&
        (this._spec.region.length === this._regions.length
          ? this._regions.forEach(e => {
              this._mergeUpdateResult(t, e.updateSpec(this._spec.region[e.getSpecIndex()])), e.reInit();
            })
          : (t.reMake = !0));
    }
    updateComponentSpec(t) {
      const e = {};
      this._components.forEach(i => {
        var n;
        const s = null !== (n = this._spec[i.specKey]) && void 0 !== n ? n : {};
        f(s)
          ? ((e[i.specKey] = e[i.specKey] || { specCount: s.length, componentCount: 0 }),
            e[i.specKey].componentCount++,
            this._mergeUpdateResult(t, i.updateSpec(s[i.getSpecIndex()], s)))
          : this._mergeUpdateResult(t, i.updateSpec(s)),
          i.reInit();
      });
      for (const i in e)
        if (Object.prototype.hasOwnProperty.call(e, i)) {
          const n = e[i];
          n.componentCount !== n.specCount && (t.reMake = !0);
        }
    }
    updateSeriesSpec(t) {
      this._spec.series.length === this._series.length
        ? this._series.forEach(e => {
            var i;
            const n = this._spec.series[e.getSpecIndex()];
            if (t.reMakeData) {
              let t;
              (t = n.data
                ? n.data.values
                : null === (i = this.getSeriesData(n.dataId, n.dataIndex)) || void 0 === i
                ? void 0
                : i.latestData),
                e.updateRawData(t);
            }
            const s = e.getSpec();
            this._mergeUpdateResult(t, e.updateSpec(n)), e.reInit(null, s);
          })
        : (t.reMake = !0);
    }
    getCanvas() {
      var t, e;
      return null !== (e = null === (t = this.getCompiler()) || void 0 === t ? void 0 : t.getCanvas()) && void 0 !== e
        ? e
        : null;
    }
    isValidSeries(t) {
      return !0;
    }
    _getDefaultSeriesSpec(t) {
      var e, i;
      return {
        data: null === (e = t.data) || void 0 === e ? void 0 : e[0],
        dataKey: t.dataKey,
        hover: t.hover,
        select: t.select,
        label: t.label,
        seriesStyle: t.seriesStyle,
        animation: t.animation,
        animationThreshold: null !== (i = t.animationThreshold) && void 0 !== i ? i : this._theme.animationThreshold,
        animationAppear: t.animationAppear,
        animationDisappear: t.animationDisappear,
        animationEnter: t.animationEnter,
        animationUpdate: t.animationUpdate,
        animationExit: t.animationExit,
        animationNormal: t.animationNormal,
        extensionMark: t.extensionMark,
        large: t.large,
        largeThreshold: t.largeThreshold,
        progressiveStep: t.progressiveStep,
        progressiveThreshold: t.progressiveThreshold,
        background: t.seriesBackground,
        invalidType: t.invalidType,
        seriesField: t.seriesField
      };
    }
    _mergeUpdateResult(t, e) {
      (t.change = t.change || e.change),
        (t.reCompile = t.reCompile || e.reCompile),
        (t.reMake = t.reMake || e.reMake),
        (t.reRender = t.reRender || e.reRender),
        (t.reSize = t.reSize || e.reSize);
    }
    _updateLayoutRect(t) {
      let e = this.getCanvasRect();
      if (t) {
        this._viewBox = t;
        const { x1: i = 0, y1: n = 0, x2: s, y2: r } = t;
        e = { width: s - i, height: r - n };
      } else this._viewBox = { x1: 0, y1: 0, x2: e.width, y2: e.height };
      (this._viewRect = e),
        (this.padding = yV(this._paddingSpec, e, e)),
        (this._layoutRect.width = e.width - this.padding.left - this.padding.right),
        (this._layoutRect.height = e.height - this.padding.top - this.padding.bottom),
        (this._layoutRect.x = this.padding.left),
        (this._layoutRect.y = this.padding.top),
        this._event.emit(Gq.layoutRectUpdate, {});
    }
    getCurrentTheme() {
      return this._theme;
    }
    setCurrentTheme(t) {
      (this._theme = t),
        this.setLayoutTag(!0),
        this.transformSpec(this._spec),
        this.updateGlobalScaleTheme(),
        this.setRegionTheme(),
        this.setComponentTheme(t),
        this.setSeriesTheme(t);
    }
    setRegionTheme() {
      this._regions.forEach(t => {
        t.reInit();
      });
    }
    setComponentTheme(t) {
      this._components.forEach(e => {
        e.setCurrentTheme(t.series[e.type], !0);
      });
    }
    setSeriesTheme(t) {
      this._series.forEach(e =>
        yn(this, void 0, void 0, function* () {
          yield e.setCurrentTheme(t.series[e.type], !0);
        })
      );
    }
    clear() {
      this.getLayoutElements().forEach(t => {
        var e;
        return null === (e = t.clear) || void 0 === e ? void 0 : e.call(t);
      });
    }
    compile() {
      this.compileBackground(),
        this.compileLayout(),
        this.compileRegions(),
        this.compileSeries(),
        this.compileComponents();
    }
    afterCompile() {
      this.getAllRegions().forEach(t => {
        var e;
        null === (e = t.afterCompile) || void 0 === e || e.call(t);
      }),
        this.getAllSeries().forEach(t => {
          var e;
          null === (e = t.afterCompile) || void 0 === e || e.call(t);
        }),
        this.getAllComponents().forEach(t => {
          var e;
          null === (e = t.afterCompile) || void 0 === e || e.call(t);
        });
    }
    compileLayout() {
      const { width: t, height: e } = this.getCanvasRect();
      this.getCompiler().setSize(t, e);
    }
    compileBackground() {
      var t;
      this._backgroundMark &&
        (this._backgroundMark.compile(),
        null === (t = this._backgroundMark.getProduct()) ||
          void 0 === t ||
          t.configure({ context: { model: this } }).layout(() => {}));
    }
    compileRegions() {
      var t, e, i, n;
      null === (e = null === (t = this._option.performanceHook) || void 0 === t ? void 0 : t.beforeRegionCompile) ||
        void 0 === e ||
        e.call(t),
        this.getAllRegions().forEach(t => {
          t.compile();
        }),
        null === (n = null === (i = this._option.performanceHook) || void 0 === i ? void 0 : i.afterRegionCompile) ||
          void 0 === n ||
          n.call(i);
    }
    compileSeries() {
      var t, e, i, n;
      null === (e = null === (t = this._option.performanceHook) || void 0 === t ? void 0 : t.beforeSeriesCompile) ||
        void 0 === e ||
        e.call(t),
        this.getAllSeries().forEach(t => {
          t.compile();
        }),
        null === (n = null === (i = this._option.performanceHook) || void 0 === i ? void 0 : i.afterSeriesCompile) ||
          void 0 === n ||
          n.call(i);
    }
    compileComponents() {
      var t, e, i, n;
      null === (e = null === (t = this._option.performanceHook) || void 0 === t ? void 0 : t.beforeComponentCompile) ||
        void 0 === e ||
        e.call(t),
        this.getAllComponents().forEach(t => {
          t.compile();
        }),
        null === (n = null === (i = this._option.performanceHook) || void 0 === i ? void 0 : i.afterComponentCompile) ||
          void 0 === n ||
          n.call(i);
    }
    release() {
      super.release(),
        this.clear(),
        [...this._components, ...this._regions, ...this._series].forEach(t => {
          t.release();
        }),
        (this._components = this._regions = this._series = []),
        (this._spec = {}),
        (this._dataSet = this._globalScale = this._layoutFunc = null),
        (this._layoutTag = !1),
        this._idMap.clear();
    }
    onLayout(t) {
      const e = t.rootMark;
      this.checkUpdate(e, null, null), this.layout({ group: e, srView: t });
    }
    checkUpdate(t, e, i) {
      var n, s;
      (null === (n = t.context) || void 0 === n ? void 0 : n.model) && ((i = t), (e = t.context.model)),
        e && t.isUpdated
          ? null === (s = e.bindSceneNode) || void 0 === s || s.call(e, i.elements[0])
          : 'group' === t.markType &&
            t.children.forEach(t => {
              this.checkUpdate(t, e, i);
            });
    }
    updateState(t, e) {
      const i = this.getAllSeries();
      for (const n in t) {
        if (T(t[n])) continue;
        const s = t[n];
        let r = { stateValue: n };
        (r = o(s.filter) ? Object.assign({ filter: s.filter }, r) : Object.assign(Object.assign({}, s.filter), r)),
          s.level && (r.level = s.level),
          i.forEach(t => {
            t.getMarks().forEach(i => {
              i.stateStyle[n] && ((e && !e(t, i, n)) || (i.state.changeStateInfo(r), i.updateMarkState(n)));
            });
          });
      }
    }
    setSelected(t, e, i) {
      this._setStateInDatum(BQ.STATE_SELECTED, !0, t, e, i);
    }
    setHovered(t, e, i) {
      this._setStateInDatum(BQ.STATE_HOVER, !0, t, e, i);
    }
    initEvent() {
      [Gq.dataZoomChange, Gq.scrollBarChange].forEach(t => {
        this._event.on(t, ({ value: t }) => {
          if (!t.filterData) return;
          this._disableMarkAnimation(['exit', 'update']);
          const e = () => {
            this._enableMarkAnimation(['exit', 'update']), this._event.off(tG.AFTER_MARK_RENDER_END, e);
          };
          this._event.on(tG.AFTER_MARK_RENDER_END, e);
        });
      });
    }
    _enableMarkAnimation(t) {
      this.getAllMarks().forEach(e => {
        const i = e.getProduct();
        i && i.animate && i.animate.enableAnimationState(t);
      });
    }
    _disableMarkAnimation(t) {
      this.getAllMarks().forEach(e => {
        const i = e.getProduct();
        i && i.animate && i.animate.disableAnimationState(t);
      });
    }
    _setStateInDatum(t, e, i, n, s) {
      const r = (i = i ? V(i) : null) ? Object.keys(i[0]) : null;
      this.getRegionsInQuerier(s).forEach(s => {
        i
          ? (s.getSeries().forEach(e => {
              e.getMarks().forEach(a => {
                if (a.getProduct() && (!n || (o(n) && n(e, a)))) {
                  const e = a.getProduct().isCollectionMark(),
                    n = a.getProduct().elements;
                  let o = n;
                  if (e)
                    o = n.filter(t => {
                      const e = t.getDatum();
                      i.every((t, i) => r.every(n => t[n] == e[i][n]));
                    });
                  else if (i.length > 1) {
                    const t = [...i];
                    o = n.filter(e => {
                      if (0 === t.length) return !1;
                      const i = e.getDatum(),
                        n = t.findIndex(t => r.every(e => t[e] == i[e]));
                      return n >= 0 && (t.splice(n, 1), !0);
                    });
                  } else {
                    const t = n.find(t => r.every(e => i[0][e] == t.getDatum()[e]));
                    t && (o = [t]);
                  }
                  o.forEach(e => {
                    s.interaction.addEventElement(t, e);
                  });
                }
              });
            }),
            e && s.interaction.reverseEventElement(t))
          : s.interaction.clearEventElement(t, !0);
      });
    }
    setDimensionIndex(t, e) {
      var i, n, s, r;
      let a = null;
      Array.from(this._event.getComposedEventMap().values()).forEach(i => {
        const { eventType: n, event: s } = i;
        if (n === fQ.dimensionHover || n === fQ.dimensionClick) {
          const i = s.dispatch(t, e);
          (null == i ? void 0 : i.length) && (a = i);
        }
      });
      const o = l(t) || !a || a.every(t => Qo(t.axis.getScale().type) && l(t.index));
      if (!1 !== e.tooltip) {
        const t = this._components.find(t => t.type === xn.tooltip);
        if (null == t ? void 0 : t.getVisible())
          if (o) null === (n = (i = t).hideTooltip) || void 0 === n || n.call(i);
          else {
            const i = {};
            a.forEach(t => {
              const { axis: e, value: n, data: s } = t,
                r = 'left' === e.getOrient() || 'right' === e.getOrient();
              s.forEach(t => {
                r ? (i[t.series.fieldY[0]] = n) : (i[t.series.fieldX[0]] = n);
              });
            }),
              t.showTooltip(i, e.showTooltipOption);
          }
      }
      if (!1 !== e.crosshair) {
        const t = this._components.find(t => t.type === xn.cartesianCrosshair);
        t &&
          t.clearAxisValue &&
          t.setAxisValue &&
          (o
            ? (null === (s = t.clearAxisValue) || void 0 === s || s.call(t),
              null === (r = t.hide) || void 0 === r || r.call(t))
            : a.forEach(e => {
                const { axis: i, value: n } = e;
                t.clearAxisValue(), t.setAxisValue(n, i), t.layoutByValue();
              }));
      }
    }
  }
  class c2 extends h2 {
    isValidSeries(t) {
      return !this.seriesType || t === this.seriesType;
    }
    needAxes() {
      return !0;
    }
    _getDefaultSeriesSpec(t) {
      const e = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
          xField: t.xField,
          yField: t.yField,
          zField: t.zField,
          seriesField: t.seriesField,
          seriesStyle: t.seriesStyle,
          direction: t.direction,
          stack: t.stack,
          percent: t.percent,
          stackOffsetSilhouette: t.stackOffsetSilhouette,
          totalLabel: t.totalLabel
        }),
        i = this.seriesType;
      return i && ((e.type = i), (e[i] = t[i])), e;
    }
    transformSpec(t) {
      super.transformSpec(t),
        this.needAxes() &&
          (t.axes || (t.axes = []),
          t.region.forEach(e => {
            const i = { x: !1, y: !1, z: !1 };
            t.axes.forEach(t => {
              const { orient: e } = t;
              ('top' !== e && 'bottom' !== e) || (i.x = !0),
                ('left' !== e && 'right' !== e) || (i.y = !0),
                'z' === e && (i.z = !0);
            }),
              i.x || t.axes.push({ orient: 'bottom' }),
              i.y || t.axes.push({ orient: 'left' }),
              t.zField && !i.z && t.axes.push({ orient: 'z' });
          }));
      const e = this._getDefaultSeriesSpec(t);
      t.series && 0 !== t.series.length
        ? t.series.forEach(t => {
            this.isValidSeries(t.type) &&
              Object.keys(e).forEach(i => {
                i in t || (t[i] = e[i]);
              });
          })
        : (t.series = [e]);
    }
  }
  var d2;
  !(function (t) {
    (t.common = 'common'),
      (t.area = 'area'),
      (t.line = 'line'),
      (t.bar = 'bar'),
      (t.bar3d = 'bar3d'),
      (t.histogram = 'histogram'),
      (t.histogram3d = 'histogram3d'),
      (t.rangeColumn = 'rangeColumn'),
      (t.rangeColumn3d = 'rangeColumn3d'),
      (t.rangeArea = 'rangeArea'),
      (t.map = 'map'),
      (t.pie = 'pie'),
      (t.pie3d = 'pie3d'),
      (t.radar = 'radar'),
      (t.rose = 'rose'),
      (t.scatter = 'scatter'),
      (t.sequence = 'sequence'),
      (t.circularProgress = 'circularProgress'),
      (t.linearProgress = 'linearProgress'),
      (t.wordCloud = 'wordCloud'),
      (t.wordCloud3d = 'wordCloud3d'),
      (t.funnel = 'funnel'),
      (t.funnel3d = 'funnel3d'),
      (t.waterfall = 'waterfall'),
      (t.boxPlot = 'boxPlot'),
      (t.gauge = 'gauge'),
      (t.sankey = 'sankey'),
      (t.treemap = 'treemap'),
      (t.sunburst = 'sunburst'),
      (t.circlePacking = 'circlePacking'),
      (t.heatmap = 'heatmap');
  })(d2 || (d2 = {})),
    NQ.useSeries([a2]);
  class u2 extends c2 {
    constructor() {
      super(...arguments), (this.type = d2.area), (this.seriesType = DZ.area);
    }
    _getDefaultSeriesSpec(t) {
      var e;
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        point: t.point,
        line: t.line,
        area: t.area,
        seriesMark: null !== (e = t.seriesMark) && void 0 !== e ? e : 'area',
        activePoint: t.activePoint
      });
    }
    transformSpec(t) {
      super.transformSpec(t), zQ(t);
    }
  }
  (u2.type = d2.area), (u2.view = 'singleDefault');
  class p2 extends g0 {
    constructor() {
      super(...arguments), (this.type = p2.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), {
        width: void 0,
        height: void 0,
        lineWidth: 0
      });
    }
  }
  (p2.type = jZ.rect), NQ.useMark([p2, i2]);
  class g2 extends J1 {
    constructor() {
      super(...arguments),
        (this.type = DZ.bar),
        (this._barMarkName = LZ.bar),
        (this._barMarkType = jZ.rect),
        (this._stack = !0),
        (this._bandPosition = 0);
    }
    initMark() {
      const t = {
        progressiveStep: this._spec.progressiveStep,
        progressiveThreshold: this._spec.progressiveThreshold,
        large: this._spec.large,
        largeThreshold: this._spec.largeThreshold
      };
      this._rectMark = this._createMark(
        Object.assign(Object.assign({}, g2.mark.bar), { name: this._barMarkName, type: this._barMarkType }),
        {
          morph: T1(this._spec.animation, this._spec.morph, A1(this.type, this._spec)),
          defaultMorphElementKey: this.getDimensionField()[0],
          groupKey: this._seriesField,
          isSeriesMark: !0,
          label: _J({ animation: this._spec.animation }, this._spec.label),
          progressive: t
        }
      );
    }
    initMarkStyle() {
      var t;
      const e = this._rectMark;
      e &&
        (this.setMarkStyle(e, { fill: this.getColorAttribute() }, 'normal', Jq.Series),
        this._trigger.registerMark(e),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(e));
    }
    initLabelMarkStyle(t) {
      t &&
        this.setMarkStyle(t, {
          fill: this.getColorAttribute(),
          text: t => t[this.getStackValueField()],
          z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        });
    }
    init(t) {
      var e, i;
      super.init(t),
        'vertical' === this.direction
          ? 'band' === (null === (e = this._xAxisHelper) || void 0 === e ? void 0 : e.getScale(0).type)
            ? this.initBandRectMarkStyle()
            : this.initLinearRectMarkStyle()
          : 'band' === (null === (i = this._yAxisHelper) || void 0 === i ? void 0 : i.getScale(0).type)
          ? this.initBandRectMarkStyle()
          : this.initLinearRectMarkStyle();
    }
    initBandRectMarkStyle() {
      var t, e, i, n;
      const s =
          null === (e = null === (t = this._xAxisHelper) || void 0 === t ? void 0 : t.getScale) || void 0 === e
            ? void 0
            : e.call(t, 0),
        r =
          null === (n = null === (i = this._yAxisHelper) || void 0 === i ? void 0 : i.getScale) || void 0 === n
            ? void 0
            : n.call(i, 0);
      this.direction === JJ.horizontal
        ? this.setMarkStyle(
            this._rectMark,
            {
              x: t => uV(this.dataToPositionX(t), s),
              x1: t => uV(this.dataToPositionX1(t), s),
              y: t => this._getPosition(this.direction, t),
              height: () => this._getBarWidth(this._yAxisHelper)
            },
            'normal',
            Jq.Series
          )
        : this.setMarkStyle(
            this._rectMark,
            {
              x: t => this._getPosition(this.direction, t),
              y: t => uV(this.dataToPositionY(t), r),
              y1: t => uV(this.dataToPositionY1(t), r),
              width: () => this._getBarWidth(this._xAxisHelper)
            },
            'normal',
            Jq.Series
          );
    }
    initLinearRectMarkStyle() {
      var t, e, i, n;
      const s =
          null === (e = null === (t = this._xAxisHelper) || void 0 === t ? void 0 : t.getScale) || void 0 === e
            ? void 0
            : e.call(t, 0),
        r =
          null === (n = null === (i = this._yAxisHelper) || void 0 === i ? void 0 : i.getScale) || void 0 === n
            ? void 0
            : n.call(i, 0);
      this.setMarkStyle(
        this._rectMark,
        {
          x: t => uV(this.dataToPositionX(t), s),
          x1: t => uV(this.dataToPositionX1(t), s),
          y: t => uV(this.dataToPositionY(t), r),
          y1: t => uV(this.dataToPositionY1(t), r)
        },
        'normal',
        Jq.Series
      );
    }
    initAnimation() {
      var t, e;
      const i = {
          yField: this._fieldY[0],
          xField: this._fieldX[0],
          direction: this.direction,
          growFrom: () => {
            var t, e;
            return 'horizontal' === this.direction
              ? null === (t = this._xAxisHelper) || void 0 === t
                ? void 0
                : t.getScale(0).scale(0)
              : null === (e = this._yAxisHelper) || void 0 === e
              ? void 0
              : e.getScale(0).scale(0);
          }
        },
        n =
          null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
            ? void 0
            : e.preset;
      this._rectMark.setAnimationConfig(
        w1(x1.bar(i, n), A1(this._barMarkName, this._spec), {
          dataIndex: t => {
            var e, i, n;
            const s = null == t ? void 0 : t[this._fieldX[0]];
            return (
              (null ===
                (n =
                  null === (i = null === (e = this.getViewDataStatistics()) || void 0 === e ? void 0 : e.latestData) ||
                  void 0 === i
                    ? void 0
                    : i[this._fieldX[0]]) || void 0 === n
                ? void 0
                : n.values.indexOf(s)) || 0
            );
          }
        })
      );
    }
    _getBarWidth(t) {
      var e, i;
      const n = void 0 !== this._spec.barWidth,
        s =
          null !==
            (i =
              null === (e = t.getBandwidth) || void 0 === e
                ? void 0
                : e.call(t, this._groups ? this._groups.fields.length - 1 : 0)) && void 0 !== i
            ? i
            : 6;
      if (n) return xV(this._spec.barWidth, s);
      const r = void 0 !== this._spec.barMinWidth,
        a = void 0 !== this._spec.barMaxWidth;
      let o = s;
      return (
        r && (o = Math.max(o, xV(this._spec.barMinWidth, s))), a && (o = Math.min(o, xV(this._spec.barMaxWidth, s))), o
      );
    }
    _getPosition(t, e) {
      var i, n, s, r, a, o, l, c, d;
      let u, p, g;
      t === JJ.horizontal
        ? ((u = this.getYAxisHelper()), (p = 'height'), (g = this.dataToPositionY.bind(this)))
        : ((u = this.getXAxisHelper()), (p = 'width'), (g = this.dataToPositionX.bind(this)));
      const f = u.getScale(0),
        v = this._rectMark.getAttribute(p, e),
        m =
          null !==
            (n =
              null === (i = u.getBandwidth) || void 0 === i
                ? void 0
                : i.call(u, this._groups ? this._groups.fields.length - 1 : 0)) && void 0 !== n
            ? n
            : 6;
      if (
        (null === (r = null === (s = this._groups) || void 0 === s ? void 0 : s.fields) || void 0 === r
          ? void 0
          : r.length) > 1 &&
        h(this._spec.barGapInGroup)
      ) {
        const t = this._groups.fields,
          i = V(this._spec.barGapInGroup);
        let n = 0,
          s = 0;
        for (let r = t.length - 1; r >= 1; r--) {
          const h = t[r],
            u =
              null !==
                (c =
                  null ===
                    (l =
                      null ===
                        (o = null === (a = this.getViewDataStatistics()) || void 0 === a ? void 0 : a.latestData) ||
                      void 0 === o
                        ? void 0
                        : o[h]) || void 0 === l
                    ? void 0
                    : l.values) && void 0 !== c
                ? c
                : [],
            p = u.length,
            g = xV(null !== (d = i[r - 1]) && void 0 !== d ? d : W(i), m),
            f = u.indexOf(e[h]);
          r === t.length - 1
            ? ((n += p * v + (p - 1) * g), (s += f * (v + g)))
            : ((s += f * (n + g)), (n += n + (p - 1) * g));
        }
        return f.scale(e[t[0]]) + u.getBandwidth(0) / 2 - n / 2 + s;
      }
      const y = Zo(f.type || 'band');
      return g(e) + 0.5 * (m - v) + (y ? -m / 2 : 0);
    }
    updateSpec(t) {
      const { direction: e } = this._spec,
        i = super.updateSpec(t);
      return t.direction !== e && ((i.change = !0), (i.reRender = !0), (i.reMake = !0)), i;
    }
    getDefaultShapeType() {
      return 'square';
    }
  }
  (g2.type = DZ.bar), (g2.mark = HZ), NQ.useSeries([g2]);
  class f2 extends c2 {
    constructor() {
      super(...arguments), (this.type = d2.bar), (this.seriesType = DZ.bar);
    }
    _getDefaultSeriesSpec(t) {
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        barWidth: t.barWidth,
        barMaxWidth: t.barMaxWidth,
        barMinWidth: t.barMinWidth,
        barGapInGroup: t.barGapInGroup
      });
    }
    transformSpec(t) {
      super.transformSpec(t), zQ(t);
    }
  }
  (f2.type = d2.bar), (f2.view = 'singleDefault');
  class v2 extends g0 {
    constructor() {
      super(...arguments), (this.type = v2.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), { width: void 0, height: void 0, length: 3 });
    }
  }
  (v2.type = jZ.rect3d), NQ.useMark([v2, i2]);
  class m2 extends g2 {
    constructor() {
      super(...arguments), (this.type = DZ.bar3d), (this._barMarkName = LZ.bar3d), (this._barMarkType = jZ.rect3d);
    }
  }
  (m2.type = DZ.bar3d), (m2.mark = NZ), NQ.useSeries([m2]);
  class y2 extends c2 {
    constructor() {
      super(...arguments), (this.type = d2.bar3d), (this.seriesType = DZ.bar3d);
    }
    _getDefaultSeriesSpec(t) {
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        barWidth: t.barWidth,
        barMaxWidth: t.barMaxWidth,
        barMinWidth: t.barMinWidth,
        barGapInGroup: t.barGapInGroup
      });
    }
  }
  (y2.type = d2.bar3d), (y2.view = 'singleDefault');
  const _2 = `${UV}_BOX_PLOT_OUTLIER_VALUE`;
  var b2;
  !(function (t) {
    (t.OUTLIER = 'outlier'),
      (t.MAX = 'max'),
      (t.MIN = 'min'),
      (t.MEDIAN = 'median'),
      (t.Q1 = 'q1'),
      (t.Q3 = 'q3'),
      (t.SERIES_FIELD = 'seriesField');
  })(b2 || (b2 = {}));
  const x2 = (t, e) => {
    const i = [],
      { outliersField: n, dimensionField: s } = e;
    return (
      (t[0].latestData || []).forEach(t => {
        let e = t[n];
        f(e) || (e = [e]),
          i.push(
            ...e.map(e => {
              const i = { [_2]: e };
              return (
                s.forEach(e => {
                  i[e] = t[e];
                }),
                i
              );
            })
          );
      }),
      i
    );
  };
  class S2 extends z1 {
    constructor() {
      super(...arguments),
        (this.getContentKey = t => e => {
          if (this.isOutlierMark(e)) {
            if (t === b2.OUTLIER) return this.series.getOutliersField();
            if (t === b2.SERIES_FIELD) {
              return this.series.getSeriesField();
            }
            return null;
          }
          switch (t) {
            case b2.MIN:
              return this.series.getMinField();
            case b2.MAX:
              return this.series.getMaxField();
            case b2.MEDIAN:
              return this.series.getMedianField();
            case b2.Q1:
              return this.series.getQ1Field();
            case b2.Q3:
              return this.series.getQ3Field();
            case b2.SERIES_FIELD:
              return this.series.getSeriesField();
          }
          return null;
        }),
        (this.getContentValue = t => e => {
          if (this.isOutlierMark(e)) {
            if (t === b2.OUTLIER) return e[_2];
            if (t === b2.SERIES_FIELD) {
              return e[this.series.getSeriesField()];
            }
            return null;
          }
          switch (t) {
            case b2.MIN:
              return e[this.series.getMinField()];
            case b2.MAX:
              return e[this.series.getMaxField()];
            case b2.MEDIAN:
              return e[this.series.getMedianField()];
            case b2.Q1:
              return e[this.series.getQ1Field()];
            case b2.Q3:
              return e[this.series.getQ3Field()];
            case b2.SERIES_FIELD:
              return e[this.series.getSeriesField()];
          }
          return null;
        }),
        (this.contentShapeColorCallback = t =>
          'line' === this.series.getShaftShape()
            ? this.series.getMarkInName('boxPlot').getAttribute('stroke', t)
            : this.series.getMarkInName('boxPlot').getAttribute('fill', t)),
        (this.getOutlierFillColor = t => {
          var e;
          const i = this.series.getOutliersStyle();
          return null !== (e = null == i ? void 0 : i.fill) && void 0 !== e
            ? e
            : this.series.getMarkInName('outlier').getAttribute('fill', t);
        }),
        (this.isOutlierMark = t => h(t[_2]));
    }
    getDefaultTooltipPattern(t) {
      return {
        visible: !0,
        activeType: t,
        title: { key: void 0, value: this.titleValueCallback, hasShape: !1 },
        content: [
          {
            key: this.getContentKey(b2.OUTLIER),
            value: this.getContentValue(b2.OUTLIER),
            hasShape: !0,
            shapeType: this.contentShapeTypeCallback,
            shapeColor: this.getOutlierFillColor,
            shapeHollow: !1
          },
          {
            key: this.getContentKey(b2.MAX),
            value: this.getContentValue(b2.MAX),
            hasShape: !0,
            shapeType: this.contentShapeTypeCallback,
            shapeColor: this.contentShapeColorCallback,
            shapeHollow: !1
          },
          {
            key: this.getContentKey(b2.Q3),
            value: this.getContentValue(b2.Q3),
            hasShape: !0,
            shapeType: this.contentShapeTypeCallback,
            shapeColor: this.contentShapeColorCallback,
            shapeHollow: !1
          },
          {
            key: this.getContentKey(b2.MEDIAN),
            value: this.getContentValue(b2.MEDIAN),
            hasShape: !0,
            shapeType: this.contentShapeTypeCallback,
            shapeColor: this.contentShapeColorCallback,
            shapeHollow: !1
          },
          {
            key: this.getContentKey(b2.Q1),
            value: this.getContentValue(b2.Q1),
            hasShape: !0,
            shapeType: this.contentShapeTypeCallback,
            shapeColor: this.contentShapeColorCallback,
            shapeHollow: !1
          },
          {
            key: this.getContentKey(b2.MIN),
            value: this.getContentValue(b2.MIN),
            hasShape: !0,
            shapeType: this.contentShapeTypeCallback,
            shapeColor: this.contentShapeColorCallback,
            shapeHollow: !1
          },
          {
            key: this.getContentKey(b2.SERIES_FIELD),
            value: this.getContentValue(b2.SERIES_FIELD),
            hasShape: !0,
            shapeType: this.contentShapeTypeCallback,
            shapeColor: this.contentShapeColorCallback,
            shapeHollow: !1
          }
        ]
      };
    }
  }
  class w2 extends g0 {
    constructor() {
      super(...arguments), (this.type = w2.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), {
        lineWidth: 2,
        boxWidth: 30,
        shaftWidth: 20,
        shaftShape: 'line'
      });
    }
    _initProduct(t) {
      const e = this.getStyle('shaftShape');
      'bar' === e
        ? (EG('barBoxplot', { minMaxBox: 'rect', q1q3Box: 'rect', median: 'rule' })
            .registerProgressiveChannels([
              'x',
              'y',
              'q1',
              'q3',
              'min',
              'max',
              'median',
              'angle',
              'width',
              'height',
              'minMaxWidth',
              'q1q3Width',
              'minMaxHeight',
              'q1q3Height'
            ])
            .registerFunctionEncoder(mU)
            .registerChannelEncoder('q1', (t, e, i, n, s, r) =>
              'horizontal' === (null == r ? void 0 : r.direction) ? { q1q3Box: { x: e } } : { q1q3Box: { y: e } }
            )
            .registerChannelEncoder('q3', (t, e, i, n, s, r) =>
              'horizontal' === (null == r ? void 0 : r.direction) ? { q1q3Box: { x1: e } } : { q1q3Box: { y1: e } }
            )
            .registerChannelEncoder('min', (t, e, i, n, s, r) =>
              'horizontal' === (null == r ? void 0 : r.direction) ? { minMaxBox: { x: e } } : { minMaxBox: { y: e } }
            )
            .registerChannelEncoder('max', (t, e, i, n, s, r) =>
              'horizontal' === (null == r ? void 0 : r.direction) ? { minMaxBox: { x1: e } } : { minMaxBox: { y1: e } }
            )
            .registerChannelEncoder('median', (t, e, i, n, s, r) =>
              'horizontal' === (null == r ? void 0 : r.direction)
                ? { median: { x: e, x1: e, visible: !0 } }
                : { median: { y: e, y1: e, visible: !0 } }
            )
            .registerChannelEncoder('angle', (t, e, i, n, s, r) => {
              var a;
              const o = null !== (a = i.anchor) && void 0 !== a ? a : [i.x, (i.min + i.max) / 2];
              return {
                minMaxBox: { angle: e, anchor: o },
                q1q3Box: { angle: e, anchor: o },
                median: { angle: e, anchor: o }
              };
            })
            .registerChannelEncoder('lineWidth', (t, e, i, n, s, r) => ({
              minMaxBox: { lineWidth: 0 },
              q1q3Box: { lineWidth: 0 }
            }))
            .registerChannelEncoder('minMaxFillOpacity', (t, e, i, n, s, r) => ({ minMaxBox: { fillOpacity: e } }))
            .registerChannelEncoder('stroke', (t, e, i, n, s, r) => ({
              minMaxBox: { stroke: !1 },
              q1q3Box: { stroke: !1 }
            }))
            .registerDefaultEncoder(() => ({
              minMaxBox: { lineWidth: 0 },
              q1q3Box: { lineWidth: 0 },
              median: { visible: !1 }
            })),
          hU('barBoxplotScaleIn', yU),
          hU('barBoxplotScaleOut', _U))
        : (EG('boxplot', { shaft: 'rule', box: 'rect', max: 'rule', min: 'rule', median: 'rule' })
            .registerProgressiveChannels([
              'x',
              'y',
              'q1',
              'q3',
              'min',
              'max',
              'median',
              'angle',
              'width',
              'height',
              'boxWidth',
              'boxHeight',
              'ruleWidth',
              'ruleHeight'
            ])
            .registerFunctionEncoder(pU)
            .registerChannelEncoder('x', (t, e, i, n, s, r) =>
              'horizontal' === (null == r ? void 0 : r.direction) ? null : { shaft: { x: e, x1: e } }
            )
            .registerChannelEncoder('y', (t, e, i, n, s, r) =>
              'horizontal' !== (null == r ? void 0 : r.direction) ? null : { shaft: { y: e, y1: e } }
            )
            .registerChannelEncoder('q1', (t, e, i, n, s, r) =>
              'horizontal' === (null == r ? void 0 : r.direction) ? { box: { x: e } } : { box: { y: e } }
            )
            .registerChannelEncoder('q3', (t, e, i, n, s, r) =>
              'horizontal' === (null == r ? void 0 : r.direction) ? { box: { x1: e } } : { box: { y1: e } }
            )
            .registerChannelEncoder('min', (t, e, i, n, s, r) =>
              'horizontal' === (null == r ? void 0 : r.direction)
                ? { shaft: { x: e }, min: { x: e, x1: e, visible: !0 } }
                : { shaft: { y: e }, min: { y: e, y1: e, visible: !0 } }
            )
            .registerChannelEncoder('max', (t, e, i, n, s, r) =>
              'horizontal' === (null == r ? void 0 : r.direction)
                ? { shaft: { x1: e }, max: { x: e, x1: e, visible: !0 } }
                : { shaft: { y1: e }, max: { y: e, y1: e, visible: !0 } }
            )
            .registerChannelEncoder('median', (t, e, i, n, s, r) =>
              'horizontal' === (null == r ? void 0 : r.direction)
                ? { median: { x: e, x1: e, visible: !0 } }
                : { median: { y: e, y1: e, visible: !0 } }
            )
            .registerChannelEncoder('angle', (t, e, i, n, s, r) => {
              var a;
              const o =
                  'horizontal' === (null == r ? void 0 : r.direction)
                    ? [(i.min + i.max) / 2, i.y]
                    : [i.x, (i.min + i.max) / 2],
                l = null !== (a = i.anchor) && void 0 !== a ? a : o;
              return {
                shaft: { angle: e, anchor: l },
                box: { angle: e, anchor: l },
                max: { angle: e, anchor: l },
                min: { angle: e, anchor: l },
                median: { angle: e, anchor: l }
              };
            })
            .registerDefaultEncoder(() => ({ max: { visible: !1 }, min: { visible: !1 }, median: { visible: !1 } })),
          hU('boxplotScaleIn', gU),
          hU('boxplotScaleOut', fU));
      const i = this.getVGrammarView(),
        n = this.getProductId(),
        s = 'bar' === e ? 'barBoxplot' : 'boxplot',
        r = this.getStyle('direction');
      (this._product = i
        .glyph(s, null != t ? t : i.rootMark)
        .id(n)
        .configureGlyph({ direction: r })),
        (this._compiledProductId = n);
    }
  }
  (w2.type = jZ.boxPlot), NQ.useMark([w2, s2]);
  class A2 extends J1 {
    constructor() {
      super(...arguments), (this.type = DZ.boxPlot);
    }
    getMinField() {
      return this._minField;
    }
    getMaxField() {
      return this._maxField;
    }
    getQ1Field() {
      return this._q1Field;
    }
    getMedianField() {
      return this._medianField;
    }
    getQ3Field() {
      return this._q3Field;
    }
    getOutliersField() {
      return this._outliersField;
    }
    getShaftShape() {
      return this._shaftShape;
    }
    getBoxFillColor() {
      return this._boxFillColor;
    }
    getStrokeColor() {
      return this._strokeColor;
    }
    getOutliersStyle() {
      return this._outliersStyle;
    }
    setAttrFromSpec() {
      var t, e, i, n, s;
      super.setAttrFromSpec();
      const r =
        null !== (e = null === (t = this._spec.boxPlot) || void 0 === t ? void 0 : t.style) && void 0 !== e ? e : {};
      (this._minField = this._spec.minField),
        (this._maxField = this._spec.maxField),
        (this._q1Field = this._spec.q1Field),
        (this._medianField = this._spec.medianField),
        (this._q3Field = this._spec.q3Field),
        (this._outliersField = this._spec.outliersField),
        (this._lineWidth = null !== (i = r.lineWidth) && void 0 !== i ? i : 2),
        (this._boxWidth = r.boxWidth),
        (this._shaftShape = null !== (n = r.shaftShape) && void 0 !== n ? n : 'line'),
        (this._shaftWidth = r.shaftWidth),
        (this._boxFillColor = r.boxFill),
        (this._strokeColor = r.stroke),
        (this._shaftFillOpacity =
          'bar' === this._shaftShape ? (null !== (s = r.shaftFillOpacity) && void 0 !== s ? s : 0.5) : void 0),
        (this._outliersStyle = this._spec.outliersStyle);
    }
    initMark() {
      const t = {
        progressiveStep: this._spec.progressiveStep,
        progressiveThreshold: this._spec.progressiveThreshold,
        large: this._spec.large,
        largeThreshold: this._spec.largeThreshold
      };
      (this._boxPlotMark = this._createMark(A2.mark.boxPlot, { isSeriesMark: !0, progressive: t })),
        (this._outlierMark = this._createMark(A2.mark.outlier, {
          progressive: t,
          key: Xq,
          dataView: this._outlierDataView.getDataView(),
          dataProductId: this._outlierDataView.getProductId()
        }));
    }
    initMarkStyle() {
      var t, e, i, n, s, r, a;
      const o = this._boxPlotMark;
      if (o) {
        const n = {
            direction: this._direction,
            lineWidth: this._lineWidth,
            shaftShape: this._shaftShape,
            fill:
              null !== (t = this._boxFillColor) && void 0 !== t
                ? t
                : 'line' === this._shaftShape
                ? '#FFF'
                : this.getColorAttribute(),
            minMaxFillOpacity: this._shaftFillOpacity,
            stroke:
              null !== (e = this._strokeColor) && void 0 !== e
                ? e
                : 'line' === this._shaftShape
                ? this.getColorAttribute()
                : '#000'
          },
          s =
            this._direction === JJ.vertical
              ? Object.assign(Object.assign({ x: this.dataToPositionX.bind(this) }, n), {
                  boxWidth: () => {
                    var t;
                    return null !== (t = this._boxWidth) && void 0 !== t ? t : this._getMarkWidth();
                  },
                  ruleWidth: () => {
                    var t;
                    return null !== (t = this._shaftWidth) && void 0 !== t ? t : this._getMarkWidth();
                  },
                  q1q3Width: () => {
                    var t;
                    return null !== (t = this._boxWidth) && void 0 !== t ? t : this._getMarkWidth();
                  },
                  minMaxWidth: () => {
                    var t;
                    return null !== (t = this._shaftWidth) && void 0 !== t ? t : this._getMarkWidth();
                  }
                })
              : Object.assign(Object.assign({ y: this.dataToPositionY.bind(this) }, n), {
                  boxHeight: () => {
                    var t;
                    return null !== (t = this._boxWidth) && void 0 !== t ? t : this._getMarkWidth();
                  },
                  ruleHeight: () => {
                    var t;
                    return null !== (t = this._shaftWidth) && void 0 !== t ? t : this._getMarkWidth();
                  },
                  q1q3Height: () => {
                    var t;
                    return null !== (t = this._boxWidth) && void 0 !== t ? t : this._getMarkWidth();
                  },
                  minMaxHeight: () => {
                    var t;
                    return null !== (t = this._shaftWidth) && void 0 !== t ? t : this._getMarkWidth();
                  }
                });
        this.setMarkStyle(o, s, BQ.STATE_NORMAL, Jq.Series),
          this._trigger.registerMark(o),
          null === (i = this._tooltipHelper) || void 0 === i || i.activeTriggerSet.mark.add(o);
      }
      const l = this._outlierMark;
      l &&
        (this.setMarkStyle(
          l,
          {
            fill:
              null !== (s = null === (n = this._outliersStyle) || void 0 === n ? void 0 : n.fill) && void 0 !== s
                ? s
                : this.getColorAttribute(),
            size: y(null === (r = this._outliersStyle) || void 0 === r ? void 0 : r.size)
              ? this._outliersStyle.size
              : 10,
            symbolType: 'circle'
          },
          BQ.STATE_NORMAL,
          Jq.Series
        ),
        this._trigger.registerMark(l),
        null === (a = this._tooltipHelper) || void 0 === a || a.activeTriggerSet.mark.add(l));
    }
    initBoxPlotMarkStyle() {
      var t, e;
      const i = this._boxPlotMark,
        n = this._direction === JJ.vertical ? this._yAxisHelper : this._xAxisHelper;
      if (i && n) {
        const { dataToPosition: e } = n,
          s = null === (t = null == n ? void 0 : n.getScale) || void 0 === t ? void 0 : t.call(n, 0);
        this.setMarkStyle(
          i,
          {
            min: t => uV(e(this.getDatumPositionValues(t, this._minField), { bandPosition: this._bandPosition }), s),
            q1: t => uV(e(this.getDatumPositionValues(t, this._q1Field), { bandPosition: this._bandPosition }), s),
            median: t =>
              uV(e(this.getDatumPositionValues(t, this._medianField), { bandPosition: this._bandPosition }), s),
            q3: t => uV(e(this.getDatumPositionValues(t, this._q3Field), { bandPosition: this._bandPosition }), s),
            max: t => uV(e(this.getDatumPositionValues(t, this._maxField), { bandPosition: this._bandPosition }), s)
          },
          BQ.STATE_NORMAL,
          Jq.Series
        );
      }
      const s = this._outlierMark;
      if (s && n) {
        const { dataToPosition: t } = n,
          i = null === (e = null == n ? void 0 : n.getScale) || void 0 === e ? void 0 : e.call(n, 0),
          r =
            this._direction === JJ.vertical
              ? {
                  x: this.dataToPositionX.bind(this),
                  y: e => uV(t(this.getDatumPositionValues(e, _2), { bandPosition: this._bandPosition }), i)
                }
              : {
                  y: this.dataToPositionY.bind(this),
                  x: e => uV(t(this.getDatumPositionValues(e, _2), { bandPosition: this._bandPosition }), i)
                };
        this.setMarkStyle(s, r, BQ.STATE_NORMAL, Jq.Series);
      }
    }
    initData() {
      if ((super.initData(), !this._data)) return;
      xQ(this._dataSet, 'foldOutlierData', x2), xQ(this._dataSet, 'addVChartProperty', P1);
      const t = new yo(this._dataSet);
      t.parse([this.getViewData()], { type: 'dataview' }),
        (t.name = `${UV}_series_${this.id}_outlierData`),
        t.transform({
          type: 'foldOutlierData',
          options: {
            dimensionField: this._direction === JJ.vertical ? this._fieldX : this._fieldY,
            outliersField: this._outliersField
          }
        }),
        t.transform({ type: 'addVChartProperty', options: { beforeCall: $1, call: X1.bind(this) } }, !1),
        (this._outlierDataView = new W1(this._option, t));
    }
    init(t) {
      super.init(t), this.initBoxPlotMarkStyle();
    }
    _getMarkWidth() {
      if (this._autoBoxWidth) return this._autoBoxWidth;
      const t = this._direction === JJ.vertical ? this._xAxisHelper : this._yAxisHelper,
        e = this._direction === JJ.vertical ? this._fieldX : this._fieldY,
        i = t.getBandwidth(e.length - 1) / e.length;
      return (this._autoBoxWidth = i), this._autoBoxWidth;
    }
    onLayoutEnd(t) {
      super.onLayoutEnd(t), (this._autoBoxWidth = null);
    }
    _initAnimationSpec(t) {
      const e = Object.assign({}, t);
      return (
        ['appear', 'enter', 'update', 'exit', 'disappear'].forEach(t => {
          e[t] && 'scaleIn' === e[t].type
            ? (e[t].type = 'line' === this._shaftShape ? 'boxplotScaleIn' : 'barBoxplotScaleIn')
            : e[t] &&
              'scaleOut' === e[t].type &&
              (e[t].type = 'line' === this._shaftShape ? 'boxplotScaleOut' : 'barBoxplotScaleOut');
        }),
        e
      );
    }
    initAnimation() {
      var t, e, i, n, s;
      const r = t => {
        var e, i, n;
        const s = this._direction === JJ.vertical ? this._fieldX[0] : this._fieldY[0],
          r = null == t ? void 0 : t[s];
        return (
          (null ===
            (n =
              null === (i = null === (e = this._viewDataStatistics) || void 0 === e ? void 0 : e.latestData) ||
              void 0 === i
                ? void 0
                : i[s]) || void 0 === n
            ? void 0
            : n.values.indexOf(r)) || 0
        );
      };
      if (this._boxPlotMark) {
        const t = this._initAnimationSpec(x1.boxPlot()),
          e = this._initAnimationSpec(A1(LZ.boxPlot, this._spec));
        this._boxPlotMark.setAnimationConfig(w1(t, e, { dataIndex: r }));
      }
      if (this._outlierMark) {
        const a = {
          appear: null === (t = this._spec.animationAppear) || void 0 === t ? void 0 : t.symbol,
          disappear: null === (e = this._spec.animationDisappear) || void 0 === e ? void 0 : e.symbol,
          enter: null === (i = this._spec.animationEnter) || void 0 === i ? void 0 : i.symbol,
          exit: null === (n = this._spec.animationExit) || void 0 === n ? void 0 : n.symbol,
          update: null === (s = this._spec.animationUpdate) || void 0 === s ? void 0 : s.symbol
        };
        this._outlierMark.setAnimationConfig(w1(x1.symbol(), a, { dataIndex: r }));
      }
    }
    initTooltip() {
      this._tooltipHelper = new S2(this);
    }
    getStatisticFields() {
      const t = super.getStatisticFields(),
        e = t.find(t => t.key === this._outliersField);
      return e && (e.operations = ['array-min', 'array-max']), t;
    }
    onEvaluateEnd(t) {
      super.onEvaluateEnd(t), this._outlierDataView.updateData();
    }
    getDefaultShapeType() {
      return 'square';
    }
  }
  (A2.type = DZ.boxPlot), (A2.mark = rJ), NQ.useSeries([A2]);
  class k2 extends c2 {
    constructor() {
      super(...arguments), (this.type = d2.boxPlot), (this.seriesType = DZ.boxPlot);
    }
    _getDefaultSeriesSpec(t) {
      var e;
      const i = [t.maxField, t.medianField, t.q1Field, t.q3Field, t.minField, t.outliersField],
        n = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
          boxPlot: t.boxPlot,
          direction: null !== (e = t.direction) && void 0 !== e ? e : JJ.vertical,
          minField: t.minField,
          maxField: t.maxField,
          q1Field: t.q1Field,
          medianField: t.medianField,
          q3Field: t.q3Field,
          outliersField: t.outliersField,
          outliersStyle: t.outliersStyle
        });
      return (n[n.direction === JJ.vertical ? 'yField' : 'xField'] = i), n;
    }
    transformSpec(t) {
      super.transformSpec(t), t.axes || (t.axes = [{ orient: 'bottom' }, { orient: 'left' }]), zQ(t);
    }
  }
  (k2.type = d2.boxPlot), (k2.view = 'singleDefault');
  const M2 = function (t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
      i = arguments.length > 2 ? arguments[2] : void 0;
    const n = (null == i ? void 0 : i.maxDepth) >= 0;
    return (
      t.forEach(t => {
        (!n || t.depth <= i.maxDepth) &&
          (e.push((null == i ? void 0 : i.callback) ? i.callback(t) : t),
          t.children && (n && t.depth === i.maxDepth ? ((t.children = null), (t.isLeaf = !0)) : M2(t.children, e, i)));
      }),
      e
    );
  };
  function T2(t, e, i, n, s) {
    let r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : { x0: 'x0', x1: 'x1', y0: 'y0', y1: 'y1' };
    const a = t.children;
    let o,
      l = -1;
    const h = a.length,
      c = t.value && (n - e) / t.value;
    for (; ++l < h; ) (o = a[l]), (o[r.y0] = i), (o[r.y1] = s), (o[r.x0] = e), (o[r.x1] = e += o.value * c);
  }
  function C2(t, e, i, n, s) {
    const r = t.children;
    let a,
      o = -1;
    const l = r.length,
      h = t.value && (s - i) / t.value;
    for (; ++o < l; ) (a = r[o]), (a.x0 = e), (a.x1 = n), (a.y0 = i), (i += a.value * h), (a.y1 = i);
  }
  const E2 = t => (e, i, n, s, r) => {
      !(function (t, e, i, n, s, r) {
        const a = [],
          o = e.children;
        let l,
          h,
          c = 0,
          d = 0;
        const u = o.length;
        let p,
          g,
          f,
          v,
          m,
          y,
          _,
          b,
          x,
          S = e.value;
        for (; c < u; ) {
          (p = s - i), (g = r - n);
          do {
            f = o[d++].value;
          } while (!f && d < u);
          for (
            v = f, m = f, b = Math.max(g / p, p / g) / (S * t), x = f * f * b, _ = Math.max(m / x, x / v);
            d < u;
            ++d
          ) {
            if (
              ((h = o[d].value),
              (f += h),
              h < v && (v = h),
              h > m && (m = h),
              (x = f * f * b),
              (y = Math.max(m / x, x / v)),
              y > _)
            ) {
              f -= h;
              break;
            }
            _ = y;
          }
          (l = Object.assign({}, e, { value: f, children: o.slice(c, d) })),
            a.push(l),
            p < g ? T2(l, i, n, s, S ? (n += (g * f) / S) : r) : C2(l, i, n, S ? (i += (p * f) / S) : s, r),
            (S -= f),
            (c = d);
        }
      })(t, e, i, n, s, r);
    },
    P2 = function (t, e) {
      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1,
        s = arguments.length > 4 ? arguments[4] : void 0,
        r = arguments.length > 5 ? arguments[5] : void 0,
        a = 0,
        o = null != n ? n : -1,
        h = i;
      return (
        t.forEach((t, n) => {
          var c, d;
          const u = {
            flattenIndex: ++o,
            key: r ? r(t) : `${null !== (c = null == s ? void 0 : s.key) && void 0 !== c ? c : ''}-${n}`,
            maxDepth: -1,
            depth: i,
            index: n,
            value: t.value,
            isLeaf: !0,
            datum: s ? s.datum.concat(t) : [t],
            parentKey: null == s ? void 0 : s.key
          };
          if (null === (d = t.children) || void 0 === d ? void 0 : d.length) {
            (u.children = []), (u.isLeaf = !1);
            const e = P2(t.children, u.children, i + 1, o, u, r);
            (u.value = l(t.value) ? e.sum : Math.max(e.sum, u.value)),
              (o = e.flattenIndex),
              (h = Math.max(e.maxDepth, h));
          } else (u.isLeaf = !0), (u.value = l(t.value) ? 0 : t.value);
          (a += Math.abs(u.value)), e.push(u);
        }),
        { sum: a, maxDepth: h, flattenIndex: o }
      );
    },
    R2 = (t, e, i, n) => {
      let s = n;
      return (
        t.forEach((t, n) => {
          var r;
          (s = e(t, n, i, s)),
            (null === (r = t.children) || void 0 === r ? void 0 : r.length) && (s = R2(t.children, e, t, s));
        }),
        n
      );
    },
    O2 = (t, e, i, n) => {
      let s = n;
      return (
        t.forEach((t, n) => {
          var r;
          (null === (r = t.children) || void 0 === r ? void 0 : r.length) && (s = O2(t.children, e, t, s)),
            (s = e(t, n, i, s));
        }),
        s
      );
    },
    B2 = {
      binary: function (t, e, i, n, s) {
        const r = t.children,
          a = r.length;
        let o = 0;
        const l = new Array(a + 1);
        l[0] = 0;
        for (let t = 0; t < a; ++t) (o += r[t].value), (l[t + 1] = o);
        const h = (t, e, i, n, s, a, o) => {
          if (t >= e - 1) {
            const e = r[t];
            return (e.x0 = n), (e.y0 = s), (e.x1 = a), void (e.y1 = o);
          }
          const c = l[t],
            d = i / 2 + c;
          let u = t + 1,
            p = e - 1;
          for (; u < p; ) {
            const t = (u + p) >>> 1;
            l[t] < d ? (u = t + 1) : (p = t);
          }
          d - l[u - 1] < l[u] - d && t + 1 < u && --u;
          const g = l[u] - c,
            f = i - g;
          if (a - n > o - s) {
            const r = i ? (n * f + a * g) / i : a;
            h(t, u, g, n, s, r, o), h(u, e, f, r, s, a, o);
          } else {
            const r = i ? (s * f + o * g) / i : o;
            h(t, u, g, n, s, a, r), h(u, e, f, n, r, a, o);
          }
        };
        h(0, a, t.value, e, i, n, s);
      },
      dice: T2,
      slice: C2,
      sliceDice: function (t, e, i, n, s) {
        (t.depth % 2 == 1 ? C2 : T2)(t, e, i, n, s);
      }
    };
  class I2 {
    constructor(t) {
      var e;
      (this._filterByArea = (t, e) => {
        var i;
        const n = this._getMinAreaByDepth(t.depth);
        if (n > 0 && t.value * e < n) return !1;
        if (null === (i = t.children) || void 0 === i ? void 0 : i.length) {
          const i = t.children.filter(t => this._filterByArea(t, e));
          i.length ? i.length !== t.children.length && (t.children = i) : ((t.isLeaf = !0), (t.children = null));
        }
        return !0;
      }),
        (this._getMinAreaByDepth = t => {
          var e;
          return t < 0
            ? 0
            : null !==
                (e = f(this.options.minVisibleArea) ? this.options.minVisibleArea[t] : this.options.minVisibleArea) &&
              void 0 !== e
            ? e
            : 0;
        }),
        (this._getGapWidthByDepth = t => {
          var e;
          return t < 0
            ? 0
            : null !== (e = f(this.options.gapWidth) ? this.options.gapWidth[t] : this.options.gapWidth) && void 0 !== e
            ? e
            : 0;
        }),
        (this._getPaddingByDepth = t => {
          var e;
          return t < 0
            ? 0
            : null !== (e = f(this.options.padding) ? this.options.padding[t] : this.options.padding) && void 0 !== e
            ? e
            : 0;
        }),
        (this._getLabelPaddingByDepth = t => {
          var e;
          return t < 0
            ? 0
            : null !== (e = f(this.options.labelPadding) ? this.options.labelPadding[t] : this.options.labelPadding) &&
              void 0 !== e
            ? e
            : 0;
        }),
        (this._layoutNode = t => {
          const e = this._getGapWidthByDepth(t.depth);
          let i = t.x0,
            n = t.y0,
            s = t.x1,
            r = t.y1;
          if (
            ((t.maxDepth = this._maxDepth),
            e > 0 &&
              ((i += e / 2),
              (s -= e / 2),
              (n += e / 2),
              (r -= e / 2),
              i > s && ((i = (i + s) / 2), (s = i)),
              n > r && ((n = (n + r) / 2), (r = n)),
              (t.x0 = i),
              (t.x1 = s),
              (t.y0 = n),
              (t.y1 = r)),
            t.children)
          ) {
            const e = this._getLabelPaddingByDepth(t.depth),
              a = this._getPaddingByDepth(t.depth);
            a > 0 && a < Math.min(s - i, r - n) / 2 && ((n += a), (r -= a), (i += a), (s -= a)),
              e > 0 &&
                ('top' === this.options.labelPosition && n + e < r
                  ? ((t.labelRect = { x0: i, y0: n, x1: s, y1: n + e }), (n += e))
                  : 'bottom' === this.options.labelPosition && r - e > n
                  ? ((t.labelRect = { x0: i, y0: r - e, x1: s, y1: r }), (r -= e))
                  : 'left' === this.options.labelPosition && i + e < s
                  ? ((t.labelRect = { x0: i, y0: n, x1: i + e, y1: r }), (i += e))
                  : 'right' === this.options.labelPosition &&
                    s - e > i &&
                    ((t.labelRect = { x0: s - e, y0: n, x1: s, y1: r }), (s -= e)));
            const o = this._getGapWidthByDepth(t.depth + 1);
            o > 0 && ((i -= o / 2), (s += o / 2), (n -= o / 2), (r += o / 2)), this._splitNode(t, i, n, s, r);
          }
        }),
        (this.options = Object.assign({}, I2.defaultOpionts, t));
      const i = this.options.nodeKey,
        n = o(i) ? i : i ? jo(i) : null;
      (this._getNodeKey = n),
        (this._splitNode =
          'squarify' === this.options.splitType
            ? E2(this.options.aspectRatio)
            : null !== (e = B2[this.options.splitType]) && void 0 !== e
            ? e
            : B2.binary),
        (this._maxDepth = -1);
    }
    layout(t, e) {
      var i;
      if (!t || !t.length) return [];
      const n =
          'width' in e
            ? { x0: 0, x1: e.width, y0: 0, y1: e.height, width: e.width, height: e.height }
            : {
                x0: Math.min(e.x0, e.x1),
                x1: Math.max(e.x0, e.x1),
                y0: Math.min(e.y0, e.y1),
                y1: Math.max(e.y0, e.y1),
                width: Math.abs(e.x1 - e.x0),
                height: Math.abs(e.y1 - e.y0)
              },
        s = [],
        r = P2(t, s, 0, -1, null, this._getNodeKey);
      if (((this._maxDepth = r.maxDepth), r.sum <= 0)) return [];
      const a = {
          flattenIndex: -1,
          maxDepth: -1,
          key: '-1',
          depth: -1,
          index: -1,
          value: r.sum,
          datum: null,
          x0: n.x0,
          x1: n.x1,
          y0: n.y0,
          y1: n.y1,
          children: s
        },
        o = (n.width * n.height) / r.sum;
      return this._filterByArea(a, o), this._layout(a), null !== (i = a.children) && void 0 !== i ? i : [];
    }
    _filterChildren(t) {
      const e = this.options.maxDepth;
      if (y(e) && e >= 0 && t.depth >= e) return !1;
      const i = this.options.minChildrenVisibleArea;
      if (y(i) && Math.abs((t.x1 - t.x0) * (t.y1 - t.y0)) < i) return !1;
      const n = this.options.minChildrenVisibleSize;
      return !y(n) || !(Math.abs(t.x1 - t.x0) < n || Math.abs(t.y1 - t.y0) < n);
    }
    _layout(t) {
      var e;
      this._filterChildren(t) || ((t.children = null), (t.isLeaf = !0)),
        this._layoutNode(t),
        (null === (e = t.children) || void 0 === e ? void 0 : e.length) &&
          t.children.forEach(t => {
            var e;
            (null === (e = null == t ? void 0 : t.children) || void 0 === e ? void 0 : e.length)
              ? this._layout(t)
              : this._layoutNode(t);
          });
    }
  }
  I2.defaultOpionts = {
    aspectRatio: (1 + Math.sqrt(5)) / 2,
    gapWidth: 0,
    labelPadding: 0,
    labelPosition: 'top',
    splitType: 'binary',
    minVisibleArea: 10
  };
  const D2 = { x0: 'startAngle', x1: 'endAngle', y0: 'innerRadius', y1: 'outerRadius' };
  class L2 {
    constructor(t) {
      (this._layoutNode = t => {
        if (((t.maxDepth = this._maxDepth), t.children)) {
          const e = this._parsedInnerRadius[t.depth + 1],
            i = this._parsedOutterRadius[t.depth + 1];
          T2(t, t.startAngle, Math.min(e, i), t.endAngle, Math.max(e, i), D2);
          const n = f(this.options.label) ? this.options.label[t.depth + 1] : this.options.label;
          t.children.forEach(t => {
            if (((t.x = this._parsedCenter[0]), (t.y = this._parsedCenter[1]), n))
              return this._layoutLabel(t, a(n) ? { align: 'center', rotate: 'radial' } : n);
          });
        }
      }),
        (this.options = t ? Object.assign({}, L2.defaultOpionts, t) : Object.assign({}, L2.defaultOpionts));
      const e = this.options.nodeKey,
        i = o(e) ? e : e ? jo(e) : null;
      (this._getNodeKey = i), (this._maxDepth = -1);
    }
    _parseRadius(t, e) {
      const i = t.x0 + Yo(this.options.center[0], t.width),
        n = t.y0 + Yo(this.options.center[1], t.height),
        s = Math.min(t.width / 2, t.height / 2),
        r = this.options.innerRadius,
        a = this.options.outerRadius,
        o = f(r),
        h = o ? r.map(t => Yo(t, s)) : Yo(r, s),
        c = f(a),
        d = this.options.gapRadius,
        u = c ? a.map(t => Yo(t, s)) : Yo(a, s),
        p = X(0, e + 1);
      if (o)
        (this._parsedInnerRadius = p.map((t, e) => {
          const i = h[e];
          return l(i) ? s : i;
        })),
          (this._parsedOutterRadius = p.map((t, i) => {
            var n;
            return c
              ? u[i]
              : i < e
              ? this._parsedInnerRadius[i + 1] - (f(d) ? (null !== (n = d[i]) && void 0 !== n ? n : 0) : d)
              : u;
          }));
      else if (c)
        (this._parsedOutterRadius = p.map((t, e) => (l(u[e]) ? s : u[e]))),
          (this._parsedInnerRadius = p.map((t, e) => {
            var i;
            return 0 === e
              ? h
              : this._parsedOutterRadius[e - 1] - (f(d) ? (null !== (i = d[e]) && void 0 !== i ? i : 0) : d);
          }));
      else {
        const t = Yo(r, s),
          i = (u - t) / (e + 1);
        (this._parsedInnerRadius = p.map((e, n) => t + n * i)),
          (this._parsedOutterRadius = p.map((t, e) => {
            var n;
            return this._parsedInnerRadius[e] + i - (f(d) ? (null !== (n = d[e]) && void 0 !== n ? n : 0) : d);
          }));
      }
      (this._parsedCenter = [i, n]), (this._maxRadius = s);
    }
    layout(t, e) {
      const i =
        'width' in e
          ? { x0: 0, x1: e.width, y0: 0, y1: e.height, width: e.width, height: e.height }
          : {
              x0: Math.min(e.x0, e.x1),
              x1: Math.max(e.x0, e.x1),
              y0: Math.min(e.y0, e.y1),
              y1: Math.max(e.y0, e.y1),
              width: Math.abs(e.x1 - e.x0),
              height: Math.abs(e.y1 - e.y0)
            };
      if (!t || !t.length) return [];
      const n = [],
        s = P2(t, n, 0, -1, null, this._getNodeKey);
      return (
        this._parseRadius(i, s.maxDepth),
        (this._maxDepth = s.maxDepth),
        this._layout(n, {
          flattenIndex: -1,
          maxDepth: -1,
          key: '-1',
          depth: -1,
          index: -1,
          value: s.sum,
          datum: null,
          children: n,
          startAngle: this.options.startAngle,
          endAngle: this.options.endAngle
        }),
        n
      );
    }
    _layout(t, e) {
      this._layoutNode(e),
        t.forEach(t => {
          var e;
          (null === (e = null == t ? void 0 : t.children) || void 0 === e ? void 0 : e.length)
            ? this._layout(t.children, t)
            : this._layoutNode(t);
        });
    }
    _layoutLabel(t, e) {
      var i;
      const n = (t.startAngle + t.endAngle) / 2,
        s =
          ('start' === e.align
            ? t.innerRadius
            : 'end' === e.align
            ? t.outerRadius
            : (t.innerRadius + t.outerRadius) / 2) + (null !== (i = e.offset) && void 0 !== i ? i : 0),
        r = te({ x: this._parsedCenter[0], y: this._parsedCenter[1] }, s, n);
      if (((t.label = { x: r.x, y: r.y, textBaseline: 'middle' }), 'tangential' === e.rotate))
        (t.label.angle = n - Math.PI / 2),
          (t.label.textAlign = 'center'),
          (t.label.maxLineWidth = Math.abs(t.endAngle - t.startAngle) * s);
      else {
        const i = n % (2 * Math.PI),
          s = i < 0 ? i + 2 * Math.PI : i;
        s > Math.PI / 2 && s < 1.5 * Math.PI
          ? ((t.label.angle = s + Math.PI),
            (t.label.textAlign = 'start' === e.align ? 'end' : 'end' === e.align ? 'start' : 'center'))
          : ((t.label.angle = s), (t.label.textAlign = e.align)),
          (t.label.maxLineWidth = t.isLeaf ? void 0 : Math.abs(t.outerRadius - t.innerRadius));
      }
    }
  }
  L2.defaultOpionts = {
    startAngle: Math.PI / 2,
    endAngle: (-3 * Math.PI) / 2,
    center: ['50%', '50%'],
    gapRadius: 0,
    innerRadius: 0,
    outerRadius: '70%'
  };
  const F2 = 4294967296;
  function j2(t, e) {
    let i, n;
    if (N2(e, t)) return [e];
    for (i = 0; i < t.length; ++i) if (z2(e, t[i]) && N2(W2(t[i], e), t)) return [t[i], e];
    for (i = 0; i < t.length - 1; ++i)
      for (n = i + 1; n < t.length; ++n)
        if (z2(W2(t[i], t[n]), e) && z2(W2(t[i], e), t[n]) && z2(W2(t[n], e), t[i]) && N2(G2(t[i], t[n], e), t))
          return [t[i], t[n], e];
    Ze.getInstance().error('error when packEncloseRandom');
  }
  function z2(t, e) {
    const i = t.radius - e.radius,
      n = e.x - t.x,
      s = e.y - t.y;
    return i < 0 || i * i < n * n + s * s;
  }
  function H2(t, e) {
    const i = t.radius - e.radius + 1e-9 * Math.max(t.radius, e.radius, 1),
      n = e.x - t.x,
      s = e.y - t.y;
    return i > 0 && i * i > n * n + s * s;
  }
  function N2(t, e) {
    for (let i = 0; i < e.length; ++i) if (!H2(t, e[i])) return !1;
    return !0;
  }
  function V2(t) {
    switch (t.length) {
      case 1:
        return (function (t) {
          return { x: t.x, y: t.y, radius: t.radius };
        })(t[0]);
      case 2:
        return W2(t[0], t[1]);
      case 3:
        return G2(t[0], t[1], t[2]);
    }
  }
  function W2(t, e) {
    const i = t.x,
      n = t.y,
      s = t.radius,
      r = e.x,
      a = e.y,
      o = e.radius,
      l = r - i,
      h = a - n,
      c = o - s,
      d = Math.sqrt(l * l + h * h);
    return { x: (i + r + (l / d) * c) / 2, y: (n + a + (h / d) * c) / 2, radius: (d + s + o) / 2 };
  }
  function G2(t, e, i) {
    const n = t.x,
      s = t.y,
      r = t.radius,
      a = e.x,
      o = e.y,
      l = e.radius,
      h = i.x,
      c = i.y,
      d = i.radius,
      u = n - a,
      p = n - h,
      g = s - o,
      f = s - c,
      v = l - r,
      m = d - r,
      y = n * n + s * s - r * r,
      _ = y - a * a - o * o + l * l,
      b = y - h * h - c * c + d * d,
      x = p * g - u * f,
      S = (g * b - f * _) / (2 * x) - n,
      w = (f * v - g * m) / x,
      A = (p * _ - u * b) / (2 * x) - s,
      k = (u * m - p * v) / x,
      M = w * w + k * k - 1,
      T = 2 * (r + S * w + A * k),
      C = S * S + A * A - r * r,
      E = -(Math.abs(M) > 1e-6 ? (T + Math.sqrt(T * T - 4 * M * C)) / (2 * M) : C / T);
    return { x: n + S + w * E, y: s + A + k * E, radius: E };
  }
  function U2(t, e, i) {
    const n = t.x - e.x;
    let s, r;
    const a = t.y - e.y;
    let o, l;
    const h = n * n + a * a;
    h
      ? ((r = e.radius + i.radius),
        (r *= r),
        (l = t.radius + i.radius),
        (l *= l),
        r > l
          ? ((s = (h + l - r) / (2 * h)),
            (o = Math.sqrt(Math.max(0, l / h - s * s))),
            (i.x = t.x - s * n - o * a),
            (i.y = t.y - s * a + o * n))
          : ((s = (h + r - l) / (2 * h)),
            (o = Math.sqrt(Math.max(0, r / h - s * s))),
            (i.x = e.x + s * n - o * a),
            (i.y = e.y + s * a + o * n)))
      : ((i.x = e.x + i.radius), (i.y = e.y));
  }
  function Y2(t, e) {
    const i = t.radius + e.radius - 1e-6,
      n = e.x - t.x,
      s = e.y - t.y;
    return i > 0 && i * i > n * n + s * s;
  }
  function $2(t) {
    const e = t._,
      i = t.next._,
      n = e.radius + i.radius,
      s = (e.x * i.radius + i.x * e.radius) / n,
      r = (e.y * i.radius + i.y * e.radius) / n;
    return s * s + r * r;
  }
  function X2(t) {
    return { _: t, next: null, prev: null };
  }
  function K2(t, e) {
    const i = (t = V(t)).length;
    if (!i) return 0;
    let n = t[0];
    if (((n.x = 0), (n.y = 0), 1 === i)) return n.radius;
    const s = t[1];
    if (((n.x = -s.radius), (s.x = n.radius), (s.y = 0), 2 === i)) return n.radius + s.radius;
    let r = t[2];
    U2(s, n, r);
    let a,
      o,
      l,
      h,
      c,
      d,
      u,
      p = X2(n),
      g = X2(s),
      f = X2(r);
    (p.next = g), (f.prev = g), (g.next = f), (p.prev = f), (f.next = p), (g.prev = p);
    for (let e = 3; e < i; ++e) {
      (u = !1),
        (r = t[e]),
        U2(p._, g._, r),
        (f = X2(r)),
        (a = g.next),
        (o = p.prev),
        (l = g._.radius),
        (h = p._.radius);
      do {
        if (l <= h) {
          if (Y2(a._, f._)) {
            (g = a), (p.next = g), (g.prev = p), --e, (u = !0);
            break;
          }
          (l += a._.radius), (a = a.next);
        } else {
          if (Y2(o._, f._)) {
            (p = o), (p.next = g), (g.prev = p), --e, (u = !0);
            break;
          }
          (h += o._.radius), (o = o.prev);
        }
      } while (a !== o.next);
      if (!u) {
        for (f.prev = p, f.next = g, p.next = g.prev = g = f, c = $2(p), f = f.next; f !== g; )
          (d = $2(f)), d < c && ((p = f), (c = d)), (f = f.next);
        g = p.next;
      }
    }
    const v = [g._];
    for (f = g.next; f !== g; ) v.push(f._), (f = f.next);
    r = (function (t, e) {
      let i = 0;
      const n = Y(Array.from(t), e),
        s = n.length;
      let r,
        a,
        o = [];
      for (; i < s; ) (r = n[i]), a && H2(a, r) ? ++i : ((o = j2(o, r)), (a = V2(o)), (i = 0));
      return a;
    })(v, e);
    for (let e = 0; e < i; ++e) (n = t[e]), (n.x -= r.x), (n.y -= r.y);
    return r.radius;
  }
  function q2(t) {
    return function (e) {
      e.children || (e.radius = Math.max(0, +t(e) || 0));
    };
  }
  function Z2(t, e, i) {
    return function (n) {
      const s = null == n ? void 0 : n.children;
      if (s) {
        let r;
        const a = s.length,
          o = t(n) * e || 0;
        if (o) for (r = 0; r < a; ++r) s[r].radius += o;
        const l = K2(s, i);
        if (o) for (r = 0; r < a; ++r) s[r].radius -= o;
        n.radius = l + o;
      }
    };
  }
  function J2(t, e) {
    return function (i, n, s) {
      (i.radius *= t), (i.maxDepth = e), s && ((i.x = s.x + t * i.x), (i.y = s.y + t * i.y));
    };
  }
  class Q2 {
    constructor(t) {
      this.options = t;
      const e = null == t ? void 0 : t.nodeKey,
        i = o(e) ? e : e ? jo(e) : null;
      (this._getNodeKey = i),
        (this._getPadding = y(null == t ? void 0 : t.padding)
          ? e => t.padding
          : f(null == t ? void 0 : t.padding)
          ? e => {
              var i;
              return null !== (i = t.padding[e.depth + 1]) && void 0 !== i ? i : 0;
            }
          : () => 0),
        (this._maxDepth = -1);
    }
    layout(t, e) {
      var i, n, s, r, a;
      const l =
        'width' in e
          ? { x0: 0, x1: e.width, y0: 0, y1: e.height, width: e.width, height: e.height }
          : {
              x0: Math.min(e.x0, e.x1),
              x1: Math.max(e.x0, e.x1),
              y0: Math.min(e.y0, e.y1),
              y1: Math.max(e.y0, e.y1),
              width: Math.abs(e.x1 - e.x0),
              height: Math.abs(e.y1 - e.y0)
            };
      if (!t || !t.length) return [];
      const h = [],
        c = P2(t, h, 0, -1, null, this._getNodeKey);
      this._maxDepth = c.maxDepth;
      const d = (function () {
          let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
          return () => (t = (1664525 * t + 1013904223) % F2) / F2;
        })(),
        u = {
          flattenIndex: -1,
          maxDepth: -1,
          key: 'root',
          depth: -1,
          index: -1,
          value: c.sum,
          datum: null,
          children: h,
          x: l.x0 + l.width / 2,
          y: l.y0 + l.height / 2
        };
      if (!1 !== (null === (i = this.options) || void 0 === i ? void 0 : i.nodeSort)) {
        const t = o(null === (n = this.options) || void 0 === n ? void 0 : n.nodeSort)
          ? this.options.nodeKey
          : Q2.defaultOpionts.nodeSort;
        R2([u], e => {
          e.children && e.children.length && e.children.sort(t);
        });
      }
      if (null === (s = this.options) || void 0 === s ? void 0 : s.setRadius)
        R2([u], q2(this.options.setRadius)), O2([u], Z2(this._getPadding, 0.5, d)), R2([u], J2(1, this._maxDepth));
      else {
        const t = Math.min(l.width, l.height);
        R2([u], q2(Q2.defaultOpionts.setRadius)),
          O2([u], Z2(Ho, 1, d)),
          (null === (r = this.options) || void 0 === r ? void 0 : r.padding) &&
            O2([u], Z2(this._getPadding, u.radius / t, d)),
          R2([u], J2(t / (2 * u.radius), this._maxDepth));
      }
      return (null === (a = this.options) || void 0 === a ? void 0 : a.includeRoot) ? [u] : h;
    }
  }
  Q2.defaultOpionts = { setRadius: t => Math.sqrt(t.value), padding: 0, nodeSort: (t, e) => e.value - t.value };
  const t3 = (t, e) => {
      if (!t) return t;
      const i = e(),
        { width: n, height: s } = i;
      if (0 === n || 0 === s) return t;
      return new Q2(i).layout(t, { width: n, height: s });
    },
    e3 = (t, e = {}) => {
      if (!t) return [];
      const i = [];
      return M2(t, i, e), i;
    };
  class i3 extends z1 {
    constructor() {
      super(...arguments),
        (this.contentKeyCallback = t => (null == t ? void 0 : t[this.series.getDimensionField()[0]]));
    }
  }
  var n3;
  !(function (t) {
    (t.DrillDown = 'drillDown'), (t.DrillUp = 'drillUp');
  })(n3 || (n3 = {}));
  const s3 = (t, e) => {
    const i = e.info(),
      n = e.keyField(),
      s = null == i ? void 0 : i.key;
    if (l(s)) return t;
    if (i.type === n3.DrillDown) {
      return V(zJ(t, s, n, 'children'));
    }
    if (i.type === n3.DrillUp) {
      const e = HJ(t, s, n, 'children');
      if (e) return V(e);
    }
    return t;
  };
  class r3 {
    parserScrollEvent(t) {
      return t
        ? !(t.ctrlKey || (0 === t.deltaY && 0 === t.deltaX)) && ((t.scrollX = t.deltaX), (t.scrollY = t.deltaY), t)
        : t;
    }
    parserZoomEvent(t) {
      if (!t) return t;
      const e = Math.pow(1.0005, -t.deltaY * Math.pow(16, t.deltaMode));
      return (t.zoomDelta = e), (t.zoomX = t.canvasX), (t.zoomY = t.canvasY), t;
    }
    clearZoom() {}
    clearScroll() {}
    parserDragEvent() {
      return !0;
    }
  }
  class a3 {
    constructor() {
      this._lastScale = 0;
    }
    clearZoom() {
      (this._lastScale = 0), (this.pointerId = null);
    }
    parserDragEvent(t) {
      return this.pointerId ? this.pointerId === t.pointerId : ((this.pointerId = t.pointerId), !0);
    }
    parserZoomEvent(t) {
      const e = t.scale;
      if (0 === this._lastScale) return (this._lastScale = e), t;
      t.zoomDelta = e / this._lastScale;
      const i = t.center;
      return (t.zoomX = i.x), (t.zoomY = i.y), (this._lastScale = e), t;
    }
    parserScrollEvent(t) {
      return t;
    }
    clearScroll() {}
  }
  const o3 = {
    [t.RenderModeEnum['desktop-browser']]: {
      start: 'pointerdown',
      move: 'pointermove',
      end: 'pointerup',
      zoom: 'wheel',
      zoomEnd: 'pointerup',
      scroll: 'wheel',
      trigger: r3
    },
    [t.RenderModeEnum['desktop-miniApp']]: {
      start: 'pointerdown',
      move: 'pointermove',
      end: 'pointerup',
      zoom: 'wheel',
      zoomEnd: 'pointerup',
      scroll: 'wheel',
      trigger: r3
    },
    [t.RenderModeEnum['mobile-browser']]: {
      start: 'pointerdown',
      move: 'pointermove',
      end: 'pointerup',
      zoom: 'pinch',
      zoomEnd: 'pinchend',
      scroll: 'pan',
      scrollEnd: 'panend',
      trigger: a3
    },
    [t.RenderModeEnum.miniApp]: {
      start: 'pointerdown',
      move: 'pointermove',
      end: 'pointerup',
      zoom: 'pinch',
      zoomEnd: 'pinchend',
      scroll: 'pan',
      scrollEnd: 'panend',
      trigger: a3
    },
    [t.RenderModeEnum.lynx]: {
      start: 'pointerdown',
      move: 'pointermove',
      end: 'pointerup',
      zoom: 'pinch',
      zoomEnd: 'pinchend',
      scroll: 'pan',
      scrollEnd: 'panend',
      trigger: a3
    }
  };
  class l3 {
    _getTriggerEvent(t) {
      var e;
      const { mode: i } = this._drillParams;
      return null === (e = o3[i]) || void 0 === e ? void 0 : e[t];
    }
    _hideTooltip() {
      const t = this.getChart()
        .getAllComponents()
        .find(t => t.type === xn.tooltip);
      t && t.hideTooltip();
    }
    initDrillable(t) {
      this._drillParams = t;
    }
    initDrillableData(t) {
      const { getRawData: e } = this._drillParams;
      xQ(t, 'drillFilter', s3),
        e().transform({
          type: 'drillFilter',
          options: { info: () => this._drillInfo, keyField: () => this._drillParams.drillField() }
        });
    }
    bindDrillEvent() {
      const { event: t, getRawData: e, drillField: i } = this._drillParams,
        n = i();
      this._getTriggerEvent('start') &&
        t.on(this._getTriggerEvent('start'), t => {
          var i, s, r;
          if (l(t.datum) || l(null === (i = t.datum) || void 0 === i ? void 0 : i[n])) return void this.drillUp();
          this._hideTooltip();
          const a = t.datum[n],
            o =
              null !== (r = null === (s = this._drillInfo) || void 0 === s ? void 0 : s.path) && void 0 !== r ? r : [],
            h = ((t, e, i = 'key', n = 'children') => {
              const s = [],
                r = (t, a) => {
                  for (const o of t) {
                    if (o[i] === e) return s.push(...a, o[i].toString()), !0;
                    if (o[n]) {
                      const t = r(o[n], [...a, o[i]]);
                      if (!0 === t) return t;
                    }
                  }
                  return !1;
                };
              return r(t, []), s;
            })(e().rawData, a, n, 'children');
          o[o.length - 1] === h[h.length - 1] ? this.drillUp() : this.drillDown(h);
        });
    }
    drillDown(t = []) {
      const { getRawData: e, event: i } = this._drillParams;
      if (!f(t) || T(t)) return t;
      const n = t[t.length - 1];
      return (
        (this._drillInfo = { key: n, path: t, type: n3.DrillDown }),
        e().reRunAllTransform(),
        i.emit(Gq.drill, { value: { path: t, type: n3.DrillDown }, model: this }),
        t
      );
    }
    drillUp() {
      var t, e;
      const { getRawData: i, event: n } = this._drillParams,
        s = null !== (e = null === (t = this._drillInfo) || void 0 === t ? void 0 : t.path) && void 0 !== e ? e : [];
      if (!f(s) || T(s)) return s;
      const r = s.pop();
      return (
        (this._drillInfo = { key: r, path: s, type: n3.DrillUp }),
        i().reRunAllTransform(),
        n.emit(Gq.drill, { value: { path: s, type: n3.DrillUp }, model: this }),
        s
      );
    }
  }
  class h3 extends g0 {
    constructor(t, e) {
      super(t, e),
        (this.type = c3.type),
        (this._unCompileChannel = { centerOffset: !0, radiusOffset: !0 }),
        (this.computeOuterRadius = (t, e, i = 'normal', n, s) => {
          var r;
          return s + (null !== (r = this._computeAttribute('radiusOffset', e, i, n)) && void 0 !== r ? r : 0);
        }),
        (this.computeCenter = (t, e, i = 'normal', n, s) =>
          s + YN({ angle: e[lW], radius: this._computeAttribute('centerOffset', e, i, n) })[t]),
        (this._computeExChannel.x = this.computeCenter),
        (this._computeExChannel.y = this.computeCenter),
        (this._computeExChannel.outerRadius = this.computeOuterRadius),
        (this._extensionChannel.centerOffset = ['x', 'y']),
        (this._extensionChannel.radiusOffset = ['outerRadius']);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), {
        startAngle: 0,
        endAngle: 0,
        outerRadius: 0,
        innerRadius: 0,
        cornerRadius: 0,
        lineWidth: 0
      });
    }
  }
  class c3 extends h3 {
    constructor() {
      super(...arguments), (this.type = c3.type);
    }
  }
  (c3.type = jZ.arc), NQ.useMark([c3, i2]);
  class d3 extends J1 {
    constructor() {
      super(...arguments), (this.type = DZ.circlePacking);
    }
    setCategoryField(t) {
      return (this._categoryField = t), this._categoryField;
    }
    getCategoryField() {
      return this._categoryField;
    }
    setValueField(t) {
      return (this._valueField = t), this._valueField;
    }
    getValueField() {
      return this._valueField;
    }
    getDimensionField() {
      return [this._categoryField];
    }
    getMeasureField() {
      return [this._valueField];
    }
    setAttrFromSpec() {
      var t;
      super.setAttrFromSpec(),
        this.setCategoryField(this._spec.categoryField),
        this.setValueField(this._spec.valueField),
        this.setSeriesField(null !== (t = this._spec.seriesField) && void 0 !== t ? t : U1),
        this._spec.drill &&
          this.initDrillable({
            event: this.event,
            mode: this._option.mode,
            drillField: () => {
              var t;
              return null !== (t = this._spec.drillField) && void 0 !== t ? t : Kq;
            },
            getRawData: () => this.getRawData()
          }),
        (this._circlePacking = this._spec.circlePacking),
        (this._label = this._spec.label),
        (this._layoutPadding = this._spec.layoutPadding);
    }
    initData() {
      super.initData();
      const t = this.getRawData();
      l(t) ||
        (this._spec.drill && this.initDrillableData(this._dataSet),
        xQ(this._dataSet, 'circlePackingLayout', t3),
        xQ(this._dataSet, 'flatten', e3),
        t.transform({
          type: 'circlePackingLayout',
          options: () => ({
            nodeKey: this._categoryField,
            padding: this._layoutPadding,
            includeRoot: !1,
            width: this.getLayoutRect().width || 1,
            height: this.getLayoutRect().height || 1
          })
        }),
        t.transform({
          type: 'flatten',
          options: {
            callback: t => {
              if (t.datum) {
                const e = t.datum[t.depth];
                return Object.assign(Object.assign({}, t), e);
              }
              return t;
            }
          }
        }));
    }
    _addDataIndexAndKey() {
      const t = this.getRawData();
      l(null == t ? void 0 : t.dataSet) ||
        (xQ(t.dataSet, 'addVChartProperty', P1),
        t.transform({ type: 'addVChartProperty', options: { beforeCall: $1, call: K1.bind(this) } }));
    }
    initMark() {
      this._initCirclePackingMark(), this._initLabelMark();
    }
    initMarkStyle() {
      this._initCirclePackingMarkStyle(), this._initLabelMarkStyle();
    }
    _initCirclePackingMark() {
      var t, e;
      if (!1 === (null === (t = this._circlePacking) || void 0 === t ? void 0 : t.visible)) return;
      const i = this._createMark(d3.mark.circlePacking, { isSeriesMark: !0 });
      (this._circlePackingMark = i),
        this._trigger.registerMark(i),
        null === (e = this._tooltipHelper) || void 0 === e || e.activeTriggerSet.mark.add(i);
    }
    _initCirclePackingMarkStyle() {
      l(this._circlePackingMark) ||
        this.setMarkStyle(
          this._circlePackingMark,
          {
            x: t => t.x,
            y: t => t.y,
            outerRadius: t => t.radius,
            innerRadius: 0,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            fill: this.getColorAttribute(),
            zIndex: t => t.depth
          },
          BQ.STATE_NORMAL,
          Jq.Series
        );
    }
    _initLabelMark() {
      var t, e;
      if (!1 === (null === (t = this._label) || void 0 === t ? void 0 : t.visible)) return;
      const i = this._createMark(d3.mark.label, { isSeriesMark: !1 });
      (this._labelMark = i),
        this._trigger.registerMark(i),
        null === (e = this._tooltipHelper) || void 0 === e || e.activeTriggerSet.mark.add(i);
    }
    _initLabelMarkStyle() {
      l(this._labelMark) ||
        this.setMarkStyle(
          this._labelMark,
          { x: t => t.x, y: t => t.y, text: t => t.key, cursor: 'pointer' },
          BQ.STATE_NORMAL,
          Jq.Series
        );
    }
    getStatisticFields() {
      return super.getStatisticFields().concat([
        { key: this._categoryField, operations: ['values'] },
        { key: this._valueField, operations: ['max', 'min'] },
        { key: G1, operations: ['max', 'min', 'values'] },
        { key: U1, operations: ['values'] }
      ]);
    }
    initTooltip() {
      this._tooltipHelper = new i3(this);
    }
    initAnimation() {
      var t, e;
      const i =
        null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
          ? void 0
          : e.preset;
      this.getMarksInType(jZ.arc).forEach(t => {
        t.setAnimationConfig(w1(x1.circlePacking({}, i), A1(t.name, this._spec)));
      }),
        this.getMarksInType(jZ.text).forEach(t => {
          t.setAnimationConfig(w1(x1.label(), A1(t.name, this._spec)));
        });
    }
    initEvent() {
      super.initEvent(), this._spec.drill && this.bindDrillEvent();
    }
    onLayoutEnd(t) {
      super.onLayoutEnd(t), this._rawData.reRunAllTransform();
    }
    _noAnimationDataKey(t, e) {}
  }
  (d3.type = DZ.circlePacking), (d3.mark = pJ), N(d3, l3), NQ.useSeries([d3]);
  class u3 extends h2 {
    constructor() {
      super(...arguments), (this.type = d2.circlePacking), (this.seriesType = DZ.circlePacking);
    }
    getDefaultSeriesSpec(t) {
      const e = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
          categoryField: t.categoryField,
          valueField: t.valueField,
          seriesField: t.seriesField,
          layoutPadding: t.layoutPadding,
          label: t.label,
          circlePacking: t.circlePacking,
          drill: t.drill,
          drillField: t.drillField
        }),
        i = DZ.circlePacking;
      return (e.type = i), (e[i] = t[i]), e;
    }
    transformSpec(t) {
      super.transformSpec(t);
      const e = this.getDefaultSeriesSpec(t);
      t.series && 0 !== t.series.length
        ? t.series.forEach(t => {
            this.isValidSeries(t.type) &&
              Object.keys(e).forEach(i => {
                i in t || (t[i] = e[i]);
              });
          })
        : (t.series = [e]);
    }
  }
  (u3.type = d2.circlePacking), (u3.view = 'singleDefault');
  class p3 extends h2 {
    constructor() {
      super(...arguments), (this.type = d2.common);
    }
    _getDefaultSeriesSpec(t) {
      const e = super._getDefaultSeriesSpec(t);
      return delete e.data, e;
    }
    transformSpec(t) {
      if ((super.transformSpec(t), f(t.series))) {
        const e = this._getDefaultSeriesSpec(t);
        t.series.forEach(t => {
          this.isValidSeries(t.type) &&
            Object.keys(e).forEach(i => {
              i in t || (t[i] = e[i]);
            });
        });
      }
    }
  }
  (p3.type = d2.common), (p3.view = 'singleDefault');
  class g3 extends h2 {
    needAxes() {
      return !1;
    }
    _getDefaultSeriesSpec(t) {
      const e = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
          categoryField: t.categoryField,
          valueField: t.valueField,
          seriesField: t.seriesField,
          funnelAlign: t.funnelAlign,
          funnelOrient: t.funnelOrient,
          shape: t.shape,
          funnel: t.funnel,
          transform: t.transform,
          outerLabel: t.outerLabel,
          transformLabel: t.transformLabel,
          isTransform: t.isTransform,
          maxSize: t.maxSize,
          minSize: t.minSize,
          gap: t.gap,
          isCone: t.isCone,
          range: t.range
        }),
        i = this.seriesType;
      return i && ((e.type = i), (e[i] = t[i])), e;
    }
    transformSpec(t) {
      super.transformSpec(t);
      const e = this._getDefaultSeriesSpec(t);
      t.series && 0 !== t.series.length
        ? t.series.forEach(t => {
            this.isValidSeries(t.type) &&
              Object.keys(e).forEach(i => {
                i in t || (t[i] = e[i]);
              });
          })
        : (t.series = [e]);
    }
  }
  const f3 = (t, e) => {
      var i, n;
      const s = t.map(t => Object.assign({}, t));
      if (!s || 0 === s.length) return s;
      const {
          valueField: r,
          asTransformRatio: a,
          asReachRatio: o,
          asHeightRatio: l,
          asValueRatio: h,
          asNextValueRatio: c,
          asLastValueRatio: d,
          asLastValue: u,
          asCurrentValue: p,
          asNextValue: g,
          heightVisual: f = !1,
          isCone: v = !0,
          range: m
        } = e,
        y = s.reduce((t, e) => Math.max(t, Number.parseFloat(e[r]) || -1 / 0), -1 / 0),
        b = s.reduce((t, e) => Math.min(t, Number.parseFloat(e[r]) || 1 / 0), 1 / 0),
        x = [
          null !== (i = null == m ? void 0 : m.min) && void 0 !== i ? i : b,
          null !== (n = null == m ? void 0 : m.max) && void 0 !== n ? n : y
        ];
      return (
        s.forEach((t, e) => {
          var i, n;
          const m = Number.parseFloat(t[r]),
            y = Number.parseFloat(null === (i = s[e - 1]) || void 0 === i ? void 0 : i[r]),
            b = Number.parseFloat(null === (n = s[e + 1]) || void 0 === n ? void 0 : n[r]),
            S = _(b * m) ? b / m : null,
            w = _(m * m) ? m / y : null;
          u && (t[u] = y),
            g && (t[g] = b),
            a && (t[a] = S),
            o && (t[o] = 0 === e ? 1 : w),
            l && (t[l] = !0 === f ? S : 1 / s.length),
            h && (t[h] = m / x[1]),
            c && (t[c] = e === s.length - 1 ? (v ? 0 : t[h]) : b / x[1]),
            d && (t[d] = 0 === e ? 1 : y / x[1]),
            p && (t[p] = m);
        }),
        s
      );
    },
    v3 = (t, e) => {
      var i, n;
      const s =
        null === (n = null === (i = t[0]) || void 0 === i ? void 0 : i.latestData) || void 0 === n
          ? void 0
          : n.map(t => Object.assign({}, t));
      return s && 0 !== s.length
        ? (s.shift(),
          s.forEach(t => {
            t[e.asIsTransformLevel] = !0;
          }),
          s)
        : s;
    },
    m3 = `${UV}_FUNNEL_TRANSFORM_RATIO`,
    y3 = `${UV}_FUNNEL_REACH_RATIO`,
    _3 = `${UV}_FUNNEL_HEIGHT_RATIO`,
    b3 = `${UV}_FUNNEL_VALUE_RATIO`,
    x3 = `${UV}_FUNNEL_LAST_VALUE_RATIO`,
    S3 = `${UV}_FUNNEL_NEXT_VALUE_RATIO`,
    w3 = `${UV}_FUNNEL_LAST_VALUE`,
    A3 = `${UV}_FUNNEL_CURRENT_VALUE`,
    k3 = `${UV}_FUNNEL_NEXT_VALUE`,
    M3 = `${UV}_FUNNEL_TRANSFORM_LEVEL`,
    T3 = 20;
  class C3 extends z1 {
    constructor() {
      super(...arguments),
        (this.titleValueCallback = (t, e) => {
          var i, n, s;
          const r = this.series;
          return (null === (i = null == e ? void 0 : e.mark) || void 0 === i ? void 0 : i.name) === LZ.transform
            ? '转化率'
            : null !== (n = this._getDimensionData(t)) && void 0 !== n
            ? n
            : null === (s = t.properties) || void 0 === s
            ? void 0
            : s[`${r.getCategoryField()}`];
        }),
        (this.contentValueCallback = (t, e) => {
          var i;
          if ((null === (i = null == e ? void 0 : e.mark) || void 0 === i ? void 0 : i.name) === LZ.transform) {
            return `${(100 * (null == t ? void 0 : t[y3])).toFixed(1)}%`;
          }
          return this._getMeasureData(t);
        }),
        (this.contentKeyCallback = (t, e) => {
          var i;
          if ((null === (i = null == e ? void 0 : e.mark) || void 0 === i ? void 0 : i.name) === LZ.transform)
            return '转化率';
          const { dimensionFields: n, seriesFields: s } = this._seriesCacheInfo,
            r = n[n.length - 1];
          return h(s[0]) ? (null == t ? void 0 : t[s[0]]) : null == t ? void 0 : t[r];
        });
    }
  }
  class E3 extends g0 {
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), { points: [] });
    }
  }
  class P3 extends E3 {
    constructor() {
      super(...arguments), (this.type = P3.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), { lineWidth: 0 });
    }
  }
  P3.type = jZ.polygon;
  class R3 extends g0 {
    constructor() {
      super(...arguments), (this.type = R3.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), { x1: 0, y1: 0 });
    }
  }
  (R3.type = jZ.rule), NQ.useMark([P3, i2, R3]);
  class O3 extends q1 {
    constructor() {
      super(...arguments),
        (this.type = DZ.funnel),
        (this._funnelMarkName = LZ.funnel),
        (this._funnelMarkType = jZ.polygon),
        (this._transformMarkName = LZ.transform),
        (this._transformMarkType = jZ.polygon),
        (this._funnelMark = null),
        (this._funnelTransformMark = null),
        (this._labelMark = null),
        (this._transformLabelMark = null),
        (this._funnelOuterLabelMark = {});
    }
    getCategoryField() {
      return this._categoryField;
    }
    setCategoryField(t) {
      return (this._categoryField = t), this._categoryField;
    }
    getValueField() {
      return this._valueField;
    }
    setValueField(t) {
      return (this._valueField = t), this._valueField;
    }
    setAttrFromSpec() {
      var t, e;
      super.setAttrFromSpec(),
        this.setCategoryField(this._spec.categoryField),
        this.setValueField(this._spec.valueField),
        (this._funnelOrient = null !== (t = this._spec.funnelOrient) && void 0 !== t ? t : 'top'),
        (this._shape = null !== (e = this._spec.shape) && void 0 !== e ? e : 'trapezoid'),
        this._isHorizontal()
          ? (this._funnelAlign = ['top', 'bottom'].includes(this._spec.funnelAlign) ? this._spec.funnelAlign : 'center')
          : (this._funnelAlign = ['left', 'right'].includes(this._spec.funnelAlign)
              ? this._spec.funnelAlign
              : 'center'),
        this._spec.categoryField && this.setSeriesField(this._spec.categoryField);
    }
    initData() {
      if ((super.initData(), !this._data)) return;
      xQ(this._dataSet, 'funnel', f3), xQ(this._dataSet, 'funnelTransform', v3);
      const t = new yo(this._dataSet);
      t.parse([this.getViewData()], { type: 'dataview' }),
        (t.name = `${UV}_series_${this.id}_viewDataTransform`),
        (this._viewDataTransform = new W1(this._option, t));
    }
    getStatisticFields() {
      const t = [];
      return (
        t.push({ key: this._categoryField, operations: ['values'] }),
        t.push({ key: this._valueField, operations: ['max', 'min'] }),
        t
      );
    }
    _statisticViewData() {
      var t, e, i, n, s, r, a, o, l;
      super._statisticViewData(),
        this._data.getDataView().transform({
          type: 'funnel',
          options: {
            valueField: this.getValueField(),
            isCone: this._spec.isCone,
            asCurrentValue: A3,
            asTransformRatio: m3,
            asReachRatio: y3,
            asHeightRatio: _3,
            asValueRatio: b3,
            asNextValueRatio: S3,
            asLastValueRatio: x3,
            asLastValue: w3,
            asNextValue: k3,
            range: {
              min:
                null !== (e = null === (t = this._spec.range) || void 0 === t ? void 0 : t.min) && void 0 !== e
                  ? e
                  : null ===
                      (n =
                        null === (i = this.getViewDataStatistics().latestData) || void 0 === i
                          ? void 0
                          : i[this.getValueField()]) || void 0 === n
                  ? void 0
                  : n.min,
              max:
                null !== (r = null === (s = this._spec.range) || void 0 === s ? void 0 : s.max) && void 0 !== r
                  ? r
                  : null ===
                      (o =
                        null === (a = this.getViewDataStatistics().latestData) || void 0 === a
                          ? void 0
                          : a[this.getValueField()]) || void 0 === o
                  ? void 0
                  : o.max
            }
          }
        }),
        null === (l = this._viewDataTransform.getDataView()) ||
          void 0 === l ||
          l.transform({ type: 'funnelTransform', options: { asIsTransformLevel: M3 } });
    }
    initMark() {
      var t, e, i, n, s, r, a, o;
      if (
        ((this._funnelMark = this._createMark(
          Object.assign(Object.assign({}, O3.mark.funnel), { name: this._funnelMarkName, type: this._funnelMarkType }),
          {
            themeSpec: null === (t = this._theme) || void 0 === t ? void 0 : t.funnel,
            morph: T1(this._spec.animation, this._spec.morph, A1(this.type, this._spec)),
            defaultMorphElementKey: this._seriesField,
            key: this._seriesField,
            groupKey: this._seriesField,
            isSeriesMark: !0,
            label: D({ animation: this._spec.animation }, this._spec.label)
          }
        )),
        this._spec.isTransform &&
          (this._funnelTransformMark = this._createMark(
            Object.assign(Object.assign({}, O3.mark.transform), {
              name: this._transformMarkName,
              type: this._transformMarkType
            }),
            {
              themeSpec: null === (e = this._theme) || void 0 === e ? void 0 : e.transform,
              key: this._seriesField,
              skipBeforeLayouted: !1,
              dataView: this._viewDataTransform.getDataView(),
              dataProductId: this._viewDataTransform.getProductId(),
              label: D({ animation: this._spec.animation }, this._spec.transformLabel)
            }
          )),
        null === (n = null === (i = this._spec) || void 0 === i ? void 0 : i.outerLabel) || void 0 === n
          ? void 0
          : n.visible)
      ) {
        const { line: t } = null !== (s = this._spec.outerLabel) && void 0 !== s ? s : {},
          { line: e } =
            null !== (a = null === (r = this._theme) || void 0 === r ? void 0 : r.outerLabel) && void 0 !== a ? a : {};
        (this._funnelOuterLabelMark.label = this._createMark(O3.mark.outerLabel, {
          themeSpec: null === (o = this._theme) || void 0 === o ? void 0 : o.outerLabel,
          key: this._seriesField,
          markSpec: this._spec.outerLabel,
          skipBeforeLayouted: !0
        })),
          (this._funnelOuterLabelMark.line = this._createMark(O3.mark.outerLabelLine, {
            themeSpec: e,
            key: this._seriesField,
            markSpec: t,
            depend: [this._funnelOuterLabelMark.label]
          }));
      }
    }
    initTooltip() {
      this._tooltipHelper = new C3(this);
    }
    getDimensionField() {
      return this._seriesField ? [this._seriesField] : [];
    }
    getMeasureField() {
      return [this._valueField];
    }
    getGroupFields() {
      return null;
    }
    initMarkStyle() {
      var t, e;
      const i = this._funnelMark;
      i &&
        (this.setMarkStyle(
          i,
          { points: t => this.getPoints(t), visible: t => h(t[this._valueField]), fill: this.getColorAttribute() },
          'normal',
          Jq.Series
        ),
        this._trigger.registerMark(i),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(i));
      const n = this._funnelTransformMark;
      n &&
        (this.setMarkStyle(n, { points: t => this.getPoints(t) }, 'normal', Jq.Series),
        this._trigger.registerMark(n),
        null === (e = this._tooltipHelper) || void 0 === e || e.activeTriggerSet.mark.add(n));
      const s = this._funnelOuterLabelMark.label;
      s &&
        this.setMarkStyle(
          s,
          {
            text: t => {
              const e = `${t[this.getCategoryField()]}`;
              return o(this._spec.outerLabel.formatMethod) ? this._spec.outerLabel.formatMethod(e, t) : e;
            },
            x: t => this._computeOuterLabelPosition(t).x,
            y: t => this._computeOuterLabelPosition(t).y,
            textAlign: t => this._computeOuterLabelPosition(t).align,
            textBaseline: t => this._computeOuterLabelPosition(t).textBaseline,
            limit: t => this._computeOuterLabelLimit(t)
          },
          'normal',
          Jq.Series
        );
      const r = this._funnelOuterLabelMark.line;
      r &&
        s &&
        this.setMarkStyle(
          r,
          {
            x: t => this._computeOuterLabelLinePosition(t).x1,
            y: t => this._computeOuterLabelLinePosition(t).y1,
            x1: t => this._computeOuterLabelLinePosition(t).x2,
            y1: t => this._computeOuterLabelLinePosition(t).y2
          },
          'normal',
          Jq.Series
        );
    }
    initLabelMarkStyle(t) {
      var e, i;
      if (!t) return;
      const n = t.getTarget(),
        s = t.getComponent();
      n === this._funnelMark
        ? ((this._labelMark = t),
          this.setMarkStyle(
            t,
            {
              text: t => `${t[this.getCategoryField()]} ${t[this.getValueField()]}`,
              x: t => this._computeLabelPosition(t).x,
              y: t => this._computeLabelPosition(t).y,
              maxLineWidth: t => this._computeLabelLimit(t, this._spec.label),
              stroke: this.getColorAttribute()
            },
            'normal',
            Jq.Series
          ),
          (null === (e = this._funnelOuterLabelMark) || void 0 === e ? void 0 : e.label) &&
            this._funnelOuterLabelMark.label.setDepend(s),
          (null === (i = this._funnelOuterLabelMark) || void 0 === i ? void 0 : i.line) &&
            this._funnelOuterLabelMark.line.setDepend(...this._funnelOuterLabelMark.line.getDepend()))
        : this._funnelTransformMark &&
          n === this._funnelTransformMark &&
          ((this._transformLabelMark = t),
          this.setMarkStyle(
            t,
            {
              text: t => `${(100 * iV(y3).bind(this)(t)).toFixed(1)}%`,
              x: t => this._computeLabelPosition(t).x,
              y: t => this._computeLabelPosition(t).y,
              maxLineWidth: t => this._computeLabelLimit(t, this._spec.transformLabel)
            },
            'normal',
            Jq.Series
          ));
    }
    initAnimation() {
      var t, e, i, n, s;
      const r =
        null !==
          (i =
            null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
              ? void 0
              : e.preset) && void 0 !== i
          ? i
          : 'clipIn';
      'clipIn' === r &&
        this._rootMark &&
        this._rootMark.setAnimationConfig(
          w1(
            x1.cartesianGroup(
              {
                direction: () => (this._isHorizontal() ? 'x' : 'y'),
                width: () => this.getLayoutRect().width,
                height: () => this.getLayoutRect().height,
                orient: () => (this._isReverse() ? 'negative' : 'positive')
              },
              r
            ),
            A1(LZ.group, this._spec)
          )
        ),
        [null === (n = this._funnelOuterLabelMark) || void 0 === n ? void 0 : n.label].forEach(t => {
          t && t.setAnimationConfig(w1(x1.label(), A1(t.name, this._spec)));
        }),
        [this._funnelMark, this._funnelTransformMark].forEach(t => {
          t && t.setAnimationConfig(w1(x1.funnel({}, r), A1(t.name, this._spec)));
        }),
        (null === (s = this._funnelOuterLabelMark) || void 0 === s ? void 0 : s.line) &&
          this._funnelOuterLabelMark.line.setAnimationConfig(w1(x1.label(), A1(LZ.outerLabelLine, this._spec)));
    }
    initGroups() {}
    getStackGroupFields() {
      return [];
    }
    getStackValueField() {
      return null;
    }
    setValueFieldToStack() {}
    setValueFieldToPercent() {}
    initEvent() {
      var t;
      super.initEvent(),
        null === (t = this._viewDataTransform.getDataView()) ||
          void 0 === t ||
          t.target.addListener('change', t => {
            this._viewDataTransform.updateData();
          });
    }
    getPoints(t) {
      const e = this.isTransformLevel(t),
        i = this._getMainAxisLength(e) / 2;
      let n, s;
      e
        ? ((n =
            'rect' === this._shape ? this._getSecondaryAxisLength(t[x3]) / 2 : this._getSecondaryAxisLength(t[b3]) / 2),
          (s = this._getSecondaryAxisLength(t[b3]) / 2))
        : ((n = this._getSecondaryAxisLength(t[b3]) / 2),
          (s = 'rect' === this._shape ? n : this._getSecondaryAxisLength(t[S3]) / 2));
      const { x: r, y: a } = this._getPositionByData(t),
        o = this._getPolygonPoints([r, a], n, s, n, s, i);
      return 'center' !== this._funnelAlign && this._adjustPoints(o), o;
    }
    isTransformLevel(t) {
      return !!(null == t ? void 0 : t[M3]);
    }
    _buildMarkAttributeContext() {
      super._buildMarkAttributeContext(),
        (this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this));
    }
    valueToPosition(t) {
      var e, i, n;
      const s =
        null ===
          (n =
            null === (i = null === (e = this.getViewData()) || void 0 === e ? void 0 : e.latestData) || void 0 === i
              ? void 0
              : i.find) || void 0 === n
          ? void 0
          : n.call(i, e => e[this._categoryField] === t);
      return h(s) ? this._getPolygonCenter(this.getPoints(s)) : null;
    }
    dataToPosition(t) {
      return this.valueToPosition(t[this._categoryField]);
    }
    dataToPositionX(t) {
      return this.dataToPosition(t).x;
    }
    dataToPositionY(t) {
      return this.dataToPosition(t).y;
    }
    dataToPositionZ(t) {
      return 0;
    }
    _getMainAxisLength(t = !1) {
      var e;
      const i = this.getViewDataStatistics().latestData[this.getCategoryField()].values.length,
        n = this._isHorizontal() ? this.getLayoutRect().width : this.getLayoutRect().height,
        s = !!this._spec.isTransform,
        r = s ? 0 : null !== (e = this._spec.gap) && void 0 !== e ? e : 0,
        a = s ? Math.max(0, i - 1) : 0,
        o = (n - r * Math.max(0, i - 1)) / (i + 0.5 * a);
      return t ? (s ? 0.5 * o : 0) : o;
    }
    _getSecondaryAxisLength(t) {
      const e = Number.isNaN(t) || !Number.isFinite(t) ? 0 : t,
        i = this._computeMaxSize(),
        n = this._computeMinSize();
      return n + (i - n) * e;
    }
    _getPositionByData(t) {
      var e;
      const i =
        null === (e = this.getViewData().latestData) || void 0 === e
          ? void 0
          : e.findIndex(e => e[this._seriesField] === t[this._seriesField]);
      if (!h(i) || i < 0) return {};
      const n = this.isTransformLevel(t),
        s = this._isHorizontal(),
        r = s ? this.getLayoutRect().height : this.getLayoutRect().width,
        a = s ? this.getLayoutRect().width : this.getLayoutRect().height,
        o = r / 2;
      let l = 0;
      const c = this._getMainAxisLength(),
        d = this._getMainAxisLength(!0);
      return (
        (l += i * (c + d)),
        (l += n ? -d / 2 : c / 2),
        !this._spec.isTransform && this._spec.gap && (l += this._spec.gap * i),
        this._isReverse() && (l = a - l),
        this._isHorizontal() ? { x: l, y: o } : { x: o, y: l }
      );
    }
    _getPolygonPoints(t, e, i, n, s, r) {
      const a = t[0],
        o = t[1];
      switch (this._funnelOrient) {
        case 'left':
          return [
            { x: a - r, y: o + e },
            { x: a - r, y: o - n },
            { x: a + r, y: o - s },
            { x: a + r, y: o + i }
          ];
        case 'right':
          return [
            { x: a + r, y: o - n },
            { x: a + r, y: o + n },
            { x: a - r, y: o + i },
            { x: a - r, y: o - i }
          ];
        case 'bottom':
          return [
            { x: a + e, y: o + r },
            { x: a - n, y: o + r },
            { x: a - s, y: o - r },
            { x: a + i, y: o - r }
          ];
        default:
          return [
            { x: a - e, y: o - r },
            { x: a + n, y: o - r },
            { x: a + s, y: o + r },
            { x: a - i, y: o + r }
          ];
      }
    }
    _getPolygonCenter(t) {
      if (this._isHorizontal()) {
        const e = (t[0].x + t[3].x) / 2,
          i = (t[0].y + t[3].y) / 2;
        return { x: (e + (t[1].x + t[2].x) / 2) / 2, y: (i + (t[1].y + t[2].y) / 2) / 2 };
      }
      const e = (t[0].x + t[3].x) / 2,
        i = (t[0].y + t[3].y) / 2;
      return { x: (e + (t[1].x + t[2].x) / 2) / 2, y: (i + (t[1].y + t[2].y) / 2) / 2 };
    }
    _adjustPoints(t) {
      let e, i, n;
      return (
        this._isHorizontal()
          ? ((n = 'y'),
            'left' === this._funnelOrient
              ? ((e = 'bottom' === this._funnelAlign ? -t[1].y : t[1].y),
                (i = 'bottom' === this._funnelAlign ? -t[2].y : t[2].y))
              : ((e = 'bottom' === this._funnelAlign ? -t[0].y : t[0].y),
                (i = 'bottom' === this._funnelAlign ? -t[3].y : t[3].y)))
          : ((n = 'x'),
            'top' === this._funnelOrient
              ? ((e = 'left' === this._funnelAlign ? t[0].x : -t[0].x),
                (i = 'left' === this._funnelAlign ? t[3].x : -t[3].x))
              : ((e = 'left' === this._funnelAlign ? t[1].x : -t[1].x),
                (i = 'left' === this._funnelAlign ? t[2].x : -t[2].x))),
        (t[0][n] -= e),
        (t[1][n] -= e),
        (t[2][n] -= i),
        (t[3][n] -= i),
        t
      );
    }
    _computeLabelPosition(t) {
      const e = this.getPoints(t);
      return this._getPolygonCenter(e);
    }
    _computeLabelLimit(t, e) {
      const i = null == e ? void 0 : e.limit;
      if (y(i)) return i;
      const n = this.getPoints(t);
      return 'shapeSize' === i
        ? this._isHorizontal()
          ? Math.abs(n[3].x - n[0].x)
          : (Math.abs(n[0].x - n[1].x) + Math.abs(n[2].x - n[3].x)) / 2
        : this._isHorizontal()
        ? Math.abs(n[3].x - n[0].x)
        : void 0;
    }
    _computeOuterLabelPosition(t) {
      var e, i;
      let n,
        s,
        r = null === (e = this._spec.outerLabel) || void 0 === e ? void 0 : e.position,
        a = 'center',
        o = 'middle';
      if (
        ((r = this._isHorizontal()
          ? ['top', 'bottom'].includes(r)
            ? r
            : 'bottom' === this._funnelAlign
            ? 'top'
            : 'bottom'
          : ['left', 'right'].includes(r)
          ? r
          : 'left' === this._funnelAlign
          ? 'right'
          : 'left'),
        !1 !== (null === (i = this._spec.outerLabel) || void 0 === i ? void 0 : i.alignLabel))
      )
        ({ x: n, y: s } = this._getPositionByData(t)),
          'left' === r
            ? ((n = 0), (a = 'left'))
            : 'right' === r
            ? ((n = this.getLayoutRect().width), (a = 'right'))
            : 'top' === r
            ? ((s = 0), (o = 'top'))
            : 'bottom' === r && ((s = this.getLayoutRect().height), (o = 'bottom'));
      else {
        const { x2: e, y2: i } = this._computeOuterLabelLinePosition(t);
        (n = e),
          (s = i),
          'left' === r
            ? ((n -= 5), (a = 'right'))
            : 'right' === r
            ? ((n += 5), (a = 'left'))
            : 'top' === r
            ? ((s -= 5), (o = 'bottom'))
            : 'bottom' === r && ((s += 5), (o = 'top'));
      }
      return { x: n, y: s, align: a, textBaseline: o };
    }
    _computeOuterLabelLimit(t) {
      var e, i, n, s, r;
      if (this._isHorizontal()) return this._getMainAxisLength(this.isTransformLevel(t));
      const a = this.getPoints(t),
        o = (Math.abs(a[0].x - a[1].x) + Math.abs(a[2].x - a[3].x)) / 2,
        l = this.getCategoryField(),
        h =
          null ===
            (n =
              null === (i = null === (e = this._labelMark) || void 0 === e ? void 0 : e.getComponent()) || void 0 === i
                ? void 0
                : i
                    .getProduct()
                    .getGroupGraphicItem()
                    .find(({ attribute: e, type: i }) => {
                      var n;
                      return 'text' === i && (null === (n = e.data) || void 0 === n ? void 0 : n[l]) === t[l];
                    }, !0)) || void 0 === n
            ? void 0
            : n.AABBBounds,
        c = h ? h.x2 - h.x1 : 0;
      return (
        this.getLayoutRect().width / 2 -
        Math.max(o / 2, c / 2) -
        T3 -
        2 *
          (null !== (r = null === (s = this._spec.outerLabel) || void 0 === s ? void 0 : s.spaceWidth) && void 0 !== r
            ? r
            : 5)
      );
    }
    _computeOuterLabelLinePosition(t) {
      var e, i, n, s, r, a, o, l, h, c, d, u, p, g, f, v;
      const m = this.getCategoryField(),
        y =
          null ===
            (r =
              null ===
                (s =
                  null ===
                    (n =
                      null === (i = null === (e = this._funnelOuterLabelMark) || void 0 === e ? void 0 : e.label) ||
                      void 0 === i
                        ? void 0
                        : i.getProduct()) || void 0 === n
                    ? void 0
                    : n.elements) || void 0 === s
                ? void 0
                : s.find(e => {
                    var i;
                    return (null === (i = e.data[0]) || void 0 === i ? void 0 : i[m]) === t[m];
                  })) || void 0 === r
            ? void 0
            : r.getBounds(),
        _ =
          null ===
            (l =
              null === (o = null === (a = this._labelMark) || void 0 === a ? void 0 : a.getComponent()) || void 0 === o
                ? void 0
                : o
                    .getProduct()
                    .getGroupGraphicItem()
                    .find(({ attribute: e, type: i }) => {
                      var n;
                      return 'text' === i && (null === (n = e.data) || void 0 === n ? void 0 : n[m]) === t[m];
                    }, !0)) || void 0 === l
            ? void 0
            : l.AABBBounds;
      let b, x, S, w;
      if (this._isHorizontal()) {
        const e =
            null !== (c = null === (h = this._spec.outerLabel) || void 0 === h ? void 0 : h.spaceWidth) && void 0 !== c
              ? c
              : 5,
          i = this.getPoints(t),
          n = (Math.abs(i[0].y - i[1].y) + Math.abs(i[2].y - i[3].y)) / 2;
        return (
          'top' === this._spec.outerLabel.position || 'bottom' === this._funnelAlign
            ? ((S = this._getPolygonCenter(i).y - n / 2 - e),
              (w =
                !1 !== (null === (d = this._spec.outerLabel) || void 0 === d ? void 0 : d.alignLabel)
                  ? (null == y ? void 0 : y.y2) + e
                  : S - e),
              (b = this._getPolygonCenter(i).x),
              S - w < T3 && (w = S - T3),
              (x = b))
            : ((S = this._getPolygonCenter(i).y + n / 2 + e),
              (w =
                !1 !== (null === (u = this._spec.outerLabel) || void 0 === u ? void 0 : u.alignLabel)
                  ? (null == y ? void 0 : y.y1) - e
                  : S + e),
              (b = this._getPolygonCenter(i).x),
              w - S < T3 && (w = S + T3),
              (x = b)),
          { x1: b, x2: x, y1: S, y2: w }
        );
      }
      const A = this.getPoints(t),
        k = (Math.abs(A[0].x - A[1].x) + Math.abs(A[2].x - A[3].x)) / 2,
        M = (null == _ ? void 0 : _.x2) - (null == _ ? void 0 : _.x1) || 0,
        T =
          null !== (g = null === (p = this._spec.outerLabel) || void 0 === p ? void 0 : p.spaceWidth) && void 0 !== g
            ? g
            : 5;
      return (
        'right' === this._spec.outerLabel.position || 'left' === this._funnelAlign
          ? ((b = this._getPolygonCenter(A).x + Math.max(M / 2, k / 2) + T),
            (x =
              !1 !== (null === (f = this._spec.outerLabel) || void 0 === f ? void 0 : f.alignLabel)
                ? (null == y ? void 0 : y.x1) - T
                : b + T),
            (S = this._getPolygonCenter(A).y),
            x - b < T3 && (x = b + T3),
            (w = S))
          : ((b = this._getPolygonCenter(A).x - Math.max(M / 2, k / 2) - T),
            (x =
              !1 !== (null === (v = this._spec.outerLabel) || void 0 === v ? void 0 : v.alignLabel)
                ? (null == y ? void 0 : y.x2) + T
                : b - T),
            (S = this._getPolygonCenter(A).y),
            b - x < T3 && (x = b - T3),
            (w = S)),
        { x1: b, x2: x, y1: S, y2: w }
      );
    }
    _computeMaxSize() {
      var t;
      const e = this._isHorizontal() ? this.getLayoutRect().height : this.getLayoutRect().width;
      return mV(null !== (t = this._spec.maxSize) && void 0 !== t ? t : '80%', e);
    }
    _computeMinSize() {
      var t;
      const e = this._isHorizontal() ? this.getLayoutRect().height : this.getLayoutRect().width;
      return mV(null !== (t = this._spec.minSize) && void 0 !== t ? t : 0, e);
    }
    _isHorizontal() {
      return 'left' === this._funnelOrient || 'right' === this._funnelOrient;
    }
    _isReverse() {
      return 'bottom' === this._funnelOrient || 'right' === this._funnelOrient;
    }
    setValueFieldToStackOffsetSilhouette() {}
    getDefaultShapeType() {
      return 'square';
    }
    updateSpec(t) {
      const e = this._originalSpec,
        i = mn(e, ['data']),
        n = super.updateSpec(t);
      return z(i, mn(e, ['data'])) || ((n.reCompile = !0), (n.reMake = !0), (n.reRender = !0), (n.change = !0)), n;
    }
  }
  (O3.type = DZ.funnel), (O3.mark = eJ), NQ.useSeries([O3]);
  class B3 extends g3 {
    constructor() {
      super(...arguments), (this.type = d2.funnel), (this.seriesType = DZ.funnel);
    }
  }
  (B3.type = d2.funnel), (B3.view = 'singleDefault');
  class I3 extends E3 {
    constructor() {
      super(...arguments), (this.type = I3.type);
    }
  }
  (I3.type = jZ.pyramid3d), NQ.useMark([I3, i2, R3]);
  class D3 extends O3 {
    constructor() {
      super(...arguments),
        (this.type = DZ.funnel3d),
        (this._funnelMarkName = LZ.funnel3d),
        (this._funnelMarkType = jZ.pyramid3d),
        (this._transformMarkName = LZ.transform3d),
        (this._transformMarkType = jZ.pyramid3d);
    }
    initMark() {
      var t, e, i, n, s, r, a, o;
      if (
        ((this._funnelMark = this._createMark(
          Object.assign(Object.assign({}, D3.mark.funnel3d), {
            name: this._funnelMarkName,
            type: this._funnelMarkType
          }),
          {
            themeSpec: null === (t = this._theme) || void 0 === t ? void 0 : t.funnel3d,
            key: this._seriesField,
            isSeriesMark: !0,
            label: this._spec.label,
            support3d: !0
          }
        )),
        this._spec.isTransform &&
          (this._funnelTransformMark = this._createMark(
            Object.assign(Object.assign({}, D3.mark.transform3d), {
              name: this._transformMarkName,
              type: this._transformMarkType
            }),
            {
              themeSpec: null === (e = this._theme) || void 0 === e ? void 0 : e.transform3d,
              key: this._seriesField,
              skipBeforeLayouted: !1,
              dataView: this._viewDataTransform.getDataView(),
              dataProductId: this._viewDataTransform.getProductId()
            }
          )),
        null === (n = null === (i = this._spec) || void 0 === i ? void 0 : i.outerLabel) || void 0 === n
          ? void 0
          : n.visible)
      ) {
        const { line: t } = null !== (s = this._spec.outerLabel) && void 0 !== s ? s : {},
          { line: e } =
            null !== (a = null === (r = this._theme) || void 0 === r ? void 0 : r.outerLabel) && void 0 !== a ? a : {};
        (this._funnelOuterLabelMark.label = this._createMark(D3.mark.outerLabel, {
          themeSpec: null === (o = this._theme) || void 0 === o ? void 0 : o.outerLabel,
          key: this._seriesField,
          markSpec: this._spec.outerLabel
        })),
          (this._funnelOuterLabelMark.line = this._createMark(D3.mark.outerLabelLine, {
            themeSpec: e,
            key: this._seriesField,
            markSpec: t,
            depend: [this._funnelOuterLabelMark.label]
          }));
      }
    }
    initMarkStyle() {
      super.initMarkStyle();
      const t = this._funnelMark;
      t &&
        this.setMarkStyle(
          t,
          {
            z: t => {
              if (this._isHorizontal()) return 0;
              const e = this.getPoints(t),
                i = Math.max(Math.abs(e[0].x - e[1].x), Math.abs(e[2].x - e[3].x));
              return (this._computeMaxSize() - i) / 2;
            }
          },
          'normal',
          Jq.Series
        );
    }
    initLabelMarkStyle(t) {
      var e, i;
      super.initLabelMarkStyle(t),
        this.setMarkStyle(
          t,
          {
            z: t => {
              if (this._isHorizontal()) return 0;
              const e = this.getPoints(t),
                i = Math.max(Math.abs(e[0].x - e[1].x), Math.abs(e[2].x - e[3].x));
              return (this._computeMaxSize() - i) / 2;
            }
          },
          'normal',
          Jq.Series
        ),
        (this._labelMark = t),
        (null === (e = this._funnelOuterLabelMark) || void 0 === e ? void 0 : e.label) &&
          this._funnelOuterLabelMark.label.setDepend(t.getComponent()),
        (null === (i = this._funnelOuterLabelMark) || void 0 === i ? void 0 : i.line) &&
          this._funnelOuterLabelMark.line.setDepend(...this._funnelOuterLabelMark.line.getDepend());
    }
  }
  (D3.type = DZ.funnel3d), (D3.mark = iJ), NQ.useSeries([D3]);
  class L3 extends g3 {
    constructor() {
      super(...arguments), (this.type = d2.funnel3d), (this.seriesType = DZ.funnel3d);
    }
  }
  (L3.type = d2.funnel3d), (L3.view = 'singleDefault');
  class F3 extends q1 {
    constructor() {
      super(...arguments),
        (this.coordinate = 'polar'),
        (this._outerRadius = fW),
        (this._innerRadius = 0),
        (this._angleField = []),
        (this._radiusField = []),
        (this._sortDataByAxis = !1);
    }
    get outerRadius() {
      return this._outerRadius;
    }
    get innerRadius() {
      return this._innerRadius;
    }
    getAngleField() {
      return this._angleField;
    }
    setAngleField(t) {
      return (this._angleField = h(t) ? V(t) : []), this._angleField;
    }
    getRadiusField() {
      return this._radiusField;
    }
    setRadiusField(t) {
      return (this._radiusField = h(t) ? V(t) : []), this._radiusField;
    }
    get innerRadiusField() {
      return this._innerRadiusField;
    }
    setInnerRadiusField(t) {
      return (this._innerRadiusField = V(t)), this._innerRadiusField;
    }
    get radiusScale() {
      return this._radiusScale;
    }
    setRadiusScale(t) {
      return (this._radiusScale = t), t;
    }
    get angleScale() {
      return this._angleScale;
    }
    setAngleScale(t) {
      return (this._angleScale = t), t;
    }
    get angleAxisHelper() {
      return this._angleAxisHelper;
    }
    set angleAxisHelper(t) {
      (this._angleAxisHelper = t), this.onAngleAxisHelperUpdate();
    }
    get radiusAxisHelper() {
      return this._radiusAxisHelper;
    }
    set radiusAxisHelper(t) {
      (this._radiusAxisHelper = t), this.onRadiusAxisHelperUpdate();
    }
    get sortDataByAxis() {
      return this._sortDataByAxis;
    }
    _buildMarkAttributeContext() {
      super._buildMarkAttributeContext(),
        (this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this)),
        (this._markAttributeContext.getCenter = () => this.angleAxisHelper.center());
    }
    valueToPosition(t, e) {
      if (l(t) || l(e) || !this.angleAxisHelper || !this.radiusAxisHelper) return { x: Number.NaN, y: Number.NaN };
      const i = this.angleAxisHelper.dataToPosition(V(t)),
        n = this.radiusAxisHelper.dataToPosition(V(e));
      return this.angleAxisHelper.coordToPoint({ angle: i, radius: n });
    }
    dataToPosition(t) {
      return t && this.angleAxisHelper && this.radiusAxisHelper
        ? this.valueToPosition(
            this.getDatumPositionValues(t, this._angleField),
            this.getDatumPositionValues(t, this._radiusField)
          )
        : { x: Number.NaN, y: Number.NaN };
    }
    dataToPositionX(t) {
      return this.dataToPosition(t).x;
    }
    dataToPositionY(t) {
      return this.dataToPosition(t).y;
    }
    dataToPositionZ(t) {
      return 0;
    }
    positionToData(t) {}
    radiusToData(t) {}
    angleToData(t) {}
    getStatisticFields() {
      var t, e;
      const i = [];
      return (
        (null === (t = this.radiusAxisHelper) || void 0 === t ? void 0 : t.getScale) &&
          this._radiusField.forEach(t => {
            const e = { key: t, operations: [] };
            Zo(this.radiusAxisHelper.getScale(0).type) ? (e.operations = ['max', 'min']) : (e.operations = ['values']),
              i.push(e);
          }),
        (null === (e = this.angleAxisHelper) || void 0 === e ? void 0 : e.getScale) &&
          this._angleField.forEach(t => {
            const e = { key: t, operations: [] };
            Zo(this.angleAxisHelper.getScale(0).type) ? (e.operations = ['max', 'min']) : (e.operations = ['values']),
              i.push(e);
          }),
        i
      );
    }
    _getDefaultSpecFromChart(t) {
      const { outerRadius: e, innerRadius: i } = t;
      return { outerRadius: e, innerRadius: i };
    }
    setAttrFromSpec() {
      super.setAttrFromSpec(),
        h(this._spec.outerRadius) && (this._outerRadius = this._spec.outerRadius),
        h(this._spec.radius) && (this._outerRadius = this._spec.radius),
        h(this._spec.innerRadius) && (this._innerRadius = this._spec.innerRadius),
        h(this._spec.sortDataByAxis) && (this._sortDataByAxis = !0 === this._spec.sortDataByAxis);
    }
    updateSpec(t) {
      const e = this._originalSpec,
        { angleField: i, radiusField: n } = e,
        s = super.updateSpec(t);
      return (bo(t.angleField, i) && bo(t.radiusField, n)) || ((s.change = !0), (s.reRender = !0), (s.reMake = !0)), s;
    }
    onRadiusAxisHelperUpdate() {
      this.onMarkPositionUpdate();
    }
    onAngleAxisHelperUpdate() {
      this.onMarkPositionUpdate();
    }
    afterInitMark() {
      super.afterInitMark(), this._trigger.setStateKeys([...this._angleField, ...this._radiusField]);
    }
    _computeLayoutRadius() {
      const { width: t, height: e } = this._region.getLayoutRect();
      return Math.min(t / 2, e / 2);
    }
    setValueFieldToStackOffsetSilhouette() {}
    fillData() {
      super.fillData(), this.sortDataByAxis && this._sortDataInAxisDomain();
    }
    _sortDataInAxisDomain() {
      var t, e;
      (null === (e = null === (t = this.getViewData()) || void 0 === t ? void 0 : t.latestData) || void 0 === e
        ? void 0
        : e.length) && Z1(this.angleAxisHelper, this._angleField[0], this.getViewData().latestData);
    }
  }
  class j3 extends F3 {
    constructor() {
      super(...arguments), (this._stack = !0);
    }
    setAttrFromSpec() {
      var t, e, i;
      super.setAttrFromSpec();
      const n = null === (t = this._option.globalInstance.getChart()) || void 0 === t ? void 0 : t.getSpec(),
        s = null !== (e = this._spec.startAngle) && void 0 !== e ? e : null == n ? void 0 : n.startAngle;
      this._startAngle = h(s) ? qt(s) : dW;
      const r = null !== (i = this._spec.endAngle) && void 0 !== i ? i : null == n ? void 0 : n.endAngle;
      (this._endAngle = h(r) ? qt(r) : uW),
        this.setAngleField(this._spec.valueField || this._spec.angleField),
        this.setRadiusField(this._spec.categoryField || this._spec.radiusField);
    }
    getStackGroupFields() {
      return this._radiusField;
    }
    getStackValueField() {
      var t;
      return null === (t = this._angleField) || void 0 === t ? void 0 : t[0];
    }
    setValueFieldToStack() {}
    setValueFieldToPercent() {}
    setValueFieldToStackOffsetSilhouette() {}
    getGroupFields() {
      return this._angleField;
    }
    _convertMarkStyle(t) {
      const e = super._convertMarkStyle(t),
        i = 'fill';
      if (e[i]) {
        const n = t[i];
        'conical' !== (null == n ? void 0 : n.gradient) ||
          h(null == n ? void 0 : n.startAngle) ||
          h(null == n ? void 0 : n.endAngle) ||
          (e[i] = Object.assign(Object.assign({}, n), { startAngle: this._startAngle, endAngle: this._endAngle }));
      }
      return e;
    }
    _getAngleValueStart(t) {
      if (this._stack) {
        const e = uV(this.angleAxisHelper.dataToPosition([t[Qq]]), this.angleAxisHelper.getScale(0));
        if (_(e)) return e;
      }
      return this._startAngle;
    }
    _getAngleValueEnd(t) {
      if (this._stack) {
        const e = uV(this.angleAxisHelper.dataToPosition([t[tZ]]), this.angleAxisHelper.getScale(0));
        if (_(e)) return e;
      }
      return this.angleAxisHelper.dataToPosition([t[this._angleField[0]]]);
    }
    getDimensionField() {
      return this._radiusField;
    }
    getMeasureField() {
      return this._angleField;
    }
  }
  class z3 extends g0 {
    constructor() {
      super(...arguments), (this.type = z3.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), { lineWidth: 0, path: '' });
    }
  }
  (z3.type = jZ.path), NQ.useMark([z3, p2]);
  class H3 extends j3 {
    constructor() {
      super(...arguments),
        (this.type = DZ.gaugePointer),
        (this._pinMark = null),
        (this._pointerMark = null),
        (this._pinBackgroundMark = null);
    }
    setAttrFromSpec() {
      var t;
      super.setAttrFromSpec(),
        this.setRadiusField(this._spec.radiusField),
        (this._pointerType =
          'rect' === (null === (t = this._spec.pointer) || void 0 === t ? void 0 : t.type) ? jZ.rect : jZ.path);
    }
    initMark() {
      (this._pinBackgroundMark = this._createMark(H3.mark.pinBackground)),
        (this._pointerMark = this._createMark(
          Object.assign(Object.assign({}, H3.mark.pointer), { type: this._pointerType }),
          { isSeriesMark: !0 }
        )),
        (this._pinMark = this._createMark(H3.mark.pin));
    }
    initMarkStyle() {
      this.initPinBackgroundMarkStyle(), this.initPointerMarkStyle(), this.initPinMarkStyle();
    }
    initGroups() {}
    initPointerMarkStyle() {
      var t;
      const e = this._pointerMark,
        i = this._spec.pointer;
      e &&
        (this.setMarkStyle(e, {
          x: () => {
            var t, e;
            const { x: n } = this.angleAxisHelper.center();
            return (
              n -
              this._getPointerWidth() *
                (null !== (e = null === (t = null == i ? void 0 : i.center) || void 0 === t ? void 0 : t[0]) &&
                void 0 !== e
                  ? e
                  : 0)
            );
          },
          y: t => {
            var e, n;
            const { y: s } = this.angleAxisHelper.center();
            return (
              s -
              this._getPointerHeight(t) *
                (null !== (n = null === (e = null == i ? void 0 : i.center) || void 0 === e ? void 0 : e[1]) &&
                void 0 !== n
                  ? n
                  : 0)
            );
          },
          anchor: () => {
            const { x: t, y: e } = this.angleAxisHelper.center();
            return [t, e];
          },
          fill: this.getColorAttribute(),
          zIndex: 200
        }),
        this._pointerType === jZ.path
          ? this.setMarkStyle(e, {
              scaleX: this._getPointerWidth.bind(this),
              scaleY: this._getPointerHeight.bind(this),
              angle: t => this._getPointerAngle(t) + Math.PI / 2
            })
          : this.setMarkStyle(e, {
              width: this._getPointerWidth.bind(this),
              height: this._getPointerHeight.bind(this),
              angle: t => this._getPointerAngle(t) - Math.PI / 2
            }),
        this._trigger.registerMark(e),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(e));
    }
    _getPointerWidth() {
      return this._spec.pointer.width * this._computeLayoutRadius();
    }
    _getPointerHeight(t) {
      var e, i;
      const n = this._spec.pointer,
        s = this._radiusField[0];
      return h(this.radiusAxisHelper) && h(s)
        ? this.radiusAxisHelper.dataToPosition([t[s]]) -
            (null !== (e = null == n ? void 0 : n.innerPadding) && void 0 !== e ? e : 0) -
            (null !== (i = null == n ? void 0 : n.outerPadding) && void 0 !== i ? i : 10)
        : n.height * this._computeLayoutRadius();
    }
    _getPointerAngle(t) {
      return this.angleAxisHelper.dataToPosition([t[this._angleField[0]]]);
    }
    _getRotatedPointerCenterOffset(t) {
      var e, i, n, s;
      const r = this._spec.pointer,
        a =
          this._getPointerWidth() *
          (null !== (i = null === (e = null == r ? void 0 : r.center) || void 0 === e ? void 0 : e[0]) && void 0 !== i
            ? i
            : 0),
        o =
          -this._getPointerHeight(t) *
          (null !== (s = null === (n = null == r ? void 0 : r.center) || void 0 === n ? void 0 : n[1]) && void 0 !== s
            ? s
            : 0),
        l = this._getPointerAngle(t) - Math.PI / 2,
        h = Math.cos(l),
        c = Math.sin(l);
      return { x: a * h + o * c, y: -(o * h - a * c) };
    }
    initPinBackgroundMarkStyle() {
      const t = this._pinBackgroundMark,
        e = this._spec.pinBackground;
      t &&
        this.setMarkStyle(t, {
          x: () => this.angleAxisHelper.center().x,
          y: () => this.angleAxisHelper.center().y,
          scaleX: () => e.width * this._computeLayoutRadius(),
          scaleY: () => e.height * this._computeLayoutRadius(),
          fill: this.getColorAttribute(),
          zIndex: 100
        });
    }
    initPinMarkStyle() {
      const t = this._pinMark,
        e = this._spec.pin;
      t &&
        this.setMarkStyle(t, {
          x: () => this.angleAxisHelper.center().x,
          y: () => this.angleAxisHelper.center().y,
          scaleX: () => e.width * this._computeLayoutRadius(),
          scaleY: () => e.height * this._computeLayoutRadius(),
          fill: this.getColorAttribute(),
          zIndex: 300
        });
    }
    initAnimation() {
      var t, e;
      const i =
        null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
          ? void 0
          : e.preset;
      this._pointerMark.setAnimationConfig(
        w1(x1.circularProgress({ startAngle: this._startAngle }, i), A1(LZ.pointer, this._spec))
      );
    }
    getDefaultShapeType() {
      return 'circle';
    }
  }
  (H3.type = DZ.gaugePointer), (H3.mark = hJ);
  class N3 extends h3 {
    constructor() {
      super(...arguments), (this._cacheStateStyle = {});
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), { innerPadding: 0, outerPadding: 0 });
    }
    _filterStyle(t, e, i, n = this.stateStyle) {
      var s, r, a, l, c, d;
      h(t.innerRadius) &&
        this.setAttribute('innerRadius', this._styleConvert(t.innerRadius), e, i, this._cacheStateStyle),
        h(t.outerRadius) &&
          this.setAttribute('outerRadius', this._styleConvert(t.outerRadius), e, i, this._cacheStateStyle);
      const u = null !== (s = t.innerPadding) && void 0 !== s ? s : n[e].innerPadding.style,
        p = null !== (r = t.outerPadding) && void 0 !== r ? r : n[e].outerPadding.style,
        g =
          null !==
            (l = null !== (a = t.innerRadius) && void 0 !== a ? a : this._cacheStateStyle[e].innerRadius.style) &&
          void 0 !== l
            ? l
            : n[e].innerRadius.style,
        f =
          null !==
            (d = null !== (c = t.outerRadius) && void 0 !== c ? c : this._cacheStateStyle[e].outerRadius.style) &&
          void 0 !== d
            ? d
            : n[e].outerRadius.style;
      if (0 === g && 0 === f) return t;
      const v = (h(t.innerPadding) && h(g)) || (h(t.outerPadding) && h(f)),
        m = (h(t.innerRadius) && u) || (h(t.outerRadius) && p);
      if (v || m) {
        const e = Object.assign({}, t);
        return (
          u &&
            h(g) &&
            (o(g)
              ? (e.innerRadius = (t, e, i, n) => g(t, e, i, n) + (o(u) ? u(t, e, i, n) : u))
              : o(u)
              ? (e.innerRadius = (t, e, i, n) => {
                  const s = u(t, e, i, n);
                  return g + s;
                })
              : (e.innerRadius = g + u)),
          p &&
            h(f) &&
            (o(f)
              ? (e.outerRadius = (t, e, i, n) => f(t, e, i, n) - (o(p) ? p(t, e, i, n) : p))
              : o(p)
              ? (e.outerRadius = (t, e, i, n) => {
                  const s = p(t, e, i, n);
                  return f - s;
                })
              : (e.outerRadius = f - p)),
          e
        );
      }
      return t;
    }
  }
  (N3.type = jZ.arc), (N3.constructorType = jZ.progressArc), NQ.useMark([N3]);
  class V3 extends j3 {
    constructor() {
      super(...arguments),
        (this.type = DZ.gauge),
        (this._segmentMark = null),
        (this._trackMark = null),
        (this._stack = !1),
        (this._padAngle = 0);
    }
    setAttrFromSpec() {
      var t;
      super.setAttrFromSpec(), (this._padAngle = qt(null !== (t = this._spec.padAngle) && void 0 !== t ? t : 0));
    }
    initData() {
      var t;
      super.initData();
      xQ(this._option.dataSet, 'spiltSegment', (t, e) => {
        const i = [...t];
        return (
          i.sort((t, e) => t[this._angleField[0]] - e[this._angleField[0]]),
          i.forEach((t, e) => {
            (t[hZ] = t[this._angleField[0]]), (t[lZ] = e > 0 ? i[e - 1][hZ] : void 0);
          }),
          i
        );
      }),
        null === (t = this.getViewDataFilter()) || void 0 === t || t.transform({ type: 'spiltSegment' }, !1);
    }
    initMark() {
      (this._trackMark = this._createMark(V3.mark.track)),
        (this._segmentMark = this._createMark(V3.mark.segment, { isSeriesMark: !0 }));
    }
    initMarkStyle() {
      this.initTrackMarkStyle(), this.initSegmentMarkStyle();
    }
    initSegmentMarkStyle() {
      var t, e;
      const i = this._segmentMark;
      i &&
        (this.setMarkStyle(i, {
          x: () => this.angleAxisHelper.center().x,
          y: () => this.angleAxisHelper.center().y,
          startAngle: this._getAngleValueStart.bind(this),
          endAngle: this._getAngleValueEnd.bind(this),
          innerRadius: () => {
            var t;
            return this._computeLayoutRadius() * (null !== (t = this._spec.innerRadius) && void 0 !== t ? t : 0);
          },
          outerRadius: () => {
            var t, e;
            return (
              this._computeLayoutRadius() *
              (null !== (e = null !== (t = this._spec.radius) && void 0 !== t ? t : this._spec.outerRadius) &&
              void 0 !== e
                ? e
                : 1)
            );
          },
          cap: null !== (t = this._spec.roundCap) && void 0 !== t && t,
          boundsMode: 'imprecise',
          cornerRadius: this._spec.cornerRadius,
          fill: this.getColorAttribute(),
          zIndex: 200,
          forceShowCap: !0
        }),
        this._trigger.registerMark(i),
        null === (e = this._tooltipHelper) || void 0 === e || e.activeTriggerSet.mark.add(i));
    }
    initTrackMarkStyle() {
      const t = this._trackMark;
      t &&
        (this.setMarkStyle(t, {
          x: () => this.angleAxisHelper.center().x,
          y: () => this.angleAxisHelper.center().y,
          startAngle: this._startAngle,
          endAngle: this._endAngle,
          cornerRadius: this._spec.cornerRadius,
          zIndex: 100
        }),
        this._trigger.registerMark(t));
    }
    _getAngleValueStart(t) {
      var e;
      return (
        (h(t[lZ]) ? this.angleAxisHelper.dataToPosition([t[lZ]]) : this._startAngle) +
        (null !== (e = this._spec.padAngle) && void 0 !== e ? e : 0) / 2
      );
    }
    _getAngleValueEnd(t) {
      var e;
      return (
        this.angleAxisHelper.dataToPosition([t[hZ]]) - (null !== (e = this._spec.padAngle) && void 0 !== e ? e : 0) / 2
      );
    }
    initAnimation() {
      var t, e;
      const i =
        null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
          ? void 0
          : e.preset;
      this._segmentMark.setAnimationConfig(
        w1(x1.circularProgress({ startAngle: this._startAngle }, i), A1(LZ.segment, this._spec))
      );
    }
    getDefaultShapeType() {
      return 'circle';
    }
  }
  (V3.type = DZ.gauge), (V3.mark = lJ);
  const W3 = {
    left: { textAlign: 'center', textBaseline: 'bottom' },
    right: { textAlign: 'center', textBaseline: 'bottom' },
    radius: {},
    angle: {}
  };
  function G3(t) {
    let e = 0;
    return C(t, 'tick.visible') && (e += C(t, 'tick.tickSize')), C(t, 'label.visible') && (e += C(t, 'label.space')), e;
  }
  function U3(t, e) {
    var i, n, s, r, a, o;
    return {
      min:
        null !==
          (s = null !== (i = t.min) && void 0 !== i ? i : null === (n = t.range) || void 0 === n ? void 0 : n.min) &&
        void 0 !== s
          ? s
          : null == e
          ? void 0
          : e.min,
      max:
        null !==
          (o = null !== (r = t.max) && void 0 !== r ? r : null === (a = t.range) || void 0 === a ? void 0 : a.max) &&
        void 0 !== o
          ? o
          : null == e
          ? void 0
          : e.max
    };
  }
  function Y3(t) {
    const e = null == t ? void 0 : t.orient;
    return 'top' === e || 'bottom' === e || 'left' === e || 'right' === e || 'z' === e;
  }
  function $3(t) {
    const e = null == t ? void 0 : t.orient;
    return 'angle' === e || 'radius' === e;
  }
  const X3 = (t, e, i) => {
      var n, s;
      const {
        axisBand: r,
        axisLinear: a,
        axisX: o,
        axisY: l,
        axis: h
      } = null !== (n = i.component) && void 0 !== n ? n : {};
      return _J(
        {},
        h,
        null !== (s = 'band' === e ? r : ['linear', 'log', 'symlog'].includes(e) ? a : {}) && void 0 !== s ? s : {},
        tQ(t) ? o : l
      );
    },
    K3 = (t, e, i) => {
      var n, s;
      const {
        axisBand: r,
        axisLinear: a,
        axisAngle: o,
        axisRadius: l,
        axis: h
      } = null !== (n = i.component) && void 0 !== n ? n : {};
      return _J(
        {},
        h,
        null !== (s = 'band' === e ? r : 'linear' === e ? a : {}) && void 0 !== s ? s : {},
        'angle' === t ? o : l
      );
    };
  class q3 extends h2 {
    isValidSeries(t) {
      return !this.seriesType || t === this.seriesType;
    }
    _getDefaultSeriesSpec(t) {
      const e = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
          radius: t.radius,
          outerRadius: t.outerRadius,
          innerRadius: t.innerRadius,
          startAngle: t.startAngle,
          endAngle: t.endAngle
        }),
        i = this.seriesType;
      return i && ((e.type = i), (e[i] = t[i])), e;
    }
    getIndicatorSpec(t) {
      var e, i, n;
      const s = V(t.indicator),
        r =
          null !== (e = t.innerRadius) && void 0 !== e
            ? e
            : null === (n = null === (i = t.series) || void 0 === i ? void 0 : i[0]) || void 0 === n
            ? void 0
            : n.innerRadius;
      return (
        h(r) &&
          s.forEach(t => {
            l(t.limitRatio) && (t.limitRatio = r);
          }),
        s
      );
    }
    transformSpec(t) {
      super.transformSpec(t),
        t.dataZoom &&
          t.dataZoom.length > 0 &&
          t.dataZoom.forEach(t => {
            'axis' === t.filterMode && (t.filterMode = 'filter');
          });
      const e = this._getDefaultSeriesSpec(t);
      t.series && 0 !== t.series.length
        ? t.series.forEach(t => {
            this.isValidSeries(t.type) &&
              Object.keys(e).forEach(i => {
                i in t || (t[i] = e[i]);
              });
          })
        : (t.series = [e]),
        h(t.indicator) && (t.indicator = this.getIndicatorSpec(t));
    }
  }
  class Z3 extends q3 {
    needAxes() {
      return !1;
    }
    _getDefaultSeriesSpec(t) {
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        seriesField: t.seriesField,
        categoryField: t.categoryField || t.radiusField,
        valueField: t.valueField || t.angleField,
        startAngle: t.startAngle,
        endAngle: t.endAngle,
        radius: t.radius,
        innerRadius: t.innerRadius,
        centerX: t.centerX,
        centerY: t.centerY
      });
    }
    _transformProgressAxisSpec(t, e, i) {
      var n;
      t.axes || (t.axes = []);
      const s = { radius: null, angle: null };
      (null !== (n = t.axes) && void 0 !== n ? n : []).forEach(t => {
        const { orient: e } = t;
        'radius' === e && (s.radius = t), 'angle' === e && (s.angle = t);
      }),
        s.angle || ((s.angle = e), t.axes.push(s.angle)),
        s.radius || ((s.radius = i), t.axes.push(s.radius)),
        l(s.angle.type) && (s.angle.type = 'linear'),
        l(s.radius.type) && (s.radius.type = 'band');
      const r = U3(s.angle, { min: 0, max: 1 });
      l(s.angle.min) && (s.angle.min = r.min), l(s.angle.max) && (s.angle.max = r.max);
    }
  }
  NQ.useSeries([H3, V3]);
  class J3 extends Z3 {
    constructor() {
      super(...arguments), (this.type = d2.gauge), (this.seriesType = DZ.gaugePointer);
    }
    _getDefaultSeriesSpec(t) {
      const e = super._getDefaultSeriesSpec(t);
      return Object.assign(Object.assign({}, e), {
        radiusField: t.radiusField,
        pin: t.pin,
        pinBackground: t.pinBackground,
        pointer: t.pointer
      });
    }
    _getDefaultCircularProgressSeriesSpec(t) {
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), { type: DZ.circularProgress });
    }
    transformSpec(t) {
      var e, i, n, s;
      super.transformSpec(t);
      let r =
        null === (e = t.series) || void 0 === e
          ? void 0
          : e.find(t => t.type === DZ.gauge || t.type === DZ.circularProgress);
      l(r) &&
        ((r = null !== (i = t.gauge) && void 0 !== i ? i : this._getDefaultCircularProgressSeriesSpec(t)),
        'circularProgress' === r.type &&
          l(r.radiusField) &&
          l(r.categoryField) &&
          (r.radiusField =
            null !== (s = null !== (n = t.radiusField) && void 0 !== n ? n : t.categoryField) && void 0 !== s
              ? s
              : t.seriesField),
        1 === t.series.length
          ? t.series.push(r)
          : t.series.forEach(t => {
              t.type === r.type &&
                Object.keys(r).forEach(e => {
                  e in t || (t[e] = r[e]);
                });
            })),
        r.type === DZ.circularProgress
          ? this._transformProgressAxisSpec(
              t,
              { orient: 'angle', visible: !0, domainLine: { visible: !1 }, grid: { visible: !1 } },
              { orient: 'radius', visible: !1 }
            )
          : this._transformGaugeAxisSpec(t);
    }
    _transformGaugeAxisSpec(t) {
      var e;
      t.axes || (t.axes = []);
      const i = { radius: null, angle: null };
      (null !== (e = t.axes) && void 0 !== e ? e : []).forEach(t => {
        const { orient: e } = t;
        'radius' === e && (i.radius = t), 'angle' === e && (i.angle = t);
      }),
        i.angle || ((i.angle = { orient: 'angle', visible: !0 }), t.axes.push(i.angle)),
        i.radius || ((i.radius = { orient: 'radius', visible: !1 }), t.axes.push(i.radius)),
        l(i.angle.type) && (i.angle.type = 'linear'),
        l(i.radius.type) && (i.radius.type = 'linear');
    }
  }
  (J3.type = d2.gauge), (J3.view = 'singleDefault');
  class Q3 extends z1 {
    getDefaultTooltipPattern(t, e) {
      const i = super.getDefaultTooltipPattern(t, e);
      return h(i) && 'dimension' === t && (i.visible = !1), i;
    }
  }
  class t5 extends n2 {
    constructor() {
      super(...arguments), (this.type = t5.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), { padding: 0 });
    }
  }
  (t5.type = jZ.cell), NQ.useMark([t5, i2]);
  class e5 extends J1 {
    constructor() {
      super(...arguments), (this.type = DZ.heatmap);
    }
    getFieldValue() {
      return this._fieldValue;
    }
    setFieldValue(t) {
      this._fieldValue = V(t);
    }
    setAttrFromSpec() {
      super.setAttrFromSpec(), this.setFieldValue(this._spec.valueField);
    }
    initMark() {
      const t = {
        progressiveStep: this._spec.progressiveStep,
        progressiveThreshold: this._spec.progressiveThreshold,
        large: this._spec.large,
        largeThreshold: this._spec.largeThreshold
      };
      (this._cellMark = this._createMark(e5.mark.cell, {
        morph: T1(this._spec.animation, this._spec.morph, A1('cell', this._spec)),
        defaultMorphElementKey: this.getDimensionField()[0],
        isSeriesMark: !0,
        label: _J({ animation: this._spec.animation }, this._spec.label),
        progressive: t
      })),
        (this._backgroundMark = this._createMark(e5.mark.cellBackground, { progressive: t }));
    }
    initMarkStyle() {
      this.initCellMarkStyle(), this.initCellBackgroundMarkStyle();
    }
    initLabelMarkStyle(t) {
      t && this.setMarkStyle(t, { fill: this.getColorAttribute(), text: t => t[this.getMeasureField()[0]] });
    }
    initCellMarkStyle() {
      var t;
      this.setMarkStyle(
        this._cellMark,
        {
          x: t => this.dataToPositionX(t),
          y: t => this.dataToPositionY(t),
          size: () => [this.getCellSize(this._xAxisHelper), this.getCellSize(this._yAxisHelper)],
          fill: this.getColorAttribute()
        },
        'normal',
        Jq.Series
      ),
        this._trigger.registerMark(this._cellMark),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(this._cellMark);
    }
    initCellBackgroundMarkStyle() {
      var t, e, i;
      const n = Je(
        null !==
          (i =
            null === (e = null === (t = this._spec.cellBackground) || void 0 === t ? void 0 : t.style) || void 0 === e
              ? void 0
              : e.padding) && void 0 !== i
          ? i
          : 0
      );
      this.setMarkStyle(
        this._backgroundMark,
        {
          x: t => {
            const e = this.getCellSize(this._xAxisHelper);
            return this.dataToPositionX(t) - e / 2 + n[3];
          },
          y: t => {
            const e = this.getCellSize(this._yAxisHelper);
            return this.dataToPositionY(t) - e / 2 + n[0];
          },
          width: () => this.getCellSize(this._xAxisHelper) - n[1] - n[3],
          height: () => this.getCellSize(this._yAxisHelper) - n[0] - n[2]
        },
        'normal',
        Jq.Series
      );
    }
    getColorAttribute() {
      var t;
      return {
        scale:
          null !== (t = this._option.globalScale.getScale('color')) && void 0 !== t ? t : this.getDefaultColorScale(),
        field: this.getFieldValue[0]
      };
    }
    initAnimation() {
      var t, e;
      const i =
        null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
          ? void 0
          : e.preset;
      this._cellMark.setAnimationConfig(
        w1(x1.heatmap(i), A1(LZ.cell, this._spec), {
          dataIndex: t => {
            var e, i, n;
            const s = null == t ? void 0 : t[this._fieldX[0]];
            return (
              (null ===
                (n =
                  null === (i = null === (e = this.getViewDataStatistics()) || void 0 === e ? void 0 : e.latestData) ||
                  void 0 === i
                    ? void 0
                    : i[this._fieldX[0]]) || void 0 === n
                ? void 0
                : n.values.indexOf(s)) || 0
            );
          }
        })
      );
    }
    getCellSize(t) {
      var e, i;
      return null !== (i = null === (e = t.getBandwidth) || void 0 === e ? void 0 : e.call(t, 0)) && void 0 !== i
        ? i
        : 6;
    }
    updateSpec(t) {
      const { direction: e } = this._spec,
        i = super.updateSpec(t);
      return t.direction !== e && ((i.change = !0), (i.reRender = !0), (i.reMake = !0)), i;
    }
    initTooltip() {
      this._tooltipHelper = new Q3(this);
    }
    getDefaultShapeType() {
      return 'square';
    }
    getDimensionField() {
      return [].concat(this.fieldX, this.fieldY);
    }
    getMeasureField() {
      return this.getFieldValue();
    }
  }
  (e5.type = DZ.heatmap), (e5.mark = gJ), NQ.useSeries([e5]);
  class i5 extends c2 {
    constructor() {
      super(...arguments), (this.type = d2.heatmap), (this.seriesType = DZ.heatmap);
    }
    _getDefaultSeriesSpec(t) {
      const e = super._getDefaultSeriesSpec(t);
      return Object.assign(Object.assign({}, e), { valueField: t.valueField, cell: t.cell });
    }
  }
  (i5.type = d2.heatmap), (i5.view = 'singleDefault');
  class n5 extends c2 {
    transformSpec(t) {
      super.transformSpec(t), t.axes.forEach(t => (t.type = 'linear'));
    }
    _getDefaultSeriesSpec(t) {
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        x2Field: null == t ? void 0 : t.x2Field,
        y2Field: null == t ? void 0 : t.y2Field
      });
    }
  }
  NQ.useSeries([g2]);
  class s5 extends n5 {
    constructor() {
      super(...arguments), (this.type = d2.histogram), (this.seriesType = DZ.bar);
    }
    transformSpec(t) {
      super.transformSpec(t), zQ(t);
    }
  }
  (s5.type = d2.histogram), (s5.view = 'singleDefault'), NQ.useSeries([m2]);
  class r5 extends n5 {
    constructor() {
      super(...arguments), (this.type = d2.histogram3d), (this.seriesType = DZ.bar3d);
    }
  }
  (r5.type = d2.histogram3d), (r5.view = 'singleDefault'), NQ.useMark([t2, s2, i2]);
  class a5 extends J1 {
    constructor() {
      super(...arguments), (this.type = DZ.line), (this._sortDataByAxis = !1);
    }
    initMark() {
      var t;
      const e = {
          progressiveStep: this._spec.progressiveStep,
          progressiveThreshold: this._spec.progressiveThreshold,
          large: this._spec.large,
          largeThreshold: this._spec.largeThreshold
        },
        i = null !== (t = this._spec.seriesMark) && void 0 !== t ? t : 'line';
      this.initLineMark(e, 'line' === i), this.initSymbolMark(e, 'point' === i);
    }
    initMarkStyle() {
      this.initLineMarkStyle(this._direction), this.initSymbolMarkStyle();
    }
    initAnimation() {
      var t, e;
      const i = { direction: this.direction },
        n =
          null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
            ? void 0
            : e.preset;
      this._lineMark.setAnimationConfig(w1(x1.line(i, n), A1(LZ.line, this._spec))),
        this._symbolMark && this._symbolMark.setAnimationConfig(w1(x1.symbol(), A1(LZ.point, this._spec)));
    }
    getSeriesStyle(t) {
      var e;
      const i = 'point' !== (null === (e = this._spec) || void 0 === e ? void 0 : e.seriesMark);
      return e => {
        var n, s;
        return (
          i && 'fill' === e && (e = 'stroke'),
          null !== (s = null === (n = this._seriesMark) || void 0 === n ? void 0 : n.getAttribute(e, t)) && void 0 !== s
            ? s
            : null
        );
      };
    }
    getDefaultShapeType() {
      return 'circle';
    }
  }
  (a5.type = DZ.line), (a5.mark = WZ), N(a5, E1), NQ.useSeries([a5]);
  class o5 extends c2 {
    constructor() {
      super(...arguments), (this.type = d2.line), (this.seriesType = DZ.line);
    }
    _getDefaultSeriesSpec(t) {
      var e;
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        point: t.point,
        line: t.line,
        seriesMark: null !== (e = t.seriesMark) && void 0 !== e ? e : 'line',
        activePoint: t.activePoint
      });
    }
    transformSpec(t) {
      super.transformSpec(t), zQ(t);
    }
  }
  (o5.type = d2.line), (o5.view = 'singleDefault'), Rr();
  const l5 = {},
    h5 = [
      'clipAngle',
      'clipExtent',
      'scale',
      'translate',
      'center',
      'rotate',
      'precision',
      'reflectX',
      'reflectY',
      'parallels',
      'coefficient',
      'distance',
      'fraction',
      'lobes',
      'parallel',
      'radius',
      'ratio',
      'spacing',
      'tilt'
    ];
  function c5(t, e) {
    (t && g(t)) || Lo('Projection type must be a name string.');
    const i = t.toLowerCase();
    return (
      arguments.length > 1 &&
        (l5[i] = (function (t, e) {
          return function i() {
            const n = e();
            return (
              (n.type = t),
              (n.path = Rr().projection(n)),
              (n.copy =
                n.copy ||
                function () {
                  const t = i();
                  return (
                    h5.forEach(e => {
                      n[e] && t[e](n[e]());
                    }),
                    t.path.pointRadius(n.path.pointRadius()),
                    t
                  );
                }),
              n
            );
          };
        })(i, e)),
      l5[i] || null
    );
  }
  const d5 = {
    albers: qr,
    albersusa: function () {
      var t,
        e,
        i,
        n,
        s,
        r,
        a = qr(),
        o = Kr().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
        l = Kr().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
        h = {
          point: function (t, e) {
            r = [t, e];
          }
        };
      function c(t) {
        var e = t[0],
          a = t[1];
        return (r = null), i.point(e, a), r || (n.point(e, a), r) || (s.point(e, a), r);
      }
      function d() {
        return (t = e = null), c;
      }
      return (
        (c.invert = function (t) {
          var e = a.scale(),
            i = a.translate(),
            n = (t[0] - i[0]) / e,
            s = (t[1] - i[1]) / e;
          return (
            s >= 0.12 && s < 0.234 && n >= -0.425 && n < -0.214
              ? o
              : s >= 0.166 && s < 0.234 && n >= -0.214 && n < -0.115
              ? l
              : a
          ).invert(t);
        }),
        (c.stream = function (i) {
          return t && e === i
            ? t
            : ((n = [a.stream((e = i)), o.stream(i), l.stream(i)]),
              (s = n.length),
              (t = {
                point: function (t, e) {
                  for (var i = -1; ++i < s; ) n[i].point(t, e);
                },
                sphere: function () {
                  for (var t = -1; ++t < s; ) n[t].sphere();
                },
                lineStart: function () {
                  for (var t = -1; ++t < s; ) n[t].lineStart();
                },
                lineEnd: function () {
                  for (var t = -1; ++t < s; ) n[t].lineEnd();
                },
                polygonStart: function () {
                  for (var t = -1; ++t < s; ) n[t].polygonStart();
                },
                polygonEnd: function () {
                  for (var t = -1; ++t < s; ) n[t].polygonEnd();
                }
              }));
          var n, s;
        }),
        (c.precision = function (t) {
          return arguments.length ? (a.precision(t), o.precision(t), l.precision(t), d()) : a.precision();
        }),
        (c.scale = function (t) {
          return arguments.length ? (a.scale(t), o.scale(0.35 * t), l.scale(t), c.translate(a.translate())) : a.scale();
        }),
        (c.translate = function (t) {
          if (!arguments.length) return a.translate();
          var e = a.scale(),
            r = +t[0],
            c = +t[1];
          return (
            (i = a
              .translate(t)
              .clipExtent([
                [r - 0.455 * e, c - 0.238 * e],
                [r + 0.455 * e, c + 0.238 * e]
              ])
              .stream(h)),
            (n = o
              .translate([r - 0.307 * e, c + 0.201 * e])
              .clipExtent([
                [r - 0.425 * e + Mn, c + 0.12 * e + Mn],
                [r - 0.214 * e - Mn, c + 0.234 * e - Mn]
              ])
              .stream(h)),
            (s = l
              .translate([r - 0.205 * e, c + 0.212 * e])
              .clipExtent([
                [r - 0.214 * e + Mn, c + 0.166 * e + Mn],
                [r - 0.115 * e - Mn, c + 0.234 * e - Mn]
              ])
              .stream(h)),
            d()
          );
        }),
        (c.fitExtent = function (t, e) {
          return Dr(c, t, e);
        }),
        (c.fitSize = function (t, e) {
          return Lr(c, t, e);
        }),
        (c.fitWidth = function (t, e) {
          return Fr(c, t, e);
        }),
        (c.fitHeight = function (t, e) {
          return jr(c, t, e);
        }),
        c.scale(1070)
      );
    },
    azimuthalequalarea: function () {
      return Ur(Qr).scale(124.75).clipAngle(179.999);
    },
    azimuthalequidistant: function () {
      return Ur(ta).scale(79.4188).clipAngle(179.999);
    },
    conicconformal: function () {
      return $r(sa).scale(109.5).parallels([30, 30]);
    },
    conicequalarea: Kr,
    conicequidistant: function () {
      return $r(aa).scale(131.154).center([0, 13.9389]);
    },
    equalEarth: function () {
      return Ur(ua).scale(177.158);
    },
    equirectangular: function () {
      return Ur(ra).scale(152.63);
    },
    gnomonic: function () {
      return Ur(pa).scale(144.049).clipAngle(60);
    },
    identity: function () {
      var t,
        e,
        i,
        n,
        s,
        r,
        a,
        o = 1,
        l = 0,
        h = 0,
        c = 1,
        d = 1,
        u = 0,
        p = null,
        g = 1,
        f = 1,
        v = Or({
          point: function (t, e) {
            var i = _([t, e]);
            this.stream.point(i[0], i[1]);
          }
        }),
        m = Ps;
      function y() {
        return (g = o * c), (f = o * d), (r = a = null), _;
      }
      function _(i) {
        var n = i[0] * g,
          s = i[1] * f;
        if (u) {
          var r = s * t - n * e;
          (n = n * t + s * e), (s = r);
        }
        return [n + l, s + h];
      }
      return (
        (_.invert = function (i) {
          var n = i[0] - l,
            s = i[1] - h;
          if (u) {
            var r = s * t + n * e;
            (n = n * t - s * e), (s = r);
          }
          return [n / g, s / f];
        }),
        (_.stream = function (t) {
          return r && a === t ? r : (r = v(m((a = t))));
        }),
        (_.postclip = function (t) {
          return arguments.length ? ((m = t), (p = i = n = s = null), y()) : m;
        }),
        (_.clipExtent = function (t) {
          return arguments.length
            ? ((m =
                null == t
                  ? ((p = i = n = s = null), Ps)
                  : Es((p = +t[0][0]), (i = +t[0][1]), (n = +t[1][0]), (s = +t[1][1]))),
              y())
            : null == p
            ? null
            : [
                [p, i],
                [n, s]
              ];
        }),
        (_.scale = function (t) {
          return arguments.length ? ((o = +t), y()) : o;
        }),
        (_.translate = function (t) {
          return arguments.length ? ((l = +t[0]), (h = +t[1]), y()) : [l, h];
        }),
        (_.angle = function (i) {
          return arguments.length ? ((e = Hn((u = (i % 360) * On))), (t = Ln(u)), y()) : u * Rn;
        }),
        (_.reflectX = function (t) {
          return arguments.length ? ((c = t ? -1 : 1), y()) : c < 0;
        }),
        (_.reflectY = function (t) {
          return arguments.length ? ((d = t ? -1 : 1), y()) : d < 0;
        }),
        (_.fitExtent = function (t, e) {
          return Dr(_, t, e);
        }),
        (_.fitSize = function (t, e) {
          return Lr(_, t, e);
        }),
        (_.fitWidth = function (t, e) {
          return Fr(_, t, e);
        }),
        (_.fitHeight = function (t, e) {
          return jr(_, t, e);
        }),
        _
      );
    },
    mercator: function () {
      return ia(ea).scale(961 / Pn);
    },
    naturalEarth1: function () {
      return Ur(ga).scale(175.295);
    },
    orthographic: function () {
      return Ur(fa)
        .scale(249.5)
        .clipAngle(90 + Mn);
    },
    stereographic: function () {
      return Ur(va).scale(250).clipAngle(142);
    },
    transversemercator: function () {
      var t = ia(ma),
        e = t.center,
        i = t.rotate;
      return (
        (t.center = function (t) {
          return arguments.length ? e([-t[1], t[0]]) : [(t = e())[1], -t[0]];
        }),
        (t.rotate = function (t) {
          return arguments.length ? i([t[0], t[1], t.length > 2 ? t[2] + 90 : 90]) : [(t = i())[0], t[1], t[2] - 90];
        }),
        i([0, 0, 90]).scale(159.155)
      );
    }
  };
  Object.keys(d5).forEach(t => {
    c5(t, d5[t]);
  });
  const u5 = 'Feature',
    p5 = 'FeatureCollection';
  function g5(t) {
    const e = V(t);
    return 1 === e.length
      ? e[0]
      : {
          type: p5,
          features: e.reduce(
            (t, e) =>
              t.concat(
                (function (t) {
                  return t.type === p5
                    ? t.features
                    : V(t)
                        .filter(t => !l(t))
                        .map(t => (t.type === u5 ? t : { type: u5, geometry: t }));
                })(e)
              ),
            []
          )
        };
  }
  const f5 = h5.concat(['pointRadius', 'fit', 'extent', 'size']);
  function v5(t, e) {
    let i = [];
    return t
      ? (Object.keys(t).forEach(n => {
          f5.includes(n) && (i = i.concat(IW(t[n], e)));
        }),
        i)
      : i;
  }
  const m5 = (t, e) => {
    if (!e.from || !e.from()) return t;
    const i = e.fields,
      n = e.key,
      s = e.values,
      r = e.default,
      a = e.as || [i],
      c = e.from().reduce(function (t, e) {
        return e[i] && t.set(e[i], e), t;
      }, new Map());
    let d;
    if (o(e.set))
      d = function (t) {
        const i = c.get(t[n]);
        e.set(t, i);
      };
    else if (s) {
      const t = s.length;
      d = function (e) {
        const i = c.get(e[n]);
        if (l(i)) for (let i = 0; i < t; ++i) e[a[i]] = r;
        else for (let n = 0; n < t; ++n) e[a[n]] = i[s[n]];
      };
    } else
      d = function (t) {
        const e = c.get(t[n]);
        t[a[0]] = h(e) ? e : r;
      };
    return 0 === t.length ? [] : t.map(t => (d(t), t));
  };
  class y5 extends q1 {
    constructor() {
      super(...arguments), (this.type = DZ.geo), (this.coordinate = 'geo'), (this._nameProperty = 'name');
    }
    getMapViewData() {
      var t;
      return null === (t = this._mapViewData) || void 0 === t ? void 0 : t.getDataView();
    }
    get nameField() {
      return this._nameField;
    }
    set nameField(t) {
      this._nameField = t;
    }
    get valueField() {
      return this._valueField;
    }
    set valueField(t) {
      this._valueField = t;
    }
    getNameProperty() {
      return this._nameProperty;
    }
    getCoordinateHelper() {
      return this._coordinateHelper;
    }
    setCoordinateHelper(t) {
      this._coordinateHelper = t;
    }
    getStatisticFields() {
      const t = [];
      return (
        t.push({ key: this._nameField, operations: ['values'] }),
        t.push({ key: this._valueField, operations: ['max', 'min'] }),
        t
      );
    }
    getGroupFields() {
      return null;
    }
    dataToPosition(t) {
      var e;
      let i = null;
      if (!t) return i;
      const { dataToPosition: n, latitudeField: s, longitudeField: r } = this._coordinateHelper;
      if (((i = this.nameToPosition(t)), null === i)) {
        const a = r ? (null == t ? void 0 : t[r]) : Number.NaN,
          o = s ? (null == t ? void 0 : t[s]) : Number.NaN;
        i = null !== (e = null == n ? void 0 : n([a, o])) && void 0 !== e ? e : null;
      }
      return i;
    }
    nameToPosition(t) {
      var e, i;
      const n = this._getDatumName(t);
      if (l(n)) return null;
      const s =
        null === (i = null === (e = this.getMapViewData()) || void 0 === e ? void 0 : e.latestData) || void 0 === i
          ? void 0
          : i.filter(t => this._getDatumName(t) === n)[0];
      if (l(s)) return null;
      const { dataToPosition: r } = this._coordinateHelper,
        a = this._getDatumCenter(s),
        o = null == r ? void 0 : r(a);
      return l(o) || isNaN(o.x) || isNaN(o.y) ? null : o;
    }
    dataToLatitude(t) {
      if (!this._coordinateHelper) return Number.NaN;
      const { dataToLatitude: e } = this._coordinateHelper;
      return e(t);
    }
    dataToLongitude(t) {
      if (!this._coordinateHelper) return Number.NaN;
      const { dataToLatitude: e } = this._coordinateHelper;
      return e(t);
    }
    valueToPosition(t, e) {
      return { x: this.dataToLongitude(t), y: this.dataToLatitude(e) };
    }
    positionToData(t) {}
    latitudeToData(t) {}
    longitudeToData(t) {}
    dataToPositionX(t) {
      var e;
      return null === (e = this._option) || void 0 === e || e.onError('Method not implemented.'), 0;
    }
    dataToPositionY(t) {
      var e;
      return null === (e = this._option) || void 0 === e || e.onError('Method not implemented.'), 0;
    }
    dataToPositionZ(t) {
      var e;
      return null === (e = this._option) || void 0 === e || e.onError('Method not implemented.'), 0;
    }
    release() {
      super.release(), this._mapViewData.release(), (this._mapViewData = this._mapViewDataStatistics = null);
    }
    getStackGroupFields() {
      return [this._nameField];
    }
    getStackValueField() {
      return this._spec.valueField;
    }
    setValueFieldToStack() {}
    setValueFieldToPercent() {}
    setValueFieldToStackOffsetSilhouette() {}
    compileData() {
      var t;
      null === (t = this._mapViewData) || void 0 === t || t.compile();
    }
    initStatisticalData() {
      if ((super.initStatisticalData(), this._mapViewData)) {
        const t = `${UV}_series_${this.id}_mapViewDataStatic`;
        (this._mapViewDataStatistics = this.createStatisticalData(t, this._mapViewData.getDataView())),
          this._mapViewData
            .getDataView()
            .target.removeListener('change', this._mapViewDataStatistics.reRunAllTransform);
      }
    }
    getSeriesKeys() {
      var t, e, i, n, s, r, a;
      return this._seriesField
        ? null !==
            (a =
              null !==
                (n =
                  null ===
                    (i =
                      null === (e = null === (t = this._rawDataStatistics) || void 0 === t ? void 0 : t.latestData) ||
                      void 0 === e
                        ? void 0
                        : e[this._seriesField]) || void 0 === i
                    ? void 0
                    : i.values) && void 0 !== n
                ? n
                : null ===
                    (r =
                      null === (s = this._mapViewDataStatistics) || void 0 === s
                        ? void 0
                        : s.latestData[this._seriesField]) || void 0 === r
                ? void 0
                : r.values) && void 0 !== a
          ? a
          : []
        : this.name
        ? [this.name]
        : this.userId
        ? [`${this.userId}`]
        : [`${this.type}_${this.id}`];
    }
    fillData() {
      var t, e;
      super.fillData(),
        null === (t = this._mapViewData.getDataView()) || void 0 === t || t.reRunAllTransform(),
        null === (e = this._mapViewDataStatistics) || void 0 === e || e.reRunAllTransform();
    }
  }
  const _5 = `${UV}_MAP_LOOK_UP_KEY`,
    b5 = (t, e) => (
      t.features &&
        t.features.forEach((t, i) => {
          var n, s;
          (t[Xq] = i),
            e.nameMap
              ? (t[_5] = e.nameMap[null === (n = t.properties) || void 0 === n ? void 0 : n[e.nameProperty]])
              : (t[_5] = null === (s = t.properties) || void 0 === s ? void 0 : s[e.nameProperty]);
        }),
      t.features
    );
  class x5 extends z1 {
    constructor() {
      super(...arguments),
        (this.titleValueCallback = t => {
          var e, i;
          const n = this.series;
          return null !== (e = this._getDimensionData(t)) && void 0 !== e
            ? e
            : null === (i = t.properties) || void 0 === i
            ? void 0
            : i[`${n.getNameProperty()}`];
        });
    }
  }
  var S5, w5, A5;
  NQ.useMark([z3, i2]),
    (S5 = 'projection'),
    (w5 = class extends VU {
      constructor(t) {
        super(t), (this.grammarType = 'projection');
      }
      parse(t) {
        return (
          super.parse(t),
          this.pointRadius(t.pointRadius),
          this.size(t.size),
          this.extent(t.extent),
          this.fit(t.fit),
          this.configure(t),
          this.commit(),
          this
        );
      }
      pointRadius(t) {
        return (
          l(this.spec.pointRadius) || this.detach(IW(this.spec.pointRadius, this.view)),
          (this.spec.pointRadius = t),
          this.attach(IW(t, this.view)),
          this.commit(),
          this
        );
      }
      size(t) {
        return (
          l(this.spec.size) || this.detach(IW(this.spec.size, this.view)),
          (this.spec.size = t),
          this.attach(IW(t, this.view)),
          this.commit(),
          this
        );
      }
      extent(t) {
        return (
          l(this.spec.extent) || this.detach(IW(this.spec.extent, this.view)),
          (this.spec.extent = t),
          this.attach(IW(t, this.view)),
          this.commit(),
          this
        );
      }
      fit(t) {
        return (
          l(this.spec.fit) || this.detach(IW(this.spec.fit, this.view)),
          (this.spec.fit = t),
          this.attach(IW(t, this.view)),
          this.commit(),
          this
        );
      }
      configure(t) {
        return (
          this.detach(v5(this.spec, this.view)),
          l(t)
            ? (this.spec = {
                type: this.spec.type,
                fit: this.spec.fit,
                extent: this.spec.extent,
                size: this.spec.size,
                pointRadius: this.spec.pointRadius
              })
            : (Object.assign(this.spec, t), this.attach(v5(this.spec, this.view))),
          this.commit(),
          this
        );
      }
      evaluate(t, e) {
        if (
          ((this.projection && this.projection.type === this.spec.type) ||
            ((this.projection = (function (t) {
              const e = c5((t || 'mercator').toLowerCase());
              return e || Lo('Unrecognized projection type: ' + t), e();
            })(this.spec.type)),
            (this.projection.type = this.spec.type)),
          h5.forEach(t => {
            var i, n, s;
            l(this.spec[t]) || ((i = this.projection), (n = t), (s = LW(this.spec[t], e, c5)), o(i[n]) && i[n](s));
          }),
          l(this.spec.pointRadius) || this.projection.path.pointRadius(LW(this.spec.pointRadius, e, c5)),
          !(l(this.spec.fit) || (l(this.spec.extent) && l(this.spec.size))))
        ) {
          const t = g5(LW(this.spec.fit, e, c5));
          this.spec.extent
            ? this.projection.fitExtent(LW(this.spec.extent, e, c5), t)
            : this.spec.size && this.projection.fitSize(LW(this.spec.size, e, c5), t);
        }
        return this.projection;
      }
      output() {
        return this.projection;
      }
    }),
    (A5 = 'projections'),
    (cq[S5] = { grammarClass: w5, specKey: null != A5 ? A5 : S5 });
  class k5 extends y5 {
    constructor() {
      super(...arguments), (this.type = DZ.map), (this._areaCache = new Map());
    }
    getNameMap() {
      return this._nameMap;
    }
    setAttrFromSpec() {
      var t, e;
      super.setAttrFromSpec(),
        (this.map = this._spec.map),
        (this._nameMap = this._spec.nameMap),
        (this._nameField = this._spec.nameField),
        (this._valueField = this._spec.valueField),
        this._spec.nameProperty && (this._nameProperty = this._spec.nameProperty),
        this.map ||
          null === (t = this._option) ||
          void 0 === t ||
          t.onError(`map type '${this.map}' is not specified !`),
        wQ.get(this.map) ||
          null === (e = this._option) ||
          void 0 === e ||
          e.onError(`'${this.map}' data is not registered !`);
    }
    initData() {
      var t, e;
      super.initData(),
        xQ(this._dataSet, 'copyDataView', TQ),
        xQ(this._dataSet, 'map', b5),
        xQ(this._dataSet, 'lookup', m5);
      const i = wQ.get(this.map);
      i || null === (t = this._option) || void 0 === t || t.onError('no valid map data found!');
      const n = new yo(this._dataSet);
      n
        .parse([i], { type: 'dataview' })
        .transform({ type: 'copyDataView', options: { deep: !0 } })
        .transform({ type: 'map', options: { nameMap: this._nameMap, nameProperty: this._nameProperty } })
        .transform({
          type: 'lookup',
          options: {
            from: () => {
              var t;
              return null === (t = this._data) || void 0 === t ? void 0 : t.getLatestData();
            },
            key: _5,
            fields: this._nameField,
            set: (t, e) => {
              e &&
                Object.keys(e).forEach(i => {
                  i in t || (t[i] = e[i]);
                });
            }
          }
        }),
        null === (e = this._data) || void 0 === e || e.getDataView().target.addListener('change', n.reRunAllTransform),
        (this._mapViewData = new W1(this._option, n));
    }
    initMark() {
      this._pathMark = this._createMark(k5.mark.area, {
        morph: T1(this._spec.animation, this._spec.morph, A1('area', this._spec)),
        defaultMorphElementKey: this.getDimensionField()[0],
        groupKey: this.getDimensionField()[0],
        isSeriesMark: !0,
        skipBeforeLayouted: !0,
        dataView: this._mapViewData.getDataView(),
        dataProductId: this._mapViewData.getProductId(),
        label: _J({ animation: this._spec.animation }, this._spec.label)
      });
    }
    initMarkStyle() {
      var t;
      const e = this._pathMark;
      e &&
        (this.setMarkStyle(
          e,
          {
            fill: t => {
              var e, i, n, s;
              return h(t[null !== (e = this._seriesField) && void 0 !== e ? e : qq])
                ? (null !== (i = this._option.globalScale.getScale('color')) && void 0 !== i
                    ? i
                    : this.getDefaultColorScale()
                  ).scale(t[null !== (n = this._seriesField) && void 0 !== n ? n : qq])
                : null === (s = this._spec) || void 0 === s
                ? void 0
                : s.defaultFillColor;
            },
            path: this.getPath.bind(this)
          },
          'normal',
          Jq.Series
        ),
        e.setPostProcess('fill', t => (h(t) ? t : this._spec.defaultFillColor)),
        this.setMarkStyle(e, { smoothScale: !0 }, 'normal', Jq.Built_In),
        this._trigger.registerMark(e),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(e));
    }
    initLabelMarkStyle(t) {
      t &&
        ((this._labelMark = t),
        this.setMarkStyle(t, {
          text: t => this._getDatumName(t),
          x: t => {
            var e;
            return null === (e = this.dataToPosition(t)) || void 0 === e ? void 0 : e.x;
          },
          y: t => {
            var e;
            return null === (e = this.dataToPosition(t)) || void 0 === e ? void 0 : e.y;
          }
        }));
    }
    initAnimation() {
      this._pathMark.setAnimationConfig(w1(x1.path(), A1(LZ.area, this._spec)));
    }
    initTooltip() {
      this._tooltipHelper = new x5(this);
    }
    getPath(t) {
      var e;
      const i = this._areaCache.get(t[Xq]);
      if (i) return i.shape;
      const n = null === (e = this._coordinateHelper) || void 0 === e ? void 0 : e.shape(t);
      return this._areaCache.set(t[Xq], { shape: n }), n;
    }
    onEvaluateEnd() {
      this._mapViewData.updateData();
    }
    getDimensionField() {
      return [this.nameField];
    }
    getMeasureField() {
      return [this.valueField];
    }
    release() {
      super.release(), this._areaCache.clear(), (this._nameMap = {}), (this._trigger = this._mapViewData = null);
    }
    updateSpec(t) {
      const e = this._originalSpec,
        { map: i, nameMap: n, valueField: s, nameProperty: r } = e,
        a = super.updateSpec(t);
      return (
        ((null == t ? void 0 : t.map) === i &&
          (null == t ? void 0 : t.nameMap) === n &&
          (null == t ? void 0 : t.valueField) === s &&
          (null == t ? void 0 : t.nameProperty) === r) ||
          ((a.change = !0), (a.reRender = !0), (a.reMake = !0)),
        a
      );
    }
    handleZoom(t) {
      var e, i, n;
      const { scale: s, scaleCenter: r } = t;
      if (1 === s) return;
      const a = null === (e = this.getRootMark().getProduct()) || void 0 === e ? void 0 : e.getGroupGraphicItem();
      a && (a.attribute.postMatrix || a.setAttributes({ postMatrix: new ie() }), a.scale(s, s, r));
      const o =
        null === (n = null === (i = this._labelMark) || void 0 === i ? void 0 : i.getComponent()) || void 0 === n
          ? void 0
          : n.getProduct();
      o && o.evaluateSync(null, null);
    }
    handlePan(t) {
      var e, i, n;
      const { delta: s } = t;
      if (0 === s[0] && 0 === s[1]) return;
      const r = null === (e = this.getRootMark().getProduct()) || void 0 === e ? void 0 : e.getGroupGraphicItem();
      r && (r.attribute.postMatrix || r.setAttributes({ postMatrix: new ie() }), r.translate(s[0], s[1]));
      const a =
        null === (n = null === (i = this._labelMark) || void 0 === i ? void 0 : i.getComponent()) || void 0 === n
          ? void 0
          : n.getProduct();
      a && a.evaluateSync(null, null);
    }
    _getDatumCenter(t) {
      var e, i;
      return _(t.centroidX * t.centroidY)
        ? [t.centroidX, t.centroidY]
        : (null === (e = t.properties) || void 0 === e ? void 0 : e.center)
        ? t.properties.center
        : (null === (i = t.properties) || void 0 === i ? void 0 : i.centroid)
        ? t.properties.centroid
        : [Number.NaN, Number.NaN];
    }
    _getDatumName(t) {
      var e, i, n, s;
      return t[this.nameField]
        ? t[this.nameField]
        : (null === (e = t.properties) || void 0 === e ? void 0 : e[this._nameProperty])
        ? (null === (i = this._spec) || void 0 === i ? void 0 : i.nameMap)
          ? null !== (n = this._spec.nameMap[t.properties[this._nameProperty]]) && void 0 !== n
            ? n
            : ''
          : null !== (s = t.properties[this._nameProperty]) && void 0 !== s
          ? s
          : ''
        : '';
    }
    dataToPositionX(t) {
      var e;
      return null === (e = this._option) || void 0 === e || e.onError('Method not implemented.'), 0;
    }
    dataToPositionY(t) {
      var e;
      return null === (e = this._option) || void 0 === e || e.onError('Method not implemented.'), 0;
    }
    viewDataUpdate(t) {
      var e, i, n;
      super.viewDataUpdate(t),
        null === (i = null === (e = this._mapViewData) || void 0 === e ? void 0 : e.getDataView()) ||
          void 0 === i ||
          i.reRunAllTransform(),
        null === (n = this._mapViewData) || void 0 === n || n.updateData();
    }
    _getDataIdKey() {
      return Xq;
    }
  }
  (k5.type = DZ.map), (k5.mark = qZ), NQ.useSeries([k5]);
  class M5 extends h2 {
    constructor() {
      super(...arguments), (this.type = d2.map), (this.seriesType = DZ.map);
    }
    _getDefaultSeriesSpec(t) {
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        type: t.type,
        nameField: t.nameField,
        valueField: t.valueField,
        seriesField: t.seriesField,
        map: t.map,
        nameProperty: t.nameProperty,
        nameMap: t.nameMap,
        area: t.area,
        defaultFillColor: t.defaultFillColor
      });
    }
    isValidSeries(t) {
      return t === DZ.map;
    }
    transformSpec(t) {
      super.transformSpec(t),
        t.region.forEach(t => {
          t.coordinate = 'geo';
        });
      const e = this._getDefaultSeriesSpec(t);
      t.series && 0 !== t.series.length
        ? t.series.forEach(t => {
            this.isValidSeries(t.type) &&
              Object.keys(e).forEach(i => {
                i in t || (t[i] = e[i]);
              });
          })
        : (t.series = [e]);
    }
  }
  function T5(t) {
    return Oo(t) ? Number.parseFloat(t) : 0;
  }
  (M5.type = d2.map), (M5.view = 'singleDefault');
  const C5 = (t, e) => {
    const i = t.map(t => Object.assign({}, t));
    if (!i || 0 === i.length) return i;
    const {
      angleField: n,
      startAngle: s,
      endAngle: r,
      asStartAngle: a,
      asEndAngle: o,
      asMiddleAngle: l,
      asRadian: h,
      asRatio: c,
      asQuadrant: d,
      asK: u
    } = e;
    let p = 0,
      g = -1 / 0;
    for (let t = 0; t < i.length; t++) {
      const e = T5(i[t][n]);
      (p += e), (g = Math.max(e, g));
    }
    const f = r - s;
    let v = s;
    return (
      i.forEach(t => {
        const e = T5(t[n]),
          i = p ? e / p : 0,
          s = i * f;
        c && (t[c] = i),
          a && (t[a] = v),
          o && (t[o] = v + s),
          l && (t[l] = v + s / 2),
          h && (t[h] = s),
          d &&
            (t[d] = (function (t) {
              return (t = BN(t)) > 0 && t <= Math.PI / 2
                ? 2
                : t > Math.PI / 2 && t <= Math.PI
                ? 3
                : t > Math.PI && t <= (3 * Math.PI) / 2
                ? 4
                : 1;
            })(v + s / 2)),
          u && (t[u] = g ? e / g : 0),
          (v = t[o]);
      }),
      0 !== p && (i[i.length - 1][o] = r),
      i
    );
  };
  NQ.useMark([z3, i2, c3]);
  class E5 extends F3 {
    constructor() {
      super(...arguments),
        (this._pieMarkName = LZ.pie),
        (this._pieMarkType = jZ.arc),
        (this._startAngle = dW),
        (this._endAngle = uW),
        (this._pieMark = null),
        (this._labelMark = null),
        (this._labelLineMark = null),
        (this.dataToCentralPosition = t => {
          const e = t[lW];
          if (l(e)) return null;
          const i = this.computeDatumRadius(t),
            n = this.computeDatumInnerRadius(t),
            s = this.computeCenter(t),
            r = YN({ angle: e, radius: (i + n) / 2 });
          return { x: s.x + r.x, y: s.y + r.y };
        });
    }
    get center() {
      var t, e, i, n;
      return {
        x:
          null !== (e = null === (t = this._spec) || void 0 === t ? void 0 : t.centerX) && void 0 !== e
            ? e
            : this._region.getLayoutRect().width / 2,
        y:
          null !== (n = null === (i = this._spec) || void 0 === i ? void 0 : i.centerY) && void 0 !== n
            ? n
            : this._region.getLayoutRect().height / 2
      };
    }
    setAttrFromSpec() {
      var t, e, i, n, s, r, a;
      super.setAttrFromSpec(),
        (this._centerOffset =
          null !== (e = null === (t = this._spec) || void 0 === t ? void 0 : t.centerOffset) && void 0 !== e ? e : 0),
        (this._cornerRadius =
          null !== (n = null === (i = this._spec) || void 0 === i ? void 0 : i.cornerRadius) && void 0 !== n ? n : 0);
      const o = (function (t, e) {
        let i = 0,
          n = 2 * Math.PI;
        const s = h(t),
          r = h(e);
        for (
          s || r
            ? r
              ? s
                ? ((i = t), (n = e))
                : ((i = e - 2 * Math.PI), (n = e))
              : ((i = t), (n = t + 2 * Math.PI))
            : ((i = 0), (n = 2 * Math.PI));
          n <= i;

        )
          n += 2 * Math.PI;
        for (; i > 2 * Math.PI; ) (i -= 2 * Math.PI), (n -= 2 * Math.PI);
        for (; n < 0; ) (i += 2 * Math.PI), (n += 2 * Math.PI);
        return { startAngle: i, endAngle: n };
      })(
        h(null === (s = this._spec) || void 0 === s ? void 0 : s.startAngle)
          ? qt(this._spec.startAngle)
          : this._startAngle,
        h(null === (r = this._spec) || void 0 === r ? void 0 : r.endAngle) ? qt(this._spec.endAngle) : this._endAngle
      );
      (this._startAngle = o.startAngle),
        (this._endAngle = o.endAngle),
        (this._padAngle = h(null === (a = this._spec) || void 0 === a ? void 0 : a.padAngle)
          ? qt(this._spec.padAngle)
          : 0),
        this.setAngleField(this._spec.valueField || this._spec.angleField),
        this._spec.categoryField && this.setSeriesField(this._spec.categoryField),
        (this._radiusField = []);
    }
    initData() {
      super.initData();
      const t = this.getViewData();
      if (!t) return;
      xQ(this._dataSet, 'pie', C5),
        t.transform(
          {
            type: 'pie',
            options: {
              angleField: this._angleField[0],
              startAngle: this._startAngle,
              endAngle: this._endAngle,
              asStartAngle: eW,
              asEndAngle: iW,
              asRatio: tW,
              asMiddleAngle: lW,
              asRadian: cW,
              asQuadrant: hW,
              asK: nW
            }
          },
          !1
        );
      const e = new yo(this._dataSet);
      e.parse([this.getViewData()], { type: 'dataview' }),
        (e.name = `${UV}_series_${this.id}_viewDataLabel`),
        (this._viewDataLabel = new W1(this._option, e));
    }
    initMark() {
      this._pieMark = this._createMark(
        Object.assign(Object.assign({}, E5.mark.pie), { name: this._pieMarkName, type: this._pieMarkType }),
        {
          morph: T1(this._spec.animation, this._spec.morph, A1(this.type, this._spec)),
          defaultMorphElementKey: this._seriesField,
          key: Kq,
          groupKey: this._seriesField,
          skipBeforeLayouted: !0,
          isSeriesMark: !0,
          label: _J({ animation: this._spec.animation }, this._spec.label)
        }
      );
    }
    initMarkStyle() {
      var t;
      const e = this._pieMark;
      e &&
        (this.setMarkStyle(
          e,
          {
            x: () => {
              var t, e;
              return null !== (e = null === (t = this._center) || void 0 === t ? void 0 : t.x) && void 0 !== e
                ? e
                : this._region.getLayoutRect().width / 2;
            },
            y: () => {
              var t, e;
              return null !== (e = null === (t = this._center) || void 0 === t ? void 0 : t.y) && void 0 !== e
                ? e
                : this._region.getLayoutRect().height / 2;
            },
            fill: this.getColorAttribute(),
            outerRadius: pV(this._outerRadius)
              ? this._outerRadius
              : () => this.computeLayoutRadius() * this._outerRadius,
            innerRadius: pV(this._innerRadius)
              ? this._innerRadius
              : () => this.computeLayoutRadius() * this._innerRadius,
            cornerRadius: () => this.computeLayoutRadius() * this._cornerRadius,
            startAngle: iV(eW).bind(this),
            endAngle: iV(iW).bind(this),
            padAngle: this._padAngle,
            centerOffset: this._centerOffset
          },
          'normal',
          Jq.Series
        ),
        this._trigger.registerMark(e),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(e));
    }
    initMarkStyleWithSpec(t, e, i) {
      if ((super.initMarkStyleWithSpec(t, e, i), t.name === this._pieMarkName)) {
        const e = this.getSpec()[t.name];
        if (e)
          for (const i in e.state || {}) this.setMarkStyle(t, this.generateRadiusStyle(e.state[i]), i, Jq.User_Mark);
      }
    }
    initLabelMarkStyle(t) {
      var e, i, n, s, r, a;
      t &&
        this.setMarkStyle(t, {
          visible: iV(ZV).bind(this),
          text: t => t[this.getDimensionField()[0]],
          fill:
            (null === (i = null === (e = this._spec.label) || void 0 === e ? void 0 : e.style) || void 0 === i
              ? void 0
              : i.fill) || this.getColorAttribute(),
          angle:
            null === (s = null === (n = this._spec.label) || void 0 === n ? void 0 : n.style) || void 0 === s
              ? void 0
              : s.angle,
          limit:
            null === (a = null === (r = this._spec.label) || void 0 === r ? void 0 : r.style) || void 0 === a
              ? void 0
              : a.limit,
          z: this.dataToPositionZ.bind(this)
        });
    }
    afterInitMark() {
      super.afterInitMark(), this._trigger.setStateKeys([this._seriesField, ...this._radiusField]);
    }
    initEvent() {
      var t;
      super.initEvent(),
        null === (t = this._viewDataLabel.getDataView()) ||
          void 0 === t ||
          t.target.addListener('change', this.viewDataLabelUpdate.bind(this));
    }
    initGroups() {}
    onLayoutEnd(t) {
      this._viewDataLabel.getDataView().reRunAllTransform(), this.onMarkPositionUpdate(), super.onLayoutEnd(t);
    }
    getDimensionField() {
      return this._seriesField ? [this._seriesField] : [];
    }
    getMeasureField() {
      return this._angleField;
    }
    viewDataLabelUpdate() {
      this.event.emit(Gq.viewDataLabelUpdate, { model: this }), this._viewDataLabel.updateData();
    }
    generateRadiusStyle(t) {
      const e = {};
      return (
        (null == t ? void 0 : t.outerRadius) &&
          (e.outerRadius = () => this.computeLayoutRadius() * (null == t ? void 0 : t.outerRadius)),
        (null == t ? void 0 : t.innerRadius) &&
          (e.innerRadius = () => this.computeLayoutRadius() * (null == t ? void 0 : t.innerRadius)),
        (null == t ? void 0 : t.cornerRadius) &&
          (e.cornerRadius = () => this.computeLayoutRadius() * (null == t ? void 0 : t.cornerRadius)),
        e
      );
    }
    computeLayoutRadius() {
      const { width: t, height: e } = this._region.getLayoutRect();
      return Math.min(t / 2, e / 2);
    }
    computeCenter(t) {
      return { x: this._pieMark.getAttribute('x', t, 'normal'), y: this._pieMark.getAttribute('y', t, 'normal') };
    }
    generateLinePath(t) {
      const e = 'normal' === t ? 'POINT' : t.toUpperCase();
      return {
        path: t =>
          `M${Math.round(t[`${UV}_ARC_LABEL_${e}_AX`])},${Math.round(t[`${UV}_ARC_LABEL_${e}_AY`])} L${Math.round(
            t[sW]
          )},${Math.round(t[rW])} L${Math.round(t[aW])},${Math.round(t[oW])}`
      };
    }
    getRadius(t = 'normal') {
      var e, i, n, s, r, a, o;
      const l =
        'normal' === t
          ? null ===
              (n =
                null ===
                  (i = this.getSpec()[(null === (e = this._pieMark) || void 0 === e ? void 0 : e.name) || 'pie']) ||
                void 0 === i
                  ? void 0
                  : i.style) || void 0 === n
            ? void 0
            : n.outerRadius
          : null ===
              (o =
                null ===
                  (a =
                    null ===
                      (r = this.getSpec()[(null === (s = this._pieMark) || void 0 === s ? void 0 : s.name) || 'pie']) ||
                    void 0 === r
                      ? void 0
                      : r.state) || void 0 === a
                  ? void 0
                  : a[t]) || void 0 === o
          ? void 0
          : o.outerRadius;
      return null != l ? l : this._outerRadius;
    }
    getInnerRadius(t = 'normal') {
      var e, i, n, s, r, a, o;
      const l =
        'normal' === t
          ? null ===
              (n =
                null ===
                  (i = this.getSpec()[(null === (e = this._pieMark) || void 0 === e ? void 0 : e.name) || 'pie']) ||
                void 0 === i
                  ? void 0
                  : i.style) || void 0 === n
            ? void 0
            : n.innerRadius
          : null ===
              (o =
                null ===
                  (a =
                    null ===
                      (r = this.getSpec()[(null === (s = this._pieMark) || void 0 === s ? void 0 : s.name) || 'pie']) ||
                    void 0 === r
                      ? void 0
                      : r.state) || void 0 === a
                  ? void 0
                  : a[t]) || void 0 === o
          ? void 0
          : o.innerRadius;
      return null != l ? l : this._innerRadius;
    }
    getLabelConfig() {
      var t, e, i, n, s, r, a, o, l;
      return Object.assign(
        Object.assign(
          {
            visible: !0,
            position: 'outside',
            showRule: 'all',
            rotate: !0,
            coverEnable: !1,
            spaceWidth: 5,
            layoutArcGap: 6
          },
          this._spec.label
        ),
        {
          style: Object.assign({ visible: !0 }, null === (t = this._spec.label) || void 0 === t ? void 0 : t.style),
          line: Object.assign(
            {
              visible: !0,
              line1MinLength:
                null !==
                  (n =
                    null === (i = null === (e = this._spec.label) || void 0 === e ? void 0 : e.line) || void 0 === i
                      ? void 0
                      : i.line1MinLength) && void 0 !== n
                  ? n
                  : 20,
              line2MinLength:
                null !==
                  (a =
                    null === (r = null === (s = this._spec.label) || void 0 === s ? void 0 : s.line) || void 0 === r
                      ? void 0
                      : r.line2MinLength) && void 0 !== a
                  ? a
                  : 10
            },
            null === (o = this._spec.label) || void 0 === o ? void 0 : o.line
          ),
          layout: Object.assign(
            { align: 'arc', strategy: 'priority', tangentConstraint: !0 },
            null === (l = this._spec.label) || void 0 === l ? void 0 : l.layout
          )
        }
      );
    }
    computeRadius(t, e) {
      return this.computeLayoutRadius() * t * (l(e) ? 1 : e) + this._centerOffset;
    }
    computeDatumRadius(t, e) {
      return this.computeLayoutRadius() * this.getRadius(e) + this._centerOffset;
    }
    updateSpec(t) {
      const e = this._originalSpec,
        {
          centerX: i,
          centerY: n,
          centerOffset: s,
          radius: r,
          innerRadius: a,
          cornerRadius: o,
          startAngle: l,
          endAngle: h,
          padAngle: c
        } = e,
        d = super.updateSpec(t);
      return (
        ((null == t ? void 0 : t.centerX) === i &&
          (null == t ? void 0 : t.centerY) === n &&
          (null == t ? void 0 : t.centerOffset) === s &&
          (null == t ? void 0 : t.radius) === r &&
          (null == t ? void 0 : t.innerRadius) === a &&
          (null == t ? void 0 : t.cornerRadius) === o &&
          (null == t ? void 0 : t.startAngle) === l &&
          (null == t ? void 0 : t.endAngle) === h &&
          (null == t ? void 0 : t.padAngle) === c) ||
          ((d.reRender = !0), (d.change = !0)),
        d
      );
    }
    computeDatumInnerRadius(t, e) {
      return this.computeLayoutRadius() * this.getInnerRadius(e) + this._centerOffset;
    }
    dataToPosition(t) {
      const e = t[lW];
      if (l(e)) return null;
      const i = this.computeDatumRadius(t),
        n = this.computeCenter(t),
        s = YN({ angle: e, radius: i });
      return { x: n.x + s.x, y: n.y + s.y };
    }
    initAnimation() {
      var t, e;
      const i = {
          growFrom: (t, e, i) => {
            var n, s;
            if (i === RQ.appear) return this._startAngle;
            if (i === RQ.disappear) return this._endAngle;
            const r = [RQ.disappear, RQ.exit],
              a = e.mark.elements,
              o = t,
              l = null == o ? void 0 : o[Xq];
            if (
              void 0 ===
              a.find(t => {
                var e;
                return (null === (e = t.data[0]) || void 0 === e ? void 0 : e[Xq]) < l;
              })
            )
              return this._startAngle;
            if (
              void 0 ===
              a.find(t => {
                var e;
                return (null === (e = t.data[0]) || void 0 === e ? void 0 : e[Xq]) > l;
              })
            )
              return this._endAngle;
            const h = a.findLast(t => {
              var e;
              return (null === (e = t.data[0]) || void 0 === e ? void 0 : e[Xq]) < l;
            });
            return r.includes(i)
              ? null === (n = null == h ? void 0 : h.getGraphicItem().nextAttrs) || void 0 === n
                ? void 0
                : n.endAngle
              : null === (s = null == h ? void 0 : h.getGraphicItem().prevAttrs) || void 0 === s
              ? void 0
              : s.endAngle;
          }
        },
        n =
          null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
            ? void 0
            : e.preset;
      if (this._pieMark) {
        const t = w1(x1.pie(i, n), A1(LZ.pie, this._spec));
        t.normal &&
          t.normal.type &&
          (t.normal = (function (t, e) {
            var i, n, s, r;
            const a =
                null !== (n = null === (i = e.options) || void 0 === i ? void 0 : i.distance) && void 0 !== n ? n : 10,
              o = _(e.duration) ? e.duration / 2 : 1e3,
              l = null !== (s = e.options.easing) && void 0 !== s ? s : 'cubicOut';
            return {
              oneByOne: e.oneByOne,
              loop: null !== (r = e.loop) && void 0 !== r && r,
              timeSlices: [
                {
                  duration: o,
                  effects: {
                    easing: l,
                    channel: {
                      x: {
                        from: e => t.getAttribute('x', e),
                        to: e => t.getAttribute('x', e) + YN({ angle: e[lW], radius: a }).x
                      },
                      y: {
                        from: e => t.getAttribute('y', e),
                        to: e => t.getAttribute('y', e) + YN({ angle: e[lW], radius: a }).y
                      }
                    }
                  }
                },
                {
                  duration: o,
                  effects: {
                    easing: l,
                    channel: {
                      x: {
                        to: e => t.getAttribute('x', e),
                        from: e => t.getAttribute('x', e) + YN({ angle: e[lW], radius: a }).x
                      },
                      y: {
                        to: e => t.getAttribute('y', e),
                        from: e => t.getAttribute('y', e) + YN({ angle: e[lW], radius: a }).y
                      }
                    }
                  }
                }
              ]
            };
          })(this._pieMark, t.normal)),
          this._pieMark.setAnimationConfig(t);
      }
    }
    getDefaultShapeType() {
      return 'circle';
    }
    getGroupFields() {
      return [];
    }
    getStackGroupFields() {
      return [];
    }
    getStackValueField() {
      return '';
    }
    setValueFieldToStack() {}
    setValueFieldToPercent() {}
    _noAnimationDataKey(t, e) {
      return e;
    }
  }
  E5.mark = $Z;
  class P5 extends E5 {
    constructor() {
      super(...arguments), (this.type = DZ.pie);
    }
  }
  P5.type = DZ.pie;
  class R5 extends q3 {
    needAxes() {
      return !1;
    }
    _getDefaultSeriesSpec(t) {
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        categoryField: t.categoryField || t.seriesField,
        valueField: t.valueField || t.angleField,
        center: t.center,
        centerOffset: t.centerOffset,
        cornerRadius: t.cornerRadius,
        padAngle: t.padAngle
      });
    }
  }
  NQ.useSeries([P5]);
  class O5 extends R5 {
    constructor() {
      super(...arguments), (this.type = d2.pie), (this.seriesType = DZ.pie);
    }
  }
  (O5.type = d2.pie), (O5.view = 'singleDefault');
  class B5 extends h3 {
    constructor() {
      super(...arguments), (this.type = B5.type);
    }
  }
  (B5.type = jZ.arc3d), NQ.useMark([z3, i2, B5]);
  class I5 extends E5 {
    constructor() {
      super(...arguments), (this.type = DZ.pie3d), (this._pieMarkName = LZ.pie3d), (this._pieMarkType = jZ.arc3d);
    }
    setAttrFromSpec() {
      var t, e;
      super.setAttrFromSpec(),
        (this._angle3d =
          null !== (e = null === (t = this._spec) || void 0 === t ? void 0 : t.angle3d) && void 0 !== e
            ? e
            : -Math.PI / 3);
    }
    initMarkStyle() {
      var t, e, i, n, s, r, a, o;
      const l = this._pieMark;
      if (l) {
        this.setMarkStyle(
          l,
          {
            x: () => {
              var t, e;
              return null !== (e = null === (t = this._center) || void 0 === t ? void 0 : t.x) && void 0 !== e
                ? e
                : this._region.getLayoutRect().width / 2;
            },
            y: () => {
              var t, e;
              return null !== (e = null === (t = this._center) || void 0 === t ? void 0 : t.y) && void 0 !== e
                ? e
                : this._region.getLayoutRect().height / 2;
            },
            beta: () => this._angle3d,
            fill: this.getColorAttribute(),
            outerRadius: () => this.computeLayoutRadius() * this._outerRadius,
            innerRadius: () => this.computeLayoutRadius() * this._innerRadius,
            cornerRadius: () => this.computeLayoutRadius() * this._cornerRadius,
            startAngle: iV(eW).bind(this),
            endAngle: iV(iW).bind(this),
            padAngle: this._padAngle,
            centerOffset: this._centerOffset
          },
          'normal',
          Jq.Series
        );
        const e = this.getSpec()[l.name];
        if (e)
          for (const t in e.state || {}) this.setMarkStyle(l, this.generateRadiusStyle(e.state[t]), t, Jq.User_Mark);
        this._trigger.registerMark(l),
          null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(l);
      }
      const h = this._labelMark,
        c = this.getSpec(),
        d = {};
      (null === (e = null == c ? void 0 : c.label) || void 0 === e ? void 0 : e.support3d) &&
        ((d.beta = -Math.PI / 3),
        (d.anchor3d = t => {
          var e, i, n, s;
          return [
            (null !== (i = null === (e = this._center) || void 0 === e ? void 0 : e.x) && void 0 !== i
              ? i
              : this._region.getLayoutRect().width / 2) - iV(JV).bind(this)(t),
            (null !== (s = null === (n = this._center) || void 0 === n ? void 0 : n.y) && void 0 !== s
              ? s
              : this._region.getLayoutRect().height / 2) - iV(QV).bind(this)(t)
          ];
        })),
        h &&
          (this.setMarkStyle(
            h,
            Object.assign(
              {
                visible: iV(ZV).bind(this),
                x: iV(JV).bind(this),
                y: iV(QV).bind(this),
                text: iV(qV).bind(this),
                fill:
                  (null === (n = null === (i = this._spec.label) || void 0 === i ? void 0 : i.style) || void 0 === n
                    ? void 0
                    : n.fill) || this.getColorAttribute(),
                textAlign: iV(KV).bind(this),
                textBaseline:
                  'inside' === (null === (s = this._spec.label) || void 0 === s ? void 0 : s.position)
                    ? 'middle'
                    : 'top',
                angle: t => {
                  var e;
                  const i = t[lW];
                  return 'inside' === (null === (e = this._spec.label) || void 0 === e ? void 0 : e.position)
                    ? Zt(i)
                    : 0;
                },
                limit: iV(XV).bind(this)
              },
              d
            ),
            void 0,
            Jq.User_Mark
          ),
          this._trigger.registerMark(h));
      const u = this._labelLineMark;
      u &&
        (this.setMarkStyle(
          u,
          Object.assign(
            Object.assign(
              Object.assign(
                {
                  visible: iV(ZV).bind(this),
                  stroke:
                    (null ===
                      (o =
                        null === (a = null === (r = this._spec.label) || void 0 === r ? void 0 : r.line) || void 0 === a
                          ? void 0
                          : a.style) || void 0 === o
                      ? void 0
                      : o.stroke) || this.getColorAttribute(),
                  lineWidth: 1
                },
                this.generateLinePath('normal')
              ),
              d
            ),
            {
              anchor3d: () => {
                var t, e, i, n;
                return [
                  null !== (e = null === (t = this._center) || void 0 === t ? void 0 : t.x) && void 0 !== e
                    ? e
                    : this._region.getLayoutRect().width / 2,
                  null !== (n = null === (i = this._center) || void 0 === i ? void 0 : i.y) && void 0 !== n
                    ? n
                    : this._region.getLayoutRect().height / 2
                ];
              }
            }
          )
        ),
        this.setMarkStyle(u, this.generateLinePath('hover'), 'hover'),
        this.setMarkStyle(u, this.generateLinePath('selected'), 'selected'),
        this._trigger.registerMark(u));
    }
  }
  (I5.type = DZ.pie3d), (I5.mark = XZ), NQ.useSeries([I5]);
  class D5 extends R5 {
    constructor() {
      super(...arguments), (this.type = d2.pie3d), (this.seriesType = DZ.pie3d);
    }
    transformSpec(t) {
      super.transformSpec(t),
        t.series.forEach(e => {
          'pie3d' === e.type && (e.angle3d = t.angle3d);
        });
    }
  }
  (D5.type = d2.pie3d), (D5.view = 'singleDefault'), NQ.useMark([c3, N3]);
  class L5 extends j3 {
    constructor() {
      super(...arguments), (this.type = DZ.circularProgress), (this._progressMark = null), (this._trackMark = null);
    }
    getStackGroupFields() {
      return this.getGroupFields();
    }
    getGroupFields() {
      return this._radiusField;
    }
    initMark() {
      (this._trackMark = this._createMark(L5.mark.track)),
        (this._progressMark = this._createMark(L5.mark.progress, { isSeriesMark: !0 }));
    }
    initMarkStyle() {
      this.initTrackMarkStyle(), this.initProgressMarkStyle();
    }
    initProgressMarkStyle() {
      var t, e;
      const i = this._progressMark;
      i &&
        (this.setMarkStyle(i, {
          x: () => this.angleAxisHelper.center().x,
          y: () => this.angleAxisHelper.center().y,
          startAngle: this._getAngleValueStart.bind(this),
          endAngle: this._getAngleValueEnd.bind(this),
          innerRadius: this._getRadiusValueStart.bind(this),
          outerRadius: this._getRadiusValueEnd.bind(this),
          cap: null !== (t = this._spec.roundCap) && void 0 !== t && t,
          boundsMode: 'imprecise',
          cornerRadius: this._spec.cornerRadius,
          fill: this.getColorAttribute(),
          zIndex: 200,
          forceShowCap: !0
        }),
        this._trigger.registerMark(i),
        null === (e = this._tooltipHelper) || void 0 === e || e.activeTriggerSet.mark.add(i));
    }
    initTrackMarkStyle() {
      const t = this._trackMark;
      t &&
        (this.setMarkStyle(t, {
          visible: t => {
            const e = this.angleAxisHelper.getScale(0).range(),
              i = Math.min(e[0], e[e.length - 1]),
              n = this._getAngleValueStart(t);
            return Math.abs(n - i) <= 1e-14;
          },
          x: () => this.angleAxisHelper.center().x,
          y: () => this.angleAxisHelper.center().y,
          startAngle: this._startAngle,
          endAngle: this._endAngle,
          innerRadius: this._getRadiusValueStart.bind(this),
          outerRadius: this._getRadiusValueEnd.bind(this),
          cornerRadius: this._spec.cornerRadius,
          fill: this.getColorAttribute(),
          zIndex: 100
        }),
        this._trigger.registerMark(t));
    }
    _getRadiusValueStart(t) {
      if (this.getGroupFields().length > 1) {
        const e = this.radiusAxisHelper.dataToPosition(this.getDatumPositionValues(t, this.getGroupFields()));
        if (_(e)) return e;
      }
      return this.radiusAxisHelper.dataToPosition([t[this._radiusField[0]]]);
    }
    _getRadiusValueEnd(t) {
      var e, i;
      if (this.getGroupFields().length > 1) {
        const n =
          this.radiusAxisHelper.dataToPosition(this.getDatumPositionValues(t, this.getGroupFields())) +
          (null === (i = (e = this.radiusAxisHelper).getBandwidth) || void 0 === i
            ? void 0
            : i.call(e, this._groups ? this._groups.fields.length - 1 : 0));
        if (_(n)) return n;
      }
      return this.radiusAxisHelper.dataToPosition([t[this._radiusField[0]]]) + this.radiusAxisHelper.getScale(0).step();
    }
    initAnimation() {
      var t, e;
      const i =
        null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
          ? void 0
          : e.preset;
      this._progressMark.setAnimationConfig(
        w1(x1.circularProgress({ startAngle: this._startAngle }, i), A1(LZ.progress, this._spec))
      ),
        this._trackMark.setAnimationConfig(w1(x1.progressBackground(), A1(LZ.track, this._spec)));
    }
  }
  (L5.type = DZ.circularProgress), (L5.mark = ZZ), NQ.useSeries([L5]);
  class F5 extends Z3 {
    constructor() {
      super(...arguments), (this.type = d2.circularProgress), (this.seriesType = DZ.circularProgress);
    }
    _getDefaultSeriesSpec(t) {
      var e, i;
      const n = super._getDefaultSeriesSpec(t);
      return Object.assign(Object.assign({}, n), {
        cornerRadius: null !== (e = t.cornerRadius) && void 0 !== e ? e : 0,
        roundCap: null !== (i = t.roundCap) && void 0 !== i && i,
        progress: t.progress,
        background: t.background
      });
    }
    transformSpec(t) {
      super.transformSpec(t),
        this._transformProgressAxisSpec(t, { orient: 'angle', visible: !1 }, { orient: 'radius', visible: !1 });
    }
  }
  (F5.type = d2.circularProgress), (F5.view = 'singleDefault');
  class j5 extends z1 {
    getDefaultTooltipPattern(t, e) {
      const i = super.getDefaultTooltipPattern(t, e);
      return 'mark' === t ? i : 'dimension' === t ? ((i.visible = !1), i) : null;
    }
  }
  NQ.useMark([p2]);
  class z5 extends J1 {
    constructor() {
      super(...arguments),
        (this.type = DZ.linearProgress),
        (this._progressMark = null),
        (this._trackMark = null),
        (this._progressGroupMark = null);
    }
    initMark() {
      this.initProgressGroupMark(), this.initTrackMark(), this.initProgressMark();
    }
    initMarkStyle() {
      this.initProgressGroupMarkStyle(), this.initTrackMarkStyle(), this.initProgressMarkStyle();
    }
    initProgressMark() {
      return (
        (this._progressMark = this._createMark(z5.mark.progress, {
          isSeriesMark: !0,
          parent: this._progressGroupMark
        })),
        this._progressMark
      );
    }
    initProgressMarkStyle() {
      var t, e, i, n, s, r, a, o, l;
      const h = this._progressMark;
      if (h) {
        if ('vertical' === this._spec.direction) {
          const s =
              null !== (e = null === (t = this._spec.progress) || void 0 === t ? void 0 : t.leftPadding) && void 0 !== e
                ? e
                : 0,
            r =
              null !== (n = null === (i = this._spec.progress) || void 0 === i ? void 0 : i.rightPadding) &&
              void 0 !== n
                ? n
                : 0;
          this.setMarkStyle(h, {
            x: t => {
              var e, i;
              return (
                uV(
                  this.dataToPositionX(t),
                  null === (i = null === (e = this._xAxisHelper) || void 0 === e ? void 0 : e.getScale) || void 0 === i
                    ? void 0
                    : i.call(e, 0)
                ) -
                this._spec.bandWidth / 2 +
                s
              );
            },
            y: t => {
              var e, i;
              return uV(
                this.dataToPositionY(t),
                null === (i = null === (e = this._yAxisHelper) || void 0 === e ? void 0 : e.getScale) || void 0 === i
                  ? void 0
                  : i.call(e, 0)
              );
            },
            height: () => {
              var t;
              return null === (t = this._yAxisHelper) || void 0 === t
                ? void 0
                : t.dataToPosition([0], { bandPosition: this._bandPosition });
            },
            width: this._spec.bandWidth - s - r,
            cornerRadius: this._spec.cornerRadius,
            fill: this.getColorAttribute()
          });
        } else {
          const t =
              null !== (r = null === (s = this._spec.progress) || void 0 === s ? void 0 : s.topPadding) && void 0 !== r
                ? r
                : 0,
            e =
              null !== (o = null === (a = this._spec.progress) || void 0 === a ? void 0 : a.bottomPadding) &&
              void 0 !== o
                ? o
                : 0;
          this.setMarkStyle(h, {
            x: t => {
              var e, i;
              return (
                uV(
                  this.dataToPositionX(t),
                  null === (i = null === (e = this._xAxisHelper) || void 0 === e ? void 0 : e.getScale) || void 0 === i
                    ? void 0
                    : i.call(e, 0)
                ) - this._xAxisHelper.dataToPosition([1], { bandPosition: this._bandPosition })
              );
            },
            y: e => {
              var i, n;
              return (
                uV(
                  this.dataToPositionY(e),
                  null === (n = null === (i = this._yAxisHelper) || void 0 === i ? void 0 : i.getScale) || void 0 === n
                    ? void 0
                    : n.call(i, 0)
                ) -
                this._spec.bandWidth / 2 +
                t
              );
            },
            height: this._spec.bandWidth - t - e,
            width: () => {
              var t;
              return null === (t = this._xAxisHelper) || void 0 === t
                ? void 0
                : t.dataToPosition([1], { bandPosition: this._bandPosition });
            },
            cornerRadius: this._spec.cornerRadius,
            fill: this.getColorAttribute()
          });
        }
        this._trigger.registerMark(h),
          null === (l = this._tooltipHelper) || void 0 === l || l.activeTriggerSet.mark.add(h);
      }
    }
    initTrackMark() {
      return (this._trackMark = this._createMark(z5.mark.track, { parent: this._progressGroupMark })), this._trackMark;
    }
    initTrackMarkStyle() {
      var t, e, i, n, s;
      const r = this._trackMark;
      r &&
        ('vertical' === this._spec.direction
          ? this.setMarkStyle(r, {
              x: t => {
                var e, i;
                return (
                  uV(
                    this.dataToPositionX(t),
                    null === (i = null === (e = this._xAxisHelper) || void 0 === e ? void 0 : e.getScale) ||
                      void 0 === i
                      ? void 0
                      : i.call(e, 0)
                  ) -
                  this._spec.bandWidth / 2
                );
              },
              y: 0,
              width: this._spec.bandWidth,
              height: () => this._scaleY.range()[0],
              cornerRadius: this._spec.cornerRadius,
              fill:
                null === (e = null === (t = this._spec.track) || void 0 === t ? void 0 : t.style) || void 0 === e
                  ? void 0
                  : e.fill
            })
          : this.setMarkStyle(r, {
              x: 0,
              y: t => {
                var e, i;
                return (
                  uV(
                    this.dataToPositionY(t),
                    null === (i = null === (e = this._yAxisHelper) || void 0 === e ? void 0 : e.getScale) ||
                      void 0 === i
                      ? void 0
                      : i.call(e, 0)
                  ) -
                  this._spec.bandWidth / 2
                );
              },
              height: this._spec.bandWidth,
              width: () => this._scaleX.range()[1],
              cornerRadius: this._spec.cornerRadius,
              fill:
                null === (n = null === (i = this._spec.track) || void 0 === i ? void 0 : i.style) || void 0 === n
                  ? void 0
                  : n.fill
            }),
        this._trigger.registerMark(r),
        null === (s = this._tooltipHelper) || void 0 === s || s.activeTriggerSet.mark.add(r));
    }
    initProgressGroupMark() {
      return (
        (this._progressGroupMark = this._createMark(z5.mark.group, { skipBeforeLayouted: !1 })), this._progressGroupMark
      );
    }
    initProgressGroupMarkStyle() {
      const t = this._progressGroupMark;
      t.setZIndex(this.layoutZIndex),
        t.created(),
        this.setMarkStyle(
          t,
          {
            clip: !0,
            x: 0,
            y: 0,
            path: () => {
              var t;
              const e = [];
              return (
                null === (t = this._rawData) ||
                  void 0 === t ||
                  t.rawData.forEach((t, i) => {
                    var n, s, r, a;
                    if ('vertical' === this._spec.direction) {
                      const i =
                          uV(
                            this.dataToPositionX(t),
                            null === (s = null === (n = this._xAxisHelper) || void 0 === n ? void 0 : n.getScale) ||
                              void 0 === s
                              ? void 0
                              : s.call(n, 0)
                          ) -
                          this._spec.bandWidth / 2,
                        r = this._scaleY.range()[0];
                      e.push(
                        iB({
                          x: i,
                          y: 0,
                          height: r,
                          width: this._spec.bandWidth,
                          cornerRadius: this._spec.cornerRadius,
                          fill: !0
                        })
                      );
                    } else {
                      const i =
                          uV(
                            this.dataToPositionY(t),
                            null === (a = null === (r = this._yAxisHelper) || void 0 === r ? void 0 : r.getScale) ||
                              void 0 === a
                              ? void 0
                              : a.call(r, 0)
                          ) -
                          this._spec.bandWidth / 2,
                        n = this._scaleX.range()[1];
                      e.push(
                        iB({
                          x: 0,
                          y: i,
                          height: this._spec.bandWidth,
                          width: n,
                          cornerRadius: this._spec.cornerRadius,
                          fill: !0
                        })
                      );
                    }
                  }),
                e
              );
            }
          },
          'normal',
          Jq.Series
        ),
        this._progressGroupMark.setInteractive(!1);
    }
    initAnimation() {
      var t, e;
      const i = { direction: this.direction },
        n =
          null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
            ? void 0
            : e.preset;
      this._progressMark.setAnimationConfig(w1(x1.linearProgress(i, n), A1(LZ.progress, this._spec))),
        this._trackMark.setAnimationConfig(w1(x1.progressBackground(), A1(LZ.track, this._spec)));
    }
    initTooltip() {
      this._tooltipHelper = new j5(this);
    }
  }
  (z5.type = DZ.linearProgress), (z5.mark = nJ), NQ.useSeries([z5]);
  class H5 extends c2 {
    constructor() {
      super(...arguments), (this.type = d2.linearProgress), (this.seriesType = DZ.linearProgress);
    }
    needAxes() {
      return !1;
    }
    _getDefaultSeriesSpec(t) {
      var e, i;
      const n = super._getDefaultSeriesSpec(t);
      return Object.assign(Object.assign({}, n), {
        direction: null !== (e = t.direction) && void 0 !== e ? e : 'horizontal',
        cornerRadius: null !== (i = t.cornerRadius) && void 0 !== i ? i : 0,
        bandWidth: t.bandWidth,
        progress: t.progress,
        track: t.track
      });
    }
    transformSpec(t) {
      var e, i;
      if ((super.transformSpec(t), t.axes || (t.axes = []), 'vertical' === t.direction)) {
        let i = null,
          n = null;
        (null !== (e = t.axes) && void 0 !== e ? e : []).forEach(t => {
          const { orient: e } = t;
          'left' === e && (i = t), 'bottom' === e && (n = t);
        }),
          i || ((i = { orient: 'left', visible: !1 }), t.axes.push(i)),
          n || ((n = { orient: 'bottom', visible: !1 }), t.axes.push(n)),
          l(n.type) && (n.type = 'band'),
          l(i.type) && (i.type = 'linear');
        const s = U3(i, { min: 0, max: 1 });
        l(i.min) && (i.min = s.min), l(i.max) && (i.max = s.max);
      } else {
        let e = null,
          n = null;
        (null !== (i = t.axes) && void 0 !== i ? i : []).forEach(t => {
          const { orient: i } = t;
          'left' === i && (e = t), 'bottom' === i && (n = t);
        }),
          e || ((e = { type: 'band', orient: 'left', visible: !1 }), t.axes.push(e)),
          n || ((n = { orient: 'bottom', visible: !1 }), t.axes.push(n)),
          l(n.type) && (n.type = 'linear'),
          l(e.type) && (e.type = 'band');
        const s = U3(n, { min: 0, max: 1 });
        l(n.min) && (n.min = s.min), l(n.max) && (n.max = s.max);
      }
    }
  }
  (H5.type = d2.linearProgress), (H5.view = 'singleDefault');
  class N5 extends F3 {
    getStackGroupFields() {
      return this._angleField;
    }
    getStackValueField() {
      return V(this._spec.valueField)[0] || V(this._spec.radiusField)[0];
    }
    getGroupFields() {
      return this._angleField;
    }
    setAttrFromSpec() {
      super.setAttrFromSpec(),
        this.setAngleField(this._spec.categoryField || this._spec.angleField),
        this.setRadiusField(this._spec.valueField || this._spec.radiusField),
        this.setInnerRadiusField(this._spec.valueField || this._spec.radiusField),
        this._stack && this.setValueFieldToStack(),
        this._percent && this.setValueFieldToPercent();
    }
    setValueFieldToStack() {
      this.setRadiusField(tZ), this.setInnerRadiusField(Qq);
    }
    setValueFieldToPercent() {
      this.setRadiusField(iZ), this.setInnerRadiusField(eZ);
    }
    getDimensionField() {
      return this._angleField;
    }
    getMeasureField() {
      return this._radiusField;
    }
    getDefaultShapeType() {
      return 'square';
    }
    setValueFieldToStackOffsetSilhouette() {}
  }
  NQ.useMark([e2, t2, s2, i2]);
  class V5 extends N5 {
    constructor() {
      super(...arguments), (this.type = DZ.radar), (this._sortDataByAxis = !1);
    }
    initGroups() {}
    initMark() {
      var t, e, i, n;
      const s = {
          progressiveStep: this._spec.progressiveStep,
          progressiveThreshold: this._spec.progressiveThreshold,
          large: this._spec.large,
          largeThreshold: this._spec.largeThreshold
        },
        r =
          !1 !== (null === (t = this._spec.area) || void 0 === t ? void 0 : t.visible) &&
          !1 !==
            (null === (i = null === (e = this._spec.area) || void 0 === e ? void 0 : e.style) || void 0 === i
              ? void 0
              : i.visible),
        a = null !== (n = this._spec.seriesMark) && void 0 !== n ? n : 'area';
      this.initAreaMark(s, r && 'area' === a),
        this.initLineMark(s, 'line' === a || ('area' === a && !r)),
        this.initSymbolMark(s, 'point' === a);
    }
    initMarkStyle() {
      this.initAreaMarkStyle(), this.initLineMarkStyle(), this.initSymbolMarkStyle();
    }
    initAreaMark(t, e) {
      this._areaMark = this._createMark(V5.mark.area, { progressive: t, isSeriesMark: e });
    }
    initAreaMarkStyle() {
      var t;
      const e = this._areaMark;
      e &&
        (this.setMarkStyle(
          e,
          {
            x: this.dataToPositionX.bind(this),
            y: this.dataToPositionY.bind(this),
            x1: t =>
              t && this.angleAxisHelper && this.radiusAxisHelper
                ? this.valueToPosition(
                    this.getDatumPositionValues(t, this._angleField),
                    this._stack ? this.getDatumPositionValues(t, this._innerRadiusField) : this.radiusScale.domain()[0]
                  ).x
                : Number.NaN,
            y1: t => {
              if (!t || !this.angleAxisHelper || !this.radiusAxisHelper) return Number.NaN;
              return this.valueToPosition(
                this.getDatumPositionValues(t, this._angleField),
                this._stack ? this.getDatumPositionValues(t, this._innerRadiusField) : this.radiusScale.domain()[0]
              ).y;
            },
            fill: this.getColorAttribute(),
            curveType: qJ
          },
          'normal',
          Jq.Series
        ),
        this._trigger.registerMark(e),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.dimension.add(e));
    }
    initAnimation() {
      var t, e, i;
      const n = {
          center: () => {
            var t;
            return null === (t = this.angleAxisHelper) || void 0 === t ? void 0 : t.center();
          },
          radius: () => {
            const t = this.getLayoutRect();
            return Math.min(t.width, t.height);
          },
          startAngle: h(this._spec.startAngle) ? qt(this._spec.startAngle) : dW,
          pointToCoord: t => {
            var e;
            return null === (e = this.angleAxisHelper) || void 0 === e ? void 0 : e.pointToCoord(t);
          },
          coordToPoint: t => this.angleAxisHelper.coordToPoint(t)
        },
        s =
          null !==
            (i =
              null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
                ? void 0
                : e.preset) && void 0 !== i
            ? i
            : 'clipIn';
      'clipIn' === s &&
        this._rootMark &&
        this._rootMark.setAnimationConfig(w1(x1.radarGroup(n, s), A1(LZ.group, this._spec)));
      [
        [this._areaMark, 'radar'],
        [this._lineMark, 'radar'],
        [this._symbolMark, 'radarSymbol']
      ].forEach(([t, e]) => {
        if (h(t)) {
          const i = x1[e];
          t.setAnimationConfig(w1(i(n, s), A1(t.name, this._spec)));
        }
      });
    }
    getDefaultShapeType() {
      return 'square';
    }
  }
  (V5.type = DZ.radar), (V5.mark = YZ), N(V5, E1);
  class W5 extends q3 {
    needAxes() {
      return !0;
    }
    _getDefaultSeriesSpec(t) {
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        categoryField: t.categoryField || t.angleField,
        valueField: t.valueField || t.radiusField
      });
    }
    transformSpec(t) {
      var e;
      if ((super.transformSpec(t), this.needAxes())) {
        t.axes || (t.axes = []);
        const i = { radius: !1, angle: !1 };
        (null !== (e = t.axes) && void 0 !== e ? e : []).forEach(t => {
          const { orient: e } = t;
          'radius' === e && (i.radius = !0), 'angle' === e && (i.angle = !0);
        }),
          i.angle || t.axes.push({ orient: 'angle' }),
          i.radius || t.axes.push({ orient: 'radius' });
      }
    }
  }
  NQ.useSeries([V5]);
  class G5 extends W5 {
    constructor() {
      super(...arguments), (this.type = d2.radar), (this.seriesType = DZ.radar);
    }
    _getDefaultSeriesSpec(t) {
      var e;
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        seriesField: t.seriesField,
        line: t.line,
        point: t.point,
        stack: t.stack,
        percent: t.percent,
        area: _J({ visible: !1 }, t.area),
        seriesMark: null !== (e = t.seriesMark) && void 0 !== e ? e : 'area',
        activePoint: t.activePoint
      });
    }
    transformSpec(t) {
      var e;
      super.transformSpec(t),
        (null !== (e = t.axes) && void 0 !== e ? e : []).forEach(t => {
          'radius' === t.orient &&
            (['domainLine', 'label', 'tick'].forEach(e => {
              t[e] || (t[e] = { visible: !1 });
            }),
            t.grid || (t.grid = { visible: !0, smooth: !0 }));
        }),
        (t.crosshair = V(t.crosshair || {}).map(t =>
          _J({ categoryField: { visible: !0, line: { visible: !0, type: 'line' } } }, t)
        ));
    }
  }
  (G5.type = d2.radar), (G5.view = 'singleDefault');
  class U5 extends z1 {
    getDefaultTooltipPattern(t, e) {
      if ('mark' === t)
        return {
          visible: !0,
          activeType: t,
          title: { key: void 0, value: this.titleValueCallback, hasShape: !1 },
          content: [
            {
              key: this.contentKeyCallback,
              value: this.contentValueCallback,
              hasShape: !0,
              shapeType: this.contentShapeTypeCallback,
              shapeColor: this.contentShapeColorCallback,
              shapeHollow: !1
            }
          ]
        };
      if ('dimension' === t && e) {
        const i = { key: void 0, value: this._getDimensionData, hasShape: !1 },
          n = [];
        return (
          e.forEach(({ data: t }) =>
            t.forEach(({ series: t }) => {
              'rangeArea' === t.type &&
                n.push({
                  seriesId: t.id,
                  key: this.contentKeyCallback,
                  value: t =>
                    this.series.getSpec().direction === JJ.horizontal
                      ? t[this.series.getSpec().xField[0]] + '-' + t[this.series.getSpec().xField[1]]
                      : t[this.series.getSpec().yField[0]] + '-' + t[this.series.getSpec().yField[1]],
                  hasShape: !0,
                  shapeType: this.contentShapeTypeCallback,
                  shapeColor: this.contentShapeColorCallback,
                  shapeHollow: !1
                });
            })
          ),
          { visible: !0, activeType: t, title: i, content: n }
        );
      }
      return null;
    }
  }
  const Y5 = Object.assign({}, UZ);
  class $5 extends a2 {
    constructor() {
      super(...arguments), (this.type = DZ.rangeArea);
    }
    initMark() {
      this._areaMark = this._createMark($5.mark.area, {
        defaultMorphElementKey: this.getDimensionField()[0],
        groupKey: this._seriesField,
        isSeriesMark: !0
      });
    }
    initMarkStyle() {
      var t, e, i, n, s;
      const r =
          null !==
            (i =
              null === (e = null === (t = this.getSpec().area) || void 0 === t ? void 0 : t.style) || void 0 === e
                ? void 0
                : e.curveType) && void 0 !== i
            ? i
            : null === (s = null === (n = this.getSpec().line) || void 0 === n ? void 0 : n.style) || void 0 === s
            ? void 0
            : s.curveType,
        a = r === KJ ? (this._direction === JJ.vertical ? 'monotoneX' : 'monotoneY') : r,
        o = this._areaMark;
      o &&
        (this._direction === JJ.vertical
          ? this.setMarkStyle(
              this._areaMark,
              {
                x: this.dataToPositionX.bind(this),
                y1: t => {
                  if (!this._yAxisHelper) return Number.NaN;
                  const { dataToPosition: e } = this._yAxisHelper;
                  return e(this.getDatumPositionValues(t, this._spec.yField[1]), { bandPosition: this._bandPosition });
                },
                y: this.dataToPositionY.bind(this)
              },
              'normal',
              Jq.Series
            )
          : this.setMarkStyle(
              this._areaMark,
              {
                x: this.dataToPositionX.bind(this),
                x1: t => {
                  if (!this._xAxisHelper) return Number.NaN;
                  const { dataToPosition: e } = this._xAxisHelper;
                  return e(this.getDatumPositionValues(t, this._spec.xField[1]), { bandPosition: this._bandPosition });
                },
                y: this.dataToPositionY.bind(this),
                orient: this._direction
              },
              'normal',
              Jq.Series
            ),
        this.setMarkStyle(o, { fill: this.getColorAttribute(), stroke: !1 }, 'normal', Jq.Series),
        'zero' !== this._invalidType &&
          this.setMarkStyle(
            o,
            { defined: this._getInvalidDefined, connectedType: this._getInvalidConnectType() },
            'normal',
            Jq.Series
          ),
        this.setMarkStyle(o, { curveType: a }, 'normal', Jq.Built_In),
        this._trigger.registerMark(o),
        this._tooltipHelper.activeTriggerSet.dimension.add(o));
    }
    initTooltip() {
      this._tooltipHelper = new U5(this);
    }
    viewDataStatisticsUpdate(t) {
      super.viewDataStatisticsUpdate(t), this.encodeDefined(this._areaMark, 'defined');
    }
  }
  ($5.type = DZ.rangeArea), ($5.mark = Y5), NQ.useSeries([$5]);
  class X5 extends c2 {
    constructor() {
      super(...arguments), (this.type = d2.rangeArea), (this.seriesType = DZ.rangeArea);
    }
    _getDefaultSeriesSpec(t) {
      var e, i;
      const n = Object.assign({}, super._getDefaultSeriesSpec(t));
      return (
        (n.area = t.area),
        t.direction === JJ.horizontal
          ? (n.xField = null !== (e = t.xField) && void 0 !== e ? e : [t.minField, t.maxField])
          : (n.yField = null !== (i = t.yField) && void 0 !== i ? i : [t.minField, t.maxField]),
        (n.stack = !1),
        n
      );
    }
    transformSpec(t) {
      super.transformSpec(t), zQ(t);
    }
  }
  function K5(t, e, i, n, s, r, a, o, l) {
    t.setMarkStyle(e, {
      textAlign: t => {
        if (l() === JJ.vertical) return 'center';
        const e = s(t),
          n = r(t);
        if ('middle' === i) return 'center';
        if (e >= n) {
          if ('start' === i) return 'left';
          if ('end' === i) return 'right';
          if ('outside' === i) return 'left';
        } else {
          if ('start' === i) return 'right';
          if ('end' === i) return 'left';
          if ('outside' === i) return 'right';
        }
        return 'center';
      },
      textBaseline: t => {
        if (l() === JJ.horizontal) return 'middle';
        const e = a(t),
          n = o(t);
        if ('middle' === i) return 'middle';
        if (n >= e) {
          if ('start' === i) return 'bottom';
          if ('end' === i) return 'top';
          if ('outside' === i) return 'bottom';
        } else {
          if ('start' === i) return 'top';
          if ('end' === i) return 'bottom';
          if ('outside' === i) return 'top';
        }
        return 'middle';
      }
    }),
      t.setMarkStyle(
        e,
        {
          x: t => {
            const e = l(),
              a = s(t),
              o = r(t);
            if (e === JJ.vertical) return (a + o) / 2;
            if ('middle' === i) return (a + o) / 2;
            if (a >= o) {
              if ('start' === i) return o + n;
              if ('end' === i) return a - n;
              if ('outside' === i) return a + n;
            } else {
              if ('start' === i) return o - n;
              if ('end' === i) return a + n;
              if ('outside' === i) return a - n;
            }
            return (a + o) / 2;
          },
          y: t => {
            const e = l(),
              s = a(t),
              r = o(t);
            if (e === JJ.horizontal) return (s + r) / 2;
            if ('middle' === i) return (s + r) / 2;
            if (s >= r) {
              if ('start' === i) return r + n;
              if ('end' === i) return s - n;
              if ('outside' === i) return s + n;
            } else {
              if ('start' === i) return r - n;
              if ('end' === i) return s + n;
              if ('outside' === i) return s - n;
            }
            return (s + r) / 2;
          }
        },
        'normal',
        Jq.Series
      );
  }
  (X5.type = d2.rangeArea), (X5.view = 'singleDefault');
  class q5 extends z1 {
    getDefaultTooltipPattern(t) {
      return {
        visible: !0,
        activeType: t,
        title: { key: void 0, value: this.titleValueCallback, hasShape: !1 },
        content: [
          {
            key: this.contentKeyCallback,
            value: t =>
              this.series.getSpec().direction === JJ.horizontal
                ? t[this.series.getSpec().xField[0]] + '-' + t[this.series.getSpec().xField[1]]
                : t[this.series.getSpec().yField[0]] + '-' + t[this.series.getSpec().yField[1]],
            hasShape: !0,
            shapeType: this.contentShapeTypeCallback,
            shapeColor: this.contentShapeColorCallback,
            shapeHollow: !1
          }
        ]
      };
    }
  }
  class Z5 extends g2 {
    constructor() {
      super(...arguments),
        (this.type = DZ.rangeColumn),
        (this._barMarkType = jZ.rect),
        (this._barName = DZ.bar),
        (this._stack = !1);
    }
    initMark() {
      var t, e, i, n, s, r, a, o;
      const l = null === (t = this._spec.label) || void 0 === t ? void 0 : t.position;
      (this._rectMark = this._createMark(Z5.mark.bar, {
        morph: T1(this._spec.animation, this._spec.morph, A1('bar', this._spec)),
        defaultMorphElementKey: this.getDimensionField()[0],
        groupKey: this._seriesField,
        label: l === fZ.bothEnd ? void 0 : _J({}, this._spec.label),
        isSeriesMark: !0
      })),
        !1 !== (null === (e = this._spec.label) || void 0 === e ? void 0 : e.visible) &&
          l === fZ.bothEnd &&
          (!1 !==
            (null === (n = null === (i = this._spec.label) || void 0 === i ? void 0 : i.minLabel) || void 0 === n
              ? void 0
              : n.visible) &&
            (this._minLabelMark = this._createMark(Z5.mark.minLabel, {
              markSpec: null === (s = this._spec.label) || void 0 === s ? void 0 : s.minLabel
            })),
          !1 !==
            (null === (a = null === (r = this._spec.label) || void 0 === r ? void 0 : r.maxLabel) || void 0 === a
              ? void 0
              : a.visible) &&
            (this._maxLabelMark = this._createMark(Z5.mark.maxLabel, {
              markSpec: null === (o = this._spec.label) || void 0 === o ? void 0 : o.maxLabel
            })));
    }
    initMarkStyle() {
      var t, e, i, n, s, r, a, o, l, h, c, d;
      super.initMarkStyle();
      const u = this._minLabelMark,
        p = null === (t = this._spec.label) || void 0 === t ? void 0 : t.minLabel;
      if (u) {
        this.setMarkStyle(u, {
          fill:
            null !== (i = null === (e = null == p ? void 0 : p.style) || void 0 === e ? void 0 : e.fill) && void 0 !== i
              ? i
              : this.getColorAttribute(),
          text: t => {
            const e = this._spec.direction === JJ.horizontal ? t[this._spec.xField[0]] : t[this._spec.yField[0]];
            return (null == p ? void 0 : p.formatMethod) ? p.formatMethod(e, t) : e;
          }
        });
        K5(
          this,
          u,
          null !== (n = null == p ? void 0 : p.position) && void 0 !== n ? n : 'end',
          null !== (s = null == p ? void 0 : p.offset) && void 0 !== s ? s : 'vertical' === this._direction ? -20 : -25,
          t => this._rectMark.getAttribute('x', t),
          t =>
            'vertical' === this._direction
              ? this._rectMark.getAttribute('x', t) + this._rectMark.getAttribute('width', t)
              : this._rectMark.getAttribute('x1', t),
          t => this._rectMark.getAttribute('y', t),
          t =>
            'vertical' === this._direction
              ? this._rectMark.getAttribute('y1', t)
              : this._rectMark.getAttribute('y', t) + this._rectMark.getAttribute('height', t),
          () => this._direction
        ),
          null === (r = this._tooltipHelper) || void 0 === r || r.ignoreTriggerSet.mark.add(u);
      }
      const g = this._maxLabelMark,
        f = null === (a = this._spec.label) || void 0 === a ? void 0 : a.maxLabel;
      if (g) {
        this.setMarkStyle(g, {
          fill:
            null !== (l = null === (o = null == f ? void 0 : f.style) || void 0 === o ? void 0 : o.fill) && void 0 !== l
              ? l
              : this.getColorAttribute(),
          text: t => {
            const e = this._spec.direction === JJ.horizontal ? t[this._spec.xField[1]] : t[this._spec.yField[1]];
            return (null == f ? void 0 : f.formatMethod) ? f.formatMethod(e, t) : e;
          }
        });
        K5(
          this,
          g,
          null !== (h = null == f ? void 0 : f.position) && void 0 !== h ? h : 'start',
          null !== (c = null == f ? void 0 : f.offset) && void 0 !== c ? c : 'vertical' === this._direction ? -20 : -25,
          t => this._rectMark.getAttribute('x', t),
          t =>
            'vertical' === this._direction
              ? this._rectMark.getAttribute('x', t) + this._rectMark.getAttribute('width', t)
              : this._rectMark.getAttribute('x1', t),
          t => this._rectMark.getAttribute('y', t),
          t =>
            'vertical' === this._direction
              ? this._rectMark.getAttribute('y1', t)
              : this._rectMark.getAttribute('y', t) + this._rectMark.getAttribute('height', t),
          () => this._direction
        ),
          null === (d = this._tooltipHelper) || void 0 === d || d.ignoreTriggerSet.mark.add(g);
      }
    }
    initLabelMarkStyle(t) {
      var e;
      t &&
        (this.setMarkStyle(t, {
          text: t => {
            let e, i;
            return (
              this._spec.direction === JJ.horizontal
                ? ((e = t[this._spec.xField[0]]), (i = t[this._spec.xField[1]]))
                : ((e = t[this._spec.yField[0]]), (i = t[this._spec.yField[1]])),
              e + '-' + i
            );
          },
          z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }),
        null === (e = this._tooltipHelper) || void 0 === e || e.ignoreTriggerSet.mark.add(t));
    }
    initBandRectMarkStyle() {
      var t, e, i, n;
      const s =
          null === (e = null === (t = this._xAxisHelper) || void 0 === t ? void 0 : t.getScale) || void 0 === e
            ? void 0
            : e.call(t, 0),
        r =
          null === (n = null === (i = this._yAxisHelper) || void 0 === i ? void 0 : i.getScale) || void 0 === n
            ? void 0
            : n.call(i, 0),
        { dataToPosition: a } = this.direction === JJ.horizontal ? this._xAxisHelper : this._yAxisHelper;
      this.direction === JJ.horizontal
        ? this.setMarkStyle(
            this._rectMark,
            {
              x: t =>
                uV(a(this.getDatumPositionValues(t, this._spec.xField[0]), { bandPosition: this._bandPosition }), s),
              x1: t =>
                uV(a(this.getDatumPositionValues(t, this._spec.xField[1]), { bandPosition: this._bandPosition }), s),
              y: t => this._getPosition(this.direction, t),
              height: () => this._getBarWidth(this._yAxisHelper)
            },
            'normal',
            Jq.Series
          )
        : this.setMarkStyle(
            this._rectMark,
            {
              x: t => this._getPosition(this.direction, t),
              y: t =>
                uV(a(this.getDatumPositionValues(t, this._spec.yField[0]), { bandPosition: this._bandPosition }), r),
              y1: t =>
                uV(a(this.getDatumPositionValues(t, this._spec.yField[1]), { bandPosition: this._bandPosition }), r),
              width: () => this._getBarWidth(this._xAxisHelper)
            },
            'normal',
            Jq.Series
          );
    }
    initAnimation() {
      var t, e;
      const i = t => {
          var e, i, n;
          const s = null == t ? void 0 : t[this._fieldX[0]];
          return (
            (null ===
              (n =
                null === (i = null === (e = this._viewDataStatistics) || void 0 === e ? void 0 : e.latestData) ||
                void 0 === i
                  ? void 0
                  : i[this._fieldX[0]]) || void 0 === n
              ? void 0
              : n.values.indexOf(s)) || 0
          );
        },
        n =
          null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
            ? void 0
            : e.preset;
      this._rectMark.setAnimationConfig(
        w1(x1.rangeColumn({ direction: this.direction }, n), A1(LZ.bar, this._spec), { dataIndex: i })
      ),
        this._minLabelMark &&
          this._minLabelMark.setAnimationConfig(w1(x1.label(), A1(LZ.label, this._spec), { dataIndex: i })),
        this._maxLabelMark &&
          this._maxLabelMark.setAnimationConfig(w1(x1.label(), A1(LZ.label, this._spec), { dataIndex: i }));
    }
    initTooltip() {
      this._tooltipHelper = new q5(this);
    }
  }
  (Z5.type = DZ.rangeColumn), (Z5.mark = dJ), NQ.useSeries([Z5]);
  class J5 extends c2 {
    constructor() {
      super(...arguments), (this.type = d2.rangeColumn), (this.seriesType = DZ.rangeColumn);
    }
    _getDefaultSeriesSpec(t) {
      var e, i;
      const n = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), { barGapInGroup: t.barGapInGroup });
      return (
        (n.bar = t.bar),
        t.direction === JJ.horizontal
          ? (n.xField = null !== (e = t.xField) && void 0 !== e ? e : [t.minField, t.maxField])
          : (n.yField = null !== (i = t.yField) && void 0 !== i ? i : [t.minField, t.maxField]),
        n
      );
    }
    transformSpec(t) {
      super.transformSpec(t), zQ(t);
    }
  }
  (J5.type = d2.rangeColumn), (J5.view = 'singleDefault'), NQ.useMark([v2]);
  class Q5 extends Z5 {
    constructor() {
      super(...arguments), (this.type = DZ.rangeColumn3d), (this._barMarkType = jZ.rect3d), (this._barName = DZ.bar3d);
    }
  }
  (Q5.type = DZ.rangeColumn3d), (Q5.mark = uJ), NQ.useSeries([Q5]);
  class t4 extends c2 {
    constructor() {
      super(...arguments), (this.type = d2.rangeColumn3d), (this.seriesType = DZ.rangeColumn3d);
    }
    _getDefaultSeriesSpec(t) {
      var e, i;
      const n = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), { barGapInGroup: t.barGapInGroup });
      return (
        (n.bar3d = t.bar3d),
        t.direction === JJ.horizontal
          ? (n.xField = null !== (e = t.xField) && void 0 !== e ? e : [t.minField, t.maxField])
          : (n.yField = null !== (i = t.yField) && void 0 !== i ? i : [t.minField, t.maxField]),
        n
      );
    }
  }
  (t4.type = d2.rangeColumn3d), (t4.view = 'singleDefault'), NQ.useMark([c3, i2]);
  class e4 extends N5 {
    constructor() {
      super(...arguments), (this.type = DZ.rose), (this._stack = !0), (this._roseMark = null), (this._labelMark = null);
    }
    initMark() {
      this.initRoseMark();
    }
    initMarkStyle() {
      this.initRoseMarkStyle();
    }
    initRoseMark() {
      this._roseMark = this._createMark(e4.mark.rose, {
        morph: T1(this._spec.animation, this._spec.morph, A1('rose', this._spec)),
        defaultMorphElementKey: this.getDimensionField()[0],
        groupKey: this._seriesField,
        isSeriesMark: !0,
        label: _J({ animation: this._spec.animation }, this._spec.label)
      });
    }
    getRoseAngle() {
      var t, e, i;
      return null !==
        (i =
          null === (e = (t = this.angleAxisHelper).getBandwidth) || void 0 === e
            ? void 0
            : e.call(t, this._groups ? this._groups.fields.length - 1 : 0)) && void 0 !== i
        ? i
        : 0.5;
    }
    initRoseMarkStyle() {
      var t;
      const e = this._roseMark;
      e &&
        (this.setMarkStyle(e, {
          x: () => this.angleAxisHelper.center().x,
          y: () => this.angleAxisHelper.center().y,
          startAngle: t =>
            this.angleAxisHelper.dataToPosition(this.getDatumPositionValues(t, this.getGroupFields())) -
            0.5 * this.angleAxisHelper.getBandwidth(0),
          endAngle: t =>
            this.angleAxisHelper.dataToPosition(this.getDatumPositionValues(t, this.getGroupFields())) +
            this.getRoseAngle() -
            0.5 * this.angleAxisHelper.getBandwidth(0),
          fill: this.getColorAttribute(),
          outerRadius: t =>
            uV(this.radiusAxisHelper.dataToPosition([t[this._radiusField[0]]]), this.radiusAxisHelper.getScale(0)),
          innerRadius: t => {
            var e;
            if (!this._stack) return 0;
            const i = uV(
              this.radiusAxisHelper.dataToPosition([t[this._innerRadiusField[0]]]),
              this.radiusAxisHelper.getScale(0)
            );
            return i <= Number.MIN_VALUE
              ? this._computeLayoutRadius() * (null !== (e = this._spec.innerRadius) && void 0 !== e ? e : 0)
              : i;
          }
        }),
        this._trigger.registerMark(e),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(e));
    }
    initLabelMarkStyle(t) {
      var e, i, n, s, r, a, o, l;
      t &&
        this.setMarkStyle(t, {
          visible:
            null === (i = null === (e = this._spec) || void 0 === e ? void 0 : e.label) || void 0 === i
              ? void 0
              : i.visible,
          text: t => t[this.getDimensionField()[0]],
          fill:
            (null === (s = null === (n = this._spec.label) || void 0 === n ? void 0 : n.style) || void 0 === s
              ? void 0
              : s.fill) || this.getColorAttribute(),
          angle:
            null === (a = null === (r = this._spec.label) || void 0 === r ? void 0 : r.style) || void 0 === a
              ? void 0
              : a.angle,
          limit:
            null === (l = null === (o = this._spec.label) || void 0 === o ? void 0 : o.style) || void 0 === l
              ? void 0
              : l.limit,
          z: 0
        });
    }
    initAnimation() {
      var t, e;
      const i =
        null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
          ? void 0
          : e.preset;
      if (this._roseMark) {
        const t = {
          innerRadius: () => {
            var t;
            return this._computeLayoutRadius() * (null !== (t = this._spec.innerRadius) && void 0 !== t ? t : 0);
          }
        };
        this._roseMark.setAnimationConfig(w1(x1.rose(t, i), A1(LZ.rose, this._spec)));
      }
    }
    getDefaultShapeType() {
      return 'circle';
    }
  }
  (e4.type = DZ.rose), (e4.mark = KZ), NQ.useSeries([e4]);
  class i4 extends W5 {
    constructor() {
      super(...arguments), (this.type = d2.rose), (this.seriesType = DZ.rose);
    }
    _getDefaultSeriesSpec(t) {
      var e, i, n;
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        radius: null !== (e = t.radius) && void 0 !== e ? e : fW,
        outerRadius: null !== (i = t.outerRadius) && void 0 !== i ? i : fW,
        innerRadius: null !== (n = t.innerRadius) && void 0 !== n ? n : 0,
        seriesField: t.seriesField,
        stack: t.stack,
        percent: t.percent
      });
    }
    transformSpec(t) {
      var e;
      super.transformSpec(t),
        (null !== (e = t.axes) && void 0 !== e ? e : []).forEach(t => {
          ['domainLine', 'grid', 'label', 'tick'].forEach(e => {
            t[e] || (t[e] = { visible: !1 });
          });
        }),
        (t.crosshair = V(t.crosshair || {}).map(t =>
          _J({ categoryField: { visible: !0, line: { visible: !0, type: 'rect' } } }, t)
        ));
    }
  }
  (i4.type = d2.rose), (i4.view = 'singleDefault');
  const n4 = t => {
    let e = 0;
    return (
      t.forEach((t, i) => {
        var n;
        l(t.value) &&
          ((null === (n = t.children) || void 0 === n ? void 0 : n.length)
            ? (t.value = n4(t.children))
            : (t.value = 0)),
          (e += Math.abs(t.value));
      }),
      e
    );
  };
  function s4(t) {
    return t.depth;
  }
  function r4(t, e) {
    return e - 1 - t.endDepth;
  }
  const a4 = (t, e) => t.y0 - e.y0,
    o4 = (t, e) => {
      if (l(t.value)) return null;
      const i = (e ? t.targetLinks : t.sourceLinks).reduce(
        (t, e) => (l(e.value) ? (t.count += 1) : (t.sum += e.value), t),
        { sum: 0, count: 0 }
      );
      return i.count > 0 ? (t.value - i.sum) / i.count : null;
    },
    l4 = {
      left: s4,
      right: r4,
      justify: function (t, e) {
        return t.sourceLinks.length ? t.depth : e - 1;
      },
      center: function (t, e, i) {
        return t.targetLinks.length
          ? t.depth
          : t.sourceLinks.length
          ? G(t.sourceLinks.map(t => i[t.target].depth)) - 1
          : 0;
      },
      start: s4,
      end: r4
    };
  class h4 {
    constructor(t) {
      (this._ascendingSourceBreadth = (t, e) =>
        a4(this._nodeMap[t.source], this._nodeMap[e.source]) || t.index - e.index),
        (this._ascendingTargetBreadth = (t, e) =>
          a4(this._nodeMap[t.target], this._nodeMap[e.target]) || t.index - e.index),
        (this.options = Object.assign({}, h4.defaultOptions, t));
      const e = this.options.nodeKey,
        i = o(e) ? e : e ? jo(e) : null;
      (this._getNodeKey = i),
        (this._logger = Ze.getInstance()),
        (this._alignFunc = o(this.options.setNodeLayer)
          ? t => this.options.setNodeLayer(t.datum)
          : l4[this.options.nodeAlign]);
    }
    layout(t, e) {
      if (!t) return null;
      const i =
        'width' in e
          ? { x0: 0, x1: e.width, y0: 0, y1: e.height, width: e.width, height: e.height }
          : {
              x0: Math.min(e.x0, e.x1),
              x1: Math.max(e.x0, e.x1),
              y0: Math.min(e.y0, e.y1),
              y1: Math.max(e.y0, e.y1),
              width: Math.abs(e.x1 - e.x0),
              height: Math.abs(e.y1 - e.y0)
            };
      'vertical' === this.options.direction
        ? (this._viewBox = { x0: i.y0, x1: i.y1, y0: i.x0, y1: i.x1, width: i.height, height: i.width })
        : (this._viewBox = i);
      const n = this.computeNodeLinks(t),
        s = n.nodes,
        r = n.links;
      if (
        ((this._nodeMap = n.nodeMap),
        this.computeNodeValues(s),
        this.computeNodeDepths(s),
        ['right', 'end', 'justify'].includes(this.options.nodeAlign) && this.computeNodeEndDepths(s),
        this._maxDepth <= 1)
      )
        return null;
      const a = this.computeNodeBreadths(s);
      return (
        this.computeLinkBreadths(s),
        'vertical' === this.options.direction &&
          (s.forEach(t => {
            const e = t.y0,
              i = t.y1;
            (t.y0 = t.x0), (t.y1 = t.x1), (t.x0 = e), (t.x1 = i);
          }),
          r.forEach(t => {
            t.vertical = !0;
            const e = t.x0,
              i = t.x1;
            (t.x0 = t.y0), (t.x1 = t.y1), (t.y0 = e), (t.y1 = i);
          })),
        r.forEach(t => {
          const e = this._nodeMap[t.source],
            i = this._nodeMap[t.target];
          (t.sourceRect = { x0: e.x0, x1: e.x1, y0: e.y0, y1: e.y1 }),
            (t.targetRect = { x0: i.x0, x1: i.x1, y1: i.y1, y0: i.y0 });
        }),
        { nodes: s, links: r, columns: a }
      );
    }
    computeHierarchicNodeLinks(t) {
      const e = [],
        i = [],
        n = {},
        s = {},
        r = [];
      n4(t);
      const a = (t, i, s) => {
        t.forEach((t, o) => {
          var l, h;
          const c = this._getNodeKey ? this._getNodeKey(t) : s ? `${s[s.length - 1].key}-${o}` : `${i}-${o}`;
          if (n[c]) n[c].value = void 0;
          else {
            const s = {
              depth: i,
              datum: t,
              index: o,
              key: c,
              value: null !== (l = t.value) && void 0 !== l ? l : 0,
              sourceLinks: [],
              targetLinks: []
            };
            (n[c] = s), e.push(s);
          }
          s &&
            r.push({
              source: s[s.length - 1].key,
              target: c,
              value: null !== (h = t.value) && void 0 !== h ? h : 0,
              parents: s
            }),
            t.children && t.children.length && a(t.children, i + 1, s ? s.concat([n[c]]) : [n[c]]);
        });
      };
      return (
        a(t, 0, null),
        r.forEach((t, e) => {
          const r = `${t.source}-${t.target}`;
          if (s[r]) return (s[r].value += t.value), void s[r].datum.push(t);
          const a = {
            index: e,
            key: `${t.source}-${t.target}`,
            source: t.source,
            target: t.target,
            datum: [t],
            value: t.value,
            parents: t.parents.map(t => t.key)
          };
          i.push(a), n[t.source].sourceLinks.push(a), n[t.target].targetLinks.push(a), (s[r] = a);
        }),
        { nodes: e, links: i, nodeMap: n }
      );
    }
    computeNodeLinks(t) {
      if (!('links' in t)) return (this._isHierarchic = !0), this.computeHierarchicNodeLinks(t.nodes);
      const e = [],
        i = [],
        n = {};
      t.nodes &&
        t.nodes.forEach((t, i) => {
          const s = {
            depth: -1,
            datum: t,
            index: i,
            key: this._getNodeKey ? this._getNodeKey(t) : i,
            value: t.value,
            sourceLinks: [],
            targetLinks: []
          };
          (n[s.key] = s), e.push(s);
        });
      const s = [];
      if (
        (t.links.forEach((r, a) => {
          if (l(r.source) || l(r.target)) return;
          if (t.nodes && (!n[r.source] || !n[r.target])) return;
          t.nodes ||
            n[r.source] ||
            ((n[r.source] = {
              value: void 0,
              depth: -1,
              index: e.length,
              key: r.source,
              datum: null,
              sourceLinks: [],
              targetLinks: []
            }),
            e.push(n[r.source])),
            t.nodes ||
              n[r.target] ||
              ((n[r.target] = {
                value: void 0,
                depth: -1,
                index: e.length,
                key: r.target,
                datum: null,
                sourceLinks: [],
                targetLinks: []
              }),
              e.push(n[r.target]));
          const o = { index: a, source: r.source, target: r.target, datum: r, value: r.value };
          this.options.divideNodeValueToLink && l(r.value) && s.push(o),
            i.push(o),
            n[r.source].sourceLinks.push(o),
            n[r.target].targetLinks.push(o);
        }),
        this.options.divideNodeValueToLink &&
          s.length &&
          s.forEach(t => {
            const e = [o4(n[t.source]), o4(n[t.target], !0)].filter(t => !l(t));
            e.length && (t.value = Math.min.apply(null, e));
          }),
        this.options.linkSortBy)
      )
        for (let t = 0, i = e.length; t < i; t++)
          e[t].sourceLinks.sort(this.options.linkSortBy), e[t].targetLinks.sort(this.options.linkSortBy);
      return { nodes: e, links: i, nodeMap: n };
    }
    computeNodeValues(t) {
      for (let e = 0, i = t.length; e < i; e++) {
        const i = t[e];
        i.value = Math.max(
          l(i.value) ? 0 : i.value,
          i.sourceLinks.reduce((t, e) => {
            var i;
            return t + (null !== (i = e.value) && void 0 !== i ? i : 0);
          }, 0),
          i.targetLinks.reduce((t, e) => {
            var i;
            return t + (null !== (i = e.value) && void 0 !== i ? i : 0);
          }, 0)
        );
      }
    }
    computeNodeDepths(t) {
      const e = t.length;
      let i,
        n,
        s = t,
        r = 0;
      for (; s.length && r < e; ) {
        (i = []), (n = {});
        for (let t = 0, e = s.length; t < e; t++) {
          const e = s[t];
          e.depth = r;
          for (let t = 0, s = e.sourceLinks.length; t < s; t++) {
            const s = e.sourceLinks[t];
            n[s.target] || (i.push(this._nodeMap[s.target]), (n[s.target] = !0));
          }
        }
        (s = i), (r += 1);
      }
      r > e && this._logger.warn('Error: there is a circular link'), (this._maxDepth = r);
    }
    computeNodeEndDepths(t) {
      const e = t.length;
      let i,
        n,
        s = t,
        r = 0;
      for (; s.length && r < e; ) {
        (i = []), (n = {});
        for (let t = 0, e = s.length; t < e; t++) {
          const e = s[t];
          e.endDepth = r;
          for (let t = 0, s = e.targetLinks.length; t < s; t++) {
            const s = e.targetLinks[t];
            n[s.source] || (i.push(this._nodeMap[s.source]), (n[s.source] = !0));
          }
        }
        (s = i), (r += 1);
      }
      r > e && this._logger.warn('Error: there is a circular link');
    }
    computeNodeLayers(t) {
      const e = this.options.nodeWidth,
        i = this.options.linkWidth,
        n = this.options.minStepWidth,
        s = this._viewBox.width;
      let r = null,
        a = null,
        h = !1;
      if (g(e)) {
        const t = pt(parseFloat(e.replace('%', '')) / 100, 0, 1);
        let i = s / (this._maxDepth - 1 + t);
        n > 0 && (i = Math.max(n, i)), (r = i * t), (a = i * (1 - t)), (h = !0);
      } else if (y(e)) {
        if (((r = e), y(i))) a = i;
        else if (l(i)) {
          let t = (s - e) / (this._maxDepth - 1);
          n > 0 && (t = Math.max(n, t)), (a = t - e);
        }
        h = !0;
      } else o(e) && y(i) && (a = i);
      const c = [];
      for (let e = 0, i = t.length; e < i; e++) {
        const i = t[e];
        i.layer = this._isHierarchic
          ? i.depth
          : pt(Math.floor(this._alignFunc(i, this._maxDepth, this._nodeMap)), 0, this._maxDepth - 1);
        const n = i.layer;
        n === this._maxDepth - 1 && (i.isLastLayer = !0),
          h && ((i.x0 = this._viewBox.x0 + n * (r + a)), (i.x1 = i.x0 + r)),
          c[n] ? c[n].push(i) : (c[n] = [i]);
      }
      if (this.options.nodeSortBy) for (let t = 0, e = c.length; t < e; t++) c[t].sort(this.options.nodeSortBy);
      if (!h && o(e)) {
        let t = this._viewBox.x0;
        for (let n = 0; n < this._maxDepth; n++) {
          const s = c[n];
          let a = 0;
          for (let n = 0, l = s.length; n < l; n++) {
            const l = s[n],
              h = e(l);
            (l.x0 = t), (l.x1 = t + h), (a = Math.max(r, h));
            const c = l.sourceLinks;
            for (let t = 0, e = c.length; t < e; t++) {
              const e = c[t];
              o(i) && i(e);
            }
          }
          t += a;
        }
      }
      return c;
    }
    initializeNodeBreadths(t) {
      const e = this.options.minLinkHeight;
      let i = this.options.minNodeHeight;
      (l(i) || i < e) && (i = e);
      let n = 0,
        s = null;
      if (o(this.options.nodeGap))
        (s = this.options.nodeGap),
          (n = t.reduce((t, e) => {
            const i = e.reduce((t, e) => t + e.value, 0),
              n = e.reduce((t, e) => t + this.options.nodeGap(e), 0);
            return Math.min(t, (this._viewBox.height - n) / i);
          }, 1 / 0));
      else {
        const e = t.reduce((t, e) => Math.max(t, e.length), 0),
          r = Math.min(i > 0 ? Math.max(this.options.nodeGap, i) : this.options.nodeGap, this._viewBox.height / e);
        (s = () => r),
          (this._gapY = r),
          (n = t.reduce((t, e) => {
            const i = e.reduce((t, e) => t + e.value, 0);
            return Math.min(t, (this._viewBox.height - (e.length - 1) * r) / i);
          }, 1 / 0));
      }
      const r = 'start' === this.options.gapPosition,
        a = !r && 'end' !== this.options.gapPosition;
      for (let o = 0, l = t.length; o < l; o++) {
        const l = t[o];
        let h = this._viewBox.y0,
          c = 0;
        for (let t = 0, a = l.length; t < a; t++) {
          const a = l[t];
          (c = s(a)),
            r && (h += c),
            (a.y0 = h),
            (a.y1 = h + (i > 0 ? Math.max(a.value * n, i) : a.value * n)),
            (h = r ? a.y1 : a.y1 + c);
          for (let t = 0, i = a.sourceLinks.length; t < i; t++) {
            const i = a.sourceLinks[t];
            i.thickness = e > 0 ? Math.max(i.value * n, e) : i.value * n;
          }
        }
        let d = this._viewBox.y1 - h + (a ? c : 0);
        if (d > 0)
          if ('start' === this.options.crossNodeAlign);
          else if ('end' === this.options.crossNodeAlign)
            for (let t = 0, e = l.length; t < e; ++t) {
              const e = l[t];
              (e.y0 += d), (e.y1 += d);
            }
          else {
            d /= l.length + 1;
            for (let t = 0, e = l.length; t < e; ++t) {
              const e = l[t];
              (e.y0 += d * (t + 1)), (e.y1 += d * (t + 1));
            }
          }
        else if (d < 0 && l.length > 1 && ((d /= l.length - 1), c + d > 0)) {
          c += d;
          for (let t = 1, e = l.length; t < e; ++t) {
            const e = l[t];
            (e.y0 += d * t), (e.y1 += d * t);
          }
        }
        this.reorderLinks(l);
      }
    }
    computeNodeBreadths(t) {
      const e = this.computeNodeLayers(t);
      this.initializeNodeBreadths(e);
      const i = this.options.iterations;
      if (!this._isHierarchic && !o(this.options.setNodeLayer) && !o(this.options.nodeGap))
        for (let t = 0; t < i; ++t) {
          const n = Math.pow(0.99, t),
            s = Math.max(1 - n, (t + 1) / i);
          this.relaxRightToLeft(e, n, s), this.relaxLeftToRight(e, n, s);
        }
      return e;
    }
    relaxLeftToRight(t, e, i) {
      for (let n = 1, s = t.length; n < s; ++n) {
        const s = t[n];
        for (let t = 0, i = s.length; t < i; t++) {
          const i = s[t];
          let n = 0,
            r = 0;
          for (let t = 0, e = i.targetLinks.length; t < e; t++) {
            const e = i.targetLinks[t],
              s = e.value * (i.layer - this._nodeMap[e.source].layer);
            (n += this.targetTop(this._nodeMap[e.source], i) * s), (r += s);
          }
          if (!(r > 0)) continue;
          const a = (n / r - i.y0) * e;
          (i.y0 += a), (i.y1 += a), this.reorderNodeLinks(i);
        }
        l(this.options.nodeSortBy) && s.sort(a4), this.resolveCollisions(s, i);
      }
    }
    relaxRightToLeft(t, e, i) {
      for (let n = t.length - 2; n >= 0; --n) {
        const s = t[n];
        for (let t = 0, i = s.length; t < i; t++) {
          const i = s[t];
          let n = 0,
            r = 0;
          for (let t = 0, e = i.sourceLinks.length; t < e; t++) {
            const e = i.sourceLinks[t],
              s = e.value * (this._nodeMap[e.target].layer - i.layer);
            (n += this.sourceTop(i, this._nodeMap[e.target]) * s), (r += s);
          }
          if (!(r > 0)) continue;
          const a = (n / r - i.y0) * e;
          (i.y0 += a), (i.y1 += a), this.reorderNodeLinks(i);
        }
        void 0 === this.options.nodeSortBy && s.sort(a4), this.resolveCollisions(s, i);
      }
    }
    resolveCollisions(t, e) {
      const i = t.length >> 1,
        n = t[i];
      this.resolveCollisionsBottomToTop(t, n.y0 - this._gapY, i - 1, e),
        this.resolveCollisionsTopToBottom(t, n.y1 + this._gapY, i + 1, e),
        this.resolveCollisionsBottomToTop(t, this._viewBox.y1, t.length - 1, e),
        this.resolveCollisionsTopToBottom(t, this._viewBox.y0, 0, e);
    }
    resolveCollisionsTopToBottom(t, e, i, n) {
      for (; i < t.length; ++i) {
        const s = t[i],
          r = (e - s.y0) * n;
        r > 1e-6 && ((s.y0 += r), (s.y1 += r)), (e = s.y1 + this._gapY);
      }
    }
    resolveCollisionsBottomToTop(t, e, i, n) {
      for (; i >= 0; --i) {
        const s = t[i],
          r = (s.y1 - e) * n;
        r > 1e-6 && ((s.y0 -= r), (s.y1 -= r)), (e = s.y0 - this._gapY);
      }
    }
    targetTop(t, e) {
      let i,
        n,
        s,
        r = t.y0 - ((t.sourceLinks.length - 1) * this._gapY) / 2;
      for (i = 0, n = t.sourceLinks.length; i < n && ((s = t.sourceLinks[i]), s.target !== e.key); i++)
        r += s.thickness + this._gapY;
      for (i = 0, n = e.targetLinks.length; i < n && ((s = e.targetLinks[i]), s.source !== t.key); i++)
        r -= s.thickness;
      return r;
    }
    sourceTop(t, e) {
      let i,
        n,
        s,
        r = e.y0 - ((e.targetLinks.length - 1) * this._gapY) / 2;
      for (i = 0, n = e.targetLinks.length; i < n && ((s = e.targetLinks[i]), s.source !== t.key); i++)
        r += s.thickness + this._gapY;
      for (i = 0, n = t.sourceLinks.length; i < n && ((s = t.sourceLinks[i]), s.target !== e.key); i++)
        r -= s.thickness;
      return r;
    }
    computeLinkBreadths(t) {
      for (let e = 0, i = t.length; e < i; e++) {
        const i = t[e];
        let n = i.y0,
          s = n;
        for (let t = 0, e = i.sourceLinks.length; t < e; t++) {
          const e = i.sourceLinks[t];
          (e.y0 = n + e.thickness / 2), (e.x0 = i.x1), (n += e.thickness);
        }
        for (let t = 0, e = i.targetLinks.length; t < e; t++) {
          const e = i.targetLinks[t];
          (e.y1 = s + e.thickness / 2), (e.x1 = i.x0), (s += e.thickness);
        }
      }
    }
    reorderNodeLinks(t) {
      if (l(this.options.linkSortBy)) {
        const e = t.targetLinks,
          i = t.sourceLinks;
        for (let t = 0, i = e.length; t < i; t++) {
          const i = e[t];
          this._nodeMap[i.source].sourceLinks.sort(this._ascendingTargetBreadth);
        }
        for (let t = 0, e = i.length; t < e; t++) {
          const e = i[t];
          this._nodeMap[e.target].targetLinks.sort(this._ascendingSourceBreadth);
        }
      }
    }
    reorderLinks(t) {
      if (l(this.options.linkSortBy))
        for (let e = 0, i = t.length; e < i; e++) {
          const i = t[e];
          i.sourceLinks.sort(this._ascendingTargetBreadth), i.targetLinks.sort(this._ascendingSourceBreadth);
        }
    }
  }
  h4.defaultOptions = {
    iterations: 6,
    nodeAlign: 'justify',
    direction: 'horizontal',
    nodeWidth: 24,
    nodeGap: 8,
    crossNodeAlign: 'middle'
  };
  const c4 = (t, e) => {
      const i = new h4(t).layout(
        Array.isArray(e) ? e[0] : e,
        'width' in t ? { width: t.width, height: t.height } : { x0: t.x0, x1: t.x1, y0: t.y0, y1: t.y1 }
      );
      return i ? [i] : [];
    },
    d4 = (t, e) => {
      var i;
      if (!t || !(null == e ? void 0 : e.view) || !f(t)) return t;
      const n = e.view();
      if (
        n.x1 - n.x0 == 0 ||
        n.y1 - n.y0 == 0 ||
        n.x1 - n.x0 == -1 / 0 ||
        n.x1 - n.x0 == 1 / 0 ||
        n.y1 - n.y0 == -1 / 0 ||
        n.y1 - n.y0 == 1 / 0
      )
        return t;
      if (t.length > 1) {
        const e = { links: [], nodes: [] };
        t.forEach(t => {
          ('links' !== t.id && 'nodes' !== t.id) || (e[t.id] = t.values);
        }),
          (t = e);
      } else t = (null === (i = t[0]) || void 0 === i ? void 0 : i.latestData) ? t[0].latestData[0] : t[0];
      if ('source' !== e.sourceField || 'target' !== e.targetField)
        for (const i in t)
          if ('links' === i) {
            const n = [];
            t[i].forEach(t => {
              const i = {};
              for (const n in t)
                n === e.sourceField
                  ? (i.source = t[e.sourceField])
                  : n === e.targetField
                  ? (i.target = t[e.targetField])
                  : (i[n] = t[n]);
              n.push(i);
            }),
              (t[i] = n);
          }
      const s = new h4(e),
        r = [];
      return r.push(s.layout(t, n)), r;
    },
    u4 = t => {
      var e, i;
      return t &&
        f(t) &&
        (null === (e = t[0]) || void 0 === e ? void 0 : e.latestData) &&
        t[0].latestData.length &&
        t[0].latestData[0] &&
        null !== (i = t[0].latestData[0].nodes) &&
        void 0 !== i
        ? i
        : [];
    },
    p4 = t => {
      var e, i;
      return t &&
        f(t) &&
        (null === (e = t[0]) || void 0 === e ? void 0 : e.latestData) &&
        t[0].latestData.length &&
        t[0].latestData[0] &&
        null !== (i = t[0].latestData[0].links) &&
        void 0 !== i
        ? i
        : [];
    };
  class g4 extends z1 {
    getDefaultTooltipPattern(t, e) {
      if ('mark' === t)
        return {
          visible: !0,
          activeType: t,
          title: {
            key: void 0,
            value: t => {
              if (t.source) {
                if (y(t.source)) {
                  const e = this.series.getSeriesKeys();
                  return e[t.source] + ' => ' + e[t.target];
                }
                return t.source + ' => ' + t.target;
              }
              return t.datum[this.series.getSpec().categoryField];
            },
            hasShape: !1
          },
          content: [
            {
              key: this.contentKeyCallback,
              value: t => t.value,
              hasShape: !0,
              shapeType: this.contentShapeTypeCallback,
              shapeColor: t => this.contentShapeColorCallback(t),
              shapeHollow: !1
            }
          ]
        };
      if ('dimension' === t && e) {
        const i = { key: void 0, value: this._getDimensionData, hasShape: !1 },
          n = [];
        return (
          e.forEach(({ data: t }) =>
            t.forEach(({ series: t }) => {
              n.push({
                seriesId: t.id,
                key: this.contentKeyCallback,
                value: this.contentValueCallback,
                hasShape: !0,
                shapeType: this.contentShapeTypeCallback,
                shapeColor: this.contentShapeColorCallback,
                shapeHollow: !1
              });
            })
          ),
          { visible: !0, activeType: t, title: i, content: n }
        );
      }
      return null;
    }
  }
  class f4 extends g0 {
    constructor() {
      super(...arguments), (this.type = f4.type);
    }
    _getDefaultStyle() {
      return Object.assign(Object.assign({}, super._getDefaultStyle()), {
        x: 0,
        y: 0,
        x0: 0,
        y0: 0,
        x1: 100,
        y1: 100,
        thickness: 1,
        round: !0
      });
    }
    _initProduct(t) {
      EG('linkPath', { back: 'path', front: 'path' })
        .registerFunctionEncoder(SU)
        .registerChannelEncoder('backgroundStyle', (t, e) => ({ back: e }))
        .registerDefaultEncoder(() => ({ back: { zIndex: 0 }, front: { zIndex: 1 } })),
        hU('linkPathGrowIn', wU),
        hU('linkPathGrowOut', AU),
        hU('linkPathUpdate', kU);
      const e = this.getVGrammarView(),
        i = this.getProductId(),
        n = this.getStyle('direction');
      (this._product = e
        .glyph('linkPath', null != t ? t : e.rootMark)
        .id(i)
        .configureGlyph({ direction: n })),
        (this._compiledProductId = i);
    }
  }
  (f4.type = jZ.linkPath), NQ.useMark([p2, f4, i2]), yW('sankey', { transform: c4, markPhase: 'beforeJoin' }, !0);
  class v4 extends J1 {
    constructor() {
      super(...arguments),
        (this.type = DZ.sankey),
        (this._nodeLayoutZIndex = cZ.Node),
        (this._labelLayoutZIndex = cZ.Label),
        (this._viewBox = new Xt()),
        (this._handleAdjacencyClick = t => {
          const e = t.item;
          e && e.mark.id().includes('node')
            ? this._handleNodeAdjacencyClick(e)
            : e && e.mark.id().includes('link')
            ? this._handleLinkAdjacencyClick(e)
            : this._handleClearEmpty();
        }),
        (this._handleRelatedClick = t => {
          const e = t.item;
          e && e.mark.id().includes('node')
            ? this._handleNodeRelatedClick(e)
            : e && e.mark.id().includes('link')
            ? this._handleLinkRelatedClick(e)
            : this._handleClearEmpty();
        }),
        (this._handleClearEmpty = () => {
          const t = this._nodeMark.getProduct();
          if (!t || !t.elements || !t.elements.length) return;
          const e = t.elements,
            i = this._linkMark.getProduct();
          if (!i || !i.elements || !i.elements.length) return;
          const n = i.elements;
          e.forEach(t => {
            t.clearStates();
          }),
            n.forEach(t => {
              t.clearStates();
            });
        }),
        (this._handleNodeAdjacencyClick = t => {
          const e = t.getDatum(),
            i = [e.key];
          [this._linkMark].forEach(t => {
            const n = t.getProduct();
            if (!n || !n.elements || !n.elements.length) return;
            n.elements.forEach((t, n) => {
              t.clearStates();
              const s = t.getDatum(),
                r = (null == s ? void 0 : s.parents) ? 'parents' : 'source';
              if (V(s[r]).includes(e.key)) {
                let n;
                if (
                  (i.includes(s.source) || i.push(s.source), i.includes(s.target) || i.push(s.target), 'parents' === r)
                ) {
                  const t = s.datum,
                    i = t ? t.filter(t => t.parents.some(t => t.key === e.key)).reduce((t, e) => t + e.value, 0) : 0;
                  n = i / s.value;
                }
                t.addState('selected', { ratio: n });
              } else s.target === e.key ? i.includes(s.source) || i.push(s.source) : t.useStates(['blur']);
            });
          }),
            [this._nodeMark].forEach(t => {
              const e = t.getProduct();
              if (!e || !e.elements || !e.elements.length) return;
              e.elements.forEach(t => {
                t.clearStates(), i.includes(t.getDatum().key) || t.useStates(['blur']);
              });
            }),
            [this._labelMark].forEach(t => {
              const e = t.getProduct();
              if (!e || !e.elements || !e.elements.length) return;
              e.elements.forEach(t => {
                t.clearStates(), i.includes(t.getDatum().key) || t.useStates(['blur']);
              });
            });
        }),
        (this._handleLinkAdjacencyClick = t => {
          const e = t.getDatum(),
            i = [e.source, e.target];
          [this._linkMark].forEach(n => {
            const s = n.getProduct();
            if (!s || !s.elements || !s.elements.length) return;
            s.elements.forEach(n => {
              n.clearStates();
              const s = n.getDatum(),
                r = (null == s ? void 0 : s.parents) ? 'parents' : 'source';
              if (s.source === e.target || (V(s[r]).includes(e.source) && V(s[r]).includes(e.target))) {
                let t;
                if (
                  (i.includes(s.source) || i.push(s.source), i.includes(s.target) || i.push(s.target), 'parents' === r)
                ) {
                  const i = s.datum,
                    n = i
                      ? i
                          .filter(t =>
                            t.parents.some((i, n) => {
                              var s;
                              return (
                                i.key === e.source &&
                                (null === (s = t.parents[n + 1]) || void 0 === s ? void 0 : s.key) === e.target
                              );
                            })
                          )
                          .reduce((t, e) => t + e.value, 0)
                      : 0;
                  t = n / s.value;
                }
                n.addState('selected', { ratio: t });
              } else n === t || n.useStates(['blur']);
            });
          }),
            [this._nodeMark].forEach(t => {
              const e = t.getProduct();
              if (!e || !e.elements || !e.elements.length) return;
              e.elements.forEach(t => {
                t.clearStates(), i.includes(t.getDatum().key) || t.useStates(['blur']);
              });
            }),
            [this._labelMark].forEach(t => {
              const e = t.getProduct();
              if (!e || !e.elements || !e.elements.length) return;
              e.elements.forEach(t => {
                t.clearStates(), i.includes(t.getDatum().key) || t.useStates(['blur']);
              });
            });
        }),
        (this._handleNodeRelatedClick = t => {
          var e;
          const i = t.getDatum(),
            n = this._nodeMark.getProduct();
          if (!n || !n.elements || !n.elements.length) return;
          const s = n.elements,
            r = this._linkMark.getProduct();
          if (!r || !r.elements || !r.elements.length) return;
          const a = r.elements;
          if (
            'source' === ((null === (e = a[0].getDatum()) || void 0 === e ? void 0 : e.parents) ? 'parents' : 'source')
          ) {
            const t = [i.key],
              e = [];
            a.forEach((n, r) => {
              var a, o, l, h;
              n.clearStates();
              const c = n.getDatum(),
                d = (null == c ? void 0 : c.parents) ? 'parents' : 'source';
              if (V(c[d]).includes(i.key)) {
                if (
                  (e.includes(null !== (a = c.key) && void 0 !== a ? a : c.index) ||
                    e.push(null !== (o = c.key) && void 0 !== o ? o : c.index),
                  t.includes(c.source) || t.push(c.source),
                  !t.includes(c.target))
                ) {
                  t.push(c.target);
                  let i = s.find(t => t.data[0].key === c.target).data[0].sourceLinks;
                  for (; (null == i ? void 0 : i.length) > 0; ) {
                    const n = [];
                    return (
                      i.forEach(i => {
                        var r, a;
                        if (
                          !e.includes(null !== (r = i.key) && void 0 !== r ? r : i.index) &&
                          (e.push(null !== (a = i.key) && void 0 !== a ? a : i.index), !t.includes(i.target))
                        ) {
                          t.push(i.target);
                          const e = s.find(t => t.data[0].key === i.target);
                          n.push(e.data[0].targetLinks);
                        }
                      }),
                      void (i = n)
                    );
                  }
                }
              } else if (
                c.target === i.key &&
                (e.includes(null !== (l = c.key) && void 0 !== l ? l : c.index) ||
                  e.push(null !== (h = c.key) && void 0 !== h ? h : c.index),
                !t.includes(c.source))
              ) {
                t.push(c.source);
                let i = s.find(t => t.data[0].key === c.source).data[0].targetLinks;
                for (; (null == i ? void 0 : i.length) > 0; ) {
                  const n = [];
                  return (
                    i.forEach(i => {
                      var r, a;
                      if (
                        !e.includes(null !== (r = i.key) && void 0 !== r ? r : i.index) &&
                        (e.push(null !== (a = i.key) && void 0 !== a ? a : i.index), !t.includes(i.source))
                      ) {
                        t.push(i.source);
                        const e = s.find(t => t.data[0].key === i.source);
                        n.push(e.data[0].targetLinks);
                      }
                    }),
                    void (i = n)
                  );
                }
              }
            }),
              [this._linkMark].forEach(t => {
                const i = t.getProduct();
                if (!i || !i.elements || !i.elements.length) return;
                i.elements.forEach((t, i) => {
                  var n;
                  t.clearStates(),
                    e.includes(null !== (n = t.getDatum().key) && void 0 !== n ? n : t.getDatum().index)
                      ? t.useStates(['selected'])
                      : t.useStates(['blur']);
                });
              }),
              [this._nodeMark].forEach(e => {
                const i = e.getProduct();
                if (!i || !i.elements || !i.elements.length) return;
                i.elements.forEach(e => {
                  e.clearStates(), t.includes(e.getDatum().key) || e.useStates(['blur']);
                });
              }),
              [this._labelMark].forEach(e => {
                const i = e.getProduct();
                if (!i || !i.elements || !i.elements.length) return;
                i.elements.forEach(e => {
                  e.clearStates(), t.includes(e.getDatum().key) || e.useStates(['blur']);
                });
              });
          } else {
            const t = [i.key],
              e = i.targetLinks.reduce(
                (t, e) => (
                  V(e.datum).forEach(e => {
                    const n = e.parents,
                      s = n.length;
                    for (let r = 0; r < s; r++) {
                      const s = n[r].key,
                        a = n[r + 1] ? n[r + 1].key : i.key,
                        o = e.value,
                        l = t.find(t => t.source === s && t.target === a);
                      l ? (l.value += o) : t.push({ source: s, target: a, value: o });
                    }
                  }),
                  t
                ),
                []
              );
            a.forEach((n, s) => {
              n.clearStates();
              const r = n.getDatum(),
                a = (null == r ? void 0 : r.parents) ? 'parents' : 'source',
                o = r.datum,
                l = o ? o.filter(t => t[a].some(t => t.key === i.key)) : null,
                h = e.find(t => t.source === r.source && t.target === r.target);
              if (l && l.length) {
                t.includes(r.source) || t.push(r.source), t.includes(r.target) || t.push(r.target);
                const e = l.reduce((t, e) => t + e.value, 0),
                  i = e / r.value;
                return n.useStates(['selected']), void n.addState('selected', { ratio: i });
              }
              if (h)
                return (
                  t.includes(r.source) || t.push(r.source),
                  t.includes(r.target) || t.push(r.target),
                  n.useStates(['selected']),
                  void n.addState('selected', { ratio: h.value / r.value })
                );
              n.useStates(['blur']);
            }),
              [this._nodeMark].forEach(e => {
                const i = e.getProduct();
                if (!i || !i.elements || !i.elements.length) return;
                i.elements.forEach(e => {
                  e.clearStates(), t.includes(e.getDatum().key) || e.useStates(['blur']);
                });
              }),
              [this._labelMark].forEach(e => {
                const i = e.getProduct();
                if (!i || !i.elements || !i.elements.length) return;
                i.elements.forEach(e => {
                  e.clearStates(), t.includes(e.getDatum().key) || e.useStates(['blur']);
                });
              });
          }
        }),
        (this._handleLinkRelatedClick = t => {
          var e;
          const i = this._nodeMark.getProduct();
          if (!i || !i.elements || !i.elements.length) return;
          const n = i.elements,
            s = this._linkMark.getProduct();
          if (!s || !s.elements || !s.elements.length) return;
          const r = s.elements;
          if ('source' === ((null === (e = t.getDatum()) || void 0 === e ? void 0 : e.parents) ? 'parents' : 'source'))
            [this._linkMark].forEach(t => {
              const e = t.getProduct();
              if (!e || !e.elements || !e.elements.length) return;
              e.elements.forEach(t => {
                t.clearStates();
              });
            }),
              [this._nodeMark].forEach(t => {
                const e = t.getProduct();
                if (!e || !e.elements || !e.elements.length) return;
                e.elements.forEach(t => {
                  t.clearStates();
                });
              }),
              [this._labelMark].forEach(t => {
                const e = t.getProduct();
                if (!e || !e.elements || !e.elements.length) return;
                e.elements.forEach(t => {
                  t.clearStates();
                });
              });
          else {
            const e = t.getDatum(),
              i = [e.source, e.target],
              s = [];
            V(e.datum).forEach(t => {
              const e = t.parents,
                i = e.length;
              for (let n = 0; n < i - 1; n++) {
                const i = e[n].key,
                  r = e[n + 1].key,
                  a = t.value,
                  o = s.find(t => t.source === i && t.target === r);
                s.push({ source: e[n].key, target: e[n + 1].key, value: t.value }),
                  o ? (o.value += a) : s.push({ source: i, target: r, value: a });
              }
            }),
              r.forEach(t => {
                t.clearStates();
                const n = t.getDatum(),
                  r = n.datum;
                if (n.source === e.source && n.target === e.target)
                  return t.useStates(['selected']), void t.addState('selected', { ratio: 1 });
                const a = r
                  ? r.filter((t, i) =>
                      t.parents.some(n => {
                        var s;
                        return (
                          n.key === e.target &&
                          (null === (s = t.parents[i - 1]) || void 0 === s ? void 0 : s.key) === e.source
                        );
                      })
                    )
                  : null;
                if (a && a.length) {
                  i.includes(n.source) || i.push(n.source), i.includes(n.target) || i.push(n.target);
                  const s = a
                      .filter(t =>
                        t.parents.some((i, n) => {
                          var s;
                          return (
                            i.key === e.source &&
                            (null === (s = t.parents[n + 1]) || void 0 === s ? void 0 : s.key) === e.target
                          );
                        })
                      )
                      .reduce((t, e) => t + e.value, 0),
                    r = s / n.value;
                  return t.useStates(['selected']), void t.addState('selected', { ratio: r });
                }
                const o = s.find(t => t.source === n.source && t.target === n.target);
                if (o)
                  return (
                    i.includes(n.source) || i.push(n.source),
                    i.includes(n.target) || i.push(n.target),
                    t.useStates(['selected']),
                    void t.addState('selected', { ratio: o.value / n.value })
                  );
                t.useStates(['blur']);
              }),
              n.forEach(t => {
                t.clearStates(), i.includes(t.getDatum().key) || t.useStates(['blur']);
              }),
              [this._labelMark].forEach(t => {
                const e = t.getProduct();
                if (!e || !e.elements || !e.elements.length) return;
                e.elements.forEach(t => {
                  t.clearStates(), i.includes(t.getDatum().key) || t.useStates(['blur']);
                });
              });
          }
        });
    }
    getCategoryField() {
      return this._categoryField;
    }
    setCategoryField(t) {
      return (this._categoryField = t), this._categoryField;
    }
    getValueField() {
      return this._valueField;
    }
    setValueField(t) {
      return (this._valueField = t), this._valueField;
    }
    setAttrFromSpec() {
      var t, e, i;
      super.setAttrFromSpec(),
        this.setCategoryField(this._spec.categoryField),
        this.setValueField(this._spec.valueField),
        this.setSeriesField(null !== (t = this._spec.seriesField) && void 0 !== t ? t : this._spec.categoryField),
        (this._labelLimit =
          null !== (i = null === (e = this._spec.label) || void 0 === e ? void 0 : e.limit) && void 0 !== i ? i : 100);
    }
    initData() {
      var t, e, i, n, s, r;
      if ((super.initData(), this._viewDataFilter)) {
        xQ(this._dataSet, 'sankey', d4),
          this.addViewDataFilter({
            type: 'sankey',
            options: {
              view: () => ({ x0: this._viewBox.x1, x1: this._viewBox.x2, y0: this._viewBox.y1, y1: this._viewBox.y2 }),
              sourceField: this._spec.sourceField,
              targetField: this._spec.targetField,
              direction: this._spec.direction,
              nodeAlign: null !== (t = this._spec.nodeAlign) && void 0 !== t ? t : 'justify',
              nodeGap: null !== (e = this._spec.nodeGap) && void 0 !== e ? e : 8,
              nodeWidth: null !== (i = this._spec.nodeWidth) && void 0 !== i ? i : 10,
              linkWidth: this._spec.linkWidth,
              minStepWidth: this._spec.minStepWidth,
              minNodeHeight: null !== (n = this._spec.minNodeHeight) && void 0 !== n ? n : 4,
              minLinkHeight: this._spec.minLinkHeight,
              iterations: this._spec.iterations,
              nodeKey: this._spec.nodeKey,
              linkSortBy: this._spec.linkSortBy,
              nodeSortBy: this._spec.nodeSortBy,
              setNodeLayer: this._spec.setNodeLayer
            }
          });
        const a = new vo();
        SQ(a, 'dataview', po), xQ(a, 'sankeyNodes', u4), xQ(a, 'addVChartProperty', P1), xQ(a, 'flatten', e3);
        const o = new yo(a);
        o.parse([this.getViewData()], { type: 'dataview' }),
          o.transform({ type: 'sankeyNodes' }),
          o.transform({
            type: 'flatten',
            options: {
              callback: t => {
                if (t.datum) {
                  const e = t.datum[t.depth];
                  return Object.assign(Object.assign({}, t), e);
                }
                return t;
              }
            }
          }),
          o.transform({ type: 'addVChartProperty', options: { beforeCall: $1, call: X1.bind(this) } }, !1),
          null === (s = this._data) ||
            void 0 === s ||
            s.getDataView().target.addListener('change', o.reRunAllTransform),
          (this._nodesSeriesData = new W1(this._option, o));
        const l = new vo();
        SQ(l, 'dataview', po), xQ(l, 'sankeyLinks', p4), xQ(l, 'addVChartProperty', P1);
        const h = new yo(l);
        h.parse([this.getViewData()], { type: 'dataview' }),
          h.transform({ type: 'sankeyLinks' }),
          h.transform({ type: 'addVChartProperty', options: { beforeCall: $1, call: X1.bind(this) } }, !1),
          null === (r = this._data) ||
            void 0 === r ||
            r.getDataView().target.addListener('change', h.reRunAllTransform),
          (this._linksSeriesData = new W1(this._option, h));
      }
    }
    initMark() {
      var t;
      const e = this._createMark(v4.mark.node, {
        isSeriesMark: !0,
        key: Xq,
        dataView: this._nodesSeriesData.getDataView(),
        dataProductId: this._nodesSeriesData.getProductId()
      });
      e && (e.setZIndex(this._nodeLayoutZIndex), (this._nodeMark = e));
      const i = this._createMark(v4.mark.link, {
        key: Xq,
        dataView: this._linksSeriesData.getDataView(),
        dataProductId: this._linksSeriesData.getProductId()
      });
      if ((i && (this._linkMark = i), null === (t = this._spec.label) || void 0 === t ? void 0 : t.visible)) {
        const t = this._createMark(v4.mark.label, {
          key: Xq,
          dataView: this._nodesSeriesData.getDataView(),
          dataProductId: this._nodesSeriesData.getProductId()
        });
        t && (this._labelMark = t);
      }
    }
    initMarkStyle() {
      this._initNodeMarkStyle(), this._initLinkMarkStyle(), this._initLabelMarkStyle();
    }
    _initNodeMarkStyle() {
      var t;
      const e = this._nodeMark;
      e &&
        (this.setMarkStyle(
          e,
          {
            x: t => t.x0,
            x1: t => t.x1,
            y: t => t.y0,
            y1: t => t.y1,
            fill: t => {
              var e, i, n, s, r;
              const a =
                null !== (i = null !== (e = t.key) && void 0 !== e ? e : t[this._spec.categoryField]) && void 0 !== i
                  ? i
                  : '';
              return null !==
                (r =
                  null === (s = null === (n = this._spec.node) || void 0 === n ? void 0 : n.style) || void 0 === s
                    ? void 0
                    : s.fill) && void 0 !== r
                ? r
                : this.getNodeOrdinalColorScale(a);
            }
          },
          BQ.STATE_NORMAL,
          Jq.Mark
        ),
        this._trigger.registerMark(e),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(e));
    }
    _initLinkMarkStyle() {
      var t, e;
      const i = this._linkMark;
      i &&
        (this.setMarkStyle(
          i,
          {
            x0: t => t.x0,
            x1: t => t.x1,
            y0: t => t.y0,
            y1: t => t.y1,
            thickness: t => t.thickness,
            fill: t => {
              var e, i, n;
              return null !==
                (n =
                  null === (i = null === (e = this._spec.link) || void 0 === e ? void 0 : e.style) || void 0 === i
                    ? void 0
                    : i.fill) && void 0 !== n
                ? n
                : this.getNodeOrdinalColorScale(t.source);
            },
            direction: null !== (t = this._spec.direction) && void 0 !== t ? t : 'horizontal'
          },
          BQ.STATE_NORMAL,
          Jq.Series
        ),
        this._trigger.registerMark(i),
        null === (e = this._tooltipHelper) || void 0 === e || e.activeTriggerSet.mark.add(i));
    }
    _initLabelMarkStyle() {
      var t;
      this._labelMark &&
        ('vertical' === this._spec.direction
          ? 'inside-start' === this._spec.label.position
            ? this.setMarkStyle(
                this._labelMark,
                {
                  x: t => t.x0,
                  y: t => (t.y0 + t.y1) / 2,
                  fill: '#ffffff',
                  text: t => this._createText(t),
                  limit: t => {
                    var e;
                    return null !== (e = this._spec.label.limit) && void 0 !== e ? e : t.x1 - t.x0;
                  },
                  textAlign: 'left',
                  textBaseline: 'middle'
                },
                BQ.STATE_NORMAL,
                Jq.Series
              )
            : 'inside-middle' === this._spec.label.position
            ? this.setMarkStyle(
                this._labelMark,
                {
                  x: t => (t.x0 + t.x1) / 2,
                  y: t => (t.y0 + t.y1) / 2,
                  fill: '#ffffff',
                  text: t => this._createText(t),
                  limit: t => {
                    var e;
                    return null !== (e = this._spec.label.limit) && void 0 !== e ? e : t.x1 - t.x0;
                  },
                  textAlign: 'center',
                  textBaseline: 'middle'
                },
                BQ.STATE_NORMAL,
                Jq.Series
              )
            : 'inside-end' === this._spec.label.position
            ? this.setMarkStyle(
                this._labelMark,
                {
                  x: t => t.x1,
                  y: t => (t.y0 + t.y1) / 2,
                  fill: '#ffffff',
                  text: t => this._createText(t),
                  limit: t => {
                    var e;
                    return null !== (e = this._spec.label.limit) && void 0 !== e ? e : t.x1 - t.x0;
                  },
                  textAlign: 'right',
                  textBaseline: 'middle'
                },
                BQ.STATE_NORMAL,
                Jq.Series
              )
            : this.setMarkStyle(
                this._labelMark,
                {
                  x: t => (t.x0 + t.x1) / 2,
                  y: t => (t.y1 >= this._viewBox.y2 ? t.y0 : t.y1),
                  fill: t => {
                    var e, i, n;
                    return null !==
                      (n =
                        null === (i = null === (e = this._spec.node) || void 0 === e ? void 0 : e.style) || void 0 === i
                          ? void 0
                          : i.fill) && void 0 !== n
                      ? n
                      : this.getNodeOrdinalColorScale(t.key);
                  },
                  text: t => this._createText(t),
                  limit: this._labelLimit,
                  textAlign: 'center',
                  textBaseline: t => (t.y1 >= this._viewBox.y2 ? 'bottom' : 'top')
                },
                BQ.STATE_NORMAL,
                Jq.Series
              )
          : 'inside-start' === this._spec.label.position
          ? this.setMarkStyle(
              this._labelMark,
              {
                x: t => t.x0,
                y: t => (t.y0 + t.y1) / 2,
                fill: '#ffffff',
                text: t => this._createText(t),
                limit: t => {
                  var e;
                  return null !== (e = this._spec.label.limit) && void 0 !== e ? e : t.x1 - t.x0;
                },
                textAlign: 'left',
                textBaseline: 'middle'
              },
              BQ.STATE_NORMAL,
              Jq.Series
            )
          : 'inside-middle' === this._spec.label.position
          ? this.setMarkStyle(
              this._labelMark,
              {
                x: t => (t.x0 + t.x1) / 2,
                y: t => (t.y0 + t.y1) / 2,
                fill: '#ffffff',
                text: t => this._createText(t),
                limit: t => {
                  var e;
                  return null !== (e = this._spec.label.limit) && void 0 !== e ? e : t.x1 - t.x0;
                },
                textAlign: 'center',
                textBaseline: 'middle'
              },
              BQ.STATE_NORMAL,
              Jq.Series
            )
          : 'inside-end' === this._spec.label.position
          ? this.setMarkStyle(
              this._labelMark,
              {
                x: t => t.x1,
                y: t => (t.y0 + t.y1) / 2,
                fill: '#ffffff',
                text: t => this._createText(t),
                limit: t => {
                  var e;
                  return null !== (e = this._spec.label.limit) && void 0 !== e ? e : t.x1 - t.x0;
                },
                textAlign: 'right',
                textBaseline: 'middle'
              },
              BQ.STATE_NORMAL,
              Jq.Series
            )
          : 'left' === this._spec.label.position
          ? this.setMarkStyle(
              this._labelMark,
              {
                x: t => t.x0,
                y: t => (t.y0 + t.y1) / 2,
                fill: t => {
                  var e, i, n;
                  return null !==
                    (n =
                      null === (i = null === (e = this._spec.node) || void 0 === e ? void 0 : e.style) || void 0 === i
                        ? void 0
                        : i.fill) && void 0 !== n
                    ? n
                    : this.getNodeOrdinalColorScale(t.key);
                },
                text: t => this._createText(t),
                limit: this._labelLimit,
                textAlign: 'right',
                textBaseline: 'middle'
              },
              BQ.STATE_NORMAL,
              Jq.Series
            )
          : 'right' === this._spec.label.position
          ? this.setMarkStyle(
              this._labelMark,
              {
                x: t => t.x1,
                y: t => (t.y0 + t.y1) / 2,
                fill: t => {
                  var e, i, n;
                  return null !==
                    (n =
                      null === (i = null === (e = this._spec.node) || void 0 === e ? void 0 : e.style) || void 0 === i
                        ? void 0
                        : i.fill) && void 0 !== n
                    ? n
                    : this.getNodeOrdinalColorScale(t.key);
                },
                text: t => this._createText(t),
                limit: this._labelLimit,
                textAlign: 'left',
                textBaseline: 'middle'
              },
              BQ.STATE_NORMAL,
              Jq.Series
            )
          : this.setMarkStyle(
              this._labelMark,
              {
                x: t => (t.x1 >= this._viewBox.x2 ? t.x0 : t.x1),
                y: t => (t.y0 + t.y1) / 2,
                fill: t => {
                  var e, i, n;
                  return null !==
                    (n =
                      null === (i = null === (e = this._spec.node) || void 0 === e ? void 0 : e.style) || void 0 === i
                        ? void 0
                        : i.fill) && void 0 !== n
                    ? n
                    : this.getNodeOrdinalColorScale(t.key);
                },
                text: t => this._createText(t),
                limit: this._labelLimit,
                textAlign: t => (t.x1 >= this._viewBox.x2 ? 'right' : 'left'),
                textBaseline: 'middle'
              },
              BQ.STATE_NORMAL,
              Jq.Series
            ),
        this._labelMark.setZIndex(this._labelLayoutZIndex),
        this._trigger.registerMark(this._labelMark),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(this._labelMark));
    }
    _createText(t) {
      var e;
      if (l(t) || l(t.datum)) return '';
      let i = t.datum[this._spec.categoryField] || '';
      return (
        (null === (e = this._spec.label) || void 0 === e ? void 0 : e.formatMethod) &&
          (i = this._spec.label.formatMethod(i, t.datum)),
        i
      );
    }
    initAnimation() {
      var t, e;
      const i = {
          direction: this.direction,
          growFrom: () => {
            var t, e;
            return 'horizontal' === this.direction
              ? null === (t = this._xAxisHelper) || void 0 === t
                ? void 0
                : t.getScale(0).scale(0)
              : null === (e = this._yAxisHelper) || void 0 === e
              ? void 0
              : e.getScale(0).scale(0);
          }
        },
        n =
          null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
            ? void 0
            : e.preset;
      this._nodeMark && this._nodeMark.setAnimationConfig(w1(x1.sankeyNode(i, n), A1(LZ.node, this._spec))),
        this._linkMark && this._linkMark.setAnimationConfig(w1(x1.sankeyLinkPath(), A1(LZ.link, this._spec))),
        this._labelMark && this._labelMark.setAnimationConfig(w1(x1.label(), A1(LZ.label, this._spec)));
    }
    initEvent() {
      var t, e, i, n, s, r, a, o;
      super.initEvent(),
        null === (t = this._nodesSeriesData.getDataView()) ||
          void 0 === t ||
          t.target.addListener('change', this.nodesSeriesDataUpdate.bind(this)),
        null === (e = this._linksSeriesData.getDataView()) ||
          void 0 === e ||
          e.target.addListener('change', this.linksSeriesDataUpdate.bind(this)),
        (null === (i = this._spec.emphasis) || void 0 === i ? void 0 : i.enable) &&
          'adjacency' === (null === (n = this._spec.emphasis) || void 0 === n ? void 0 : n.effect) &&
          ('hover' === (null === (s = this._spec.emphasis) || void 0 === s ? void 0 : s.trigger)
            ? this.event.on('pointerover', { level: Yq.mark }, this._handleAdjacencyClick)
            : this.event.on('pointerdown', { level: Yq.mark }, this._handleAdjacencyClick)),
        (null === (r = this._spec.emphasis) || void 0 === r ? void 0 : r.enable) &&
          'related' === (null === (a = this._spec.emphasis) || void 0 === a ? void 0 : a.effect) &&
          ('hover' === (null === (o = this._spec.emphasis) || void 0 === o ? void 0 : o.trigger)
            ? this.event.on('pointerover', { level: Yq.mark }, this._handleRelatedClick)
            : this.event.on('pointerdown', { level: Yq.mark }, this._handleRelatedClick));
    }
    nodesSeriesDataUpdate() {
      this.event.emit(Gq.legendFilter, { model: this }), this._nodesSeriesData.updateData();
    }
    linksSeriesDataUpdate() {
      this.event.emit(Gq.legendFilter, { model: this }), this._linksSeriesData.updateData();
    }
    initTooltip() {
      this._tooltipHelper = new g4(this);
    }
    getNodeOrdinalColorScale(t) {
      var e, i, n, s, r, a, o;
      const l = (null === (e = this._rawData.latestData[0]) || void 0 === e ? void 0 : e.nodes)
          ? (null === (i = this._rawData.latestData[0].nodes[0]) || void 0 === i ? void 0 : i.children)
            ? Array.from(this.extractNamesFromTree(this._rawData.latestData[0].nodes))
            : this._rawData.latestData[0].nodes.map((t, e) => (this._spec.nodeKey ? t[this._spec.categoryField] : e))
          : null === (n = this._rawData.latestData[0]) || void 0 === n
          ? void 0
          : n.values.map((t, e) => (this._spec.nodeKey ? t[this._spec.categoryField] : e)),
        h =
          null !== (r = null === (s = this._option.globalScale.color) || void 0 === s ? void 0 : s.range()) &&
          void 0 !== r
            ? r
            : nV(this._option.getTheme().colorScheme, this.type),
        c = new hV();
      return null === (o = (a = c.domain(l)).range) || void 0 === o || o.call(a, h), c.scale(t);
    }
    extractNamesFromTree(t) {
      const e = new Set();
      return (
        t.forEach(t => {
          if ((e.add(t.name), t.children)) {
            this.extractNamesFromTree(t.children).forEach(t => e.add(t));
          }
        }),
        e
      );
    }
    getDimensionField() {
      return [this._spec.categoryField];
    }
    getMeasureField() {
      return [this._valueField];
    }
    getSeriesKeys() {
      var t;
      if (this._seriesField) {
        const e = [];
        return (
          null === (t = this._nodesSeriesData) ||
            void 0 === t ||
            t.getDataView().latestData.forEach(t => {
              var i;
              e.push(null !== (i = t[this._seriesField]) && void 0 !== i ? i : t.datum[this._seriesField]);
            }),
          e
        );
      }
      return [];
    }
    onLayoutEnd(t) {
      super.onLayoutEnd(t),
        this._viewBox.set(0, 0, this._region.getLayoutRect().width, this._region.getLayoutRect().height),
        this._rawData.reRunAllTransform(),
        this.getViewData().reRunAllTransform(),
        this._nodesSeriesData.updateData(),
        this._linksSeriesData.updateData();
    }
    getDefaultShapeType() {
      return 'square';
    }
    _noAnimationDataKey(t, e) {}
  }
  (v4.type = DZ.sankey), (v4.mark = oJ), NQ.useSeries([v4]);
  class m4 extends h2 {
    constructor() {
      super(...arguments), (this.type = d2.sankey), (this.seriesType = DZ.sankey);
    }
    getDefaultSeriesSpec(t) {
      const e = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
          categoryField: t.categoryField,
          valueField: t.valueField,
          sourceField: t.sourceField,
          targetField: t.targetField,
          direction: t.direction,
          nodeAlign: t.nodeAlign,
          nodeGap: t.nodeGap,
          nodeWidth: t.nodeWidth,
          linkWidth: t.linkWidth,
          minStepWidth: t.minStepWidth,
          minNodeHeight: t.minNodeHeight,
          minLinkHeight: t.minLinkHeight,
          iterations: t.iterations,
          nodeKey: t.nodeKey,
          linkSortBy: t.linkSortBy,
          nodeSortBy: t.nodeSortBy,
          setNodeLayer: t.setNodeLayer,
          node: t.node,
          link: t.link,
          label: t.label,
          emphasis: t.emphasis
        }),
        i = this.seriesType;
      return i && ((e.type = i), (e[i] = t[i])), e;
    }
    transformSpec(t) {
      super.transformSpec(t);
      const e = this.getDefaultSeriesSpec(t);
      t.series && 0 !== t.series.length
        ? t.series.forEach(t => {
            this.isValidSeries(t.type) &&
              Object.keys(e).forEach(i => {
                i in t || (t[i] = e[i]);
              });
          })
        : (t.series = [e]);
    }
  }
  (m4.type = d2.sankey), (m4.view = 'singleDefault');
  const y4 = [10, 20],
    _4 = qo.Linear,
    b4 = 'circle',
    x4 = qo.Ordinal,
    S4 = ['circle', 'square', 'triangle', 'diamond', 'star'];
  NQ.useMark([s2, i2]);
  class w4 extends J1 {
    constructor() {
      super(...arguments), (this.type = DZ.scatter);
    }
    setAttrFromSpec() {
      super.setAttrFromSpec(),
        (this._size = this._spec.size),
        (this._sizeField = this._spec.sizeField),
        (this._shape = this._spec.shape),
        (this._shapeField = this._spec.shapeField);
    }
    _getSeriesAttribute(t, e, { defaultScaleType: i, defaultRange: n }, s) {
      var r, a, h, d;
      if (o(e)) return e;
      if (f(e)) {
        if (l(t)) return null === (r = this._option) || void 0 === r || r.onError(`${s}Field is required.`), e;
        if (e.length > 2)
          return (
            null === (a = this._option) || void 0 === a || a.onError(`${s} length is invalid, specify up to 2 ${s}s.`),
            e
          );
        const n = `${UV}_series_scatter_${this.id}_scale_${s}`;
        return (
          this._option.globalScale.registerModelScale({
            id: n,
            type: i,
            domain: [{ dataId: this._rawData.name, fields: [t] }],
            range: e
          }),
          { scale: n, field: t }
        );
      }
      if (c(e)) {
        if (l(t)) return null === (h = this._option) || void 0 === h || h.onError(`${s}Field is required.`), e;
        const r = `${UV}_series_scatter_${this.id}_scale_${s}`,
          a = Object.assign({ id: r, type: i, domain: [{ dataId: this._rawData.name, fields: [t] }], range: n }, e);
        return this._option.globalScale.registerModelScale(a), { scale: a.id, field: t };
      }
      return null === (d = this._option) || void 0 === d || d.onError(`${s} attribute is invalid.`), e;
    }
    getSizeAttribute(t, e) {
      return l(e)
        ? 10
        : y(e)
        ? e
        : !g(e) || 'string' != typeof (i = e) || isNaN(Number(i)) || isNaN(parseFloat(i))
        ? this._getSeriesAttribute(t, e, { defaultScaleType: _4, defaultRange: y4 }, 'size')
        : parseFloat(e);
      var i;
    }
    getShapeAttribute(t, e) {
      return l(e) ? b4 : g(e) ? e : this._getSeriesAttribute(t, e, { defaultScaleType: x4, defaultRange: S4 }, 'shape');
    }
    initMark() {
      const t = {
        progressiveStep: this._spec.progressiveStep,
        progressiveThreshold: this._spec.progressiveThreshold,
        large: this._spec.large,
        largeThreshold: this._spec.largeThreshold
      };
      this._symbolMark = this._createMark(w4.mark.point, {
        morph: T1(this._spec.animation, this._spec.morph, A1('point', this._spec)),
        defaultMorphElementKey: this.getDimensionField()[0],
        groupKey: this._seriesField,
        label: _J({ animation: this._spec.animation }, this._spec.label),
        progressive: t,
        isSeriesMark: !0
      });
    }
    initMarkStyle() {
      this.initSymbolMarkStyle();
    }
    initAnimation() {
      var t, e;
      const i =
        null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
          ? void 0
          : e.preset;
      this._symbolMark.setAnimationConfig(w1(x1.scatter({}, i), A1(LZ.point, this._spec)));
    }
    initSymbolMarkStyle() {
      var t;
      const e = this._symbolMark;
      e &&
        ('zero' !== this._invalidType && this.setMarkStyle(e, { visible: this._getInvalidDefined }),
        this.setMarkStyle(
          e,
          {
            x: this.dataToPositionX.bind(this),
            y: this.dataToPositionY.bind(this),
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
            fill: this.getColorAttribute(),
            size: y(this._size) || o(this._size) ? this._size : 10,
            symbolType: g(this._shape) || o(this._shape) ? this._shape : b4
          },
          BQ.STATE_NORMAL,
          Jq.Series
        ),
        (h(this._sizeField) || h(this._size)) &&
          this.setMarkStyle(
            e,
            { size: this.getSizeAttribute(this._sizeField, this._size) },
            BQ.STATE_NORMAL,
            Jq.User_Mark
          ),
        (h(this._shapeField) || h(this._shape)) &&
          this.setMarkStyle(
            e,
            { symbolType: this.getShapeAttribute(this._shapeField, this._shape) },
            BQ.STATE_NORMAL,
            Jq.User_Mark
          ),
        this._trigger.registerMark(e),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(e));
    }
    viewDataStatisticsUpdate(t) {
      var e, i, n;
      super.viewDataStatisticsUpdate(t),
        'zero' === this._invalidType ||
        (null ===
          (n =
            null === (i = null === (e = this.getViewDataStatistics()) || void 0 === e ? void 0 : e.latestData) ||
            void 0 === i
              ? void 0
              : i[this.getStackValueField()]) || void 0 === n
          ? void 0
          : n.allValid)
          ? this.setMarkStyle(this._symbolMark, { visible: !0 }, 'normal', Jq.Series)
          : this.setMarkStyle(this._symbolMark, { visible: this._getInvalidDefined }, 'normal', Jq.Series);
    }
    initLabelMarkStyle(t) {
      t &&
        ((this._labelMark = t),
        this.setMarkStyle(
          t,
          {
            fill: this.getColorAttribute(),
            text: t => t[this.getStackValueField()],
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
          },
          BQ.STATE_NORMAL,
          Jq.Series
        ),
        'zero' !== this._invalidType &&
          this.setMarkStyle(t, { visible: this._getInvalidDefined }, BQ.STATE_NORMAL, Jq.Series));
    }
    handleZoom(t) {
      var e, i;
      this.getMarksWithoutRoot().forEach(t => {
        const e = t.getProduct();
        if (!e || !e.elements || !e.elements.length) return;
        e.elements.forEach((t, e) => {
          const i = t.getGraphicItem(),
            n = t.getDatum(),
            s = this.dataToPosition(n);
          s && i && i.translateTo(s.x, s.y);
        });
      });
      const n =
        null === (i = null === (e = this._labelMark) || void 0 === e ? void 0 : e.getComponent()) || void 0 === i
          ? void 0
          : i.getProduct();
      n && n.evaluateSync(null, null);
    }
    handlePan(t) {
      var e, i;
      this.getMarksWithoutRoot().forEach(t => {
        const e = t.getProduct();
        if (!e || !e.elements || !e.elements.length) return;
        e.elements.forEach((t, e) => {
          const i = t.getGraphicItem(),
            n = t.getDatum(),
            s = this.dataToPosition(n);
          s && i && i.translateTo(s.x, s.y);
        });
      });
      const n =
        null === (i = null === (e = this._labelMark) || void 0 === e ? void 0 : e.getComponent()) || void 0 === i
          ? void 0
          : i.getProduct();
      n && n.evaluateSync(null, null);
    }
    getDefaultShapeType() {
      return 'circle';
    }
  }
  (w4.type = DZ.scatter), (w4.mark = GZ), NQ.useSeries([w4]);
  class A4 extends c2 {
    constructor() {
      super(...arguments), (this.type = d2.scatter), (this.seriesType = DZ.scatter);
    }
    _getDefaultSeriesSpec(t) {
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        point: t.point,
        size: t.size,
        sizeField: t.sizeField,
        shape: t.shape,
        shapeField: t.shapeField
      });
    }
  }
  (A4.type = d2.scatter), (A4.view = 'singleDefault');
  class k4 extends z1 {
    getDefaultTooltipPattern(t) {
      return 'mark' === t
        ? {
            visible: !0,
            activeType: t,
            title: { key: 'link info', value: 'link info' },
            content: [
              {
                hasShape: !0,
                shapeType: 'square',
                shapeColor: this.contentShapeColorCallback,
                key: 'time',
                value: t => _o.getInstance().timeFormat('%Y%m%d %H:%M', t.from.split('_')[1])
              },
              {
                hasShape: !0,
                shapeType: 'square',
                shapeColor: this.contentShapeColorCallback,
                key: 'type',
                value: t => t.action_type
              },
              {
                hasShape: !0,
                shapeType: 'square',
                shapeColor: this.contentShapeColorCallback,
                key: 'from',
                value: t => t.from
              },
              {
                hasShape: !0,
                shapeType: 'square',
                shapeColor: this.contentShapeColorCallback,
                key: 'to',
                value: t => t.to
              }
            ]
          }
        : null;
    }
  }
  NQ.useMark([R3, s2]);
  class M4 extends J1 {
    constructor() {
      super(...arguments), (this.type = DZ.link);
    }
    getFromField() {
      return this._fromField;
    }
    setFromField(t) {
      h(t) && (this._fromField = t);
    }
    getToField() {
      return this._toField;
    }
    setToField(t) {
      h(t) && (this._toField = t);
    }
    getDotTypeField() {
      return this._dotTypeField;
    }
    setDotTypeField(t) {
      h(t) && (this._dotTypeField = t);
    }
    getDotSeriesSpec() {
      return this._dotSeriesSpec;
    }
    setDotSeriesSpec(t) {
      h(t) && (this._dotSeriesSpec = t);
    }
    initData() {
      var t;
      super.initData();
      xQ(this._option.dataSet, 'linkDotInfo', (t, e) => {
        const i = this._spec.data.latestData,
          n = this._spec.dataDot.latestData,
          s = {};
        return (
          n.forEach(t => {
            const i = {};
            for (const n in t) n !== e && (i[n] = t[n]);
            const n = t[e];
            null == n ||
              n.forEach(t => {
                s[t.node_name] = Object.assign({}, i, t);
              });
          }),
          i.forEach(t => {
            var e, i, n, r;
            (t[this._fromField + '_xField'] =
              null === (e = null == s ? void 0 : s[t[this._fromField]]) || void 0 === e
                ? void 0
                : e[this._dotSeriesSpec.xField]),
              (t[this._fromField + '_yField'] =
                null === (i = null == s ? void 0 : s[t[this._fromField]]) || void 0 === i
                  ? void 0
                  : i[this._dotSeriesSpec.yField]),
              (t[this._toField + '_xField'] =
                null === (n = null == s ? void 0 : s[t[this._toField]]) || void 0 === n
                  ? void 0
                  : n[this._dotSeriesSpec.xField]),
              (t[this._toField + '_yField'] =
                null === (r = null == s ? void 0 : s[t[this._toField]]) || void 0 === r
                  ? void 0
                  : r[this._dotSeriesSpec.yField]);
          }),
          i
        );
      }),
        null === (t = this.getViewDataFilter()) ||
          void 0 === t ||
          t.transform({ type: 'linkDotInfo', options: 'dots' }, !1);
    }
    setAttrFromSpec() {
      super.setAttrFromSpec(),
        this.setFromField(this._spec.fromField),
        this.setToField(this._spec.toField),
        this.setDotTypeField(this._spec.dotTypeField),
        this.setDotSeriesSpec(this._spec.dotSeriesSpec);
    }
    initMark() {
      (this._clipMark = this._createMark(M4.mark.group)),
        (this._containerMark = this._createMark(M4.mark.group, { parent: this._clipMark })),
        (this._linkMark = this._createMark(M4.mark.link, { skipBeforeLayouted: !1, parent: this._containerMark })),
        (this._arrowMark = this._createMark(M4.mark.arrow, {
          skipBeforeLayouted: !1,
          isSeriesMark: !0,
          parent: this._containerMark
        }));
    }
    initMarkStyle() {
      var t, e, i, n, s, r;
      const a = this._clipMark;
      a &&
        (this.setMarkStyle(
          a,
          { x: -this._spec.leftAppendPadding, y: 0, width: 1e4, height: this._spec.clipHeight, clip: !0 },
          'normal',
          Jq.Series
        ),
        a.setInteractive(!1));
      const o = this._containerMark;
      o &&
        (this.setMarkStyle(
          o,
          { x: this._spec.leftAppendPadding, width: this.getLayoutRect().width },
          'normal',
          Jq.Series
        ),
        o.setInteractive(!1));
      const l = this._linkMark;
      l &&
        (this.setMarkStyle(
          l,
          {
            stroke: this.getColorAttribute(),
            strokeOpacity: this.dataToOpacity.bind(this),
            x: this.dataToPositionXFrom.bind(this),
            y: this.dataToPositionYFrom.bind(this),
            x1: this.dataToPositionXTo.bind(this),
            y1: this.dataToPositionYTo.bind(this)
          },
          'normal',
          Jq.Series
        ),
        this._trigger.registerMark(l),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(l));
      const h = this._arrowMark;
      if (h) {
        const t =
          null !==
            (s =
              null ===
                (n =
                  null === (i = null === (e = this._theme) || void 0 === e ? void 0 : e.arrow) || void 0 === i
                    ? void 0
                    : i.style) || void 0 === n
                ? void 0
                : n.size) && void 0 !== s
            ? s
            : 10;
        this.setMarkStyle(
          h,
          {
            x: this.dataToPositionXTo.bind(this),
            y: e => this.dataToPositionArrowYTo(e, t),
            fill: this.getColorAttribute(),
            fillOpacity: this.dataToOpacity.bind(this),
            size: t,
            symbolType: t => (this.isPositionYFromHigher(t) ? ZJ.triangleDown : ZJ.triangleUp)
          },
          'normal',
          Jq.Series
        ),
          this._trigger.registerMark(h),
          null === (r = this._tooltipHelper) || void 0 === r || r.activeTriggerSet.mark.add(h);
      }
    }
    afterInitMark() {
      super.afterInitMark(), this._trigger.setStateKeys([this._seriesField, this._fromField]);
    }
    dataToPositionXFrom(t) {
      if (!this._xAxisHelper) return Number.NaN;
      const { dataToPosition: e } = this._xAxisHelper;
      return e(this.getDatumPositionValues(t, this._fromField + '_xField'), { bandPosition: this._bandPosition });
    }
    dataToPositionYFrom(t) {
      if (!this._yAxisHelper) return Number.NaN;
      const { dataToPosition: e } = this._yAxisHelper;
      return e(this.getDatumPositionValues(t, this._fromField + '_yField'));
    }
    dataToPositionXTo(t) {
      if (!this._xAxisHelper) return Number.NaN;
      const { dataToPosition: e } = this._xAxisHelper;
      return e(this.getDatumPositionValues(t, this._toField + '_xField'), { bandPosition: this._bandPosition });
    }
    dataToPositionYTo(t) {
      if (!this._yAxisHelper) return Number.NaN;
      const { dataToPosition: e } = this._yAxisHelper;
      return e(this.getDatumPositionValues(t, this._toField + '_yField'), { bandPosition: this._bandPosition });
    }
    dataToPositionArrowYTo(t, e) {
      if (!this._yAxisHelper) return Number.NaN;
      const { dataToPosition: i } = this._yAxisHelper,
        n = this.isPositionYFromHigher(t) ? -e / 2 : e / 2;
      return i(this.getDatumPositionValues(t, this._toField + '_yField'), { bandPosition: this._bandPosition }) + n;
    }
    dataToOpacity(t) {
      return this.isPositionXOuterRange(t, this._fromField + '_xField') ||
        this.isPositionXOuterRange(t, this._toField + '_xField') ||
        t[this._fromField] === t[this._toField]
        ? 0
        : 1;
    }
    isPositionYFromHigher(t) {
      return this.dataToPositionYFrom(t) < this.dataToPositionYTo(t);
    }
    isPositionXOuterRange(t, e) {
      if (!this._xAxisHelper) return !1;
      const { dataToPosition: i, getScale: n } = this._xAxisHelper;
      return (
        i(this.getDatumPositionValues(t, e), { bandPosition: this._bandPosition }) < n(0).range()[0] ||
        i(this.getDatumPositionValues(t, e), { bandPosition: this._bandPosition }) > n(0).range()[1]
      );
    }
    getDefaultColorDomain() {
      var t, e;
      return this._dotTypeField
        ? null === (t = this._viewDataStatistics) || void 0 === t
          ? void 0
          : t.latestData[this._dotTypeField].values
        : this._seriesField
        ? null === (e = this._viewDataStatistics) || void 0 === e
          ? void 0
          : e.latestData[this._seriesField].values
        : [];
    }
    getColorAttribute() {
      var t, e, i;
      return {
        scale:
          null !== (t = this._option.globalScale.getScale('color')) && void 0 !== t ? t : this.getDefaultColorScale(),
        field:
          null !== (i = null !== (e = this._dotTypeField) && void 0 !== e ? e : this._seriesField) && void 0 !== i
            ? i
            : qq
      };
    }
    initTooltip() {
      this._tooltipHelper = new k4(this);
    }
    onMarkTreePositionUpdate(t) {
      t.forEach(t => {
        'group' === t.type ? this.onMarkTreePositionUpdate(t.getMarks()) : t.updateLayoutState();
      });
    }
    getDotInfoData() {
      var t, e;
      return null === (e = null !== (t = this._linkMark) && void 0 !== t ? t : this._arrowMark) || void 0 === e
        ? void 0
        : e.getData();
    }
  }
  (M4.type = DZ.link), (M4.mark = JZ);
  class T4 extends z1 {
    updateTooltipSpec() {
      var t;
      super.updateTooltipSpec(),
        h(null === (t = this.spec) || void 0 === t ? void 0 : t.mark) &&
          (this.spec.mark.updateContent = (t, e, i) => {
            const n = [],
              s = t.filter(t => 'children' === t.key);
            return (
              s.length > 0 &&
                s[0].value.forEach(t => {
                  let i = !0;
                  for (const s in t)
                    n.push({
                      shapeType: 'circle',
                      hasShape: i,
                      shapeColor: this.contentShapeColorCallback(e[0].datum[0]),
                      key: s,
                      value: t[s] + ''
                    }),
                      (i = !1);
                }),
              t.concat(n)
            );
          });
    }
    getDefaultTooltipPattern(t) {
      return 'mark' === t
        ? {
            visible: !0,
            activeType: t,
            title: { key: 'event info', value: 'event info' },
            content: [
              {
                hasShape: !0,
                shapeType: 'square',
                shapeColor: this.contentShapeColorCallback,
                key: t => t.type,
                value: t => t.id
              },
              {
                hasShape: !0,
                shapeType: 'square',
                shapeColor: this.contentShapeColorCallback,
                key: 'event_time',
                value: t => _o.getInstance().timeFormat('%Y%m%d', t.event_time)
              },
              {
                hasShape: !0,
                shapeType: 'square',
                shapeColor: this.contentShapeColorCallback,
                key: 'action_type',
                value: t => t.action_type
              },
              {
                shapeType: 'square',
                hasShape: !0,
                shapeColor: this.contentShapeColorCallback,
                key: 'children',
                value: t => t.children
              }
            ],
            updateContent: (t, e, i) => {
              const n = [];
              return (
                t[3].value.forEach(t => {
                  let i = !0;
                  for (const s in t)
                    n.push({
                      shapeType: 'circle',
                      hasShape: i,
                      shapeColor: this.contentShapeColorCallback(e[0].datum[0]),
                      key: s,
                      value: t[s] + ''
                    }),
                      (i = !1);
                }),
                t.concat(n)
              );
            }
          }
        : null;
    }
  }
  const C4 = (t, e) => {
      const i = t[0].latestData ? t[0].latestData : t || [],
        n = [];
      return (
        i.forEach(t => {
          const i = {};
          for (const n in t) n !== e && (i[n] = t[n]);
          const s = t[e];
          null == s ||
            s.forEach(t => {
              n.push(Object.assign({}, i, t));
            });
        }),
        n
      );
    },
    E4 = { fill: '#bbb', fillOpacity: 0.2 };
  NQ.useMark([s2, i2, R3, p2]);
  class P4 extends J1 {
    constructor() {
      super(...arguments), (this.type = DZ.dot);
    }
    getSeriesGroupField() {
      return this._seriesField;
    }
    setSeriesGroupField(t) {
      h(t) && (this._seriesGroupField = t);
    }
    getTitleField() {
      return this._titleField;
    }
    setTitleField(t) {
      h(t) && (this._titleField = t);
    }
    getSubTitleField() {
      return this._subTitleField;
    }
    setSubTitleField(t) {
      h(t) && (this._subTitleField = t);
    }
    getDotTypeField() {
      return this._dotTypeField;
    }
    setDotTypeField(t) {
      h(t) && (this._dotTypeField = t);
    }
    getHighLightSeriesGroup() {
      return this._highLightSeriesGroup;
    }
    setHighLightSeriesGroup(t) {
      h(t) && (this._highLightSeriesGroup = t);
    }
    setGridBackground(t) {
      h(t) && (this._gridBackground = t);
    }
    initData() {
      var t;
      super.initData(),
        (this._xDimensionStatisticsDomain = this.getRawData().latestData.map(t => t[this._fieldY[0]])),
        xQ(this._option.dataSet, 'objFlat', C4),
        xQ(this._option.dataSet, 'copyDataView', TQ),
        SQ(this._option.dataSet, 'dataview', po),
        null === (t = this.getViewDataFilter()) ||
          void 0 === t ||
          t.transform({ type: 'objFlat', options: 'dots' }, !1);
    }
    setSeriesField(t) {
      h(t) &&
        ((this._seriesField = t),
        this.getMarksInType([jZ.line, jZ.area]).forEach(t => {
          t.setFacet(this._seriesField);
        }));
    }
    getStatisticFields() {
      return [
        { key: this._fieldY[0], operations: ['values'], customize: this._xDimensionStatisticsDomain },
        { key: this._fieldX[0], operations: ['max', 'min'] }
      ];
    }
    setAttrFromSpec() {
      var t, e;
      super.setAttrFromSpec(),
        this.setSeriesGroupField(this._spec.seriesGroupField),
        this.setTitleField(this._spec.titleField),
        this.setSubTitleField(this._spec.subTitleField),
        this.setDotTypeField(this._spec.dotTypeField),
        this.setHighLightSeriesGroup(this._spec.highLightSeriesGroup),
        this.setGridBackground(
          _J(
            E4,
            (null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.grid) || void 0 === e
              ? void 0
              : e.background) || {}
          )
        );
    }
    initMark() {
      (this._clipMark = this._createMark(P4.mark.group)),
        (this._containerMark = this._createMark(P4.mark.group, {
          parent: this._clipMark,
          dataView: this.getRawData()
        })),
        (this._gridBackgroundMark = this._createMark(P4.mark.gridBackground, {
          parent: this._containerMark,
          dataView: this.getRawData()
        })),
        (this._gridMark = this._createMark(P4.mark.grid, { parent: this._containerMark, dataView: this.getRawData() })),
        (this._dotMark = this._createMark(P4.mark.dot, {
          skipBeforeLayouted: !1,
          isSeriesMark: !0,
          parent: this._containerMark
        })),
        (this._titleMark = this._createMark(P4.mark.title, {
          parent: this._containerMark,
          dataView: this.getRawData()
        })),
        (this._subTitleMark = this._createMark(P4.mark.subTitle, {
          parent: this._containerMark,
          dataView: this.getRawData()
        })),
        (this._symbolMark = this._createMark(P4.mark.symbol, {
          parent: this._containerMark,
          dataView: this.getRawData()
        }));
    }
    initMarkStyle() {
      var t;
      const e = this._clipMark;
      e &&
        (this.setMarkStyle(
          e,
          { x: -this._spec.leftAppendPadding, y: 0, width: 1e4, height: this._spec.clipHeight, clip: !0 },
          'normal',
          Jq.Series
        ),
        e.setInteractive(!1));
      const i = this._containerMark;
      i && (this.setMarkStyle(i, { x: this._spec.leftAppendPadding }, 'normal', Jq.Series), i.setInteractive(!1));
      const n = this._gridBackgroundMark;
      n &&
        (this.setMarkStyle(
          n,
          {
            x: this.getRegionRectLeft.bind(this),
            x1: this.getRegionRectRight.bind(this),
            y: this.dataToGridBackgroundPositionY.bind(this),
            y1: this.dataToGridBackgroundPositionY1.bind(this),
            fill: this._gridBackground.fill,
            fillOpacity: this.dataToGridBackgroundOpacity.bind(this)
          },
          'normal',
          Jq.Series
        ),
        this._trigger.registerMark(n));
      const s = this._gridMark;
      s &&
        (this.setMarkStyle(
          s,
          {
            stroke: this.getColorAttribute(),
            x: this.getRegionRectLeft.bind(this),
            y: this.dataToPositionY.bind(this),
            x1: this.getRegionRectRight.bind(this),
            y1: this.dataToPositionY.bind(this)
          },
          'normal',
          Jq.Series
        ),
        this._trigger.registerMark(s));
      const r = this._dotMark;
      r &&
        (this.setMarkStyle(
          r,
          {
            x: this.dataToPositionX.bind(this),
            y: this.dataToPositionY.bind(this),
            fill: this.getDotColorAttribute(),
            fillOpacity: this.dataToOpacity.bind(this)
          },
          'normal',
          Jq.Series
        ),
        this._trigger.registerMark(r),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(r));
      const a = this._titleMark;
      a &&
        (this.setMarkStyle(
          a,
          {
            fill: this.getColorAttribute(),
            text: t => t[this.getTitleField()],
            x: this.getRegionRectLeft.bind(this),
            y: this.dataToPositionY.bind(this)
          },
          'normal',
          Jq.Series
        ),
        this._trigger.registerMark(a));
      const o = this._subTitleMark;
      o &&
        (this.setMarkStyle(
          o,
          {
            fill: this.getColorAttribute(),
            text: t => t[this.getSubTitleField()],
            x: this.getRegionRectLeft.bind(this),
            y: this.dataToPositionY.bind(this)
          },
          'normal',
          Jq.Series
        ),
        this._trigger.registerMark(o));
      const l = this._symbolMark;
      l &&
        (this.setMarkStyle(
          l,
          { x: this.getRegionRectLeft.bind(this), y: this.dataToPositionY.bind(this), fill: this.getColorAttribute() },
          'normal',
          Jq.Series
        ),
        this._trigger.registerMark(l));
    }
    dataToGridBackgroundPositionY(t) {
      if (!this._yAxisHelper) return Number.NaN;
      const { dataToPosition: e, getBandwidth: i } = this._yAxisHelper;
      return e(this.getDatumPositionValues(t, this._fieldY), { bandPosition: this._bandPosition }) - i(0) / 2;
    }
    dataToGridBackgroundPositionY1(t) {
      if (!this._yAxisHelper) return Number.NaN;
      const { dataToPosition: e, getBandwidth: i } = this._yAxisHelper;
      return e(this.getDatumPositionValues(t, this._fieldY), { bandPosition: this._bandPosition }) + i(0) / 2;
    }
    dataToOpacity(t) {
      var e, i, n, s;
      if (!this._xAxisHelper) return Number.NaN;
      const { dataToPosition: r, getScale: a } = this._xAxisHelper;
      return r(this.getDatumPositionValues(t, this._fieldX), { bandPosition: this._bandPosition }) < a(0).range()[0] ||
        r(this.getDatumPositionValues(t, this._fieldX), { bandPosition: this._bandPosition }) > a(0).range()[1]
        ? 0
        : null !==
            (s =
              null ===
                (n =
                  null === (i = null === (e = this._theme) || void 0 === e ? void 0 : e.dot) || void 0 === i
                    ? void 0
                    : i.style) || void 0 === n
                ? void 0
                : n.fillOpacity) && void 0 !== s
        ? s
        : 1;
    }
    dataToGridBackgroundOpacity(t) {
      return t[this._seriesGroupField] === this._highLightSeriesGroup ? this._gridBackground.fillOpacity : 0;
    }
    getDefaultColorDomain() {
      var t, e;
      return this._seriesGroupField
        ? null === (t = this._viewDataStatistics) || void 0 === t
          ? void 0
          : t.latestData[this._seriesGroupField].values
        : this._seriesField
        ? null === (e = this._viewDataStatistics) || void 0 === e
          ? void 0
          : e.latestData[this._seriesField].values
        : [];
    }
    getColorAttribute() {
      var t, e, i;
      return {
        scale:
          null !== (t = this._option.globalScale.getScale('color')) && void 0 !== t ? t : this.getDefaultColorScale(),
        field:
          null !== (i = null !== (e = this._seriesGroupField) && void 0 !== e ? e : this._seriesField) && void 0 !== i
            ? i
            : qq
      };
    }
    getDotColorScale() {
      var t, e, i;
      const n = this._dotTypeField
          ? null === (t = this._viewDataStatistics) || void 0 === t
            ? void 0
            : t.latestData[this._dotTypeField].values
          : this._seriesGroupField
          ? null === (e = this._viewDataStatistics) || void 0 === e
            ? void 0
            : e.latestData[this._seriesGroupField].values
          : this._seriesField
          ? null === (i = this._viewDataStatistics) || void 0 === i
            ? void 0
            : i.latestData[this._seriesField].values
          : [],
        s = nV(this._option.getTheme().colorScheme, this.type);
      return new hV().domain(n).range(s);
    }
    getDotColorAttribute() {
      var t, e, i, n;
      return {
        scale: null !== (t = this._option.globalScale.getScale('color')) && void 0 !== t ? t : this.getDotColorScale(),
        field:
          null !==
            (n =
              null !== (i = null !== (e = this._dotTypeField) && void 0 !== e ? e : this._seriesGroupField) &&
              void 0 !== i
                ? i
                : this._seriesField) && void 0 !== n
            ? n
            : qq
      };
    }
    initTooltip() {
      this._tooltipHelper = new T4(this);
    }
    onEvaluateEnd(t) {
      super.onEvaluateEnd(t);
    }
    onMarkTreePositionUpdate(t) {
      t.forEach(t => {
        'group' === t.type ? this.onMarkTreePositionUpdate(t.getMarks()) : t.updateLayoutState();
      });
    }
    getDotData() {
      var t;
      return null === (t = this._dotMark) || void 0 === t ? void 0 : t.getData();
    }
    _getDataIdKey() {}
    getStackValueField() {
      return null;
    }
  }
  (P4.type = DZ.dot), (P4.mark = QZ);
  NQ.useSeries([P4, M4]);
  class R4 extends h2 {
    constructor() {
      super(...arguments), (this.type = d2.sequence);
    }
    transformSpec(t) {
      var e, i, n, s, r, a, o, l, h, c, d;
      super.transformSpec(t);
      let u = 0;
      const p = [],
        g = [],
        f = [],
        v = [],
        m = [],
        y = t.series.filter(t => t.type !== DZ.link).length,
        _ = (this._layoutRect.height - 20 * (y - 1)) / y,
        b = (null === (e = null == t ? void 0 : t.appendPadding) || void 0 === e ? void 0 : e.left) || 0,
        x = (null === (i = null == t ? void 0 : t.appendPadding) || void 0 === i ? void 0 : i.right) || 0;
      if (null == t ? void 0 : t.legends) {
        p.push({ modelId: `legendRow${u}`, col: 1, row: u }),
          this.addAttrToComponentSpec(t.legends, 'id', `legendRow${u}`);
        const e = V(t.legends);
        let i = null !== (n = e[0].height) && void 0 !== n ? n : 40;
        if (e[0].padding) {
          const t = _V(e[0].padding);
          (i += Number(null !== (s = null == t ? void 0 : t.bottom) && void 0 !== s ? s : 0)),
            (i += Number(null !== (r = null == t ? void 0 : t.top) && void 0 !== r ? r : 0)),
            (e[0].offsetY =
              Number(null !== (o = null === (a = e[0]) || void 0 === a ? void 0 : a.offsetY) && void 0 !== o ? o : 0) +
              Number(null !== (l = null == t ? void 0 : t.top) && void 0 !== l ? l : 0));
        }
        m.push({ index: u, size: i }), u++;
      }
      (null == t ? void 0 : t.dataZoom) &&
        (p.push({ modelId: `dataZoomRow${u}`, col: 1, row: u }),
        this.addAttrToComponentSpec(t.dataZoom, 'id', `dataZoomRow${u}`),
        u++,
        m.push({ index: u, size: 10 }),
        u++),
        g.push({ id: `regionAxesRow${u}` }),
        p.push({ modelId: `axesRow${u}`, col: 1, row: u }),
        (t.axes[0].id = `axesRow${u}`),
        (t.axes[0].regionIndex = Array.from(Array(this._spec.series.length - 1), (t, e) => e + 1)),
        u++,
        null === (h = null == t ? void 0 : t.series) ||
          void 0 === h ||
          h.forEach(t => {
            var e, i;
            if ([DZ.bar, DZ.line, DZ.area, DZ.dot].includes(t.type)) {
              if (
                (p.push({ modelId: `${t.type}Row${u}`, col: 1, row: u }),
                p.push({ modelId: `axesLeftRow${u}`, col: 0, row: u }),
                g.push({ id: `${t.type}Row${u}`, clip: !1 }),
                m.push({ index: u, size: (null == t ? void 0 : t.height) || _ }),
                f.push({
                  orient: 'left',
                  id: `axesLeftRow${u}`,
                  type: t.type === DZ.dot ? 'band' : 'linear',
                  visible: t.type !== DZ.dot,
                  title: {
                    visible: !0,
                    autoRotate: !1,
                    style: { text: null == t ? void 0 : t.barTitle, dx: -20, textBaseline: 'middle', textAlign: 'end' }
                  },
                  grid: {
                    visible:
                      'boolean' !=
                        typeof (null === (e = null == t ? void 0 : t.grid) || void 0 === e ? void 0 : e.visible) ||
                      (null === (i = null == t ? void 0 : t.grid) || void 0 === i ? void 0 : i.visible),
                    style: (e, i) => {
                      var n, s, r, a, o;
                      let l = 0;
                      if (0 === i) {
                        const e = null === (n = null == t ? void 0 : t.grid) || void 0 === n ? void 0 : n.style;
                        l =
                          null !==
                            (r =
                              null !== (s = null == e ? void 0 : e.lineWidth) && void 0 !== s
                                ? s
                                : null == e
                                ? void 0
                                : e.strokeWidth) && void 0 !== r
                            ? r
                            : 1;
                      }
                      return {
                        lineWidth: l,
                        stroke:
                          (null ===
                            (o = null === (a = null == t ? void 0 : t.grid) || void 0 === a ? void 0 : a.style) ||
                          void 0 === o
                            ? void 0
                            : o.stroke) || '#dfdfdf',
                        lineDash: [0, 0]
                      };
                    }
                  },
                  domainLine: { visible: !1 },
                  tick: { visible: !1 },
                  label: { visible: !1 },
                  regionIndex: g.length - 1
                }),
                t.type === DZ.dot)
              ) {
                p.push({ modelId: `scrollBarRightRow${u}`, col: 2, row: u });
                const e = this.getSeriesData(t.dataId, t.dataIndex);
                let i = 0;
                e.latestData.length &&
                  e.latestData.length > 0 &&
                  (i = ((null == t ? void 0 : t.height) || _) / (30 * e.latestData.length)),
                  v.push({
                    orient: 'right',
                    visible: t.type === DZ.dot && i < 1,
                    id: `scrollBarRightRow${u}`,
                    start: 0,
                    end: Math.min(i, 1),
                    roam: !1,
                    filterMode: 'axis',
                    regionIndex: g.length - 1,
                    axisId: `axesLeftRow${u}`
                  });
              }
              (t.regionIndex = g.length - 1),
                u++,
                m.push({ index: u, size: (null == t ? void 0 : t.padding) || 20 }),
                u++,
                (t.leftAppendPadding = b),
                t.type === DZ.dot && ((t.title.style.dx = -b), (t.subTitle.style.dx = -b));
            }
          }),
        null === (c = null == t ? void 0 : t.series) ||
          void 0 === c ||
          c.forEach(e => {
            if (e.type === DZ.link) {
              const i = e.dotSeriesIndex + 1;
              p.push({ modelId: `${e.type}Row${i}`, col: 1, row: i - 1 }),
                (e.regionIndex = t.series[e.dotSeriesIndex].regionIndex),
                (e.leftAppendPadding = b),
                (e.height = t.series[e.dotSeriesIndex].height),
                (e.clipHeight = t.series[e.dotSeriesIndex].clipHeight);
            }
          }),
        (null == t ? void 0 : t.legends) && this.addAttrToComponentSpec(t.legends, 'regionIndex', [g.length - 1]);
      const S = {
        type: 'grid',
        col: 4,
        row: u,
        colWidth: [
          { index: 0, size: b },
          { index: 2, size: 12 },
          { index: 3, size: x }
        ],
        rowHeight: m,
        elements: p
      };
      (t.layout = S), (t.region = g), null === (d = t.axes) || void 0 === d || d.push(...f), (t.scrollBar = v);
    }
    createSeries(t) {
      t.forEach((t, e) => {
        var i, n;
        let s;
        if (
          (t.data
            ? ((t.data = EQ(t.data, this._dataSet, this._spec.data, {
                onError: null === (i = this._option) || void 0 === i ? void 0 : i.onError
              })),
              t.type === DZ.link &&
                (t.dataDot = EQ(this._spec.series[t.dotSeriesIndex].data, this._dataSet, this._spec.data, {
                  onError: null === (n = this._option) || void 0 === n ? void 0 : n.onError
                })))
            : ((t.data = this.getSeriesData(t.dataId, t.dataIndex)),
              t.type === DZ.link &&
                (t.dataDot = this.getSeriesData(
                  this._spec.series[t.dotSeriesIndex].dataId,
                  this._spec.series[t.dotSeriesIndex].dataIndex
                ))),
          t.type === DZ.link && (t.dotSeriesSpec = this._spec.series[t.dotSeriesIndex]),
          t.regionId && (s = this.getRegionsInUserId(t.regionId)),
          s || (s = this.getRegionsInIndex(t.regionIndex ? [t.regionIndex] : void 0)[0]),
          !s)
        )
          return;
        const r = UJ.createSeries(
          t.type,
          t,
          Object.assign(Object.assign({}, this._modelOption), {
            region: s,
            specIndex: e,
            specKey: 'series',
            getTheme: () => this._theme,
            globalScale: this._globalScale
          })
        );
        r && (r.created(), this._series.push(r), s.addSeries(r));
      });
    }
    addAttrToComponentSpec(t, e, i) {
      return Array.isArray(t) ? (t[0][e] = i) : (t[e] = i), t;
    }
  }
  (R4.type = d2.sequence), (R4.view = 'singleDefault');
  const O4 = (t, e) => {
    if (!t) return t;
    const i = e(),
      { width: n, height: s } = i;
    return new L2(i).layout(t, { width: n, height: s });
  };
  class B4 extends z1 {
    constructor() {
      super(...arguments),
        (this.contentKeyCallback = t => (null == t ? void 0 : t[this.series.getDimensionField()[0]]));
    }
  }
  NQ.useMark([c3, i2]);
  class I4 extends F3 {
    constructor() {
      super(...arguments), (this.type = DZ.sunburst);
    }
    setCategoryField(t) {
      return (this._categoryField = t), this._categoryField;
    }
    getCategoryField() {
      return this._categoryField;
    }
    setValueField(t) {
      return (this._valueField = t), this._valueField;
    }
    getValueField() {
      return this._valueField;
    }
    getDimensionField() {
      return [this._categoryField];
    }
    getMeasureField() {
      return [this._valueField];
    }
    setAttrFromSpec() {
      var t;
      super.setAttrFromSpec(),
        this.setCategoryField(this._spec.categoryField),
        this.setValueField(this._spec.valueField),
        this.setSeriesField(null !== (t = this._spec.seriesField) && void 0 !== t ? t : U1),
        this._spec.drill &&
          this.initDrillable({
            event: this.event,
            mode: this._option.mode,
            drillField: () => {
              var t;
              return null !== (t = this._spec.drillField) && void 0 !== t ? t : Kq;
            },
            getRawData: () => this.getRawData()
          }),
        (this._startAngle = qt(this._spec.startAngle)),
        (this._endAngle = qt(this._spec.endAngle)),
        (this._centerX = this._spec.centerX),
        (this._centerY = this._spec.centerY),
        (this._offsetX = this._spec.offsetX),
        (this._offsetY = this._spec.offsetY),
        (this.__innerRadius = this._spec.innerRadius),
        (this.__outerRadius = this._spec.outerRadius),
        (this._gap = this._spec.gap),
        (this._labelLayout = this._spec.labelLayout),
        (this._sunburst = this._spec.sunburst),
        (this._label = this._spec.label),
        (this._labelAutoVisible = this._spec.labelAutoVisible);
    }
    initData() {
      super.initData();
      const t = this.getRawData();
      t &&
        (this._spec.drill && this.initDrillableData(this._dataSet),
        xQ(this._dataSet, 'sunburstLayout', O4),
        xQ(this._dataSet, 'flatten', e3),
        t.transform({
          type: 'sunburstLayout',
          options: () => {
            const { innerRadius: t, outerRadius: e, gap: i, label: n } = this._computeLevel();
            return {
              nodeKey: this._categoryField,
              width: this.getLayoutRect().width,
              height: this.getLayoutRect().height,
              center: [
                h(this._centerX) ? this._centerX : this.getLayoutRect().width / 2,
                h(this._centerY) ? this._centerY : this.getLayoutRect().height / 2
              ],
              startAngle: this._startAngle,
              endAngle: this._endAngle,
              innerRadius: t,
              outerRadius: e,
              gapRadius: i,
              label: n
            };
          }
        }),
        t.transform({
          type: 'flatten',
          options: {
            callback: t => {
              if (t.datum) {
                const e = t.datum[t.depth];
                return Object.assign(Object.assign({}, t), e);
              }
              return t;
            }
          }
        }));
    }
    getStatisticFields() {
      return super.getStatisticFields().concat([
        { key: this._categoryField, operations: ['values'] },
        { key: this._valueField, operations: ['max', 'min'] },
        { key: G1, operations: ['max', 'min', 'values'] },
        { key: U1, operations: ['values'] }
      ]);
    }
    _addDataIndexAndKey() {
      const t = this.getRawData();
      l(null == t ? void 0 : t.dataSet) ||
        (xQ(t.dataSet, 'addVChartProperty', P1),
        t.transform({ type: 'addVChartProperty', options: { beforeCall: $1, call: K1.bind(this) } }));
    }
    initMark() {
      this._initArcMark(), this._initLabelMark();
    }
    initMarkStyle() {
      this._initArcMarkStyle(), this._initLabelMarkStyle();
    }
    _initArcMark() {
      var t;
      if (!1 === this._sunburst.visible) return;
      const e = this._createMark(I4.mark.sunburst, { isSeriesMark: !0 });
      (this._sunburstMark = e),
        this._trigger.registerMark(this._sunburstMark),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(this._sunburstMark);
    }
    _initArcMarkStyle() {
      l(this._sunburstMark) ||
        this.setMarkStyle(
          this._sunburstMark,
          {
            x: t => t.x + (h(this._offsetX) ? this._offsetX : 0),
            y: t => t.y + (h(this._offsetY) ? this._offsetY : 0),
            outerRadius: t => t.outerRadius,
            innerRadius: t => t.innerRadius,
            startAngle: t => t.startAngle,
            endAngle: t => t.endAngle,
            fill: this.getColorAttribute()
          },
          BQ.STATE_NORMAL,
          Jq.Series
        );
    }
    _initLabelMark() {
      var t;
      if (!0 !== this._label.visible) return;
      const e = this._createMark(I4.mark.label, { isSeriesMark: !1 });
      (this._labelMark = e),
        this._trigger.registerMark(e),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(e);
    }
    _initLabelMarkStyle() {
      l(this._labelMark) ||
        this.setMarkStyle(
          this._labelMark,
          {
            visible: t => {
              var e;
              const i = this._labelAutoVisible;
              return c(i) && !0 === i.enable
                ? (t.endAngle - t.startAngle) * (t.outerRadius - t.innerRadius) >
                    (null !== (e = null == i ? void 0 : i.circumference) && void 0 !== e ? e : 10)
                : this._spec.label.visible;
            },
            x: t => {
              var e;
              return (null === (e = t.label) || void 0 === e ? void 0 : e.x) + (h(this._offsetX) ? this._offsetX : 0);
            },
            y: t => {
              var e;
              return (null === (e = t.label) || void 0 === e ? void 0 : e.y) + (h(this._offsetY) ? this._offsetY : 0);
            },
            textBaseline: t => {
              var e;
              return null === (e = t.label) || void 0 === e ? void 0 : e.textBaseline;
            },
            textAlign: t => {
              var e;
              return null === (e = t.label) || void 0 === e ? void 0 : e.textAlign;
            },
            angle: t => {
              var e, i;
              return null !== (i = null === (e = t.label) || void 0 === e ? void 0 : e.angle) && void 0 !== i ? i : 0;
            },
            fontSize: 10,
            text: t => t.name
          },
          BQ.STATE_NORMAL,
          Jq.Series
        );
    }
    initTooltip() {
      this._tooltipHelper = new B4(this);
    }
    initAnimation() {
      var t, e;
      const i = {
          animationInfo: () => ({
            innerRadius: this._computeRadius(V(this.__innerRadius))[0],
            outerRadius: this._computeRadius(V(this.__outerRadius))[0],
            startAngle: V(this._startAngle)[0],
            endAngle: V(this._endAngle)[0]
          })
        },
        n =
          null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
            ? void 0
            : e.preset;
      this.getMarksInType(jZ.arc).forEach(t => {
        t.setAnimationConfig(w1(x1.sunburst(i, n), A1(t.name, this._spec)));
      }),
        this.getMarksInType(jZ.text).forEach(t => {
          t.setAnimationConfig(w1(x1.label(), A1(t.name, this._spec)));
        });
    }
    initEvent() {
      super.initEvent(), this._spec.drill && this.bindDrillEvent();
    }
    onLayoutEnd(t) {
      super.onLayoutEnd(t), this._rawData.reRunAllTransform();
    }
    _computeRadius(t) {
      if (f(t))
        return t.map(t => {
          const { width: e, height: i } = this.getRegion().getLayoutRect();
          return Math.min(e / 2, i / 2) * t;
        });
      const { width: e, height: i } = this.getRegion().getLayoutRect();
      return Math.min(e / 2, i / 2) * t;
    }
    _computeLevel() {
      return {
        innerRadius: this._computeRadius(this.__innerRadius),
        outerRadius: this._computeRadius(this.__outerRadius),
        gap: this._gap,
        label: this._labelLayout
      };
    }
    getGroupFields() {
      return [];
    }
    getStackGroupFields() {
      return [];
    }
    getStackValueField() {
      return '';
    }
    setValueFieldToStack() {}
    setValueFieldToPercent() {}
    _noAnimationDataKey(t, e) {}
  }
  (I4.type = DZ.sunburst), (I4.mark = cJ), N(I4, l3), NQ.useSeries([I4]);
  class D4 extends h2 {
    constructor() {
      super(...arguments), (this.type = d2.sunburst), (this.seriesType = DZ.sunburst);
    }
    getDefaultSeriesSpec(t) {
      const e = h(t.startAngle) ? t.startAngle : pW,
        i = h(t.endAngle) ? t.endAngle : e + Zt(2 * Math.PI),
        n = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
          categoryField: t.categoryField,
          valueField: t.valueField,
          seriesField: t.seriesField,
          centerX: t.centerX,
          centerY: t.centerY,
          offsetX: t.offsetX,
          offsetY: t.offsetY,
          startAngle: e,
          endAngle: i,
          innerRadius: t.innerRadius,
          outerRadius: t.outerRadius,
          gap: t.gap,
          labelLayout: t.labelLayout,
          label: t.label,
          labelAutoVisible: t.labelAutoVisible,
          drill: t.drill,
          drillField: t.drillField
        }),
        s = DZ.sunburst;
      return (n.type = s), (n[s] = t[s]), n;
    }
    transformSpec(t) {
      super.transformSpec(t);
      const e = this.getDefaultSeriesSpec(t);
      t.series && 0 !== t.series.length
        ? t.series.forEach(t => {
            this.isValidSeries(t.type) &&
              Object.keys(e).forEach(i => {
                i in t || (t[i] = e[i]);
              });
          })
        : (t.series = [e]);
    }
  }
  (D4.type = d2.sunburst), (D4.view = 'singleDefault');
  const L4 = (t, e) => {
      if (!t || !(null == e ? void 0 : e.range)) return t;
      const i = e.range();
      if (i.x1 - i.x0 == 0 || i.y1 - i.y0 == 0) return t;
      return new I2(e).layout(t, i);
    },
    F4 = (t, e) => {
      let i = {},
        n = e.fields;
      if ((o(n) && (n = n()), !(null == n ? void 0 : n.length) || !(null == t ? void 0 : t.length))) return i;
      if (!t[0].latestData) return i;
      const s = t[0].latestData,
        r = e3(s);
      return (i = N1([{ latestData: r }], e)), i;
    };
  class j4 extends z1 {
    constructor() {
      super(...arguments),
        (this.contentKeyCallback = t => (null == t ? void 0 : t[this.series.getDimensionField()[0]]));
    }
    get defaultShapeType() {
      return 'square';
    }
  }
  class z4 {
    initZoomable(e, i = t.RenderModeEnum['desktop-browser']) {
      (this._eventObj = e),
        (this._renderMode = i),
        o3[this._renderMode] &&
          ((this._clickEnable = !0), (this._zoomableTrigger = new (this._getTriggerEvent('trigger'))()));
    }
    _getTriggerEvent(t) {
      return o3[this._renderMode][t];
    }
    _bindZoomEventAsRegion(t, e, i) {
      t.on(this._getTriggerEvent('scrollEnd'), { level: Yq.chart, consume: !1 }, t => {
        this._zoomableTrigger.clearZoom();
      }),
        t.on(this._getTriggerEvent('scroll'), { level: Yq.chart, consume: !0 }, t => {
          if (!t.event) return;
          const n = t.event.clone();
          this._zoomableTrigger.parserZoomEvent(n);
          const { zoomDelta: s, zoomX: r, zoomY: a } = n;
          l(s) ||
            (fV({ x: r, y: a }, Object.assign(Object.assign({}, e.getLayoutRect()), e.getLayoutStartPoint())) &&
              ((this._clickEnable = !1),
              i && i({ zoomDelta: s, zoomX: r, zoomY: a }, n),
              this._eventObj.emit('zoom', {
                scale: n.zoomDelta,
                scaleCenter: { x: n.zoomX, y: n.zoomY },
                model: this
              })));
        });
    }
    initZoomEventOfSeries(t, e) {
      o3[this._renderMode] && this._bindZoomEventAsRegion(t.event, t, e);
    }
    initZoomEventOfRegions(t, e, i) {
      o3[this._renderMode] &&
        t.forEach(t => {
          e
            ? t.getSeries().forEach(t => {
                e(t) && this._bindZoomEventAsRegion(t.event, t, i);
              })
            : this._bindZoomEventAsRegion(this._eventObj, t, i);
        });
    }
    initScrollEventOfSeries(t, e) {
      o3[this._renderMode] && this._bindScrollEventAsRegion(t.event, t, e);
    }
    initScrollEventOfRegions(t, e, i) {
      o3[this._renderMode] &&
        t.forEach(t => {
          e
            ? t.getSeries().forEach(t => {
                e(t) && this._bindScrollEventAsRegion(t.event, t, i);
              })
            : this._bindScrollEventAsRegion(this._eventObj, t, i);
        });
    }
    _bindScrollEventAsRegion(t, e, i) {
      t.on(this._getTriggerEvent('scrollEnd'), { level: Yq.chart, consume: !1 }, t => {
        this._zoomableTrigger.clearScroll();
      }),
        t.on(this._getTriggerEvent('scroll'), { level: Yq.chart, consume: !0 }, t => {
          if (!t.event) return;
          const { event: n } = t;
          this._zoomableTrigger.parserScrollEvent(n);
          const { scrollX: s, scrollY: r } = n;
          (l(s) && l(r)) ||
            (fV(
              { x: n.canvasX, y: n.canvasY },
              Object.assign(Object.assign({}, e.getLayoutRect()), e.getLayoutStartPoint())
            ) &&
              ((this._clickEnable = !1),
              i && i({ scrollX: s, scrollY: r }, n),
              this._eventObj.emit('scroll', { scrollX: s, scrollY: r, model: this })));
        });
    }
    _bindDragEventAsRegion(t, e, i) {
      t.on(this._getTriggerEvent('start'), { level: Yq.chart }, t => {
        if (!t.event) return;
        const { event: n } = t;
        fV(
          { x: n.canvasX, y: n.canvasY },
          Object.assign(Object.assign({}, e.getLayoutRect()), e.getLayoutStartPoint())
        ) && this._handleDrag(t, i);
      }),
        t.on('click', { level: Yq.chart }, () => !this._clickEnable);
    }
    initDragEventOfSeries(t, e) {
      o3[this._renderMode] &&
        t.event.on(
          this._getTriggerEvent('start'),
          { level: Yq.model, filter: ({ model: e }) => (null == e ? void 0 : e.id) === t.id },
          t => {
            this._handleDrag(t, e);
          }
        );
    }
    initDragEventOfRegions(t, e, i) {
      o3[this._renderMode] &&
        t.forEach(t => {
          e
            ? t.getSeries().forEach(t => {
                e(t) &&
                  (t.event.on(
                    this._getTriggerEvent('start'),
                    { level: Yq.model, filter: ({ model: e }) => (null == e ? void 0 : e.id) === t.id },
                    t => {
                      this._handleDrag(t, i);
                    }
                  ),
                  t.event.on(
                    'click',
                    { level: Yq.model, filter: ({ model: e }) => (null == e ? void 0 : e.id) === t.id },
                    () => !this._clickEnable
                  ));
              })
            : this._bindDragEventAsRegion(this._eventObj, t, i);
        });
    }
    _handleDrag(t, e) {
      if (((this._clickEnable = !0), !this._zoomableTrigger.parserDragEvent(t.event))) return;
      const i = this._getTriggerEvent('move'),
        n = this._getTriggerEvent('end'),
        s = t.event;
      let r = s.canvasX,
        a = s.canvasY;
      const o = () => {
          (this._zoomableTrigger.pointerId = null),
            this._eventObj.off(i, { level: Yq.chart, source: Uq.chart }, l),
            this._eventObj.off(n, { level: Yq.chart, source: Uq.window }, o);
        },
        l = t => {
          if (!this._zoomableTrigger.parserDragEvent(t.event)) return;
          this._clickEnable = !1;
          const i = t.event,
            n = [i.canvasX - r, i.canvasY - a];
          (r = i.canvasX),
            (a = i.canvasY),
            e && e(n, t.event),
            this._eventObj.emit('panmove', { delta: n, model: this });
        };
      this._eventObj.on(i, { level: Yq.chart, source: Uq.chart }, l),
        this._eventObj.on(n, { level: Yq.chart, source: Uq.chart }, o);
    }
  }
  NQ.useMark([p2, i2]);
  class H4 extends J1 {
    constructor() {
      super(...arguments),
        (this.type = DZ.treemap),
        (this._viewBox = new Xt()),
        (this._clickEnable = !0),
        (this._enableAnimationHook = this.enableMarkAnimation.bind(this));
    }
    getCategoryField() {
      return this._categoryField;
    }
    setCategoryField(t) {
      return (this._categoryField = t), this._categoryField;
    }
    getValueField() {
      return this._valueField;
    }
    setValueField(t) {
      return (this._valueField = t), this._valueField;
    }
    setAttrFromSpec() {
      var t;
      super.setAttrFromSpec(),
        this.setCategoryField(this._spec.categoryField),
        this.setValueField(this._spec.valueField),
        this.setSeriesField(null !== (t = this._spec.seriesField) && void 0 !== t ? t : U1),
        this._spec.roam && (this.initZoomable(this.event, this._option.mode), (this._matrix = new ie())),
        this._spec.drill &&
          this.initDrillable({
            event: this.event,
            mode: this._option.mode,
            drillField: () => {
              var t;
              return null !== (t = this._spec.drillField) && void 0 !== t ? t : Kq;
            },
            getRawData: () => this.getRawData()
          }),
        _(this._spec.maxDepth) && (this._maxDepth = this._spec.maxDepth - 1);
    }
    initData() {
      var t, e, i, n;
      super.initData(),
        this._viewDataFilter &&
          (this._spec.drill && this.initDrillableData(this._dataSet),
          xQ(this._dataSet, 'treemap', L4),
          xQ(this._dataSet, 'flatten', e3),
          this.addViewDataFilter({
            type: 'treemap',
            options: {
              range: () => ({ x0: this._viewBox.x1, x1: this._viewBox.x2, y0: this._viewBox.y1, y1: this._viewBox.y2 }),
              maxDepth: this._maxDepth,
              gapWidth: this._spec.gapWidth,
              padding: this._spec.nodePadding,
              splitType: this._spec.splitType,
              aspectRatio: this._spec.aspectRatio,
              labelPadding: (null === (t = this._spec.nonLeafLabel) || void 0 === t ? void 0 : t.visible)
                ? null === (e = this._spec.nonLeafLabel) || void 0 === e
                  ? void 0
                  : e.padding
                : 0,
              labelPosition: null === (i = this._spec.nonLeafLabel) || void 0 === i ? void 0 : i.position,
              minVisibleArea: null !== (n = this._spec.minVisibleArea) && void 0 !== n ? n : 10,
              minChildrenVisibleArea: this._spec.minChildrenVisibleArea,
              minChildrenVisibleSize: this._spec.minChildrenVisibleSize
            }
          }),
          this.addViewDataFilter({
            type: 'flatten',
            options: {
              callback: t => {
                if (t.datum) {
                  const e = t.datum[t.depth];
                  return Object.assign(Object.assign({}, t), e);
                }
                return t;
              }
            }
          }));
    }
    _addDataIndexAndKey() {
      var t;
      (null === (t = this._rawData) || void 0 === t ? void 0 : t.dataSet) &&
        (xQ(this._rawData.dataSet, 'addVChartProperty', P1),
        this._rawData.transform({ type: 'addVChartProperty', options: { beforeCall: $1, call: K1.bind(this) } }));
    }
    _statisticRawData() {
      const t = `${UV}_series_${this.id}_rawDataStatic`;
      (this._rawDataStatistics = this._createHierarchyDataStatistics(t, [this._rawData])),
        this._rawData.target.removeListener('change', this._rawDataStatistics.reRunAllTransform),
        this._rawDataStatistics.reRunAllTransform();
    }
    _createHierarchyDataStatistics(t, e) {
      xQ(this._dataSet, 'hierarchyDimensionStatistics', F4), xQ(this._dataSet, 'flatten', e3);
      const i = new yo(this._dataSet, { name: t });
      return (
        i.parse(e, { type: 'dataview' }),
        i.transform(
          {
            type: 'hierarchyDimensionStatistics',
            options: {
              fields: () => {
                const t = this.getStatisticFields();
                return (
                  this._seriesField &&
                    this._seriesField !== this._categoryField &&
                    t.push({ key: this._seriesField, operations: ['values'] }),
                  t
                );
              }
            }
          },
          !1
        ),
        i
      );
    }
    getStatisticFields() {
      return super.getStatisticFields().concat([
        { key: this._categoryField, operations: ['values'] },
        { key: this._valueField, operations: ['max', 'min'] },
        { key: G1, operations: ['max', 'min', 'values'] },
        { key: U1, operations: ['values'] }
      ]);
    }
    initMark() {
      var t, e, i, n, s, r;
      const a = this._createMark(H4.mark.nonLeaf, { isSeriesMark: !0 });
      a &&
        (a.setTransform([{ type: 'filter', callback: t => !this._shouldFilterElement(t, 'nonLeaf') }]),
        this._trigger.registerMark(a),
        (this._nonLeafMark = a),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(a));
      const o = this._createMark(H4.mark.leaf, { isSeriesMark: !0 });
      if (
        (o &&
          (o.setTransform([{ type: 'filter', callback: t => !this._shouldFilterElement(t, 'leaf') }]),
          (this._leafMark = o),
          this._trigger.registerMark(o),
          null === (e = this._tooltipHelper) || void 0 === e || e.activeTriggerSet.mark.add(o)),
        null === (i = this._spec.label) || void 0 === i ? void 0 : i.visible)
      ) {
        const t = this._createMark(H4.mark.label, { skipBeforeLayouted: !1 });
        t &&
          (t.setTransform([{ type: 'filter', callback: t => !this._shouldFilterElement(t, 'leaf') }]),
          (this._labelMark = t),
          this._trigger.registerMark(t),
          null === (n = this._tooltipHelper) || void 0 === n || n.activeTriggerSet.mark.add(t));
      }
      if (null === (s = this._spec.nonLeafLabel) || void 0 === s ? void 0 : s.visible) {
        const t = this._createMark(H4.mark.nonLeafLabel);
        t &&
          (t.setTransform([{ type: 'filter', callback: t => !this._shouldFilterElement(t, 'nonLeaf') }]),
          (this._nonLeafLabelMark = t),
          this._trigger.registerMark(t),
          null === (r = this._tooltipHelper) || void 0 === r || r.activeTriggerSet.mark.add(t));
      }
    }
    initMarkStyle() {
      this._initLeafMarkStyle(),
        this._initNonLeafMarkStyle(),
        this._initLabelMarkStyle(),
        this._initNonLeafLabelMarkStyle();
    }
    _initLeafMarkStyle() {
      this._leafMark &&
        this.setMarkStyle(
          this._leafMark,
          { x: t => t.x0, y: t => t.y0, x1: t => t.x1, y1: t => t.y1, fill: this.getColorAttribute() },
          BQ.STATE_NORMAL,
          Jq.Series
        );
    }
    _initNonLeafMarkStyle() {
      this._nonLeafMark &&
        this.setMarkStyle(
          this._nonLeafMark,
          { x: t => t.x0, y: t => t.y0, x1: t => t.x1, y1: t => t.y1, fill: this.getColorAttribute() },
          BQ.STATE_NORMAL,
          Jq.Series
        );
    }
    _initLabelMarkStyle() {
      this._labelMark &&
        this.setMarkStyle(
          this._labelMark,
          {
            visible: (t, e, { element: i }) => {
              if (!t.isLeaf) return !1;
              const n = i.getBounds(),
                { y0: s, y1: r } = t;
              return !!n && n.y1 > s && n.y2 < r;
            },
            x: t => (t.x0 + t.x1) / 2,
            y: t => (t.y0 + t.y1) / 2,
            text: t => {
              var e;
              return null === (e = t.datum[t.depth]) || void 0 === e ? void 0 : e[this.getDimensionField()[0]];
            },
            limit: t => (t.x1 === t.x0 ? Number.MIN_VALUE : t.x1 - t.x0)
          },
          BQ.STATE_NORMAL,
          Jq.Series
        );
    }
    _initNonLeafLabelMarkStyle() {
      this._nonLeafLabelMark &&
        this.setMarkStyle(
          this._nonLeafLabelMark,
          {
            visible: t => !!t.labelRect,
            x: t => (t.labelRect ? (t.labelRect.x0 + t.labelRect.x1) / 2 : (t.x0 + t.x1) / 2),
            y: t => (t.labelRect ? (t.labelRect.y0 + t.labelRect.y1) / 2 : (t.y0 + t.y1) / 2),
            text: t => {
              var e;
              return null === (e = t.datum[t.depth]) || void 0 === e ? void 0 : e[this.getDimensionField()[0]];
            },
            limit: t => (t.x1 === t.x0 ? Number.MIN_VALUE : t.x1 - t.x0)
          },
          BQ.STATE_NORMAL,
          Jq.Series
        );
    }
    initAnimation() {
      this.getMarksInType(jZ.rect).forEach(t => {
        t.setAnimationConfig(w1(x1.treemap(), A1(t.name, this._spec)));
      }),
        this.getMarksInType(jZ.text).forEach(t => {
          t.setAnimationConfig(w1(x1.label(), A1(t.name, this._spec)));
        });
    }
    initEvent() {
      super.initEvent(),
        this._spec.roam &&
          (this.initDragEventOfSeries(this),
          this.event.on('panmove', t => {
            this.handlePan(t);
          }),
          this.initZoomEventOfSeries(this),
          this.event.on('zoom', t => {
            this.handleZoom(t);
          })),
        this._spec.drill && this.bindDrillEvent();
    }
    _getDataIdKey() {
      return 'key';
    }
    initTooltip() {
      this._tooltipHelper = new j4(this);
    }
    _shouldFilterElement(t, e) {
      const i = t.isLeaf;
      return 'leaf' === e ? !i : i;
    }
    handlePan(t) {
      const { delta: e } = t;
      if (0 === e[0] && 0 === e[1]) return;
      this._matrix.reset(), this._matrix.translate(e[0], e[1]);
      const { a: i, b: n, c: s, d: r, e: a, f: o } = this._matrix;
      this._matrix.multiply(i, n, s, r, a, o), this._viewBox.transformWithMatrix(this._matrix), this.reFilterViewData();
    }
    handleZoom(t) {
      const { scale: e, scaleCenter: i } = t;
      if (1 === e) return;
      this._matrix.reset();
      const { x: n, y: s } = i;
      this._matrix.translate(n, s), this._matrix.scale(e, e), this._matrix.translate(-n, -s);
      const { a: r, b: a, c: o, d: l, e: h, f: c } = this._matrix;
      this._matrix.multiply(r, a, o, l, h, c),
        this.disableMarkAnimation(),
        this.event.on(tG.AFTER_DO_RENDER, this._enableAnimationHook),
        this._viewBox.transformWithMatrix(this._matrix),
        this.reFilterViewData();
    }
    getDimensionField() {
      return [this._categoryField];
    }
    getMeasureField() {
      return [this._valueField];
    }
    onLayoutEnd(t) {
      super.onLayoutEnd(t),
        this._viewBox.set(0, 0, this.getLayoutRect().width, this.getLayoutRect().height),
        this._rawData.reRunAllTransform();
    }
    enableMarkAnimation() {
      this.getMarks().forEach(t => {
        var e;
        null === (e = t.getProduct().animate) || void 0 === e || e.enable();
      }),
        this.event.off(tG.AFTER_DO_RENDER, this._enableAnimationHook);
    }
    disableMarkAnimation() {
      this.getMarks().forEach(t => {
        var e;
        null === (e = t.getProduct().animate) || void 0 === e || e.disable();
      });
    }
    getDefaultShapeType() {
      return 'square';
    }
  }
  (H4.type = DZ.treemap), (H4.mark = aJ), N(H4, z4), N(H4, l3), NQ.useSeries([H4]);
  class N4 extends h2 {
    constructor() {
      super(...arguments), (this.type = d2.treemap), (this.seriesType = DZ.treemap);
    }
    getDefaultSeriesSpec(t) {
      const e = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
          categoryField: t.categoryField,
          valueField: t.valueField,
          seriesField: t.seriesField,
          aspectRatio: t.aspectRatio,
          splitType: t.splitType,
          maxDepth: t.maxDepth,
          gapWidth: t.gapWidth,
          nodePadding: t.nodePadding,
          minVisibleArea: t.minVisibleArea,
          minChildrenVisibleArea: t.minChildrenVisibleArea,
          minChildrenVisibleSize: t.minChildrenVisibleSize,
          roam: t.roam,
          drill: t.drill,
          drillField: t.drillField,
          leaf: t.leaf,
          nonLeaf: t.nonLeaf,
          nonLeafLabel: t.nonLeafLabel
        }),
        i = this.seriesType;
      return i && ((e.type = i), (e[i] = t[i])), e;
    }
    transformSpec(t) {
      super.transformSpec(t);
      const e = this.getDefaultSeriesSpec(t);
      t.series && 0 !== t.series.length
        ? t.series.forEach(t => {
            this.isValidSeries(t.type) &&
              Object.keys(e).forEach(i => {
                i in t || (t[i] = e[i]);
              });
          })
        : (t.series = [e]);
    }
  }
  (N4.type = d2.treemap), (N4.view = 'singleDefault');
  const V4 = (t, e) => {
      if (!t || 0 === t.length) return t;
      const {
          indexField: i,
          valueField: n,
          startAs: s,
          endAs: r,
          total: a,
          seriesField: o,
          seriesFieldName: h,
          groupData: c
        } = e,
        d = [],
        { dimensionValues: u, dimensionData: p } = c().latestData,
        g = Array.from(u[i]);
      let f = { start: 0, end: 0, lastIndex: null };
      return (
        g.forEach((t, e) => {
          const i = { start: f.end, end: f.end, lastIndex: f.lastIndex, lastEnd: f.end, index: t, isTotal: !1 };
          p[t].forEach(t => {
            let c = !1;
            if (a && 'end' !== a.type) {
              if ('field' === a.type || 'custom' === a.type) {
                if (t[a.tagField])
                  if (((c = !0), 'custom' === a.type)) {
                    const { start: e, end: n } = a.product(t, f);
                    (t[s] = e), (t[r] = n), (i.end = n), (i.start = e);
                  } else {
                    let e = 0,
                      o = i.end;
                    if (a.collectCountField && !l(t[a.collectCountField])) {
                      const i = d.length - +t[a.collectCountField],
                        n = d.length - 1;
                      i < 0 ? console.warn('total.collectCountField error') : (e = d[i].start),
                        n < 0 ? console.warn('total.collectCountField error') : (o = d[n].end);
                    } else
                      a.startField && !l(t[a.startField]) && (e = +t[a.startField]),
                        a.valueField && !l(t[a.valueField]) && (o = Gt(e, +t[a.valueField]));
                    (t[s] = e), (t[r] = o), (t[n] = o - e), (i.start = e), (i.end = o);
                  }
              }
            } else e === g.length - 1 && ((i.start = 0), (t[s] = i.start), (t[r] = i.end), (c = !0));
            c || ((t[s] = +i.end), (t[r] = Gt(t[s], +t[n])), (i.end = t[r])),
              (i.isTotal = c),
              (l(o) || o === $q) && (t[$q] = c ? h.total : +t[n] >= 0 ? h.increase : h.decrease);
          }),
            (f = Object.assign(Object.assign({}, i), { lastIndex: t })),
            d.push(i);
        }),
        d
      );
    },
    W4 = (t, e) => {
      if (!t) return t;
      const { indexField: i, valueField: n, total: s, seriesField: r } = e,
        a = { [i]: (null == s ? void 0 : s.text) || 'total', [n]: t.reduce((t, e) => Gt(t, +e[n]), 0) };
      return r && (a[r] = 'total'), t.push(a), t;
    },
    G4 = (t, e) => {
      if (!e.fields) return t;
      const i = {};
      return { dimensionValues: i, dimensionData: U4(t.map(t => t.latestData).flat(), e.fields, i) };
    };
  function U4(t, e, i) {
    if (0 === e.length) return t;
    const n = e[0],
      s = e.slice(1);
    i[n] = new Set();
    const r = (function (t, e, i) {
      const n = {};
      return (
        t.forEach(t => {
          const s = t[e];
          n[s] || ((n[s] = []), i.add(s)), n[s].push(t);
        }),
        n
      );
    })(t, n, i[n]);
    return s.length
      ? ((a = r), (o = (t, e) => U4(t, s, i)), Object.keys(a).reduce((t, e) => ((t[e] = o(a[e], e)), t), {}))
      : r;
    var a, o;
  }
  class Y4 {
    get fields() {
      return this._fields;
    }
    get groupData() {
      return this._groupData;
    }
    constructor(t) {
      (this._fields = []), (this._fields = t);
    }
    initData(t, e) {
      const i = t.name,
        n = new yo(e instanceof vo ? e : t.dataSet);
      (n.name = i),
        n.parse([t], { type: 'dataview' }),
        xQ(e, 'dimensionTree', G4),
        n.transform({ type: 'dimensionTree', options: { fields: this._fields } }, !1),
        n.target.addListener('change', this.groupDataUpdate.bind(this)),
        (this._groupData = n);
    }
    groupDataUpdate() {}
    getGroupValueInField(t) {
      var e, i, n;
      const s =
        null ===
          (n =
            null === (i = null === (e = this.groupData) || void 0 === e ? void 0 : e.latestData) || void 0 === i
              ? void 0
              : i.dimensionValues) || void 0 === n
          ? void 0
          : n[t];
      return s ? Array.from(s) : [];
    }
  }
  const $4 = {
    rect: function (t) {
      var e, i, n, s, r, a;
      const { series: o, labelSpec: l = {} } = t,
        h = null !== (e = l.position) && void 0 !== e ? e : 'outside',
        c = null !== (i = o.direction) && void 0 !== i ? i : 'vertical',
        d =
          'horizontal' === o.direction
            ? null === (n = o.getXAxisHelper()) || void 0 === n
              ? void 0
              : n.isInverse()
            : null === (s = o.getYAxisHelper()) || void 0 === s
            ? void 0
            : s.isInverse();
      let u,
        p = h;
      'inside' !== p &&
        (p = t => {
          const { data: e } = t,
            i = o.getMeasureField()[0];
          if ('outside' === h) {
            const t = { vertical: ['top', 'bottom'], horizontal: ['right', 'left'] },
              n = ((null == e ? void 0 : e[i]) >= 0 && d) || ((null == e ? void 0 : e[i]) < 0 && !d) ? 1 : 0;
            return t[c][n];
          }
          return 'inside-bottom' === h
            ? 'horizontal' === o.direction
              ? 'inside-left'
              : 'inside-bottom'
            : 'inside-top' === h
            ? 'horizontal' === o.direction
              ? 'inside-right'
              : 'inside-top'
            : h;
        });
      u = !1 !== l.overlap && {
        strategy:
          null !== (a = null === (r = l.overlap) || void 0 === r ? void 0 : r.strategy) && void 0 !== a ? a : Z4(o)
      };
      let f = !1;
      g(h) && h.includes('inside') && (f = !0);
      return { position: p, overlap: u, smartInvert: f };
    },
    symbol: function (t) {
      var e, i, n;
      const { series: s, labelSpec: r } = t,
        a = 'horizontal' === s.direction ? 'right' : 'top',
        o = null !== (e = r.position) && void 0 !== e ? e : a;
      let l;
      l = !1 !== r.overlap && {
        strategy:
          null !== (n = null === (i = r.overlap) || void 0 === i ? void 0 : i.strategy) && void 0 !== n ? n : q4(),
        avoidBaseMark: 'center' !== o
      };
      return { position: o, overlap: l };
    },
    arc: function (t) {
      var e;
      const { labelSpec: i } = t,
        n = null !== (e = i.position) && void 0 !== e ? e : 'outside',
        s = n;
      let r;
      r = i.smartInvert ? i.smartInvert : g(n) && n.includes('inside');
      return { position: s, smartInvert: r };
    },
    point: function (t) {
      const { labelSpec: e } = t;
      let i;
      i = !1 !== e.overlap && { avoidBaseMark: !1 };
      return { position: 'center', overlap: i };
    },
    stackLabel: function (t) {
      const e = t.series,
        i = t.labelSpec || {},
        n = e.getTotalData();
      return {
        customLayoutFunc: n =>
          n.map(n => {
            const s = i.position || 'withChange',
              r = i.offset || 0,
              a = n.data,
              o = K4(t, a, i.formatMethod);
            return (
              (o.x = (t =>
                e.direction === JJ.vertical
                  ? e.totalPositionX(t, 'index', 0.5)
                  : 'middle' === s
                  ? 0.5 * (e.totalPositionX(t, 'end') + e.totalPositionY(t, 'start'))
                  : 'max' === s
                  ? e.totalPositionX(t, t.end >= t.start ? 'end' : 'start') + r
                  : 'min' === s
                  ? e.totalPositionX(t, t.end >= t.start ? 'start' : 'end') - r
                  : e.totalPositionX(t, 'end') + (t.end >= t.start ? r : -r))(a)),
              (o.y = (t =>
                e.direction === JJ.vertical
                  ? 'middle' === s
                    ? 0.5 * (e.totalPositionY(t, 'end') + e.totalPositionY(t, 'start'))
                    : 'max' === s
                    ? e.totalPositionY(t, t.end >= t.start ? 'end' : 'start') - r
                    : 'min' === s
                    ? e.totalPositionY(t, t.end >= t.start ? 'start' : 'end') + r
                    : e.totalPositionY(t, 'end') + (t.end >= t.start ? -r : r)
                  : e.totalPositionY(t, 'index', 0.5))(a)),
              e.direction === JJ.vertical
                ? (o.textBaseline =
                    'middle' === s ? s : ('withChange' === s && a.end - a.start >= 0) || 'max' === s ? 'bottom' : 'top')
                : (o.textAlign =
                    'middle' === s
                      ? 'center'
                      : ('withChange' === s && a.end - a.start >= 0) || 'max' === s
                      ? 'left'
                      : 'right'),
              sB(Object.assign(Object.assign({}, o), { id: n.id }))
            );
          }),
        dataFilter: t => {
          const i = [];
          return (
            n.forEach(n => {
              const s = t.find(t => {
                var i;
                return n.index === (null === (i = t.data) || void 0 === i ? void 0 : i[e.getDimensionField()[0]]);
              });
              s && ((s.data = n), i.push(s));
            }),
            i
          );
        },
        overlap: { strategy: [] }
      };
    }
  };
  var X4;
  function K4(t, e, i) {
    const { labelMark: n, series: s } = t,
      r = { text: e[s.getMeasureField()[0]], data: e },
      a = Object.keys(n.stateStyle.normal);
    for (const t of a) {
      const s = n.getAttribute(t, e);
      (r[t] = s), 'text' === t && i && (r[t] = i(r[t], e));
    }
    return r;
  }
  function q4() {
    return [
      {
        type: 'position',
        position: ['top', 'bottom', 'right', 'left', 'top-right', 'top-left', 'bottom-left', 'bottom-right']
      }
    ];
  }
  function Z4(t) {
    const e = [
      {
        type: 'position',
        position: e => {
          var i, n;
          const { data: s } = e,
            r = t.getMeasureField()[0];
          return (
            'horizontal' === t.direction
              ? null === (i = t.getXAxisHelper()) || void 0 === i
                ? void 0
                : i.isInverse()
              : null === (n = t.getYAxisHelper()) || void 0 === n
              ? void 0
              : n.isInverse()
          )
            ? (null == s ? void 0 : s[r]) >= 0
              ? 'horizontal' === t.direction
                ? ['left', 'inside-left']
                : ['bottom', 'inside-bottom']
              : 'horizontal' === t.direction
              ? ['right', 'inside-right']
              : ['top', 'inside-top']
            : (null == s ? void 0 : s[r]) >= 0
            ? 'horizontal' === t.direction
              ? ['right', 'inside-right']
              : ['top', 'inside-top']
            : 'horizontal' === t.direction
            ? ['left', 'inside-left']
            : ['bottom', 'inside-bottom'];
        }
      }
    ];
    return e;
  }
  !(function (t) {
    (t.rect = 'rect'), (t.symbol = 'symbol'), (t.arc = 'arc'), (t.point = 'point'), (t.stackLabel = 'stackLabel');
  })(X4 || (X4 = {})),
    NQ.useMark([R3]);
  class J4 extends g2 {
    constructor() {
      super(...arguments),
        (this.type = DZ.waterfall),
        (this._stack = !0),
        (this._leaderLineMark = null),
        (this._stackLabelMark = null),
        (this._labelMark = null);
    }
    getTotalData() {
      var t;
      return null === (t = this._totalData) || void 0 === t ? void 0 : t.getLatestData();
    }
    initGroups() {
      const t = this.getGroupFields();
      t &&
        t.length &&
        ((this._groups = new Y4(t)), this._data && this._groups.initData(this._data.getDataView(), this._dataSet));
    }
    setAttrFromSpec() {
      super.setAttrFromSpec(),
        (this._stack = !1),
        (this._fieldX = [this._fieldX[0]]),
        (this._fieldY = [this._fieldY[0]]),
        l(this._seriesField) && (this._seriesField = $q);
    }
    getSeriesKeys() {
      return this._seriesField === $q
        ? [
            this._theme.seriesFieldName.increase,
            this._theme.seriesFieldName.decrease,
            this._theme.seriesFieldName.total
          ]
        : super.getSeriesKeys();
    }
    initData() {
      var t;
      super.initData(),
        xQ(this._dataSet, 'waterfallFillTotal', W4),
        xQ(this._dataSet, 'waterfall', V4),
        (l(this._spec.total) || 'end' === this._spec.total.type) &&
          (null === (t = this._rawData) ||
            void 0 === t ||
            t.transform(
              {
                type: 'waterfallFillTotal',
                options: {
                  indexField: this.getGroupFields()[0],
                  valueField: this.getStackValueField(),
                  seriesField: this.getSeriesField(),
                  seriesFieldName: this._theme.seriesFieldName,
                  total: this._spec.total
                }
              },
              !1
            ));
      const e = CQ(this.getViewData(), this._dataSet, { name: `${UV}_series_${this.id}_totalData` });
      this.getViewData().target.removeListener('change', e.reRunAllTransform),
        (this._totalData = new W1(this._option, e)),
        e.transform(
          {
            type: 'waterfall',
            options: {
              indexField: this.getGroupFields()[0],
              valueField: this.getStackValueField(),
              seriesField: this.getSeriesField(),
              seriesFieldName: this._theme.seriesFieldName,
              startAs: Qq,
              endAs: tZ,
              total: this._spec.total,
              groupData: () => this.getGroups().groupData
            }
          },
          !1
        );
    }
    initAnimation() {
      var t, e;
      const i = {
          yField: 'horizontal' === this.direction ? this._fieldY[0] : this.getStackValueField(),
          xField: 'horizontal' === this.direction ? this.getStackValueField() : this._fieldX[0],
          direction: this.direction,
          growFrom: () => {
            var t, e;
            return 'horizontal' === this.direction
              ? null === (t = this._xAxisHelper) || void 0 === t
                ? void 0
                : t.getScale(0).scale(0)
              : null === (e = this._yAxisHelper) || void 0 === e
              ? void 0
              : e.getScale(0).scale(0);
          }
        },
        n =
          null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.animationAppear) || void 0 === e
            ? void 0
            : e.preset;
      this._rectMark.setAnimationConfig(
        w1(x1.waterfall(i, n), A1(LZ.bar, this._spec), {
          dataIndex: t => {
            var e, i, n;
            const s = null == t ? void 0 : t[this._fieldX[0]];
            return (
              (null ===
                (n =
                  null === (i = null === (e = this.getViewDataStatistics()) || void 0 === e ? void 0 : e.latestData) ||
                  void 0 === i
                    ? void 0
                    : i[this._fieldX[0]]) || void 0 === n
                ? void 0
                : n.values.indexOf(s)) || 0
            );
          }
        })
      );
    }
    viewDataUpdate(t) {
      this._totalData.getDataView().reRunAllTransform(), this._totalData.updateData(), super.viewDataUpdate(t);
    }
    addViewDataFilter(t) {}
    reFilterViewData() {}
    onEvaluateEnd(t) {
      super.onEvaluateEnd(t), this._totalData.updateData();
    }
    initMark() {
      var t;
      super.initMark();
      const e = this._createMark(J4.mark.leaderLine, { key: 'index' });
      e && ((this._leaderLineMark = e), e.setDataView(this._totalData.getDataView(), this._totalData.getProductId())),
        (null === (t = this._spec.stackLabel) || void 0 === t ? void 0 : t.visible) &&
          this._rectMark.addLabelSpec(this._spec.stackLabel);
    }
    initLabelMarkStyle(t) {
      var e;
      if (t) {
        if (!this._labelMark && (null === (e = this._spec.label) || void 0 === e ? void 0 : e.visible))
          return super.initLabelMarkStyle(t), void (this._labelMark = t);
        (this._stackLabelMark = t),
          (t.skipEncode = !0),
          t.setRule(X4.stackLabel),
          t.setDataView(this._totalData.getDataView(), this._totalData.getProductId()),
          this.setMarkStyle(t, {
            text: t => {
              var e;
              return 'absolute' === (null === (e = this._spec.stackLabel) || void 0 === e ? void 0 : e.valueType)
                ? t.end
                : (function (t, e) {
                    return Vt(t - e, 10 ** Math.max(Wt(t), Wt(e)));
                  })(t.end, t.start);
            }
          });
      }
    }
    totalPositionX(t, e, i = 0.5) {
      const { dataToPosition: n, getBandwidth: s } = this._xAxisHelper;
      return this._direction === JJ.vertical
        ? n([t[e]], { bandPosition: this._bandPosition }) +
            0.5 * s(0) -
            this._rectMark.getAttribute('width', t) * (0.5 - i)
        : uV(n([t[e]], { bandPosition: this._bandPosition }));
    }
    totalPositionY(t, e, i = 0.5) {
      const { dataToPosition: n, getBandwidth: s } = this._yAxisHelper;
      return this._direction === JJ.vertical
        ? uV(n([t[e]], { bandPosition: this._bandPosition }))
        : n([t[e]], { bandPosition: this._bandPosition }) +
            0.5 * s(0) -
            this._rectMark.getAttribute('height', t) * (0.5 - i);
    }
    initMarkStyle() {
      super.initMarkStyle(),
        this._leaderLineMark &&
          (this._direction === JJ.vertical
            ? this.setMarkStyle(
                this._leaderLineMark,
                {
                  visible: t => !l(t.lastIndex),
                  x: t => (t.lastIndex ? this.totalPositionX(t, 'lastIndex', 1) : 0),
                  x1: t => this.totalPositionX(t, 'index', 0),
                  y: t => this.totalPositionY(t, 'lastEnd', 0),
                  y1: t => this.totalPositionY(t, t.isTotal ? 'end' : 'start', 0)
                },
                'normal',
                Jq.Series
              )
            : this.setMarkStyle(
                this._leaderLineMark,
                {
                  visible: t => !l(t.lastIndex),
                  x: t => this.totalPositionX(t, 'lastEnd', 0),
                  x1: t => this.totalPositionX(t, t.isTotal ? 'end' : 'start', 0),
                  y: t => (t.lastIndex ? this.totalPositionY(t, 'lastIndex', 1) : 0),
                  y1: t => this.totalPositionY(t, 'index', 0)
                },
                'normal',
                Jq.Series
              ));
    }
  }
  (J4.type = DZ.waterfall), (J4.mark = sJ), NQ.useSeries([J4]);
  class Q4 extends f2 {
    constructor() {
      super(...arguments), (this.type = d2.waterfall), (this.seriesType = DZ.waterfall);
    }
    transformSpec(t) {
      super.transformSpec(t),
        t.legends &&
          V(t.legends).forEach(t => {
            (t.select = !1), (t.hover = !1), (t.filter = !1);
          }),
        zQ(t);
    }
    _getDefaultSeriesSpec(t) {
      return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
        bar: t.bar,
        stackLabel: t.stackLabel,
        leaderLine: t.leaderLine,
        total: t.total
      });
    }
  }
  (Q4.type = d2.waterfall), (Q4.view = 'singleDefault');
  class t8 extends h2 {
    constructor() {
      super(...arguments), (this.type = d2.wordCloud), (this.seriesType = DZ.wordCloud);
    }
    transformSpec(t) {
      super.transformSpec(t);
      const e = this._getDefaultSeriesSpec(t);
      t.series && 0 !== t.series.length
        ? t.series.forEach(t => {
            this.isValidSeries(t.type) &&
              Object.keys(e).forEach(i => {
                i in t || (t[i] = e[i]);
              });
          })
        : (t.series = [e]);
    }
  }
  const e8 = [0],
    i8 = [20, 40],
    n8 = [200, 500],
    s8 = { shrink: !1, enlarge: !1, fontSizeLimitMin: 0 },
    r8 = ['triangleForward', 'triangle', 'diamond', 'square', 'star', 'cardioid', 'circle', 'pentagon'],
    a8 = {
      triangleForward: function () {
        return function (t) {
          const e = t % ((2 * Math.PI) / 3);
          return 1 / (Math.cos(e) + Math.sqrt(3) * Math.sin(e));
        };
      },
      triangleUpright: o8,
      triangle: o8,
      diamond: function () {
        return function (t) {
          const e = t % ((2 * Math.PI) / 4);
          return 1 / (Math.cos(e) + Math.sin(e));
        };
      },
      square: function () {
        return function (t) {
          return Math.min(1 / Math.abs(Math.cos(t)), 1 / Math.abs(Math.sin(t)));
        };
      },
      star: function () {
        return function (t) {
          const e = (t + 0.955) % ((2 * Math.PI) / 10);
          return ((t + 0.955) % ((2 * Math.PI) / 5)) - (2 * Math.PI) / 10 >= 0
            ? 1 / (Math.cos((2 * Math.PI) / 10 - e) + 3.07768 * Math.sin((2 * Math.PI) / 10 - e))
            : 1 / (Math.cos(e) + 3.07768 * Math.sin(e));
        };
      },
      cardioid: function () {
        return function (t) {
          return 1 - Math.sin(t);
        };
      },
      circle: function () {
        return function () {
          return 1;
        };
      },
      pentagon: function () {
        return function (t) {
          const e = (t + 0.955) % ((2 * Math.PI) / 5);
          return 1 / (Math.cos(e) + 0.726543 * Math.sin(e));
        };
      }
    };
  function o8() {
    return function (t) {
      const e = (t + (3 * Math.PI) / 2) % ((2 * Math.PI) / 3);
      return 1 / (Math.cos(e) + Math.sqrt(3) * Math.sin(e));
    };
  }
  function l8(t, e) {
    const i = e[0],
      n = e[1];
    let s = 1;
    const r = [e[0] >> 1, e[1] >> 1];
    switch (t) {
      case 'cardioid':
        (r[1] = ~~((n / 2.7) * 0.6)), (s = Math.floor(Math.min(i / 2.3, n / 2.6)));
        break;
      case 'triangleForward':
        s = n / Math.sqrt(0.75) > i ? Math.floor(i / 2) : Math.floor(n / (2 * Math.sqrt(0.75)));
        break;
      case 'triangle':
      case 'triangleUpright':
        (r[1] = ~~(n / 1.5)), (s = Math.floor(Math.min(n / 1.5, i / 2)));
        break;
      default:
        s = Math.floor(Math.min(i / 2, n / 2));
    }
    return { maxRadius: s, center: r };
  }
  const h8 = (t, e) =>
    'hsl(' +
    (360 * Math.random()).toFixed() +
    ',' +
    (30 * Math.random() + 70).toFixed() +
    '%,' +
    (Math.random() * (e - t) + t).toFixed() +
    '%)';
  function c8(t) {
    return o(t)
      ? t
      : function () {
          return t;
        };
  }
  class d8 {
    constructor(t) {
      var e, i;
      switch (
        ((this.options = D({}, d8.defaultOptions, t)),
        o(this.options.shape)
          ? (this.shape = this.options.shape)
          : (this.shape = (t => (a8[t] ? a8[t]() : a8.circle()))(this.options.shape)),
        (this.getText = null !== (e = c8(this.options.text)) && void 0 !== e ? e : t => t),
        (this.getTextFontWeight = c8(this.options.fontWeight)),
        (this.getTextFontSize = c8(this.options.fontSize)),
        (this.getTextFontStyle = c8(this.options.fontStyle)),
        (this.getTextFontFamily = c8(this.options.fontFamily)),
        (this.outputCallback = null !== (i = this.options.outputCallback) && void 0 !== i ? i : t => t),
        this.options.color)
      ) {
        case 'random-dark':
          this.getTextColor = () => h8(10, 50);
          break;
        case 'random-light':
          this.getTextColor = () => h8(50, 90);
          break;
        default:
          this.getTextColor = c8(this.options.color);
      }
      if (l(this.options.rotate))
        if (this.options.useRandomRotate) {
          const t = Math.abs(this.options.maxRotation - this.options.minRotation),
            e = Math.abs(Math.floor(this.options.rotationSteps)),
            i = Math.min(this.options.maxRotation, this.options.minRotation);
          this.getTextRotate = () =>
            0 === this.options.rotateRatio || Math.random() > this.options.rotateRatio
              ? 0
              : 0 === t
              ? i
              : e > 0
              ? i + (Math.floor(Math.random() * e) * t) / (e - 1)
              : i + Math.random() * t;
        } else this.getTextRotate = () => 0;
      else
        this.getTextRotate = o(this.options.rotate)
          ? t => {
              var e;
              return qt(null !== (e = this.options.rotate(t)) && void 0 !== e ? e : 0);
            }
          : () => {
              var t;
              return qt(null !== (t = this.options.rotate) && void 0 !== t ? t : 0);
            };
    }
    exceedTime() {
      var t;
      return this.options.progressiveStep > 0
        ? this.progressiveIndex >=
            ((null !== (t = this.currentStepIndex) && void 0 !== t ? t : 0) + 1) * this.options.progressiveStep
        : this.options.progressiveTime > 0 && new Date().getTime() - this.escapeTime > this.options.progressiveTime;
    }
    progressiveRun() {
      var t;
      if (
        (this.options.progressiveStep > 0
          ? (this.currentStepIndex = (null !== (t = this.currentStepIndex) && void 0 !== t ? t : 0) + 1)
          : this.options.progressiveTime > 0 && (this.escapeTime = Date.now()),
        this.data && this.progressiveIndex && this.progressiveIndex < this.data.length)
      ) {
        this.progressiveResult = [];
        const t = this.data.length;
        let e = this.progressiveIndex;
        for (; e < t && (this.layoutWord(e), e++, (this.progressiveIndex = e), !this.exceedTime()); );
        return this.progressiveResult;
      }
      return this.result;
    }
    initProgressive() {
      (this.progressiveIndex = -1),
        this.options.progressiveStep > 0
          ? (this.currentStepIndex = 0)
          : this.options.progressiveTime > 0 && (this.escapeTime = Date.now()),
        (this.progressiveResult = []);
    }
    output() {
      return this.result ? this.outputCallback(this.result) : null;
    }
    progressiveOutput() {
      return this.progressiveResult ? this.outputCallback(this.progressiveResult) : null;
    }
    unfinished() {
      return this.data && this.data.length && !l(this.progressiveIndex) && this.progressiveIndex < this.data.length;
    }
    release() {
      (this.data = null), (this.result = null), (this.progressiveIndex = null), (this.progressiveResult = null);
    }
  }
  d8.defaultOptions = {
    fontFamily: '"Trebuchet MS", "Heiti TC", "微軟正黑體", "Arial Unicode MS", "Droid Fallback Sans", sans-serif',
    fontWeight: 'normal',
    color: 'random-dark',
    fontStyle: 'normal',
    minFontSize: 12,
    drawOutOfBound: !1,
    shrink: !1,
    minRotation: -Math.PI / 2,
    maxRotation: Math.PI / 2,
    rotationSteps: 0,
    rotateRatio: 0.1,
    random: !1,
    shape: 'circle',
    progressiveTime: 0,
    progressiveStep: 0,
    backgroundColor: '#fff'
  };
  const u8 = {
    archimedean: function (t) {
      const e = t[0] / t[1];
      return t => [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
    },
    rectangular: function (t) {
      const e = (4 * t[0]) / t[1];
      let i = 0,
        n = 0;
      return t => {
        const s = t < 0 ? -1 : 1;
        switch ((Math.sqrt(1 + 4 * s * t) - s) & 3) {
          case 0:
            i += e;
            break;
          case 1:
            n += 4;
            break;
          case 2:
            i -= e;
            break;
          default:
            n -= 4;
        }
        return [i, n];
      };
    }
  };
  class p8 extends d8 {
    constructor(t) {
      var e;
      super(D({}, p8.defaultOptions, t)),
        (this.cw = 64),
        (this.ch = 2048),
        (this._size = [256, 256]),
        (this._isBoardExpandCompleted = !1),
        (this._placeStatus = 0),
        (this._tTemp = null),
        (this._dtTemp = null),
        (this._dy = 0),
        (this.cacheMap = new Map()),
        this.options.minFontSize <= p8.defaultOptions.minFontSize &&
          (this.options.minFontSize = p8.defaultOptions.minFontSize),
        (this.spiral = g(this.options.spiral)
          ? null !== (e = u8[this.options.spiral]) && void 0 !== e
            ? e
            : u8.archimedean
          : this.options.spiral),
        (this.random = this.options.random ? Math.random : () => 1),
        (this.getTextPadding = c8(this.options.padding));
    }
    zoomRatio() {
      return this._originSize[0] / this._size[0];
    }
    dy() {
      return this._dy;
    }
    layoutWord(t) {
      const e = this.data[t];
      if ('' === ('' + e.text).trim()) return !0;
      const { maxRadius: i, center: n } = l8(this.options.shape, this._size);
      if (
        ((e.x = n[0]),
        (e.y = n[1]),
        (function (t, e, i, n, s, r) {
          if (e.sprite) return;
          const a = t.context,
            o = t.ratio;
          a.setTransform(o, 0, 0, o, 0, 0), a.clearRect(0, 0, (s << 5) / o, r / o);
          let l = 0,
            h = 0,
            c = 0;
          const d = i.length;
          let u, p, g, f, v;
          for (--n; ++n < d; ) {
            if (
              ((e = i[n]),
              a.save(),
              (a.font = e.fontStyle + ' ' + e.fontWeight + ' ' + ~~((e.fontSize + 1) / o) + 'px ' + e.fontFamily),
              (u = a.measureText(e.text + 'm').width * o),
              (g = e.fontSize << 1),
              e.angle)
            ) {
              const t = Math.sin(e.angle),
                i = Math.cos(e.angle),
                n = u * i,
                s = u * t,
                r = g * i,
                a = g * t;
              (u = ((Math.max(Math.abs(n + a), Math.abs(n - a)) + 31) >> 5) << 5),
                (g = ~~Math.max(Math.abs(s + r), Math.abs(s - r)));
            } else u = ((u + 31) >> 5) << 5;
            if ((g > c && (c = g), l + u >= s << 5 && ((l = 0), (h += c), (c = 0)), h + g >= r)) break;
            a.translate((l + (u >> 1)) / o, (h + (g >> 1)) / o),
              e.angle && a.rotate(e.angle),
              a.fillText(e.text, 0, 0),
              e.padding && ((a.lineWidth = 2 * e.padding), a.strokeText(e.text, 0, 0)),
              a.restore(),
              (e.width = u),
              (e.height = g),
              (e.xoff = l),
              (e.yoff = h),
              (e.x1 = u >> 1),
              (e.y1 = g >> 1),
              (e.x0 = -e.x1),
              (e.y0 = -e.y1),
              (e.hasText = !0),
              (l += u);
          }
          const m = a.getImageData(0, 0, (s << 5) / o, r / o).data,
            y = [];
          for (; --n >= 0; ) {
            if (!(e = i[n]).hasText) continue;
            for (u = e.width, p = u >> 5, g = e.y1 - e.y0, f = 0; f < g * p; f++) y[f] = 0;
            if (((l = e.xoff), null == l)) return;
            h = e.yoff;
            let t = 0,
              r = -1;
            for (v = 0; v < g; v++) {
              for (f = 0; f < u; f++) {
                const e = p * v + (f >> 5),
                  i = m[((h + v) * (s << 5) + (l + f)) << 2] ? 1 << (31 - (f % 32)) : 0;
                (y[e] |= i), (t |= i);
              }
              t ? (r = v) : (e.y0++, g--, v--, h++);
            }
            (e.y1 = e.y0 + r), (e.sprite = y.slice(0, (e.y1 - e.y0) * p));
          }
        })(this.contextAndRatio, e, this.data, t, this.cw, this.ch),
        (this._placeStatus = 0),
        e.hasText && this.place(this._board, e, this._bounds, i))
      )
        return (
          this.result.push(e),
          this._bounds
            ? (function (t, e) {
                const i = t[0],
                  n = t[1];
                e.x + e.x0 < i.x && (i.x = e.x + e.x0),
                  e.y + e.y0 < i.y && (i.y = e.y + e.y0),
                  e.x + e.x1 > n.x && (n.x = e.x + e.x1),
                  e.y + e.y1 > n.y && (n.y = e.y + e.y1);
              })(this._bounds, e)
            : (this._bounds = [
                { x: e.x + e.x0, y: e.y + e.y0 },
                { x: e.x + e.x1, y: e.y + e.y1 }
              ]),
          (e.x -= this._size[0] >> 1),
          (e.y -= this._size[1] >> 1),
          (this._tTemp = null),
          (this._dtTemp = null),
          !0
        );
      if ((this.updateBoardExpandStatus(e.fontSize), e.hasText && this.shouldShrinkContinue())) {
        if (1 === this._placeStatus) {
          const t = (e.fontSize * this._originSize[0]) / this.options.minFontSize,
            i = Math.max(e.width, e.height);
          if (i <= t) this.expandBoard(this._board, i / this._size[0]);
          else {
            if (!this.options.clip) return !0;
            this.expandBoard(this._board, t / this._size[0]);
          }
        } else this._placeStatus, this.expandBoard(this._board);
        return this.updateBoardExpandStatus(e.fontSize), !1;
      }
      return (this._tTemp = null), (this._dtTemp = null), !0;
    }
    layout(t, e) {
      this.initProgressive(),
        (this.result = []),
        (this._size = [e.width, e.height]),
        this.clearCache(),
        (this._originSize = [...this._size]);
      const i = this.getContext(gN.createCanvas({ width: 1, height: 1 }));
      (this.contextAndRatio = i),
        (this._board = new Array((this._size[0] >> 5) * this._size[1]).fill(0)),
        (this._bounds = null);
      const n = t.length;
      let s = 0;
      this.result = [];
      const r = t
        .map(t => ({
          text: this.getText(t),
          fontFamily: this.getTextFontFamily(t),
          fontStyle: this.getTextFontStyle(t),
          fontWeight: this.getTextFontWeight(t),
          angle: this.getTextRotate(t),
          fontSize: ~~this.getTextFontSize(t),
          padding: this.getTextPadding(t),
          xoff: 0,
          yoff: 0,
          x1: 0,
          y1: 0,
          x0: 0,
          y0: 0,
          hasText: !1,
          sprite: null,
          datum: t,
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }))
        .sort(function (t, e) {
          return e.fontSize - t.fontSize;
        });
      this.data = r;
      let a = 0;
      for (
        ;
        s < n && (this.layoutWord(s) || a >= 2 ? (s++, (a = 0)) : a++, (this.progressiveIndex = s), !this.exceedTime());

      );
      if (
        (!this.options.clip && this.options.enlarge && this._bounds && this.shrinkBoard(this._bounds),
        this._bounds && ['cardioid', 'triangle', 'triangle-upright'].includes(this.options.shape))
      ) {
        const t = (this._bounds[0].y + this._bounds[1].y) / 2;
        this._dy = -(t - this._size[1] / 2);
      }
      return this.result;
    }
    formatTagItem(t) {
      const e = this._size,
        i = this.zoomRatio(),
        n = this.dy(),
        s = e[0] >> 1,
        r = e[1] >> 1,
        a = t.length,
        o = [];
      let l, h;
      for (let e = 0; e < a; ++e)
        (l = t[e]),
          (h = {}),
          (h.datum = l.datum),
          (h.x = (l.x + s) * i),
          (h.y = (l.y + r + n) * i),
          (h.fontFamily = l.fontFamily),
          (h.fontSize = l.fontSize * i),
          (h.fontStyle = l.fontStyle),
          (h.fontWeight = l.fontWeight),
          (h.angle = l.angle),
          o.push(h);
      return o;
    }
    output() {
      return this.outputCallback
        ? this.outputCallback(this.formatTagItem(this.result))
        : this.formatTagItem(this.result);
    }
    progressiveOutput() {
      return this.outputCallback
        ? this.outputCallback(this.formatTagItem(this.progressiveResult))
        : this.formatTagItem(this.progressiveResult);
    }
    updateBoardExpandStatus(t) {
      this._isBoardExpandCompleted = t * (this._originSize[0] / this._size[0]) < this.options.minFontSize;
    }
    shouldShrinkContinue() {
      return !this.options.clip && this.options.shrink && !this._isBoardExpandCompleted;
    }
    shrinkBoard(t) {
      const e = t[0],
        i = t[1];
      if (i.x >= this._size[0] || i.y >= this._size[1]) return;
      const n = Math.min(e.x, this._size[0] - i.x),
        s = Math.min(e.y, this._size[1] - i.y),
        r = 2 * Math.min(n / this._size[0], s / this._size[1]);
      this._size = this._size.map(t => t * (1 - r));
    }
    expandBoard(t, e) {
      const i = (this._size[0] * (e || 1.1) - this._size[0]) >> 5;
      let n = 2 * i > 2 ? i : 2;
      n % 2 != 0 && n++;
      let s = Math.ceil((this._size[1] * (n << 5)) / this._size[0]);
      s % 2 != 0 && s++;
      const r = this._size[0],
        a = this._size[1],
        o = new Array(n).fill(0),
        l = new Array((s / 2) * (n + (r >> 5))).fill(0);
      this.insertZerosToArray(t, a * (r >> 5), l.length + n / 2);
      for (let e = a - 1; e > 0; e--) this.insertZerosToArray(t, e * (r >> 5), o.length);
      this.insertZerosToArray(t, 0, l.length + n / 2), (this._size = [r + (n << 5), a + s]);
    }
    insertZerosToArray(t, e, i) {
      const n = Math.floor(i / 6e4),
        s = i % 6e4;
      for (let i = 0; i < n; i++) t.splice(e + 6e4 * i, 0, ...new Array(6e4).fill(0));
      t.splice(e + 6e4 * n, 0, ...new Array(s).fill(0));
    }
    getContext(t) {
      (t.width = 1), (t.height = 1);
      const e = t.getContext('2d').getImageData(0, 0, 1, 1),
        i = Math.sqrt(e.data.length >> 2);
      (t.width = (this.cw << 5) / i), (t.height = this.ch / i);
      const n = t.getContext('2d');
      return (n.fillStyle = n.strokeStyle = 'red'), (n.textAlign = 'center'), { context: n, ratio: i, canvas: t };
    }
    place(t, e, i, n) {
      let s = !1;
      if (this.shouldShrinkContinue() && (e.width > this._size[0] || e.height > this._size[1]))
        return (this._placeStatus = 1), !1;
      const r = this.random() < 0.5 ? 1 : -1;
      if (!this.shouldShrinkContinue() && this.isSizeLargerThanMax(e, r)) return null;
      const a = e.x,
        o = e.y,
        l = Math.sqrt(this._size[0] * this._size[0] + this._size[1] * this._size[1]),
        h = this.spiral(this._size);
      let c,
        d,
        u,
        p,
        g = -r;
      for (this._tTemp = null, this._dtTemp = null; (c = h((g += r))); ) {
        (d = c[0]), (u = c[1]);
        const h = Math.sqrt(d ** 2 + u ** 2);
        let f = Math.atan(u / d);
        d < 0 ? (f += Math.PI) : u < 0 && (f = 2 * Math.PI + f);
        const v = this.shape(f);
        if (Math.min(Math.abs(d), Math.abs(u)) >= l) break;
        if (h >= n) s && null === this._tTemp && ((this._tTemp = g), (this._dtTemp = r));
        else {
          if (((e.x = a + ~~(h * v * Math.cos(-f))), (e.y = o + ~~(h * v * Math.sin(-f))), (p = e), this.options.clip))
            if (this.shouldShrinkContinue()) {
              if (m8(p, this._size)) {
                s && null === this._tTemp && ((this._tTemp = g), (this._dtTemp = r));
                continue;
              }
            } else {
              if (v8(p, this._size)) {
                s && null === this._tTemp && ((this._tTemp = g), (this._dtTemp = r));
                continue;
              }
              m8(p, this._size) && (p = y8(p, this._size));
            }
          else if (m8(p, this._size)) {
            s && null === this._tTemp && ((this._tTemp = g), (this._dtTemp = r));
            continue;
          }
          if (((s = !0), (!i || f8(p, i)) && (!i || !g8(p, t, this._size)))) {
            const i = p.sprite,
              n = p.width >> 5,
              s = this._size[0] >> 5,
              r = p.x - (n << 4),
              a = 127 & r,
              o = 32 - a,
              l = p.y1 - p.y0;
            let h,
              c = (p.y + p.y0) * s + (r >> 5);
            for (let e = 0; e < l; e++) {
              h = 0;
              for (let s = 0; s <= n; s++) t[c + s] |= (h << o) | (s < n ? (h = i[e * n + s]) >>> a : 0);
              c += s;
            }
            return (e.sprite = null), (p.sprite = null), !0;
          }
        }
      }
      return null !== this._tTemp && (this._placeStatus = 3), !this.shouldShrinkContinue() && this.setCache(p, r), !1;
    }
    clearCache() {
      this.cacheMap.clear();
    }
    setCache(t, e) {
      const i = `${t.angle}-${e}`,
        n = t.x1 - t.x0,
        s = t.y1 - t.y0;
      if (!this.cacheMap.has(i)) return void this.cacheMap.set(i, { width: n, height: s });
      const { width: r, height: a } = this.cacheMap.get(i);
      ((n < r && s < a) || (n <= r && s < a)) && this.cacheMap.set(i, { width: n, height: s });
    }
    isSizeLargerThanMax(t, e) {
      const i = `${t.angle}-${e}`;
      if (!this.cacheMap.has(i)) return !1;
      const { width: n, height: s } = this.cacheMap.get(i),
        r = t.x1 - t.x0,
        a = t.y1 - t.y0;
      return r >= n && a >= s;
    }
  }
  function g8(t, e, i) {
    const n = i[0] >> 5,
      s = t.sprite,
      r = t.width >> 5,
      a = t.x - (r << 4),
      o = 127 & a,
      l = 32 - o,
      h = t.y1 - t.y0;
    let c,
      d = (t.y + t.y0) * n + (a >> 5);
    for (let t = 0; t < h; t++) {
      c = 0;
      for (let i = 0; i <= r; i++) if (((c << l) | (i < r ? (c = s[t * r + i]) >>> o : 0)) & e[d + i]) return !0;
      d += n;
    }
    return !1;
  }
  function f8(t, e) {
    return t.x + t.x1 > e[0].x && t.x + t.x0 < e[1].x && t.y + t.y1 > e[0].y && t.y + t.y0 < e[1].y;
  }
  p8.defaultOptions = { enlarge: !1, minFontSize: 2 };
  const v8 = (t, e) => t.x + t.x0 > e[0] || t.y + t.y0 > e[0] || t.x + t.x1 < 0 || t.y + t.y1 < 0,
    m8 = (t, e) => t.x + t.x0 < 0 || t.y + t.y0 < 0 || t.x + t.x1 > e[0] || t.y + t.y1 > e[1];
  function y8(t, e) {
    const i = t.sprite,
      n = t.y1 - t.y0,
      s = t.width >> 5;
    let r = 0;
    const a = [],
      o = Math.max(-(t.y0 + t.y), 0),
      l = Math.min(n + (e[1] - (t.y1 + t.y)), n),
      h = Math.max(-(t.x0 + t.x), 0) >> 5,
      c = Math.min(s + ((e[0] - (t.x1 + t.x)) >> 5) + 1, s);
    for (let t = 0; t < n; t++) {
      for (let e = 0; e < s; e++) t < o || l <= t || e < h || c <= e || a.push(i[r + e]);
      r += s;
    }
    const d = h << 5,
      u = (s - c) << 5,
      p = o,
      g = n - l;
    return Object.assign(Object.assign({}, t), {
      width: t.width - d - u,
      height: t.height - p - g,
      x0: t.x0 + d,
      x1: t.x1 - u,
      y0: t.y0 + p,
      y1: t.y1 - g,
      x: t.x + d / 2 - u / 2,
      sprite: a
    });
  }
  let _8 = class t extends d8 {
    constructor(e) {
      super(D({}, t.defaultOptions, e)),
        (this.fillGridAt = (t, e) => {
          t >= this.ngx || e >= this.ngy || t < 0 || e < 0 || (this.grid[t][e] = !1);
        }),
        (this.updateGrid = (t, e, i, n, s) => {
          const r = s.occupied;
          let a = r.length;
          for (; a--; ) {
            const i = t + r[a][0],
              n = e + r[a][1];
            i >= this.ngx || n >= this.ngy || i < 0 || n < 0 || this.fillGridAt(i, n);
          }
        }),
        (this.gridSize = Math.max(Math.floor(this.options.gridSize), 4));
    }
    getPointsAtRadius(t) {
      if (this.pointsAtRadius[t]) return this.pointsAtRadius[t];
      const e = 8 * t;
      let i = e;
      const n = [];
      for (0 === t && n.push([this.center[0], this.center[1], 0]); i--; ) {
        const s = this.shape((i / e) * 2 * Math.PI);
        n.push([
          this.center[0] + t * s * Math.cos((-i / e) * 2 * Math.PI),
          this.center[1] + t * s * Math.sin((-i / e) * 2 * Math.PI) * this.options.ellipticity,
          (i / e) * 2 * Math.PI
        ]);
      }
      return (this.pointsAtRadius[t] = n), n;
    }
    getTextInfo(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
      var i;
      const n = this.options.clip ? 1 : e,
        s = Math.max(Math.floor(this.getTextFontSize(t) * n), this.options.minFontSize);
      let r = this.getText(t) + '';
      if ((this.options.clip && (r = r.slice(0, Math.ceil(r.length * e))), !r)) return null;
      const a = this.getTextFontWeight(t),
        o = this.getTextFontStyle(t),
        l = this.getTextRotate && null !== (i = this.getTextRotate(t)) && void 0 !== i ? i : 0,
        h = this.getTextFontFamily(t),
        c = document.createElement('canvas'),
        d = c.getContext('2d', { willReadFrequently: !0 });
      d.font = o + ' ' + a + ' ' + s.toString(10) + 'px ' + h;
      const u = d.measureText(r).width,
        p = Math.max(s, d.measureText('m').width, d.measureText('Ｗ').width);
      let g = u + 2 * p,
        f = 3 * p;
      const v = Math.ceil(g / this.gridSize),
        m = Math.ceil(f / this.gridSize);
      (g = v * this.gridSize), (f = m * this.gridSize);
      const y = -u / 2,
        _ = 0.4 * -p,
        b = Math.ceil((g * Math.abs(Math.sin(l)) + f * Math.abs(Math.cos(l))) / this.gridSize),
        x = Math.ceil((g * Math.abs(Math.cos(l)) + f * Math.abs(Math.sin(l))) / this.gridSize),
        S = x * this.gridSize,
        w = b * this.gridSize;
      c.setAttribute('width', '' + S),
        c.setAttribute('height', '' + w),
        d.scale(1, 1),
        d.translate(S / 2, w / 2),
        d.rotate(-l),
        (d.font = o + ' ' + a + ' ' + s.toString(10) + 'px ' + h),
        (d.fillStyle = '#000'),
        (d.textBaseline = 'middle'),
        d.fillText(r, y, _);
      const A = d.getImageData(0, 0, S, w).data;
      if (this.exceedTime()) return null;
      const k = [];
      let M,
        T = x;
      const C = [b / 2, x / 2, b / 2, x / 2],
        E = (t, e, i) => {
          let n = this.gridSize;
          for (; n--; ) {
            let s = this.gridSize;
            for (; s--; )
              if (A[4 * ((e * this.gridSize + n) * S + (t * this.gridSize + s)) + 3])
                return (
                  i.push([t, e]),
                  t < C[3] && (C[3] = t),
                  t > C[1] && (C[1] = t),
                  e < C[0] && (C[0] = e),
                  void (e > C[2] && (C[2] = e))
                );
          }
        };
      for (; T--; ) for (M = b; M--; ) E(T, M, k);
      return {
        datum: t,
        occupied: k,
        bounds: C,
        gw: x,
        gh: b,
        fillTextOffsetX: y,
        fillTextOffsetY: _,
        fillTextWidth: u,
        fillTextHeight: p,
        fontSize: s,
        fontStyle: o,
        fontWeight: a,
        fontFamily: h,
        angle: l,
        text: r
      };
    }
    canFitText(t, e, i, n, s) {
      let r = s.length;
      for (; r--; ) {
        const i = t + s[r][0],
          n = e + s[r][1];
        if (i >= this.ngx || n >= this.ngy || i < 0 || n < 0) {
          if (!this.options.drawOutOfBound) return !1;
        } else if (!this.grid[i][n]) return !1;
      }
      return !0;
    }
    layoutWord(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
      const i = this.data[t],
        n = this.getTextInfo(i, e);
      if (!n) return !1;
      if (this.exceedTime()) return !1;
      if (
        !this.options.drawOutOfBound &&
        (!this.options.shrink || n.fontSize <= this.options.minFontSize) &&
        !this.options.clip
      ) {
        const t = n.bounds;
        if (t[1] - t[3] + 1 > this.ngx || t[2] - t[0] + 1 > this.ngy) return !1;
      }
      let s = this.maxRadius + 1;
      const r = t => {
        const e = Math.floor(t[0] - n.gw / 2),
          i = Math.floor(t[1] - n.gh / 2),
          r = n.gw,
          a = n.gh;
        return (
          !!this.canFitText(e, i, r, a, n.occupied) &&
          ((n.distance = this.maxRadius - s),
          (n.theta = t[2]),
          this.outputText(e, i, n),
          this.updateGrid(e, i, r, a, n),
          !0)
        );
      };
      for (; s--; ) {
        let t = this.getPointsAtRadius(this.maxRadius - s);
        if ((this.options.random && ((t = [].concat(t)), Y(t)), t.some(r))) return !0;
      }
      return (
        (this.options.clip || !!(this.options.shrink && n.fontSize > this.options.minFontSize)) &&
        this.layoutWord(t, 0.75 * e)
      );
    }
    outputText(t, e, i) {
      const n = this.getTextColor(i),
        s = {
          text: i.text,
          datum: i.datum,
          color: n,
          fontStyle: i.fontStyle,
          fontWeight: i.fontWeight,
          fontFamily: i.fontFamily,
          angle: i.angle,
          width: i.fillTextWidth,
          height: i.fillTextHeight,
          x: (t + i.gw / 2) * this.gridSize,
          y: (e + i.gh / 2) * this.gridSize + i.fillTextOffsetY + 0.5 * i.fontSize,
          fontSize: i.fontSize
        };
      this.result.push(s), this.progressiveResult && this.progressiveResult.push(s);
    }
    initGrid(t) {
      let e;
      if (((this.grid = []), t)) {
        let i = document.createElement('canvas').getContext('2d');
        (i.fillStyle = this.options.backgroundColor), i.fillRect(0, 0, 1, 1);
        let n = i.getImageData(0, 0, 1, 1).data,
          s = t.getContext('2d').getImageData(0, 0, this.ngx * this.gridSize, this.ngy * this.gridSize).data;
        const r = (t, i) => {
          let r = this.gridSize;
          for (; r--; ) {
            let a = this.gridSize;
            for (; a--; )
              for (e = 4; e--; )
                if (s[4 * ((i * this.gridSize + r) * this.ngx * this.gridSize + (t * this.gridSize + a)) + e] !== n[e])
                  return void (this.grid[t][i] = !1);
          }
        };
        let a = this.ngx;
        for (; a--; ) {
          this.grid[a] = [];
          let t = this.ngy;
          for (; t--; ) r(a, t), !1 !== this.grid[a][t] && (this.grid[a][t] = !0);
        }
        s = i = n = void 0;
      } else {
        let t = this.ngx;
        for (; t--; ) {
          this.grid[t] = [];
          let e = this.ngy;
          for (; e--; ) this.grid[t][e] = !0;
        }
      }
    }
    layout(t, e) {
      this.initProgressive(),
        (this.data = t),
        (this.pointsAtRadius = []),
        (this.ngx = Math.floor(e.width / this.gridSize)),
        (this.ngy = Math.floor(e.height / this.gridSize));
      const { center: i, maxRadius: n } = l8(this.options.shape, [e.width, e.height]);
      (this.center = e.origin
        ? [e.origin[0] / this.gridSize, e.origin[1] / this.gridSize]
        : [i[0] / this.gridSize, i[1] / this.gridSize]),
        (this.maxRadius = Math.floor(n / this.gridSize)),
        this.initGrid(e.canvas),
        (this.result = []);
      let s = 0;
      for (; s < t.length && (this.layoutWord(s), s++, (this.progressiveIndex = s), !this.exceedTime()); );
      return this.result;
    }
  };
  _8.defaultOptions = { gridSize: 8, ellipticity: 1 };
  class b8 extends d8 {
    constructor(t) {
      super(D({}, b8.defaultOptions, t)),
        (this.random = this.options.random ? Math.random : () => 0),
        (this.aspectRatio = 1);
    }
    fit(t) {
      for (let e = 0, i = this.result.length; e < i; e++) if (x8(t, this.result[e])) return !1;
      return !0;
    }
    getTextInfo(t) {
      const e = {
          datum: t,
          fontSize: this.getTextFontSize(t),
          fontWeight: this.getTextFontWeight(t),
          fontStyle: this.getTextFontStyle(t),
          fontFamily: this.getTextFontFamily(t),
          angle: this.getTextRotate(t),
          text: this.getText(t) + '',
          x: this.center[0],
          y: this.center[1]
        },
        i = dB(e);
      return (
        (e.width = i.width()),
        (e.height = i.height()),
        (e.top = this.center[1] - e.height + 0.21 * e.height),
        (e.left = this.center[0] - e.width / 2),
        e
      );
    }
    layoutWord(t) {
      const e = this.getTextInfo(this.data[t]);
      let i = 2 * Math.PI,
        n = 0,
        s = e.left,
        r = e.top;
      const a = e.width,
        o = e.height;
      let l = 1,
        h = this.fit(e);
      for (; !h && n < this.maxRadius; )
        (n += 0.5),
          (l = this.shape((n / this.maxRadius) * 2 * Math.PI)),
          (i += 0.5 * (this.options.random ? (this.random() > 0.5 ? 1 : -1) : t % 2 == 0 ? 1 : -1)),
          (s = this.center[0] - a / 2 + n * l * Math.cos(i) * this.aspectRatio),
          (r = this.center[1] - o / 2 + n * l * Math.sin(i)),
          (e.left = s),
          (e.top = r),
          (e.x = s + a / 2),
          (e.y = r + o / 2),
          (h = this.fit(e));
      return (
        !!h &&
        !!(
          this.options.clip ||
          (e.left >= 0 && e.left + e.width <= this.width && e.top >= 0 && e.top + e.height <= this.height)
        ) &&
        (this.result.push(e), !0)
      );
    }
    layout(t, e) {
      if (!(null == t ? void 0 : t.length)) return [];
      this.initProgressive(),
        (this.result = []),
        (this.maxRadius = Math.sqrt(e.width * e.width + e.height * e.height) / 2),
        (this.center = [e.width / 2, e.height / 2]),
        (this.width = e.width),
        (this.height = e.height),
        (this.data = t.sort((t, e) => this.getTextFontSize(e) - this.getTextFontSize(t)));
      let i = 0;
      for (; i < t.length && (this.layoutWord(i), i++, (this.progressiveIndex = i), !this.exceedTime()); );
      return this.result;
    }
  }
  function x8(t, e) {
    return !(
      t.left + t.width < e.left ||
      t.top + t.height < e.top ||
      t.left > e.left + e.width ||
      t.top > e.top + e.height
    );
  }
  b8.defaultOptions = { enlarge: !1 };
  const S8 = {
      x: 'x',
      y: 'y',
      z: 'z',
      fontFamily: 'fontFamily',
      fontSize: 'fontSize',
      fontStyle: 'fontStyle',
      fontWeight: 'fontWeight',
      angle: 'angle'
    },
    w8 = (t, e) => {
      var i, n, s, r, a, o;
      if (t.size && (t.size[0] <= 0 || t.size[1] <= 0))
        return Ze.getInstance().info('Wordcloud size dimensions must be greater than 0'), [];
      const l = e,
        h = (null !== (i = t.size) && void 0 !== i ? i : [500, 500]).slice();
      (h[0] = Math.floor(h[0])), (h[1] = Math.floor(h[1]));
      const c = t.fontFamily ? A8(t.fontFamily) : 'sans-serif',
        d = t.fontStyle ? A8(t.fontStyle) : 'normal',
        u = t.fontWeight ? A8(t.fontWeight) : 'normal',
        p = t.rotate ? A8(t.rotate) : 0,
        g = A8(t.text),
        f = null !== (n = t.spiral) && void 0 !== n ? n : 'archimedean',
        v = t.padding ? A8(t.padding) : 1,
        m = null !== (s = t.shape) && void 0 !== s ? s : 'square',
        _ = null !== (r = t.shrink) && void 0 !== r && r,
        b = null !== (a = t.enlarge) && void 0 !== a && a,
        x = null !== (o = t.clip) && void 0 !== o && o,
        S = t.minFontSize,
        w = t.randomVisible,
        A = t.as || S8,
        k = t.depth_3d,
        M = t.postProjection;
      let T = t.fontSize ? A8(t.fontSize) : 14;
      const C = t.fontSizeRange;
      if (C && !y(T)) {
        const t = T,
          e = M8(T8(t, l), C);
        T = i => e(t(i));
      }
      let E = p8;
      'fast' === t.layoutType ? (E = b8) : 'grid' === t.layoutType && (E = _8);
      const P = new E({
        text: g,
        padding: v,
        spiral: f,
        shape: m,
        rotate: p,
        fontFamily: c,
        fontStyle: d,
        fontWeight: u,
        fontSize: T,
        shrink: _,
        clip: x,
        enlarge: b,
        minFontSize: S,
        random: w,
        progressiveStep: t.progressiveStep,
        progressiveTime: t.progressiveTime,
        outputCallback: t => {
          const e = [];
          let i, n;
          for (let s = 0, r = t.length; s < r; s++)
            (n = t[s]),
              (i = n.datum),
              (i[A.x] = n.x),
              (i[A.y] = n.y),
              (i[A.fontFamily] = n.fontFamily),
              (i[A.fontSize] = n.fontSize),
              (i[A.fontStyle] = n.fontStyle),
              (i[A.fontWeight] = n.fontWeight),
              (i[A.angle] = n.angle),
              'StereographicProjection' === M && C8(h, n, i, A, k),
              e.push(i);
          return e;
        }
      });
      return (
        P.layout(l, { width: h[0], height: h[1] }),
        t.progressiveStep > 0 || t.progressiveTime > 0 ? { progressive: P } : P.output()
      );
    },
    A8 = t => (g(t) || y(t) || o(t) ? t : e => e[t.field]),
    k8 = t => (t < 0 ? -Math.sqrt(-t) : Math.sqrt(t)),
    M8 = (t, e) => {
      if (t[0] === t[1]) return t => e[0];
      const i = k8(t[0]),
        n = k8(t[1]),
        s = Math.min(i, n),
        r = Math.max(i, n);
      return t => ((k8(t) - s) / (r - s)) * (e[1] - e[0]) + e[0];
    },
    T8 = (t, e) => {
      let i = 1 / 0,
        n = -1 / 0;
      const s = e.length;
      let r;
      for (let a = 0; a < s; ++a) (r = q(t(e[a]))), r < i && (i = r), r > n && (n = r);
      return 1 === e.length && i === n && (i -= 1e4), [i, n];
    };
  function C8(t, e, i, n, s) {
    const r = Math.max(t[0], t[1]) / 2,
      a = (function (t, e, i, n, s) {
        const { x: r, y: a } = s,
          o = (r / t) * Math.PI * 2;
        let l = Math.PI - (a / e) * Math.PI;
        return (
          (l += ((l < Math.PI / 2 ? 1 : -1) * Math.pow(Math.min(l - Math.PI / 2, 1), 2)) / 5),
          { x: i * Math.sin(l) * Math.cos(o) + n.x, y: i * Math.cos(l) + n.y, z: i * Math.sin(l) * Math.sin(o) + n.z }
        );
      })(t[0], t[1], r, { x: r, y: r, z: null != s ? s : r }, e);
    (i[n.x] = a.x), (i[n.y] = a.y), (i[n.z] = a.z);
  }
  var E8;
  !(function (t) {
    (t.BEFORE_WORDCLOUD_SHAPE_LAYOUT = 'beforeWordcloudShapeLayout'),
      (t.AFTER_WORDCLOUD_SHAPE_LAYOUT = 'afterWordcloudShapeLayout');
  })(E8 || (E8 = {}));
  const P8 = t => /^[\u4e00-\u9fa5]+$/.test(t),
    R8 = (t, e) => {
      if (l(t)) return 0;
      let i = 0;
      for (const e of t) P8(e) ? (i += 1) : (i += 0.53);
      return i;
    };
  var O8 = function (t, e, i, n) {
    return new (i || (i = Promise))(function (s, r) {
      function a(t) {
        try {
          l(n.next(t));
        } catch (t) {
          r(t);
        }
      }
      function o(t) {
        try {
          l(n.throw(t));
        } catch (t) {
          r(t);
        }
      }
      function l(t) {
        var e;
        t.done
          ? s(t.value)
          : ((e = t.value),
            e instanceof i
              ? e
              : new i(function (t) {
                  t(e);
                })).then(a, o);
      }
      l((n = n.apply(t, e || [])).next());
    });
  };
  function B8(t) {
    return O8(this, void 0, void 0, function* () {
      const e = yield ((i = t.shapeUrl),
      i && (b(i) || S(i) || i.startsWith('<svg'))
        ? new Promise((t, e) => {
            const n = aB({ image: i });
            (n.successCallback = () => {
              var s;
              if (n) {
                const r = null === (s = n.resources) || void 0 === s ? void 0 : s.get(i);
                r && 'success' === r.state && r.data ? t(r.data) : e(new Error('image load failed' + i));
              } else e(new Error('image load failed' + i));
            }),
              (n.failCallback = () => {
                Ze.getInstance().error('image 加载失败！', i);
              });
          })
        : null);
      var i;
      return t.removeWhiteBorder && e
        ? (function (t, e, i) {
            (e.width = t.width), (e.height = t.height), i.clearRect(0, 0, e.width, e.height), i.drawImage(t, 0, 0);
            const n = e.width,
              s = i.getImageData(0, 0, e.width, e.height);
            let r = 0,
              a = s.height,
              o = 0,
              l = s.width;
            for (; r < a && L8(s, n, r); ) ++r;
            for (; a - 1 > r && L8(s, n, a - 1); ) --a;
            for (; o < l && F8(s, n, o, r, a); ) ++o;
            for (; l - 1 > o && F8(s, n, l - 1, r, a); ) --l;
            const h = i.getImageData(o, r, l - o, a - r);
            return (
              (e.width = h.width),
              (e.height = h.height),
              i.clearRect(0, 0, e.width, e.height),
              i.putImageData(h, 0, 0),
              e
            );
          })(e, t.tempCanvas, t.tempCtx)
        : e;
    });
  }
  function I8(t, e) {
    const { size: i, tempCanvas: n, tempCtx: s } = e,
      r = (function (t, e) {
        const i = t.width,
          n = t.height;
        let s = e[0] / i;
        n * s > e[1] && (s = e[1] / n);
        const r = Math.floor(s * i),
          a = Math.floor(s * n);
        return { x: (e[0] - r) / 2, y: (e[1] - a) / 2, width: r, height: a, scale: s };
      })(t, i);
    (n.width = i[0]),
      (n.height = i[1]),
      s.clearRect(0, 0, n.width, n.height),
      s.drawImage(t, r.x, r.y, r.width, r.height);
    const a = s.getImageData(0, 0, i[0], i[1]),
      o = new Array(i[0] * i[1]).fill(0);
    let l = 1;
    const h = [
      [0, 1],
      [1, 0],
      [-1, 0],
      [0, -1]
    ];
    let c = [];
    for (let t = 0; t < i[1]; t++)
      for (let e = 0; e < i[0]; e++)
        if (0 === o[t * i[0] + e] && !D8(a, t, e)) {
          (o[t * i[0] + e] = l), c.push([t, e]);
          for (let t = 0; t < c.length; t++)
            for (let e = 0; e < 4; e++) {
              let n = c[t][0] + h[e][0],
                s = c[t][1] + h[e][1];
              (n = n < 0 ? 0 : n >= i[1] ? i[1] - 1 : n),
                (s = s < 0 ? 0 : s >= i[0] ? i[0] - 1 : s),
                0 !== o[n * i[0] + s] || D8(a, n, s) || ((o[n * i[0] + s] = l), c.push([n, s]));
            }
          l++, (c = []);
        }
    const d = {},
      u = {},
      p = {},
      g = {},
      f = {},
      v = {},
      m = { x1: 1 / 0, x2: -1 / 0, y1: 1 / 0, y2: -1 / 0, width: 0, height: 0 };
    for (let t = 0; t < i[1]; t++)
      for (let e = 0; e < i[0]; e++) {
        const n = o[t * i[0] + e];
        0 !== n &&
          (M(t, e) &&
            ((d[n] = d[n] || []),
            d[n].push([e, t]),
            g[n] || (g[n] = [1 / 0, -1 / 0, 1 / 0, -1 / 0]),
            t < g[n][0] && (g[n][0] = t),
            t > g[n][1] && (g[n][1] = t),
            e < g[n][2] && (g[n][2] = e),
            e > g[n][3] && (g[n][3] = e),
            e < m.x1 && (m.x1 = e),
            e > m.x2 && (m.x2 = e),
            t < m.y1 && (m.y1 = t),
            t > m.y2 && (m.y2 = t)),
          (u[n] = u[n] || 0),
          u[n]++);
      }
    const y = [];
    for (const t in d) {
      const e = d[t],
        i = ~~(e.reduce((t, e) => t + e[0], 0) / e.length),
        n = ~~(e.reduce((t, e) => t + e[1], 0) / e.length);
      (p[t] = [i, n]), y.push(...e);
      const [s, r, a, o] = g[t];
      (f[t] = ~~Math.max(
        Math.sqrt((i - a) ** 2 + (n - s) ** 2),
        Math.sqrt((i - o) ** 2 + (n - r) ** 2),
        Math.sqrt((i - a) ** 2 + (n - r) ** 2),
        Math.sqrt((i - o) ** 2 + (n - s) ** 2)
      )),
        (v[t] = (o - a) / (r - s));
    }
    const _ = Object.keys(p).map(t => ({
      label: t - 1,
      boundary: d[t],
      area: u[t],
      center: p[t],
      maxPoint: g[t],
      maxR: f[t],
      ratio: v[t]
    }));
    (m.width = m.x2 - m.x1 + 1), (m.height = m.y2 - m.y1 + 1);
    const b = ~~(y.reduce((t, e) => t + e[0], 0) / y.length),
      x = ~~(y.reduce((t, e) => t + e[1], 0) / y.length),
      S = ~~Math.max(
        Math.sqrt((b - m.x1) ** 2 + (x - m.y1) ** 2),
        Math.sqrt((b - m.x2) ** 2 + (x - m.y2) ** 2),
        Math.sqrt((b - m.x1) ** 2 + (x - m.y2) ** 2),
        Math.sqrt((b - m.x2) ** 2 + (x - m.y1) ** 2)
      ),
      w = m.width / m.height,
      A = Object.keys(u).reduce((t, e) => t + u[e], 0),
      k = { regions: _, labels: o, labelNumber: l - 1 };
    return Object.assign(e, {
      segmentation: k,
      shapeConfig: r,
      shapeBounds: m,
      shapeMaxR: S,
      shapeRatio: w,
      shapeCenter: [b, x],
      shapeArea: A
    });
    function M(t, e) {
      const n = [
        [0, 1],
        [1, 0],
        [-1, 0],
        [0, -1]
      ];
      if (0 === t || 0 === e || t === i[1] - 1 || e === i[0] - 1) return !0;
      for (let s = 0; s < 4; s++) {
        let r = t + n[s][0],
          a = e + n[s][1];
        if (
          ((r = r < 0 ? 0 : r >= i[1] ? i[1] - 1 : r),
          (a = a < 0 ? 0 : a >= i[0] ? i[0] - 1 : a),
          0 === o[r * i[0] + a])
        )
          return !0;
      }
      return !1;
    }
  }
  function D8(t, e, i) {
    const n = t.width;
    return (
      0 === t.data[e * n * 4 + 4 * i + 3] ||
      (255 === t.data[e * n * 4 + 4 * i + 0] &&
        255 === t.data[e * n * 4 + 4 * i + 1] &&
        255 === t.data[e * n * 4 + 4 * i + 2])
    );
  }
  function L8(t, e, i) {
    for (let n = 0; n < e; ++n) if (!D8(t, i, n)) return !1;
    return !0;
  }
  function F8(t, e, i, n, s) {
    for (let e = n; e < s; ++e) if (!D8(t, e, i)) return !1;
    return !0;
  }
  function j8(t, e, i) {
    const { stepFactor: n, importantWordCount: s, globalShinkLimit: r } = e,
      {
        size: a,
        segmentation: { regions: o },
        tempCtx: l,
        tempCanvas: h,
        boardSize: c,
        shapeCenter: d,
        shapeMaxR: u,
        shapeRatio: p
      } = i,
      g = W8(i);
    let f = g.slice(0);
    const v = e.fontSizeShrinkFactor;
    let m = null,
      y = 1,
      _ = 1;
    const b = s;
    let x = 0;
    t.length > b && (x = t.sort((t, e) => e.weight - t.weight)[b].weight);
    for (let e = 0; e < o.length; e++) {
      const i = o[e],
        { words: s, center: d, maxR: u, ratio: p } = i;
      let b = !1;
      for (let e = 0; e < s.length; e++) {
        V8(h, l, t, e);
        const i = s[e];
        if (((i.x = d[0]), (i.y = d[1]), !i.skip && i.hasText && i.sprite && z8(f, i, u, p, a, c, n))) i.hasPlaced = !0;
        else {
          if (!i.skip && i.weight > x && _ > r) {
            const e = i.datum[Symbol.for('vGrammar_id')];
            e !== m && ((m = e), (y = _)),
              (_ *= v),
              t.forEach(t => {
                (t.hasText = !1), (t.sprite = null), (t.fontSize = t.fontSize * v);
              }),
              (f = g.slice(0)),
              (b = !0);
            break;
          }
          if (!i.skip && i.datum[Symbol.for('vGrammar_id')] === m) {
            t.forEach(t => {
              (t.hasText = !1), (t.sprite = null), (t.fontSize = t.fontSize / _);
            }),
              (i.skip = !0),
              (_ = y),
              (m = null),
              (f = g.slice(0)),
              (b = !0);
            break;
          }
        }
      }
      b && (e = -1);
    }
    for (let i = 0; i < e.textLayoutTimes; i++) {
      const i = t.filter(
        t => (
          t.hasPlaced ||
            ((t.hasText = !1),
            (t.sprite = null),
            (t.fontSize = Math.max(~~(t.fontSize * e.fontSizeShrinkFactor), e.minFontSize))),
          !t.hasPlaced
        )
      );
      if (0 === i.length) break;
      for (let t = 0; t < i.length; t++) {
        const e = i[t];
        V8(h, l, i, t), (e.x = d[0]), (e.y = d[1]), e.hasText && z8(f, e, u, p, a, c, n) && (e.hasPlaced = !0);
      }
    }
    e.board = f;
  }
  function z8(t, e, i, n, s, r, a) {
    const o = e.x,
      l = e.y,
      h = (function (t) {
        return function (e) {
          return [t * (e *= 0.1) * Math.cos(e), e * Math.sin(e)];
        };
      })(n),
      c = 1 * a;
    let d,
      u,
      p,
      g = -c;
    for (; (d = h((g += c))); ) {
      const {
        wordSize: n,
        bounds: { dTop: a, dBottom: h, dLeft: c, dRight: g }
      } = e;
      if (((u = d[0]), (p = d[1]), Math.min(Math.abs(u), Math.abs(p)) >= i)) break;
      if (
        ((e.x = ~~(o + u)),
        (e.y = ~~(l + p)),
        !(e.x - c < 0 || e.x + g > s[0] || e.y - a < 0 || e.y + h > s[1] || N8(e, t, r)))
      )
        return H8(e, t, r), !0;
    }
    return !1;
  }
  function H8(t, e, i) {
    const { wordSize: n } = t,
      s = t.sprite,
      r = n[0] >> 5,
      a = i[0] >> 5,
      o = t.x - (r << 4),
      l = o % 32,
      h = 32 - l,
      c = n[1];
    let d,
      u = (t.y - (n[1] >> 1)) * a + (o >> 5);
    if (0 === l)
      for (let t = 0; t < c; t++) {
        for (let i = 0; i < r; i++) e[u + i] |= s[t * r + i];
        u += a;
      }
    else
      for (let t = 0; t < c; t++) {
        d = 0;
        for (let i = 0; i <= r; i++) e[u + i] |= (d << h) | (i < r ? (d = s[t * r + i]) >>> l : 0);
        u += a;
      }
  }
  function N8(t, e, i) {
    const { sprite: n, wordSize: s } = t,
      r = i[0] >> 5,
      a = s[0] >> 5,
      o = t.x - (a << 4),
      l = o % 32,
      h = 32 - l,
      c = s[1];
    let d,
      u = (t.y - (s[1] >> 1)) * r + (o >> 5);
    if (0 === l)
      for (let t = 0; t < c; t++) {
        for (let i = 0; i < a; i++) if (e[u + i] & n[t * a + i]) return !0;
        u += r;
      }
    else
      for (let t = 0; t < c; t++) {
        d = 0;
        for (let i = 0; i <= a; i++) if (((d << h) | (i < a ? (d = n[t * a + i]) >>> l : 0)) & e[u + i]) return !0;
        u += r;
      }
    return !1;
  }
  function V8(t, e, i, n) {
    if (i[n].sprite || 0 === i[n].fontSize) return;
    const s = 2048,
      r = Math.PI / 180,
      a = i.length;
    (t.width = s), (t.height = 2048), e.clearRect(0, 0, s, 2048), (e.textAlign = 'center');
    let o,
      l,
      h = 0,
      c = 0,
      d = 0,
      u = 0;
    const p = n;
    for (--n; ++n < a; ) {
      const t = i[n],
        a = Math.max(t.fontSize, 2);
      if (
        (e.save(),
        (e.font = t.fontStyle + ' ' + t.fontWeight + ' ' + a + 'px ' + t.fontFamily),
        (o = e.measureText(t.text + 'm').width + 2 * t.padding),
        (l = 2 * a + 2 * t.padding),
        0 !== t.rotate)
      ) {
        const e = Math.sin(t.rotate * r),
          i = Math.cos(t.rotate * r),
          n = o * i,
          s = o * e,
          a = l * i,
          h = l * e;
        (o = Math.max(Math.abs(n + h), Math.abs(n - h))), (l = ~~Math.max(Math.abs(s + a), Math.abs(s - a)));
      }
      if (
        ((o = ((o + 31) >> 5) << 5),
        (l = Math.ceil(l)),
        l > d && (d = l),
        h + o >= s && ((h = 0), (c += d), (d = l)),
        c + l >= 2048)
      ) {
        if (0 === c) {
          t.hasText = !1;
          continue;
        }
        break;
      }
      c + l >= u && (u = c + l),
        e.translate(h + (o >> 1), c + (l >> 1)),
        0 !== t.rotate && e.rotate(t.rotate * r),
        e.fillText(t.text, 0, 0),
        t.padding && ((e.lineWidth = 2 * t.padding), e.strokeText(t.text, 0, 0)),
        e.restore(),
        (t.LT = [h, c]),
        (t.wordSize = [o, l]),
        (t.hasText = !0),
        (h += o);
    }
    if (0 === u) return;
    const g = e.getImageData(0, 0, s, u).data;
    let f, v;
    for (; --n >= p; ) {
      const t = i[n];
      if (!t.hasText) {
        t.bounds = { dTop: 1 / 0, dBottom: -1 / 0, dLeft: 1 / 0, dRight: -1 / 0 };
        break;
      }
      const { LT: e = [0, 0], wordSize: r } = t;
      [h, c] = e;
      const a = r[0] >> 5,
        o = new Array(a * r[1]).fill(0);
      let [l, d, u, p] = [1 / 0, -1 / 0, 1 / 0, -1 / 0];
      for (v = 0; v < r[1]; v++) {
        let t;
        for (f = 0; f < r[0]; f++)
          if (g[4 * ((c + v) * s + (h + f)) + 3] > 0) {
            const e = 1 << (31 - (f % 32));
            (o[a * v + (f >> 5)] |= e), f < u && (u = f), f > p && (p = f), (t |= e);
          }
        t && (v < l && (l = v), v > d && (d = v));
      }
      (t.bounds = { dTop: (r[1] >> 1) - l, dBottom: d - (r[1] >> 1), dLeft: (r[0] >> 1) - u, dRight: p - (r[0] >> 1) }),
        (t.sprite = o),
        delete t.LT;
    }
  }
  function W8(t) {
    const {
        segmentation: { labels: e },
        boardSize: i,
        size: n
      } = t,
      s = i[0] >> 5,
      r = new Array(s * n[1]).fill(0);
    for (let t = 0; t < n[1]; t++)
      for (let i = 0; i < n[0]; i++)
        if (0 === e[t * n[0] + i]) {
          const e = 1 << (31 - (i % 32));
          r[s * t + (i >> 5)] |= e;
        }
    if (i[0] > n[0]) {
      const t = (1 << (i[0] - n[0])) - 1;
      for (let e = 0; e < n[1]; e++) r[s * e + s - 1] |= t;
    }
    return r;
  }
  function G8(t, e, i) {
    (function (t, e) {
      const {
        segmentation: { regions: i }
      } = e;
      let n = -1 / 0,
        s = 0,
        r = 0;
      i.forEach((t, e) => {
        const i = t.area;
        i > n && ((n = i), (r = e)), (s += i);
      });
      let a = 0;
      i.forEach(e => {
        const i = e.area,
          r = Math.ceil((i / s) * t.length),
          o = i / n;
        (e.words = []), (e.regionNum = r), (e.regionWeight = o), (a += r);
      }),
        a < t.length && (i[r].wordsNum += t.length - a);
      let o = r;
      const l = i.map(t => t.regionNum);
      t.forEach(t => {
        let e = 0,
          n = 0;
        t.regionIndex = -1;
        do {
          if (l[o] > 0 && t.weight <= i[o].regionWeight) {
            (t.regionIndex = o), i[o].words.push(t), l[o]--, (o = (o + 1) % i.length);
            break;
          }
          (o = (o + 1) % i.length),
            e++,
            n++,
            n > i.length + 1 &&
              (i.forEach(t => {
                t.regionWeight += 0.15;
              }),
              (n = 0));
        } while (-1 === t.regionIndex && e < 3 * i.length);
        -1 === t.regionIndex && ((t.regionIndex = r), i[r].words.push(t), l[r]--);
      }),
        i.forEach(t => {
          t.words.sort((t, e) => e.weight - t.weight);
        });
    })(t, i),
      'ensureMapping' === e.layoutMode
        ? j8(t, e, i)
        : 'ensureMappingEnlarge' === e.layoutMode
        ? (function (t, e, i) {
            const { size: n, stepFactor: s, importantWordCount: r } = e,
              {
                segmentation: { regions: a },
                tempCtx: o,
                tempCanvas: l,
                boardSize: h,
                shapeCenter: c,
                shapeMaxR: d,
                shapeRatio: u
              } = i,
              p = W8(i);
            let g = p.slice(0);
            const f = e.fontSizeEnlargeFactor,
              v = Math.min(r, t.length);
            let m = 0;
            t.length > v && (m = t.sort((t, e) => e.weight - t.weight)[v - 1].weight);
            let y = 0,
              _ = 1,
              b = !1;
            for (let r = 0; r < a.length; r++) {
              const c = a[r],
                { words: d, center: u, maxR: x, ratio: S } = c;
              let w = !1;
              for (let r = 0; r < d.length; r++) {
                V8(l, o, t, r);
                const a = d[r];
                if (((a.x = u[0]), (a.y = u[1]), a.hasText && a.sprite && z8(g, a, x, S, n, h, s))) {
                  if (((a.hasPlaced = !0), a.weight >= m && y++, y >= v && !b)) {
                    (_ *= f),
                      t.forEach(t => {
                        (t.hasText = !1), (t.sprite = null), (t.fontSize = t.fontSize * f);
                      }),
                      (g = p.slice(0)),
                      (w = !0),
                      (y = 0);
                    break;
                  }
                } else {
                  if (a.weight >= m && _ > 1) {
                    t.forEach(t => {
                      (t.hasText = !1), (t.sprite = null), (t.fontSize = t.fontSize / f);
                    }),
                      (_ /= f),
                      (b = !0),
                      (g = p.slice(0)),
                      (w = !0);
                    break;
                  }
                  if (a.weight >= m) return j8(t, e, i);
                }
              }
              w && (r = -1);
            }
            for (let i = 0; i < e.textLayoutTimes; i++) {
              const i = t.filter(
                t => (
                  t.hasPlaced ||
                    ((t.hasText = !1),
                    (t.sprite = null),
                    (t.fontSize = Math.max(~~(t.fontSize * e.fontSizeShrinkFactor), e.minFontSize))),
                  !t.hasPlaced
                )
              );
              if (0 === i.length) break;
              for (let t = 0; t < i.length; t++) {
                const e = i[t];
                V8(l, o, i, t), (e.x = c[0]), (e.y = c[1]), e.hasText && z8(g, e, d, u, n, h, s) && (e.hasPlaced = !0);
              }
            }
            e.board = g;
          })(t, e, i)
        : (function (t, e, i) {
            const { size: n, stepFactor: s } = e,
              {
                segmentation: { regions: r },
                tempCtx: a,
                tempCanvas: o,
                boardSize: l,
                shapeCenter: h,
                shapeMaxR: c,
                shapeRatio: d
              } = i,
              u = W8(i);
            for (const e of r) {
              const { words: i, center: r, maxR: h, ratio: c } = e;
              for (let e = 0; e < i.length; e++) {
                V8(o, a, t, e);
                const d = i[e];
                (d.x = r[0]), (d.y = r[1]), d.hasText && d.sprite && z8(u, d, h, c, n, l, s) && (d.hasPlaced = !0);
              }
            }
            for (let i = 0; i < e.textLayoutTimes; i++) {
              const i = t.filter(
                t => (
                  t.hasPlaced ||
                    ((t.hasText = !1),
                    (t.sprite = null),
                    (t.fontSize = Math.max(~~(t.fontSize * e.fontSizeShrinkFactor), e.minFontSize))),
                  !t.hasPlaced
                )
              );
              if (0 === i.length) break;
              for (let t = 0; t < i.length; t++) {
                const e = i[t];
                V8(o, a, i, t), (e.x = h[0]), (e.y = h[1]), e.hasText && z8(u, e, c, d, n, l, s) && (e.hasPlaced = !0);
              }
            }
            e.board = u;
          })(t, e, i);
    const n = (function (t, e, i) {
        const {
            size: n,
            fillingTimes: s,
            fillingXStep: r,
            fillingYStep: a,
            getFillingFontStyle: o,
            getFillingFontWeight: l,
            getFillingFontFamily: h,
            fillingInitialFontSize: c,
            fillingDeltaFontSize: d,
            fillingInitialOpacity: u,
            fillingDeltaOpacity: p,
            fillingRotateList: g,
            getFillingPadding: f,
            random: v,
            board: m,
            minFillFoontSize: y
          } = e,
          { boardSize: _, shapeBounds: b, tempCtx: x, tempCanvas: S, randomGenerator: w } = i;
        let A = c,
          k = u;
        const M = [];
        for (let t = 0; t < s; t++) T(A, k), (A = Math.max(A > d ? A - d : d, y)), (k = k > p ? k - p : p);
        return M;
        function T(e, i) {
          const s = t.map(t => {
            const { text: n, color: s, fillingColor: r, hasPlaced: a, datum: c } = t;
            return {
              x: 0,
              y: 0,
              weight: 0,
              text: n,
              fontFamily: h(c),
              fontStyle: o(c),
              fontWeight: l(c),
              fontSize: e,
              rotate: g[~~(w() * g.length)],
              padding: f(c),
              opacity: i,
              visible: !0,
              color: s,
              fillingColor: r,
              hasPlaced: a,
              datum: c
            };
          });
          C(s);
          let c = 0;
          const { x1: d, y1: u, x2: p, y2: y } = b,
            [A, k] = [d + ~~(w() * r * 2), u + ~~(w() * a * 2)];
          for (let t = k; t <= y; t += a)
            for (let e = A; e <= p; e += r) {
              V8(S, x, s, c);
              const i = s[c];
              (i.x = e), (i.y = t);
              const { wordSize: r, bounds: a, hasPlaced: o } = i;
              if (!o || !a) {
                ++c === s.length && ((c = 0), v && C(s));
                continue;
              }
              const { dTop: l, dBottom: h, dLeft: d, dRight: u } = a;
              i.x - d < 0 ||
                i.x + u > n[0] ||
                i.y - l < 0 ||
                i.y + h > n[1] ||
                (i.hasText &&
                  i.sprite &&
                  !N8(i, m, _) &&
                  (H8(i, m, _), M.push(Object.assign({}, i)), ++c === s.length && ((c = 0), v && C(s))));
            }
        }
        function C(t) {
          return t.sort(() => w() - 0.5);
        }
      })(t, e, i),
      s = [],
      r = [];
    for (let e = 0; e < t.length; e++) t[e].hasPlaced ? r.push(t[e]) : s.push(t[e]);
    return s.forEach(t => (t.visible = !1)), { fillingWords: n, successedWords: r, failedWords: s };
  }
  var U8 = function (t, e, i, n) {
    return new (i || (i = Promise))(function (s, r) {
      function a(t) {
        try {
          l(n.next(t));
        } catch (t) {
          r(t);
        }
      }
      function o(t) {
        try {
          l(n.throw(t));
        } catch (t) {
          r(t);
        }
      }
      function l(t) {
        var e;
        t.done
          ? s(t.value)
          : ((e = t.value),
            e instanceof i
              ? e
              : new i(function (t) {
                  t(e);
                })).then(a, o);
      }
      l((n = n.apply(t, e || [])).next());
    });
  };
  const Y8 = {
      x: 'x',
      y: 'y',
      fontFamily: 'fontFamily',
      fontSize: 'fontSize',
      fontStyle: 'fontStyle',
      fontWeight: 'fontWeight',
      angle: 'angle',
      opacity: 'opacity',
      visible: 'visible',
      isFillingWord: 'isFillingWord',
      color: 'color'
    },
    $8 = (t, e, i, n) =>
      U8(void 0, void 0, void 0, function* () {
        var i, s, r;
        if (!t.size || l(t.size[0]) || l(t.size[1]) || t.size[0] <= 0 || t.size[1] <= 0)
          return Ze.getInstance().info('Wordcloud size dimensions must be greater than 0'), [];
        (t.size = [Math.ceil(t.size[0]), Math.ceil(t.size[1])]),
          t.shape || Lo('WordcloudShape shape must be specified.'),
          t.text || Lo('WordcloudShape text must be specified.'),
          (null == n ? void 0 : n.emit) && n.emit(E8.BEFORE_WORDCLOUD_SHAPE_LAYOUT);
        const a = e,
          o = t.as || Y8;
        if (!a || 0 === a.length) return [];
        const h = {
            shapeUrl: t.shape,
            size: t.size,
            ratio: t.ratio || 0.8,
            tempCanvas: void 0,
            tempCtx: void 0,
            removeWhiteBorder: t.removeWhiteBorder || !1,
            boardSize: [0, 0],
            random: !1,
            randomGenerator: void 0
          },
          c = gN.createCanvas({ width: t.size[0], height: t.size[1] }),
          d = c.getContext('2d');
        (d.textAlign = 'center'), (d.textBaseline = 'middle'), (h.tempCanvas = c), (h.tempCtx = d);
        const u = ((t.size[0] + 31) >> 5) << 5;
        (h.boardSize = [u, t.size[1]]),
          h.random
            ? (h.randomGenerator = Math.random)
            : (h.randomGenerator = (() => {
                let t = -1;
                const e = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9];
                return () => ((t = (t + 1) % e.length), e[t]);
              })());
        const p = yield B8(h);
        if (!p) return [];
        const g = I8(p, h),
          f = t.colorMode || 'ordinal',
          v = {
            getText: J8(t.text),
            getFontSize: J8(t.fontSize),
            fontSizeRange: t.fontSizeRange,
            colorMode: f,
            getColor: t.colorField ? J8(t.colorField) : J8(t.text),
            getFillingColor: J8(t.fillingColorField),
            colorList:
              t.colorList ||
              ('ordinal' === f ? ['#2E62F1'] : ['#537EF5', '#2E62F1', '#2358D8', '#184FBF', '#0C45A6', '#013B8E']),
            getColorHex: J8(t.colorHexField),
            getFontFamily: J8(t.fontFamily || 'sans-serif'),
            rotateList: t.rotateList || [0],
            getPadding: J8(t.padding || 1),
            getFontStyle: J8(t.fontStyle || 'normal'),
            getFontWeight: J8(t.fontWeight || 'normal'),
            getFontOpacity: t.fontOpacity ? J8(t.fontOpacity) : () => 1
          };
        K8(a, v, g);
        const m = {
            size: t.size,
            ratio: t.ratio || 0.8,
            shapeUrl: t.shape,
            random: void 0 === t.random || t.random,
            textLayoutTimes: t.textLayoutTimes || 3,
            removeWhiteBorder: t.removeWhiteBorder || !1,
            layoutMode: t.layoutMode || 'default',
            fontSizeShrinkFactor: t.fontSizeShrinkFactor || 0.8,
            stepFactor: t.stepFactor || 1,
            importantWordCount: t.importantWordCount || 10,
            globalShinkLimit: t.globalShinkLimit || 0.2,
            fontSizeEnlargeFactor: t.fontSizeEnlargeFactor || 1.5,
            fillingRatio: t.fillingRatio || 0.7,
            fillingTimes: t.fillingTimes || 4,
            fillingXStep: t.fillingXRatioStep
              ? Math.max(Math.floor(t.size[0] * t.fillingXRatioStep), 1)
              : t.fillingXStep || 4,
            fillingYStep: t.fillingYRatioStep
              ? Math.max(Math.floor(t.size[1] * t.fillingYRatioStep), 1)
              : t.fillingYStep || 4,
            fillingInitialFontSize: t.fillingInitialFontSize,
            fillingDeltaFontSize: t.fillingDeltaFontSize,
            fillingInitialOpacity: t.fillingInitialOpacity || 0.8,
            fillingDeltaOpacity: t.fillingDeltaOpacity || 0.05,
            getFillingFontFamily: J8(t.fillingFontFamily || 'sans-serif'),
            getFillingFontStyle: J8(t.fillingFontStyle || 'normal'),
            getFillingFontWeight: J8(t.fillingFontWeight || 'normal'),
            getFillingPadding: J8(t.fillingPadding || 0.4),
            fillingRotateList: t.fillingRotateList || [0, 90],
            fillingDeltaFontSizeFactor: t.fillingDeltaFontSizeFactor || 0.2,
            fillingColorList: t.fillingColorList || ['#537EF5'],
            sameColorList: !1,
            minInitFontSize: t.minInitFontSize || 10,
            minFontSize: t.minFontSize || 4,
            minFillFoontSize: t.minFillFoontSize || 2
          },
          y = ((t, e) => {
            if (1 === e.length && '#537EF5' === e[0]) return !0;
            if (!Array.isArray(t) || !Array.isArray(e) || t.length !== e.length) return !1;
            for (let i = 0; i < t.length; i++) if (t[i] !== e[i]) return !1;
            return !0;
          })(v.colorList, m.fillingColorList);
        (m.sameColorList = y),
          X8(a, v, m, t),
          (function (t, e, i, n) {
            const { getText: s } = e;
            let { fillingInitialFontSize: r, fillingDeltaFontSize: a } = i;
            const { fillingRatio: o } = i,
              l = Math.ceil(Math.sqrt(n.shapeArea) / 4);
            if (!r || !a) {
              const e = o / 100,
                h =
                  t.reduce((t, e) => {
                    const i = R8(s(e));
                    return i > l ? t : t + i;
                  }, 0) / t.length;
              let c;
              if (0 === h) c = 8;
              else {
                const t = 0.2 * n.shapeArea;
                c = Math.sqrt(e * (t / h));
              }
              (r = ~~c),
                (a = c * i.fillingDeltaFontSizeFactor),
                Object.assign(i, { fillingInitialFontSize: r, fillingDeltaFontSize: a });
            }
          })(a, v, m, g);
        const {
            getText: _,
            getFontFamily: b,
            getFontStyle: x,
            getFontWeight: S,
            getPadding: w,
            getColor: A,
            getFillingColor: k,
            getColorHex: M,
            fontSizeScale: T,
            colorScale: C,
            fillingColorScale: E,
            getFontOpacity: P,
            rotateList: R
          } = v,
          O = a.map(e => {
            var i, n;
            return {
              x: 0,
              y: 0,
              weight: 0,
              text: _(e),
              fontFamily: b(e),
              fontWeight: S(e),
              fontStyle: x(e),
              rotate: R[~~(h.randomGenerator() * R.length)],
              fontSize: Math.max(m.minInitFontSize, ~~T(e)),
              opacity: P(e),
              padding: w(e),
              color: (M && M(e)) || (C && C(A(e))) || 'black',
              fillingColor:
                !k ||
                ((null === (i = t.colorField) || void 0 === i ? void 0 : i.field) ===
                  (null === (n = t.fillingColorField) || void 0 === n ? void 0 : n.field) &&
                  y)
                  ? void 0
                  : (M && M(e)) || (E && E(k(e))) || 'black',
              datum: e,
              visible: !0,
              hasPlaced: !1
            };
          }),
          B = Math.max(...O.map(t => t.fontSize));
        O.forEach(t => (t.weight = t.fontSize / B)), O.sort((t, e) => e.weight - t.weight);
        const { fillingWords: I, successedWords: D, failedWords: L } = G8(O, m, g);
        let F, j;
        const z = [];
        for (let t = 0; t < O.length; ++t)
          (F = O[t]),
            (j = F.datum),
            (j[o.x] = F.x),
            (j[o.y] = F.y),
            (j[o.fontFamily] = F.fontFamily),
            (j[o.fontSize] = F.fontSize),
            (j[o.fontStyle] = F.fontStyle),
            (j[o.fontWeight] = F.fontWeight),
            (j[o.angle] = qt(F.rotate)),
            (j[o.opacity] = F.opacity),
            (j[o.visible] = F.visible),
            (j[o.isFillingWord] = !1),
            (j[o.color] = F.color),
            z.push(j);
        const H =
            null !== (s = null === (i = t.text) || void 0 === i ? void 0 : i.field) && void 0 !== s ? s : 'textKey',
          N = null !== (r = t.dataIndexKey) && void 0 !== r ? r : 'defaultDataIndexKey',
          V = [];
        return (
          I.forEach((e, i) => {
            var n, s;
            const r = {};
            (r[o.x] = e.x),
              (r[o.y] = e.y),
              (r[o.fontFamily] = e.fontFamily),
              (r[o.fontSize] = e.fontSize),
              (r[o.fontStyle] = e.fontStyle),
              (r[o.fontWeight] = e.fontWeight),
              (r[o.angle] = qt(e.rotate)),
              (r[o.opacity] = e.opacity),
              (r[o.visible] = e.visible),
              (r[o.isFillingWord] = !0),
              (r[o.color] = k
                ? (null === (n = t.colorField) || void 0 === n ? void 0 : n.field) ===
                    (null === (s = t.fillingColorField) || void 0 === s ? void 0 : s.field) && y
                  ? e.color
                  : e.fillingColor
                : m.fillingColorList[~~(h.randomGenerator() * m.fillingColorList.length)]),
              (r[H] = e.text),
              (r[N] = `${e.text}_${i}_fillingWords`),
              V.push(r);
          }),
          (null == n ? void 0 : n.emit) &&
            n.emit(E8.AFTER_WORDCLOUD_SHAPE_LAYOUT, { successedWords: D, failedWords: L }),
          z.concat(V)
        );
      }),
    X8 = (t, e, i, n) => {
      var s, r, a, o;
      const { colorMode: l, getColor: h, getFillingColor: c } = e,
        { sameColorList: d } = i;
      let u,
        p,
        g = e.colorList,
        f = i.fillingColorList;
      if ('ordinal' === l) {
        const e = t.map(t => h(t));
        if (
          ((u = t => new il().domain(e).range(g).scale(t)),
          c &&
            ((null === (s = n.colorField) || void 0 === s ? void 0 : s.field) !==
              (null === (r = n.fillingColorField) || void 0 === r ? void 0 : r.field) ||
              !d))
        ) {
          const e = t.map(t => c(t));
          p = t => new il().domain(e).range(f).scale(t);
        }
      } else {
        1 === g.length && (g = [g[0], g[0]]);
        const e = new Vl().domain(Z8(h, t)).range(g);
        if (
          ((u = t => e.scale(t)),
          c &&
            ((null === (a = n.colorField) || void 0 === a ? void 0 : a.field) !==
              (null === (o = n.fillingColorField) || void 0 === o ? void 0 : o.field) ||
              !d))
        ) {
          1 === f.length && (f = [f[0], f[0]]);
          const e = new Vl().domain(Z8(c, t)).range(f);
          p = t => e.scale(t);
        }
      }
      Object.assign(e, { colorScale: u, fillingColorScale: p });
    },
    K8 = (t, e, i) => {
      let { fontSizeRange: n } = e;
      const { getFontSize: s, getText: r } = e;
      let a;
      if (s) {
        if (s && n) {
          const e = new Kl().domain(Z8(s, t)).range(n);
          a = t => e.scale(s(t));
        } else if (s && o(s) && !n) {
          const e = 0.5,
            [o, l] = Z8(s, t),
            h = t.map(t => ({ text: r(t), value: s(t), weight: l === o ? 1 : (s(t) - o) / (l - o) })),
            c = q8(h, i, !0);
          n = [~~(e * c), ~~c];
          const d = new Kl().domain(Z8(s, t)).range(n);
          a = t => d.scale(s(t));
        }
      } else {
        const e = t.map(t => ({ text: r(t) })),
          n = q8(e, i, !1);
        a =
          'function' == typeof (l = n)
            ? l
            : function () {
                return l;
              };
      }
      var l;
      Object.assign(e, { getFontSize: s, fontSizeRange: n, fontSizeScale: a });
    },
    q8 = (t, e, i) => {
      const n = e.shapeArea,
        s = e.ratio,
        r = e.segmentation.regions,
        a = Math.ceil(Math.sqrt(n) / 12),
        o = t.reduce((t, e) => {
          const n = R8(e.text);
          return n < a ? t + n * (i ? (0.5 + 0.5 * e.weight) ** 2 : 1) : t;
        }, 0);
      if (0 === o) return 12;
      let l = 20;
      if (1 === r.length) l = Math.sqrt(s * (n / (1.7 * o)));
      else {
        const t = [];
        for (let e = 0; e < r.length; e++) {
          const i = r[e].area,
            a = r[e].ratio,
            l = i / n;
          if (l < 0.1) continue;
          const h = l * (o * (a < 1 ? 2.7 - a : 1.7)),
            c = Math.sqrt(s * (i / h));
          t.push(c);
        }
        l = t.length ? Math.min(...t) : Math.sqrt(s * (n / (1.7 * o)));
      }
      return l;
    };
  const Z8 = (t, e) => {
      let i = 1 / 0,
        n = -1 / 0;
      const s = e.length;
      let r;
      for (let a = 0; a < s; ++a) (r = q(t(e[a]))), r < i && (i = r), r > n && (n = r);
      return 1 === e.length && i === n && (i -= 1e4), [i, n];
    },
    J8 = t => (t ? ('string' == typeof t || 'number' == typeof t ? () => t : o(t) ? t : e => e[t.field]) : null),
    Q8 = `${UV}_WORD_CLOUD_ANGLE`,
    t6 = `${UV}_WORD_CLOUD_FILLING_ANGLE`,
    e6 = `${UV}_WORD_CLOUD_WEIGHT`,
    i6 = `${UV}_WORD_CLOUD_TEXT`;
  NQ.useMark([i2]),
    yW('wordcloud', { transform: w8, markPhase: 'beforeJoin' }, !0),
    yW('wordcloudShape', { transform: $8, markPhase: 'beforeJoin' }, !0);
  class n6 extends q1 {
    constructor() {
      super(...arguments), (this._fontSizeRange = [10, 10]), (this._isWordCloudShape = !1);
    }
    setValueField(t) {
      h(t) && ((this._valueField = t), this.setFontSizeRange(i8));
    }
    setFontSizeRange(t) {
      h(t) && h(this._spec.valueField) && (this._fontSizeRange = t);
    }
    setAttrFromSpec() {
      var t, e, i, n, s, r, a, o, l, h, c, d, u, p, g, f, v, m, y, _;
      super.setAttrFromSpec(),
        (this._padding = this._option.getChart().padding),
        (this._nameField = this._spec.nameField),
        (this._fontFamilyField = this._spec.fontFamilyField),
        (this._fontWeightField = this._spec.fontWeightField),
        (this._fontStyleField = this._spec.fontStyleField),
        (this._colorHexField = this._spec.colorHexField),
        (this._colorMode = null !== (t = this._spec.colorMode) && void 0 !== t ? t : 'ordinal'),
        (this._colorList = this._spec.colorList),
        this.setValueField(this._spec.valueField),
        (this._fontWeightRange = null !== (e = this._spec.fontWeightRange) && void 0 !== e ? e : n8),
        (this._rotateAngles = null !== (i = this._spec.rotateAngles) && void 0 !== i ? i : e8),
        this.setFontSizeRange(this._spec.fontSizeRange),
        (this._maskShape = null !== (n = this._spec.maskShape) && void 0 !== n ? n : 'circle'),
        (this._keepAspect = this._spec.keepAspect),
        (this._random = null === (s = this._spec.random) || void 0 === s || s),
        (this._fontPadding =
          null !==
            (d =
              null !==
                (o =
                  null === (a = null === (r = this._spec) || void 0 === r ? void 0 : r.word) || void 0 === a
                    ? void 0
                    : a.padding) && void 0 !== o
                ? o
                : null ===
                    (c =
                      null === (h = null === (l = this._theme) || void 0 === l ? void 0 : l.wordCloud) || void 0 === h
                        ? void 0
                        : h.word) || void 0 === c
                ? void 0
                : c.padding) && void 0 !== d
            ? d
            : 1),
        (this._wordCloudConfig = Object.assign(
          { drawOutOfBound: 'hidden', layoutMode: 'default', zoomToFit: s8 },
          this._spec.wordCloudConfig
        )),
        (this._wordCloudShapeConfig = Object.assign(
          { fillingSeriesField: this.getSeriesField(), fillingRotateAngles: e8, layoutMode: 'default' },
          null === (u = this._spec) || void 0 === u ? void 0 : u.wordCloudShapeConfig
        )),
        (this._fillingFontPadding =
          null !==
            (_ =
              null !==
                (f =
                  null === (g = null === (p = this._spec) || void 0 === p ? void 0 : p.fillingWord) || void 0 === g
                    ? void 0
                    : g.padding) && void 0 !== f
                ? f
                : null ===
                    (y =
                      null === (m = null === (v = this._theme) || void 0 === v ? void 0 : v.wordCloud) || void 0 === m
                        ? void 0
                        : m.fillingWord) || void 0 === y
                ? void 0
                : y.padding) && void 0 !== _
            ? _
            : 1),
        (this._isWordCloudShape = !r8.includes(this._maskShape));
    }
    initMark() {
      (this._wordMark = this._createMark(n6.mark.word, {
        defaultMorphElementKey: this._seriesField,
        groupKey: this._seriesField,
        isSeriesMark: !0
      })),
        this._isWordCloudShape && (this._fillingWordMark = this._createMark(n6.mark.fillingWord));
    }
    initMarkStyle() {
      var t, e, i;
      const n = this._wordMark,
        s = this._fillingWordMark,
        r = (null === (t = this._spec.word) || void 0 === t ? void 0 : t.formatMethod) ? i6 : this._nameField;
      n &&
        this.setMarkStyle(
          n,
          {
            fill: this._colorHexField ? t => t[this._colorHexField] : this.getWordColorAttribute(this._seriesField, !1),
            text: t => t[r],
            x: t => t.x,
            y: t => t.y,
            fontFamily: t => t.fontFamily,
            fontSize: t => t.fontSize,
            fontStyle: t => t.fontStyle,
            fontWeight: t => t.fontWeight,
            angle: t => t.angle,
            visible: t => !t.isFillingWord
          },
          'normal',
          Jq.Series
        ),
        s &&
          this.setMarkStyle(
            s,
            {
              fill: this._wordCloudShapeConfig.fillingColorHexField
                ? t => t[this._wordCloudShapeConfig.fillingColorHexField]
                : this.getWordColorAttribute(this._wordCloudShapeConfig.fillingSeriesField, !0),
              text: t => t[r],
              x: t => t.x,
              y: t => t.y,
              fontFamily: t => t.fontFamily,
              fontSize: t => t.fontSize,
              fontStyle: t => t.fontStyle,
              fontWeight: t => t.fontWeight,
              angle: t => t.angle,
              visible: t => t.isFillingWord
            },
            'normal',
            Jq.Series
          ),
        this._trigger.registerMark(n),
        null === (e = this._tooltipHelper) || void 0 === e || e.activeTriggerSet.mark.add(n),
        this._trigger.registerMark(s),
        null === (i = this._tooltipHelper) || void 0 === i || i.activeTriggerSet.mark.add(s);
    }
    initAnimation() {
      this._wordMark && this._wordMark.setAnimationConfig(w1(x1.wordCloud(), A1(LZ.word, this._spec)));
    }
    getWordOrdinalColorScale(t, e) {
      var i, n, s, r, a;
      const o = e ? this._wordCloudShapeConfig.fillingColorList : this._colorList,
        l = t ? (null === (i = this.getViewData()) || void 0 === i ? void 0 : i.latestData.map(e => e[t])) : [],
        h =
          null !==
            (s =
              null != o
                ? o
                : null === (n = this._option.globalScale.getScale('color')) || void 0 === n
                ? void 0
                : n.range()) && void 0 !== s
            ? s
            : nV(this._option.getTheme().colorScheme, this.type);
      return null === (a = (r = new hV().domain(l)).range) || void 0 === a ? void 0 : a.call(r, h);
    }
    getWordColorAttribute(t, e) {
      var i, n;
      if ('ordinal' === this._colorMode)
        return {
          scale: this.getWordOrdinalColorScale(t, e),
          field: null !== (i = this._seriesField) && void 0 !== i ? i : qq
        };
      let s =
        null !== (n = e ? this._colorList : this._wordCloudShapeConfig.fillingColorList) && void 0 !== n
          ? n
          : this._option.globalScale.getScale('color').range();
      return 1 === s.length && (s = [s[0], s[0]]), t => s[0];
    }
    compile() {
      var t,
        e,
        i,
        n,
        s,
        r,
        a,
        o,
        l,
        h,
        c,
        d,
        u,
        p,
        g,
        f,
        v,
        m,
        y,
        b,
        x,
        S,
        w,
        A,
        k,
        M,
        T,
        C,
        E,
        P,
        R,
        O,
        B,
        I,
        D,
        L,
        F,
        j,
        z,
        H,
        N,
        V,
        W,
        G,
        U,
        Y,
        $,
        X;
      super.compile();
      const { width: K, height: q } = this._region.getLayoutRect();
      if (!_(K) || !_(q) || !(q > 0 && K > 0)) return;
      const Z = [],
        J = this._valueField,
        Q = new Vl(),
        tt = this._fontWeightRange,
        et = this._rotateAngles,
        it = this._fontWeightField,
        nt = this._wordCloudShapeConfig.fillingRotateAngles;
      if (J) {
        const [e, i] = Go(null === (t = this.getViewData()) || void 0 === t ? void 0 : t.latestData.map(t => +t[J]));
        Q.domain([e, i], !0).range(tt),
          Z.push({ type: 'map', as: e6, callback: t => (e === i ? Q.scale(i) : Q.scale(t[J])) });
      }
      Z.push({ type: 'map', as: Q8, callback: () => et[Math.floor(Math.random() * et.length)] }),
        Z.push({ type: 'map', as: t6, callback: () => nt[Math.floor(Math.random() * nt.length)] }),
        (null === (e = this._spec.word) || void 0 === e ? void 0 : e.formatMethod) &&
          Z.push({ type: 'map', as: i6, callback: this._spec.word.formatMethod });
      const st = (null === (i = this._spec.word) || void 0 === i ? void 0 : i.formatMethod) ? i6 : this._nameField;
      this._isWordCloudShape
        ? Z.push({
            type: 'wordcloudShape',
            dataIndexKey: Kq,
            size: [K, q],
            shape: this._maskShape,
            text: {
              field: (null === (h = this._spec.word) || void 0 === h ? void 0 : h.formatMethod) ? i6 : this._nameField
            },
            fontSize: J ? { field: J } : this._fontSizeRange[0],
            fontSizeRange: this._fontSizeRange,
            padding: this._fontPadding,
            rotateList: et,
            fontFamily:
              null !== (c = this._fontFamilyField) && void 0 !== c
                ? c
                : null === (u = null === (d = this._spec.word) || void 0 === d ? void 0 : d.style) || void 0 === u
                ? void 0
                : u.fontFamily,
            fontWeight: it ? { field: it } : J ? { field: e6 } : null,
            fontStyle:
              null !== (p = this._fontStyleField) && void 0 !== p
                ? p
                : null === (f = null === (g = this._spec.word) || void 0 === g ? void 0 : g.style) || void 0 === f
                ? void 0
                : f.fontStyle,
            fillingFontFamily:
              null !==
                (m = null === (v = this._wordCloudShapeConfig) || void 0 === v ? void 0 : v.fillingFontFamilyField) &&
              void 0 !== m
                ? m
                : null === (b = null === (y = this._spec.word) || void 0 === y ? void 0 : y.style) || void 0 === b
                ? void 0
                : b.fontFamily,
            fillingPadding: this._fillingFontPadding,
            fillingFontStyle:
              null !==
                (S = null === (x = this._wordCloudShapeConfig) || void 0 === x ? void 0 : x.fillingFontStyleField) &&
              void 0 !== S
                ? S
                : null === (A = null === (w = this._spec.word) || void 0 === w ? void 0 : w.style) || void 0 === A
                ? void 0
                : A.fontStyle,
            fillingFontWeight:
              null !==
                (M = null === (k = this._wordCloudShapeConfig) || void 0 === k ? void 0 : k.fillingFontWeightField) &&
              void 0 !== M
                ? M
                : null === (C = null === (T = this._spec.word) || void 0 === T ? void 0 : T.style) || void 0 === C
                ? void 0
                : C.fontWeight,
            fillingRotateList: nt,
            fillingTimes: null === (E = this._wordCloudShapeConfig) || void 0 === E ? void 0 : E.fillingTimes,
            fillingXStep: null === (P = this._wordCloudShapeConfig) || void 0 === P ? void 0 : P.fillingXStep,
            fillingYStep: null === (R = this._wordCloudShapeConfig) || void 0 === R ? void 0 : R.fillingYStep,
            fillingXRatioStep: null === (O = this._wordCloudShapeConfig) || void 0 === O ? void 0 : O.fillingXRatioStep,
            fillingYRatioStep: null === (B = this._wordCloudShapeConfig) || void 0 === B ? void 0 : B.fillingYRatioStep,
            fillingInitialOpacity:
              null === (I = this._wordCloudShapeConfig) || void 0 === I ? void 0 : I.fillingInitialOpacity,
            fillingDeltaOpacity:
              null === (D = this._wordCloudShapeConfig) || void 0 === D ? void 0 : D.fillingDeltaOpacity,
            fillingInitialFontSize:
              null === (L = this._wordCloudShapeConfig) || void 0 === L ? void 0 : L.fillingInitialFontSize,
            fillingDeltaFontSize:
              null === (F = this._wordCloudShapeConfig) || void 0 === F ? void 0 : F.fillingDeltaFontSize,
            ratio: null === (j = this._wordCloudShapeConfig) || void 0 === j ? void 0 : j.ratio,
            fillingRatio: null === (z = this._wordCloudShapeConfig) || void 0 === z ? void 0 : z.fillingRatio,
            removeWhiteBorder: null === (H = this._wordCloudShapeConfig) || void 0 === H ? void 0 : H.removeWhiteBorder,
            textLayoutTimes: null === (N = this._wordCloudShapeConfig) || void 0 === N ? void 0 : N.textLayoutTimes,
            fontSizeShrinkFactor:
              null === (V = this._wordCloudShapeConfig) || void 0 === V ? void 0 : V.fontSizeShrinkFactor,
            stepFactor: null === (W = this._wordCloudShapeConfig) || void 0 === W ? void 0 : W.stepFactor,
            layoutMode: null === (G = this._wordCloudShapeConfig) || void 0 === G ? void 0 : G.layoutMode,
            importantWordCount:
              null === (U = this._wordCloudShapeConfig) || void 0 === U ? void 0 : U.importantWordCount,
            globalShinkLimit: null === (Y = this._wordCloudShapeConfig) || void 0 === Y ? void 0 : Y.globalShinkLimit,
            fontSizeEnlargeFactor:
              null === ($ = this._wordCloudShapeConfig) || void 0 === $ ? void 0 : $.fontSizeEnlargeFactor,
            fillingDeltaFontSizeFactor:
              null === (X = this._wordCloudShapeConfig) || void 0 === X ? void 0 : X.fillingDeltaFontSizeFactor
          })
        : (Z.push({
            type: 'wordcloud',
            layoutType: To(this._option.mode) ? this._wordCloudConfig.layoutMode : 'fast',
            size: [K, q],
            shape: this._maskShape,
            dataIndexKey: Kq,
            text: { field: st },
            fontSize: J ? { field: J } : this._fontSizeRange[0],
            fontSizeRange: this._fontSizeRange,
            padding: this._fontPadding,
            rotate: { field: Q8 },
            fontFamily:
              null !== (n = this._fontFamilyField) && void 0 !== n
                ? n
                : null === (r = null === (s = this._spec.word) || void 0 === s ? void 0 : s.style) || void 0 === r
                ? void 0
                : r.fontFamily,
            fontWeight: it ? { field: it } : J ? { field: e6 } : null,
            fontStyle:
              null !== (a = this._fontStyleField) && void 0 !== a
                ? a
                : null === (l = null === (o = this._spec.word) || void 0 === o ? void 0 : o.style) || void 0 === l
                ? void 0
                : l.fontStyle,
            randomVisible: this._random,
            clip: 'clip' === this._wordCloudConfig.drawOutOfBound,
            shrink: this._wordCloudConfig.zoomToFit.shrink,
            enlarge: this._wordCloudConfig.zoomToFit.enlarge,
            minFontSize: this._wordCloudConfig.zoomToFit.fontSizeLimitMin,
            progressiveTime: this._wordCloudConfig.progressiveTime,
            progressiveStep: this._wordCloudConfig.progressiveStep
          }),
          this._wordMark.getProduct().transform(Z)),
        this._data.getProduct().transform(Z);
    }
    getStatisticFields() {
      const t = [];
      return (
        t.push({ key: this._nameField, operations: ['values'] }),
        t.push({ key: this._valueField, operations: ['max', 'min'] }),
        t
      );
    }
    dataToPosition(t) {
      return null;
    }
    dataToPositionX(t) {
      return null;
    }
    dataToPositionY(t) {
      return null;
    }
    dataToPositionZ(t) {
      return null;
    }
    valueToPosition(t, e) {
      return null;
    }
    setValueFieldToStackOffsetSilhouette() {}
    getGroupFields() {
      return [];
    }
    getStackGroupFields() {
      return [];
    }
    getStackValueField() {
      return '';
    }
    setValueFieldToStack() {}
    setValueFieldToPercent() {}
    onLayoutEnd(t) {
      super.onLayoutEnd(t), this.compile();
    }
    updateSpec(t) {
      const e = this._originalSpec,
        i = super.updateSpec(t);
      return z(e, t) || ((i.reMake = !0), (i.reCompile = !0)), i;
    }
  }
  n6.mark = tJ;
  class s6 extends n6 {
    constructor() {
      super(...arguments), (this.type = DZ.wordCloud);
    }
  }
  (s6.type = DZ.wordCloud), NQ.useSeries([s6]);
  class r6 extends t8 {
    constructor() {
      super(...arguments), (this.type = d2.wordCloud), (this.seriesType = DZ.wordCloud);
    }
    _getDefaultSeriesSpec(t) {
      const e = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
          nameField: t.nameField,
          valueField: t.valueField,
          seriesField: t.seriesField,
          fontFamilyField: t.fontFamilyField,
          fontWeightField: t.fontWeightField,
          fontStyleField: t.fontStyleField,
          colorHexField: t.colorHexField,
          colorMode: t.colorMode,
          colorList: t.colorList,
          rotateAngles: t.rotateAngles,
          fontWeightRange: t.fontWeightRange,
          fontSizeRange: t.fontSizeRange,
          maskShape: t.maskShape,
          keepAspect: t.keepAspect,
          random: t.random,
          wordCloudConfig: t.wordCloudConfig,
          wordCloudShapeConfig: t.wordCloudShapeConfig,
          word: t.word,
          fillingWord: t.fillingWord
        }),
        i = this.seriesType;
      return i && ((e.type = i), (e[i] = t[i])), e;
    }
  }
  (r6.type = d2.wordCloud), (r6.view = 'singleDefault');
  class a6 extends n6 {
    constructor() {
      super(...arguments), (this.type = DZ.wordCloud3d);
    }
    compile() {
      var t,
        e,
        i,
        n,
        s,
        r,
        a,
        o,
        l,
        h,
        c,
        d,
        u,
        p,
        g,
        f,
        v,
        m,
        y,
        _,
        b,
        x,
        S,
        w,
        A,
        k,
        M,
        T,
        C,
        E,
        P,
        R,
        O,
        B,
        I,
        D,
        L,
        F,
        j,
        z,
        H,
        N,
        V,
        W,
        G,
        U,
        Y,
        $,
        X;
      super.compile();
      const K = [],
        q = this._valueField,
        Z = new Vl(),
        J = this._fontWeightRange,
        Q = this._rotateAngles,
        tt = this._fontWeightField,
        et = this._wordCloudShapeConfig.fillingRotateAngles;
      if (q) {
        const [e, i] = Go(null === (t = this.getViewData()) || void 0 === t ? void 0 : t.latestData.map(t => +t[q]));
        Z.domain([e, i], !0).range(J),
          K.push({ type: 'map', as: e6, callback: t => (e === i ? Z.scale(i) : Z.scale(t[q])) });
      }
      K.push({ type: 'map', as: Q8, callback: () => Q[Math.floor(Math.random() * Q.length)] }),
        K.push({ type: 'map', as: t6, callback: () => et[Math.floor(Math.random() * et.length)] }),
        (null === (e = this._spec.word) || void 0 === e ? void 0 : e.formatMethod) &&
          K.push({ type: 'map', as: i6, callback: this._spec.word.formatMethod });
      const it = (null === (i = this._spec.word) || void 0 === i ? void 0 : i.formatMethod) ? i6 : this._nameField;
      this._isWordCloudShape
        ? K.push({
            type: 'wordcloudShape',
            size: [this._region.getLayoutRect().width, this._region.getLayoutRect().height],
            shape: this._maskShape,
            postProjection: null !== (c = this._spec.postProjection) && void 0 !== c ? c : 'StereographicProjection',
            dataIndexKey: Kq,
            text: { field: it },
            fontSize: q ? { field: q } : this._fontSizeRange[0],
            fontSizeRange: this._fontSizeRange,
            padding: this._fontPadding,
            rotateList: Q,
            fontFamily:
              null !== (d = this._fontFamilyField) && void 0 !== d
                ? d
                : null === (p = null === (u = this._spec.word) || void 0 === u ? void 0 : u.style) || void 0 === p
                ? void 0
                : p.fontFamily,
            fontWeight: tt ? { field: tt } : q ? { field: e6 } : null,
            fontStyle:
              null !== (g = this._fontStyleField) && void 0 !== g
                ? g
                : null === (v = null === (f = this._spec.word) || void 0 === f ? void 0 : f.style) || void 0 === v
                ? void 0
                : v.fontStyle,
            depth_3d: this._spec.depth_3d,
            fillingFontFamily:
              null !==
                (y = null === (m = this._wordCloudShapeConfig) || void 0 === m ? void 0 : m.fillingFontFamilyField) &&
              void 0 !== y
                ? y
                : null === (b = null === (_ = this._spec.word) || void 0 === _ ? void 0 : _.style) || void 0 === b
                ? void 0
                : b.fontFamily,
            fillingPadding: this._fillingFontPadding,
            fillingFontStyle:
              null !==
                (S = null === (x = this._wordCloudShapeConfig) || void 0 === x ? void 0 : x.fillingFontStyleField) &&
              void 0 !== S
                ? S
                : null === (A = null === (w = this._spec.word) || void 0 === w ? void 0 : w.style) || void 0 === A
                ? void 0
                : A.fontStyle,
            fillingFontWeight:
              null !==
                (M = null === (k = this._wordCloudShapeConfig) || void 0 === k ? void 0 : k.fillingFontWeightField) &&
              void 0 !== M
                ? M
                : null === (C = null === (T = this._spec.word) || void 0 === T ? void 0 : T.style) || void 0 === C
                ? void 0
                : C.fontWeight,
            fillingRotateList: et,
            fillingTimes: null === (E = this._wordCloudShapeConfig) || void 0 === E ? void 0 : E.fillingTimes,
            fillingXStep: null === (P = this._wordCloudShapeConfig) || void 0 === P ? void 0 : P.fillingXStep,
            fillingYStep: null === (R = this._wordCloudShapeConfig) || void 0 === R ? void 0 : R.fillingYStep,
            fillingXRatioStep: null === (O = this._wordCloudShapeConfig) || void 0 === O ? void 0 : O.fillingXRatioStep,
            fillingYRatioStep: null === (B = this._wordCloudShapeConfig) || void 0 === B ? void 0 : B.fillingYRatioStep,
            fillingInitialOpacity:
              null === (I = this._wordCloudShapeConfig) || void 0 === I ? void 0 : I.fillingInitialOpacity,
            fillingDeltaOpacity:
              null === (D = this._wordCloudShapeConfig) || void 0 === D ? void 0 : D.fillingDeltaOpacity,
            fillingInitialFontSize:
              null === (L = this._wordCloudShapeConfig) || void 0 === L ? void 0 : L.fillingInitialFontSize,
            fillingDeltaFontSize:
              null === (F = this._wordCloudShapeConfig) || void 0 === F ? void 0 : F.fillingDeltaFontSize,
            ratio: null === (j = this._wordCloudShapeConfig) || void 0 === j ? void 0 : j.ratio,
            fillingRatio: null === (z = this._wordCloudShapeConfig) || void 0 === z ? void 0 : z.fillingRatio,
            removeWhiteBorder: null === (H = this._wordCloudShapeConfig) || void 0 === H ? void 0 : H.removeWhiteBorder,
            textLayoutTimes: null === (N = this._wordCloudShapeConfig) || void 0 === N ? void 0 : N.textLayoutTimes,
            fontSizeShrinkFactor:
              null === (V = this._wordCloudShapeConfig) || void 0 === V ? void 0 : V.fontSizeShrinkFactor,
            stepFactor: null === (W = this._wordCloudShapeConfig) || void 0 === W ? void 0 : W.stepFactor,
            layoutMode: null === (G = this._wordCloudShapeConfig) || void 0 === G ? void 0 : G.layoutMode,
            importantWordCount:
              null === (U = this._wordCloudShapeConfig) || void 0 === U ? void 0 : U.importantWordCount,
            globalShinkLimit: null === (Y = this._wordCloudShapeConfig) || void 0 === Y ? void 0 : Y.globalShinkLimit,
            fontSizeEnlargeFactor:
              null === ($ = this._wordCloudShapeConfig) || void 0 === $ ? void 0 : $.fontSizeEnlargeFactor,
            fillingDeltaFontSizeFactor:
              null === (X = this._wordCloudShapeConfig) || void 0 === X ? void 0 : X.fillingDeltaFontSizeFactor
          })
        : (K.push({
            type: 'wordcloud',
            layoutType: this._wordCloudConfig.layoutMode,
            size: [this._region.getLayoutRect().width, this._region.getLayoutRect().height],
            shape: this._maskShape,
            postProjection: null !== (n = this._spec.postProjection) && void 0 !== n ? n : 'StereographicProjection',
            dataIndexKey: Kq,
            text: { field: it },
            fontSize: q ? { field: q } : this._fontSizeRange[0],
            fontSizeRange: this._fontSizeRange,
            padding: this._fontPadding,
            rotate: { field: Q8 },
            fontFamily:
              null !== (s = this._fontFamilyField) && void 0 !== s
                ? s
                : null === (a = null === (r = this._spec.word) || void 0 === r ? void 0 : r.style) || void 0 === a
                ? void 0
                : a.fontFamily,
            fontWeight: tt ? { field: tt } : q ? { field: e6 } : null,
            fontStyle:
              null !== (o = this._fontStyleField) && void 0 !== o
                ? o
                : null === (h = null === (l = this._spec.word) || void 0 === l ? void 0 : l.style) || void 0 === h
                ? void 0
                : h.fontStyle,
            depth_3d: this._spec.depth_3d,
            randomVisible: this._random,
            clip: 'clip' === this._wordCloudConfig.drawOutOfBound,
            shrink: this._wordCloudConfig.zoomToFit.shrink,
            enlarge: this._wordCloudConfig.zoomToFit.enlarge,
            minFontSize: this._wordCloudConfig.zoomToFit.fontSizeLimitMin,
            progressiveTime: this._wordCloudConfig.progressiveTime,
            progressiveStep: this._wordCloudConfig.progressiveStep
          }),
          this._wordMark.getProduct().transform(K)),
        this._data.getProduct().transform(K);
    }
    initMark() {
      (this._wordMark = this._createMark(n6.mark.word, {
        groupKey: this._seriesField,
        support3d: !0,
        isSeriesMark: !0
      })),
        this._isWordCloudShape &&
          (this._fillingWordMark = this._createMark(n6.mark.fillingWord, {
            groupKey: this._seriesField,
            support3d: !0,
            isSeriesMark: !0
          }));
    }
    initMarkStyle() {
      var t, e;
      const i = this._wordMark,
        n = this._fillingWordMark;
      i &&
        this.setMarkStyle(
          i,
          {
            fill: this._colorHexField ? t => t[this._colorHexField] : this.getWordColorAttribute(this._seriesField, !1),
            text: t => t[this._nameField],
            x: t => t.x,
            y: t => t.y,
            z: t => {
              var e;
              return null !== (e = t.z) && void 0 !== e ? e : 0;
            },
            fontFamily: t => t.fontFamily,
            fontSize: t => t.fontSize,
            fontStyle: t => t.fontStyle,
            fontWeight: t => t.fontWeight,
            angle: t => t.angle,
            visible: t => !t.isFillingWord
          },
          'normal',
          Jq.Series
        ),
        n &&
          this.setMarkStyle(
            n,
            {
              fill: this._wordCloudShapeConfig.fillingColorHexField
                ? t => t[this._wordCloudShapeConfig.fillingColorHexField]
                : this.getWordColorAttribute(this._wordCloudShapeConfig.fillingSeriesField, !0),
              text: t => t[this._nameField],
              x: t => t.x,
              y: t => t.y,
              z: t => {
                var e;
                return null !== (e = t.z) && void 0 !== e ? e : 0;
              },
              fontFamily: t => t.fontFamily,
              fontSize: t => t.fontSize,
              fontStyle: t => t.fontStyle,
              fontWeight: t => t.fontWeight,
              angle: t => t.angle,
              visible: t => t.isFillingWord
            },
            'normal',
            Jq.Series
          ),
        this._trigger.registerMark(i),
        null === (t = this._tooltipHelper) || void 0 === t || t.activeTriggerSet.mark.add(i),
        this._trigger.registerMark(n),
        null === (e = this._tooltipHelper) || void 0 === e || e.activeTriggerSet.mark.add(n);
    }
    initAnimation() {
      this._wordMark &&
        this._wordMark.setAnimationConfig(
          w1(
            x1.wordCloud3d(() => {
              var t, e, i, n, s;
              const r = this.getCompiler().getVGrammarView(),
                a =
                  r.width() - (null === (t = this._padding) || void 0 === t ? void 0 : t.left) ||
                  0 - (null === (e = this._padding) || void 0 === e ? void 0 : e.right) ||
                  0,
                o =
                  r.height() - (null === (i = this._padding) || void 0 === i ? void 0 : i.top) ||
                  0 - (null === (n = this._padding) || void 0 === n ? void 0 : n.bottom) ||
                  0,
                l = Math.max(a, o) / 2;
              return { center: { x: l, y: l, z: null !== (s = this._spec.depth_3d) && void 0 !== s ? s : l }, r: l };
            }),
            A1(LZ.word, this._spec)
          )
        ),
        this._fillingWordMark &&
          this._fillingWordMark.setAnimationConfig(
            w1(
              x1.wordCloud3d(() => {
                var t, e, i, n, s;
                const r = this.getCompiler().getVGrammarView(),
                  a =
                    r.width() - (null === (t = this._padding) || void 0 === t ? void 0 : t.left) ||
                    0 - (null === (e = this._padding) || void 0 === e ? void 0 : e.right) ||
                    0,
                  o =
                    r.height() - (null === (i = this._padding) || void 0 === i ? void 0 : i.top) ||
                    0 - (null === (n = this._padding) || void 0 === n ? void 0 : n.bottom) ||
                    0,
                  l = Math.max(a, o) / 2;
                return { center: { x: l, y: l, z: null !== (s = this._spec.depth_3d) && void 0 !== s ? s : l }, r: l };
              }),
              A1(LZ.fillingWord, this._spec)
            )
          );
    }
  }
  (a6.type = DZ.wordCloud3d), NQ.useSeries([a6]);
  class o6 extends t8 {
    constructor() {
      super(...arguments), (this.type = d2.wordCloud3d), (this.seriesType = DZ.wordCloud3d);
    }
    _getDefaultSeriesSpec(t) {
      const e = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(t)), {
          nameField: t.nameField,
          valueField: t.valueField,
          seriesField: t.seriesField,
          fontFamilyField: t.fontFamilyField,
          fontWeightField: t.fontWeightField,
          fontStyleField: t.fontStyleField,
          colorHexField: t.colorHexField,
          colorMode: t.colorMode,
          colorList: t.colorList,
          rotateAngles: t.rotateAngles,
          fontWeightRange: t.fontWeightRange,
          fontSizeRange: t.fontSizeRange,
          depth_3d: t.depth_3d,
          maskShape: t.maskShape,
          keepAspect: t.keepAspect,
          random: t.random,
          wordCloudConfig: t.wordCloudConfig,
          wordCloudShapeConfig: t.wordCloudShapeConfig,
          word: t.word,
          fillingWord: t.fillingWord
        }),
        i = this.seriesType;
      return i && ((e.type = i), (e[i] = t[i])), e;
    }
  }
  (o6.type = d2.wordCloud3d), (o6.view = 'singleDefault');
  class l6 {
    constructor(t) {
      (this.id = Ro()), (this.plugins = []), (this.component = t);
    }
    add(t) {
      if (!t || 0 === t.length) return null;
      const e = [];
      return (
        t.forEach(t => {
          this.plugins.find(e => e.id === t.id) ? So('不要重复添加相同的plugin') : (this.plugins.push(t), e.push(t));
        }),
        e
      );
    }
    load(t) {
      const e = this.add(t);
      e && e.length && this.activate(t);
    }
    activate(t) {
      t.length &&
        t.forEach(t => {
          t.init && t.init();
        });
    }
    get(t) {
      return this.plugins.find(e => e.id === t);
    }
    getAll() {
      return this.plugins.slice();
    }
    dispose(t) {
      const e = this.plugins.find(e => e.id === t);
      e && e.dispose && e.dispose(this);
    }
    disposeAll() {
      this.plugins.forEach(t => {
        t.dispose && t.dispose(this);
      });
    }
  }
  function h6(t, e) {
    const { x1: i, y1: n, x2: s, y2: r } = e,
      { x1: a, y1: o, x2: l, y2: h } = t.AABBBounds,
      { dx: c = 0, dy: d = 0 } = t.attribute;
    let u = 0,
      p = 0;
    a < i && (u = i - a),
      o < n && (p = n - o),
      l > s && (u = s - l),
      h > r && (p = r - h),
      u && t.setAttribute('dx', u + c),
      p && t.setAttribute('dy', p + d);
  }
  function c6(t, e, i, n) {
    let s = 0,
      r = t.length - 1;
    for (; s <= r; ) {
      const a = Math.floor((s + r) / 2),
        o = t[a];
      if (o[i] <= e && o[n || i] >= e) return o;
      o[i] > e ? (r = a - 1) : (s = a + 1);
    }
    return null;
  }
  function d6(t) {
    var e, i;
    const n = Object.assign({}, t);
    return (
      T(t.style) || (n.textStyle = GJ(t.style)),
      T(t.textStyle) || _J(n.textStyle, GJ(t.textStyle)),
      (null === (e = t.shape) || void 0 === e ? void 0 : e.style) && GJ(n.shape.style),
      (null === (i = t.background) || void 0 === i ? void 0 : i.style) && GJ(n.background.style),
      n
    );
  }
  function u6(t) {
    return 'bottom' === t.orient || 'top' === t.orient ? 'horizontal' : 'vertical';
  }
  function p6(t, e, i, n) {
    var s, r, a;
    switch (t) {
      case xn.cartesianBandAxis:
        return X3(nQ(i), 'band', e);
      case xn.cartesianLinearAxis:
        return X3(nQ(i), 'linear', e);
      case xn.cartesianLogAxis:
        return X3(nQ(i), 'log', e);
      case xn.cartesianSymlogAxis:
        return X3(nQ(i), 'symlog', e);
      case xn.cartesianAxis:
      case xn.cartesianTimeAxis:
        return X3(nQ(i), void 0, e);
      case xn.polarBandAxis:
        return K3(i.orient, 'band', e);
      case xn.polarLinearAxis:
        return K3(i.orient, 'linear', e);
      case xn.polarAxis:
        return K3(i.orient, void 0, e);
      case xn.cartesianCrosshair:
        return ((t, e) => {
          var i;
          const n = e.getAllComponents().filter(t => t.type.includes('Axis')),
            {
              bandField: s,
              linearField: r,
              xField: a,
              yField: o
            } = null !== (i = t.component.crosshair) && void 0 !== i ? i : {},
            l = n.find(t => tQ(t.getOrient()));
          let c;
          c = h(l) ? _J({}, Qo(l.getScale().type) ? s : r, a) : a;
          const d = n.find(t => eQ(t.getOrient()));
          let u;
          return (u = h(d) ? _J({}, Qo(d.getScale().type) ? s : r, o) : o), { xField: c, yField: u };
        })(e, n);
      case xn.polarCrosshair:
        return ((t, e) => {
          var i;
          const n = e.getAllComponents().filter(t => t.type.includes('Axis')),
            {
              bandField: s,
              linearField: r,
              categoryField: a,
              valueField: o
            } = null !== (i = t.component.crosshair) && void 0 !== i ? i : {},
            l = n.find(t => 'angle' === t.getOrient());
          let c;
          c = h(l) ? _J({}, Qo(l.getScale().type) ? s : r, a) : a;
          const d = n.find(t => 'radius' === t.getOrient());
          let u;
          return (u = h(d) ? _J({}, Qo(d.getScale().type) ? s : r, o) : o), { categoryField: c, valueField: u };
        })(e, n);
      case xn.colorLegend:
        return null === (s = e.component) || void 0 === s ? void 0 : s.colorLegend[u6(i)];
      case xn.sizeLegend:
        return null === (r = e.component) || void 0 === r ? void 0 : r.sizeLegend[u6(i)];
      default:
        return null === (a = e.component) || void 0 === a ? void 0 : a[t];
    }
  }
  class g6 extends ZQ {
    getRegions() {
      return this._regions;
    }
    created() {
      super.created(), (this.pluginService = new l6(this));
    }
    constructor(t, e) {
      super(t, e),
        (this.name = 'component'),
        (this.modelType = 'component'),
        (this._regions = []),
        (this._delegateEvent = (t, e, i, n = null, s = null) => {
          var r, a;
          this.event.emit(
            i,
            {
              model: this,
              node: t,
              event: e,
              item: n,
              datum: s,
              source: Uq.chart,
              chart:
                null === (a = null === (r = this._option) || void 0 === r ? void 0 : r.globalInstance) || void 0 === a
                  ? void 0
                  : a.getChart()
            },
            'model'
          );
        }),
        (this._regions = e.getRegionsInIndex()),
        (this.layoutBindRegionID = this._regions.map(t => t.id)),
        this._option.animation && (this.animate = new r0({ getCompiler: e.getCompiler }));
    }
    callPlugin(t) {
      this.pluginService && this.pluginService.getAll().forEach(e => t(e));
    }
    eventPos(t) {
      return { x: t.event.viewX - this.getLayoutStartPoint().x, y: t.event.viewY - this.getLayoutStartPoint().y };
    }
    setCurrentTheme(t, e) {
      return yn(this, void 0, void 0, function* () {
        const i = () => (this.reInit(t), { change: !0, reMake: !1 });
        e ? i() : yield this._option.globalInstance.updateCustomConfigAndRerender(i);
      });
    }
    _initTheme(t) {
      const e = this._option.getTheme();
      t ? super._initTheme(t) : super._initTheme(p6(this.type, e, this._originalSpec, this._option.getChart())),
        this._mergeThemeToSpec();
      const { padding: i, noOuterPadding: n = !0, orient: s } = this._spec;
      n && i && s && (this._spec.padding = Object.assign(Object.assign({}, _V(i)), { [s]: 0 }));
    }
    getContainer() {
      return (
        this._container || (this._container = this._option.globalInstance.getStage().find(t => 'root' === t.name, !0)),
        this._container
      );
    }
    updateSpec(t) {
      const e = this._originalSpec,
        i = super.updateSpec(t);
      return (
        i.reMake ||
          (i.reMake = ['seriesId', 'seriesIndex', 'regionId', 'regionIndex'].some(
            i => JSON.stringify(e[i]) !== JSON.stringify(t[i])
          )),
        e.visible !== t.visible && (i.reCompile = !0),
        i
      );
    }
    release() {
      super.release(), this.clear();
    }
    clear() {
      var t;
      (this._container = null),
        null === (t = this.pluginService) || void 0 === t || t.disposeAll(),
        (this.pluginService = null);
    }
    compile() {
      this.compileSignal(), this.compileMarks();
    }
    compileMarks(t) {
      this.getMarks().forEach(e => {
        var i;
        e.compile({ group: t }),
          null === (i = e.getProduct()) || void 0 === i || i.configure({ context: { model: this } });
      });
    }
  }
  const f6 = (t, e) => {
      const { getNewDomain: i, isContinuous: n, field: s } = e,
        r = s(),
        a = i();
      if (l(a) || l(r)) return t;
      if (0 === a.length) return [];
      let o = null;
      return (
        (o = n() ? t => t[r] >= a[0] && t[r] <= a[1] : t => a.indexOf(t[r] + '') >= 0 || a.indexOf(t[r]) >= 0),
        t.filter(o)
      );
    },
    v6 = (t, e) => {
      const { stateFields: i, valueFields: n, dataCollection: s } = e.input,
        { stateField: r, valueField: a } = e.output,
        o = {},
        h = [];
      return (
        s.forEach((t, e) => {
          l(i[e]) ||
            t.latestData.forEach(t => {
              V(i[e]).forEach(i => {
                l(t[i]) ||
                  (l(o[t[i]]) && (o[t[i]] = 0),
                  l(n[e]) || (o[t[i]] += isNaN(parseFloat(t[n[e]])) ? 1 : parseFloat(t[n[e]])));
              });
            });
        }),
        Object.keys(o).forEach((t, e) => {
          const i = { [r]: t };
          a && (i[a] = o[t]), h.push(i);
        }),
        h
      );
    };
  class m6 extends g6 {
    get orient() {
      return this._orient;
    }
    get layoutOrient() {
      return this._orient;
    }
    set layoutOrient(t) {
      this._orient = t;
    }
    setStartAndEnd(t, e) {
      this._handleChange(t, e, !0);
    }
    get visible() {
      return this._visible;
    }
    constructor(t, e) {
      var i;
      super(t, Object.assign({}, e)),
        (this.layoutType = 'region-relative'),
        (this._orient = 'left'),
        (this._stateField = 'x'),
        (this.effect = {
          onZoomChange: () => {
            var t;
            if (this._relatedAxisComponent && 'axis' === this._filterMode) {
              const e = this._relatedAxisComponent.getScale();
              this._auto && e.range(null === (t = this._stateScale) || void 0 === t ? void 0 : t.range(), !0),
                e.rangeFactor([this._start, this._end]),
                this._relatedAxisComponent.effect.scaleUpdate();
            } else
              tV(
                this._regions,
                t => {
                  var e;
                  null === (e = t.getViewDataFilter()) || void 0 === e || e.markRunning();
                },
                { userId: this._seriesUserId, specIndex: this._seriesIndex }
              ),
                tV(
                  this._regions,
                  t => {
                    t.reFilterViewData();
                  },
                  { userId: this._seriesUserId, specIndex: this._seriesIndex }
                );
          }
        }),
        (this._visible = !0),
        (this._handleStateChange = (t, e) => {
          var i, n;
          return (
            (this._startValue = t),
            (this._endValue = e),
            (this._newDomain = this._parseDomainFromState(this._startValue, this._endValue)),
            null === (n = (i = this.effect).onZoomChange) || void 0 === n || n.call(i),
            !0
          );
        }),
        (this._handleChartScroll = (t, e) => {
          this._handleChartDrag([t.scrollX, t.scrollY], e);
        }),
        (this._handleChartZoom = (t, e) => {
          const { zoomDelta: i } = t,
            n = Math.abs(this._start - this._end);
          if (n >= 1 && i > 1) return;
          if (n <= 0.01 && i < 1) return;
          const s = (n * (i - 1)) / 2,
            r = pt(this._start - s, 0, 1),
            a = pt(this._end + s, 0, 1);
          this._handleChange(Math.min(r, a), Math.max(r, a), !0);
        }),
        (this._handleChartDrag = (t, e) => {
          const [i, n] = t,
            s = this._isHorizontal ? i : n,
            r = this._isHorizontal ? this.getLayoutRect().width : this.getLayoutRect().height;
          if (Math.abs(s) >= 1e-6)
            if (s > 0 && this._end < 1) {
              const t = 0.02 * Math.min(1 - this._end, s / r);
              this._handleChange(this._start + t, this._end + t, !0);
            } else if (s < 0 && this._start > 0) {
              const t = 0.02 * Math.max(-this._start, s / r);
              this._handleChange(this._start + t, this._end + t, !0);
            }
        }),
        (this._orient = nQ(t)),
        (this._layoutOrient = this._orient),
        (this._isHorizontal =
          ('top' === (i = this._layoutOrient) || 'bottom' === i ? JJ.horizontal : JJ.vertical) === JJ.horizontal),
        h(t.autoIndent) && (this._autoIndent = t.autoIndent);
    }
    created() {
      super.created(),
        this._setAxisFromSpec(),
        this._setRegionsFromSpec(),
        this._initData(),
        this._initStateScale(),
        this._setStateFromSpec();
    }
    _setAxisFromSpec() {
      if (
        (h(this._spec.axisId)
          ? (this._relatedAxisComponent = this._option.getComponentByUserId(this._spec.axisId))
          : h(this._spec.axisIndex) &&
            (this._relatedAxisComponent = this._option.getComponentByIndex('axes', this._spec.axisIndex)),
        l(this._spec.field) && !this._relatedAxisComponent)
      ) {
        const t = this._option.getComponentsByKey('axes'),
          e = t.find(t => t._orient === this._orient);
        if (e) this._relatedAxisComponent = e;
        else {
          const e = t.find(t => !Zo(t.getScale().type));
          this._relatedAxisComponent = e;
        }
      }
    }
    _setRegionsFromSpec() {
      var t, e;
      this._regions = this._relatedAxisComponent
        ? this._relatedAxisComponent.getRegions()
        : this._option.getAllRegions();
      const i = this._relatedAxisComponent
        ? null === (e = (t = this._relatedAxisComponent).getBindSeriesFilter) || void 0 === e
          ? void 0
          : e.call(t)
        : null;
      if (
        (h(i) &&
          (h(i.userId) && (this._seriesUserId = V(i.userId)), h(i.specIndex) && (this._seriesIndex = V(i.specIndex))),
        h(this._spec.seriesId))
      ) {
        const t = V(this._spec.seriesId);
        this._seriesUserId
          ? (this._seriesUserId = this._seriesUserId.filter(e => t.includes(e)))
          : (this._seriesUserId = t);
      }
      if (h(this._spec.seriesIndex)) {
        const t = V(this._spec.seriesIndex);
        this._seriesIndex
          ? (this._seriesIndex = this._seriesIndex.filter(e => t.includes(e)))
          : (this._seriesIndex = t);
      }
      if (h(this._spec.regionIndex)) {
        const t = this._option.getRegionsInIndex(V(this._spec.regionIndex));
        this._regions = this._regions.filter(e => t.includes(e));
      } else if (h(this._spec.regionId)) {
        const t = V(this._spec.regionId);
        this._regions = t.length ? this._regions.filter(e => t.includes(e.id)) : [];
      } else;
    }
    onDataUpdate() {
      const t = this._computeDomainOfStateScale(Zo(this._stateScale.type));
      this._stateScale.domain(t, !0), this._handleChange(this._start, this._end, !0);
    }
    _computeDomainOfStateScale(t) {
      const e = this._data.getLatestData().map(t => t[this._stateField]);
      return t ? (e.length ? [Math.min.apply(null, e), Math.max.apply(null, e)] : [-1 / 0, 1 / 0]) : e;
    }
    _initData() {
      const t = [],
        e = [],
        i = [];
      if (this._relatedAxisComponent) {
        const n = {};
        tV(
          this._regions,
          s => {
            var r, a;
            const o =
                'cartesian' === s.coordinate ? s.getXAxisHelper() : 'polar' === s.coordinate ? s.angleAxisHelper : null,
              l =
                'cartesian' === s.coordinate
                  ? s.getYAxisHelper()
                  : 'polar' === s.coordinate
                  ? s.radiusAxisHelper
                  : null;
            if (!o || !l) return;
            const h =
                o.getAxisId() === this._relatedAxisComponent.id
                  ? o
                  : l.getAxisId() === this._relatedAxisComponent.id
                  ? l
                  : this._isHorizontal
                  ? o
                  : l,
              c = h === o ? l : o,
              d = Zo(c.getScale(0).type);
            t.push(s.getRawData());
            const u = s.getSpec(),
              p = V(u.xField),
              g = V(u.yField),
              f =
                'cartesian' === s.coordinate ? p[0] : null !== (r = u.angleField) && void 0 !== r ? r : u.categoryField,
              v = 'cartesian' === s.coordinate ? g[0] : null !== (a = u.radiusField) && void 0 !== a ? a : u.valueField;
            if (((n[s.id] = 'link' === s.type ? 'from_xField' : h === o ? f : v), e.push(n[s.id]), this._valueField)) {
              const t = 'link' === s.type ? 'from_yField' : c === o ? f : v;
              i.push(d ? t : null);
            }
          },
          { userId: this._seriesUserId, specIndex: this._seriesIndex }
        ),
          (this._originalStateFields = n);
      } else
        l(this._spec.valueField),
          tV(
            this._regions,
            n => {
              t.push(n.getRawData()), e.push(this._field), this._valueField && i.push(this._spec.valueField);
            },
            { userId: this._seriesUserId, specIndex: this._seriesIndex }
          );
      const { dataSet: n } = this._option;
      SQ(n, 'dataview', po), xQ(n, 'dataFilterComputeDomain', v6);
      const s = new yo(n);
      s.transform(
        {
          type: 'dataFilterComputeDomain',
          options: {
            input: { dataCollection: t, stateFields: e, valueFields: i },
            output: { stateField: this._stateField, valueField: this._valueField }
          }
        },
        !1
      ),
        (this._data = new d0(this._option, s)),
        s.reRunAllTransform(),
        n.multipleDataViewAddListener(t, 'change', this._handleDataCollectionChange.bind(this));
    }
    setAttrFromSpec() {
      var t;
      super.setAttrFromSpec(),
        this._spec.roam && this.initZoomable(this.event, this._option.mode),
        (this._field = this._spec.field),
        (this._width = this._computeWidth()),
        (this._height = this._computeHeight()),
        (this._visible = null === (t = this._spec.visible) || void 0 === t || t);
    }
    _statePointToData(t) {
      const e = this._stateScale;
      let i = e.range();
      !this._isHorizontal && Zo(e.type) && (i = i.slice().reverse());
      const n = i[0] + (i[1] - i[0]) * t;
      return e.invert(n);
    }
    _dataToStatePoint(t) {
      const e = this._stateScale,
        i = e.scale(t);
      let n = e.range();
      return !this._isHorizontal && Zo(e.type) && (n = n.slice().reverse()), (i - n[0]) / (n[1] - n[0]);
    }
    _modeCheck(t, e) {
      return 'start' === t
        ? ('percent' === e && this._spec.start) || ('value' === e && this._spec.startValue)
        : ('percent' === e && this._spec.end) || ('value' === e && this._spec.endValue);
    }
    _setStateFromSpec() {
      let t, e;
      if (((this._auto = !!this._spec.auto), this._spec.rangeMode)) {
        const [i, n] = this._spec.rangeMode;
        this._modeCheck('start', i) &&
          this._modeCheck('end', n) &&
          ((t = 'percent' === i ? this._spec.start : this._dataToStatePoint(this._spec.startValue)),
          (e = 'percent' === n ? this._spec.end : this._dataToStatePoint(this._spec.endValue)));
      } else (t = this._spec.start ? this._spec.start : this._spec.startValue ? this._dataToStatePoint(this._spec.startValue) : 0), (e = this._spec.end ? this._spec.end : this._spec.endValue ? this._dataToStatePoint(this._spec.endValue) : 1);
      (this._startValue = this._statePointToData(t)),
        (this._endValue = this._statePointToData(e)),
        (this._start = t),
        (this._end = e),
        (this._relatedAxisComponent && 'axis' === this._filterMode) ||
          (0 === this._start && 1 === this._end) ||
          (this._newDomain = this._parseDomainFromState(this._startValue, this._endValue));
    }
    _parseFieldOfSeries(t) {
      var e;
      return null === (e = this._originalStateFields) || void 0 === e ? void 0 : e[t.id];
    }
    _initStateScale() {
      const t = [0, 1];
      if (this._relatedAxisComponent) {
        const e = this._relatedAxisComponent.getScale(),
          i = Zo(e.type),
          n = this._computeDomainOfStateScale(i);
        (this._stateScale = e.clone()),
          i
            ? this._stateScale
                .domain(n.length ? [Math.min.apply(null, n), Math.max.apply(null, n)] : [0, 1], !0)
                .range(t)
            : this._stateScale.domain(n, !0).range(t);
      } else (this._stateScale = new xl()), this._stateScale.domain(this._computeDomainOfStateScale(), !0).range(t);
    }
    init(t) {
      super.init(t), this._addTransformToSeries(), (0 === this._start && 1 === this._end) || this.effect.onZoomChange();
    }
    _addTransformToSeries() {
      (this._relatedAxisComponent && 'axis' === this._filterMode) ||
        (xQ(this._option.dataSet, 'dataFilterWithNewDomain', f6),
        tV(
          this._regions,
          t => {
            t.addViewDataFilter({
              type: 'dataFilterWithNewDomain',
              options: {
                getNewDomain: () => this._newDomain,
                field: () => {
                  var e;
                  return null !== (e = this._field) && void 0 !== e ? e : this._parseFieldOfSeries(t);
                },
                isContinuous: () => Zo(this._stateScale.type)
              }
            });
          },
          { userId: this._seriesUserId, specIndex: this._seriesIndex }
        ));
    }
    onRender(t) {}
    updateSpec(t) {
      const e = super.updateSpec(t);
      return (e.reRender = !0), (e.reMake = !0), e;
    }
    reInit(t) {
      super.reInit(t),
        this._marks.forEach(t => {
          t.getMarks().forEach(t => {
            this.initMarkStyleWithSpec(t, this._spec[t.name]);
          });
        });
    }
    changeRegions() {}
    update(t) {}
    resize(t) {}
    _parseDomainFromState(t, e) {
      if (Zo(this._stateScale.type)) return [Math.min(e, t), Math.max(e, t)];
      const i = this._stateScale.domain(),
        n = i.indexOf(t),
        s = i.indexOf(e);
      return i.slice(Math.min(n, s), Math.max(n, s) + 1);
    }
    _initCommonEvent() {
      this._spec.roam &&
        (this.initZoomEventOfRegions(this._regions, null, this._handleChartZoom),
        this.initScrollEventOfRegions(this._regions, null, this._handleChartScroll),
        this.initDragEventOfRegions(this._regions, null, this._handleChartDrag));
    }
    updateLayoutAttribute() {
      this._visible && this._createOrUpdateComponent(),
        this._initCommonEvent(),
        this._initEvent(),
        super.updateLayoutAttribute();
    }
    _boundsInRect(t) {
      if (!this._autoUpdate(t)) return { x1: 0, y1: 0, x2: 0, y2: 0 };
      const e = { x1: this.getLayoutStartPoint().x, y1: this.getLayoutStartPoint().y, x2: 0, y2: 0 };
      return (
        this._isHorizontal
          ? ((e.y2 = e.y1 + this._height), (e.x2 = e.x1 + t.width))
          : ((e.x2 = e.x1 + this._width), (e.y2 = e.y1 + t.height)),
        e
      );
    }
    hide() {
      var t;
      null === (t = this._component) || void 0 === t || t.hideAll();
    }
    show() {
      var t;
      null === (t = this._component) || void 0 === t || t.showAll();
    }
    _autoUpdate(t) {
      var e, i, n;
      if (!this._auto) return !0;
      const s = null === (e = this._relatedAxisComponent) || void 0 === e ? void 0 : e.getSpec(),
        r = null == s ? void 0 : s.bandSize,
        a = null == s ? void 0 : s.maxBandSize,
        o = null == s ? void 0 : s.minBandSize;
      if (
        (null == t ? void 0 : t.height) === (null === (i = this._cacheRect) || void 0 === i ? void 0 : i.height) &&
        (null == t ? void 0 : t.width) === (null === (n = this._cacheRect) || void 0 === n ? void 0 : n.width) &&
        this._fixedBandSize === r
      )
        return this._cacheVisibility;
      this._cacheRect = t;
      let l = !0;
      const h = this._stateScale;
      if (
        (h.range(this._isHorizontal ? [0, t.width] : s.inverse ? [0, t.height] : [t.height, 0]),
        Qo(h.type) && (r || o || a))
      ) {
        (this._start || this._end) && h.rangeFactor([this._start, this._end], !0),
          r && h.bandwidth(r, !0),
          a && h.maxBandwidth(a, !0),
          o && h.minBandwidth(o, !0),
          h.rescale(!1);
        let [t, e] = h.rangeFactor();
        (t || e) && h.isBandwidthFixed()
          ? 0 === t && 1 === e
            ? (this.hide(), (l = !1))
            : this.show()
          : ((t = 0), (e = 1), this.hide(), (l = !1)),
          (this._start = t),
          (this._end = e);
      }
      return this.setStartAndEnd(this._start, this._end), (this._cacheVisibility = l), l;
    }
  }
  N(m6, z4);
  class y6 extends m6 {
    static createComponent(t, e) {
      const i = t.scrollBar || e.defaultSpec;
      if (l(i)) return;
      if (!f(i)) return new y6(i, Object.assign(Object.assign({}, e), { specKey: 'scrollBar' }));
      const n = [];
      return (
        i.forEach((t, i) => {
          n.push(new y6(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: 'scrollBar' })));
        }),
        n
      );
    }
    constructor(t, e) {
      var i;
      super(t, Object.assign({}, e)),
        (this.type = xn.scrollBar),
        (this.name = xn.scrollBar),
        (this.layoutZIndex = cZ.DataZoom),
        (this.layoutLevel = dZ.DataZoom),
        (this._filterMode = null !== (i = t.filterMode) && void 0 !== i ? i : 'axis');
    }
    onLayoutEnd(t) {
      this._updateScaleRange(), super.onLayoutEnd(t);
    }
    _updateScaleRange() {
      this._component &&
        this._component.setAttributes({
          x: this.getLayoutStartPoint().x,
          y: this.getLayoutStartPoint().y,
          width: this.getLayoutRect().width,
          height: this.getLayoutRect().height
        });
    }
    _computeWidth() {
      return y(this._spec.width) ? this._spec.width : this._isHorizontal ? this.getLayoutRect().width : 12;
    }
    _computeHeight() {
      return y(this._spec.height) ? this._spec.height : this._isHorizontal ? 12 : this.getLayoutRect().height;
    }
    _createOrUpdateComponent() {
      if (!this._component) {
        const t = this.getContainer();
        (this._component = new pY(
          Object.assign(
            {
              zIndex: this.layoutZIndex,
              x: this.getLayoutStartPoint().x,
              y: this.getLayoutStartPoint().y,
              width: this.getLayoutRect().width,
              height: this.getLayoutRect().height,
              range: [this._start, this._end],
              direction: this._isHorizontal ? 'horizontal' : 'vertical'
            },
            this._getComponentAttrs()
          )
        )),
          t.add(this._component);
      }
    }
    _handleChange(t, e, i) {
      i && this._component && this._component.setAttribute('range', [t, e]), (this._start = t), (this._end = e);
      this._handleStateChange(this._statePointToData(t), this._statePointToData(e)) &&
        this.event.emit(Gq.scrollBarChange, {
          model: this,
          value: {
            filterData: 'axis' !== this._filterMode,
            start: this._start,
            end: this._end,
            startValue: this._startValue,
            endValue: this._endValue,
            newDomain: this._newDomain
          }
        });
    }
    _handleDataCollectionChange() {}
    _initEvent() {
      this._component &&
        this._component.on('scroll', t => {
          const e = t.detail.value;
          this._handleChange(e[0], e[1]);
        });
    }
    _initCommonEvent() {
      this._spec.roam &&
        (this.initScrollEventOfRegions(this._regions, null, this._handleChartScroll),
        this.initDragEventOfRegions(this._regions, null, this._handleChartDrag));
    }
    _getComponentAttrs() {
      const { rail: t, slider: e, innerPadding: i } = this._spec,
        n = {};
      return (
        l(i) || (n.padding = i),
        T(null == t ? void 0 : t.style) || (n.railStyle = GJ(t.style)),
        T(null == e ? void 0 : e.style) || (n.sliderStyle = GJ(e.style)),
        n
      );
    }
  }
  y6.type = xn.scrollBar;
  class _6 extends m6 {
    static createComponent(t, e) {
      const i = t.dataZoom || e.defaultSpec;
      if (l(i)) return;
      if (!f(i)) return new _6(i, Object.assign(Object.assign({}, e), { specKey: 'dataZoom' }));
      const n = [];
      return (
        i.forEach((t, i) => {
          n.push(new _6(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: 'dataZoom' })));
        }),
        n
      );
    }
    constructor(t, e) {
      var i;
      super(t, Object.assign({}, e)),
        (this.type = xn.dataZoom),
        (this.name = xn.dataZoom),
        (this.layoutZIndex = cZ.DataZoom),
        (this.layoutLevel = dZ.DataZoom),
        (this._dataToPositionX = t => {
          const e = 'left' === this._orient ? this._middleHandlerSize : 0,
            i = this._isHorizontal ? this._startHandlerSize / 2 : 0,
            n = this._isHorizontal ? this._stateScale : this._valueScale,
            s = this._isHorizontal ? this._stateField : this._valueField;
          return n.scale(t[s]) + this.getLayoutStartPoint().x + e + i;
        }),
        (this._dataToPositionX2 = t => {
          const e = 'left' === this._orient ? this._middleHandlerSize : 0,
            i = this._isHorizontal ? this._startHandlerSize / 2 : 0,
            n = this._isHorizontal ? this._stateScale : this._valueScale,
            s = n.domain()[0];
          return n.scale(s) + this.getLayoutStartPoint().x + e + i;
        }),
        (this._dataToPositionY = t => {
          const e = this._isHorizontal ? this._middleHandlerSize : 0,
            i = this._isHorizontal ? 0 : this._startHandlerSize / 2,
            n = this._isHorizontal ? this._valueScale : this._stateScale,
            s = this._isHorizontal ? this._valueField : this._stateField;
          return n.scale(t[s]) + this.getLayoutStartPoint().y + e + i;
        }),
        (this._dataToPositionY2 = t => {
          const e = this._isHorizontal ? this._middleHandlerSize : 0,
            i = this._isHorizontal ? 0 : this._startHandlerSize / 2,
            n = this._isHorizontal ? this._valueScale : this._stateScale,
            s = n.domain()[0];
          return n.scale(s) + this.getLayoutStartPoint().y + e + i;
        }),
        (this._valueField = 'y'),
        (this._filterMode = null !== (i = t.filterMode) && void 0 !== i ? i : 'filter');
    }
    created() {
      super.created(), this._initValueScale();
    }
    setAttrFromSpec() {
      var t, e, i, n, s, r, a, o, h, c;
      super.setAttrFromSpec(),
        (this._backgroundSize =
          null !== (e = null === (t = this._spec.background) || void 0 === t ? void 0 : t.size) && void 0 !== e
            ? e
            : 30),
        (this._middleHandlerSize = this._computeMiddleHandlerSize()),
        (this._width = this._computeWidth()),
        (this._height = this._computeHeight()),
        l(
          null ===
            (s =
              null === (n = null === (i = this._originalSpec) || void 0 === i ? void 0 : i.startHandler) || void 0 === n
                ? void 0
                : n.style) || void 0 === s
            ? void 0
            : s.size
        ) &&
          (this._spec.startHandler.style.size = this._isHorizontal
            ? this._height - this._middleHandlerSize
            : this._width - this._middleHandlerSize),
        l(
          null ===
            (o =
              null === (a = null === (r = this._originalSpec) || void 0 === r ? void 0 : r.startHandler) || void 0 === a
                ? void 0
                : a.style) || void 0 === o
            ? void 0
            : o.size
        ) &&
          (this._spec.endHandler.style.size = this._isHorizontal
            ? this._height - this._middleHandlerSize
            : this._width - this._middleHandlerSize);
      const d = null === (h = this._spec.startHandler.style.visible) || void 0 === h || h,
        u = null === (c = this._spec.endHandler.style.visible) || void 0 === c || c;
      (this._startHandlerSize = d ? this._spec.startHandler.style.size : 0),
        (this._endHandlerSize = u ? this._spec.endHandler.style.size : 0);
    }
    _prepareSpecBeforeMergingTheme(t) {
      const e = Object.assign({}, t),
        { selectedBackgroundChart: i = {} } = e,
        { line: n, area: s } = i;
      return (
        (n || s) &&
          (e.selectedBackgroundChart = Object.assign(Object.assign({}, i), {
            line:
              n && !1 !== n.visible
                ? Object.assign(Object.assign({}, n), {
                    style: Object.assign(Object.assign({}, n.style), { visible: !0 })
                  })
                : n,
            area:
              s && !1 !== s.visible
                ? Object.assign(Object.assign({}, s), {
                    style: Object.assign(Object.assign({}, s.style), { visible: !0 })
                  })
                : s
          })),
        e
      );
    }
    onLayoutEnd(t) {
      this._updateScaleRange(), super.onLayoutEnd(t);
    }
    _initValueScale() {
      const t = this._computeDomainOfValueScale();
      if (t) {
        const e = new Vl();
        e.domain(t), (this._valueScale = e);
      }
    }
    _updateScaleRange() {
      const t = (this._startHandlerSize + this._endHandlerSize) / 2;
      this._stateScale &&
        this._valueScale &&
        (this._isHorizontal
          ? (this._stateScale.range([0, this._computeWidth() - t]),
            this._valueScale.range([this._computeHeight() - this._middleHandlerSize, 0]))
          : 'left' === this.layoutOrient
          ? (this._stateScale.range([0, this._computeHeight() - t]),
            this._valueScale.range([this._computeWidth() - this._middleHandlerSize, 0]))
          : (this._stateScale.range([0, this._computeHeight() - t]),
            this._valueScale.range([0, this._computeWidth() - this._middleHandlerSize])),
        this._component &&
          this._component.setAttributes({ size: { width: this._computeWidth(), height: this._computeHeight() } }));
    }
    _computeDomainOfValueScale() {
      const t = this._data.getLatestData().map(t => t[this._valueField]);
      return t.length ? [Math.min.apply(null, t), Math.max.apply(null, t)] : null;
    }
    _computeMiddleHandlerSize() {
      var t, e, i, n;
      let s = 0;
      if (
        null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.middleHandler) || void 0 === e
          ? void 0
          : e.visible
      ) {
        const t = null !== (i = this._spec.middleHandler.icon.style.size) && void 0 !== i ? i : 8,
          e = null !== (n = this._spec.middleHandler.background.size) && void 0 !== n ? n : 40;
        s += Math.max(t, e);
      }
      return s;
    }
    _computeWidth() {
      return !1 === this._visible
        ? 0
        : y(this._spec.width)
        ? this._spec.width
        : this._isHorizontal
        ? this.getLayoutRect().width
        : this._backgroundSize + this._middleHandlerSize;
    }
    _computeHeight() {
      return !1 === this._visible
        ? 0
        : y(this._spec.height)
        ? this._spec.height
        : this._isHorizontal
        ? this._backgroundSize + this._middleHandlerSize
        : this.getLayoutRect().height - (this._startHandlerSize + this._endHandlerSize) / 2;
    }
    _createOrUpdateComponent() {
      var t, e, i;
      if (!this._component && this._visible) {
        const n = this.getContainer();
        (this._component = new iX(
          Object.assign(
            {
              zIndex: this.layoutZIndex,
              start: this._start,
              end: this._end,
              position: { x: this.getLayoutStartPoint().x, y: this.getLayoutStartPoint().y },
              orient: this._orient,
              size: { width: this.getLayoutRect().width, height: this.getLayoutRect().height },
              showDetail: null === (t = this._spec) || void 0 === t ? void 0 : t.showDetail,
              brushSelect:
                null !== (i = null === (e = this._spec) || void 0 === e ? void 0 : e.brushSelect) && void 0 !== i && i,
              previewData: this._data.getLatestData(),
              previewCallbackX: this._dataToPositionX,
              previewCallbackY: this._dataToPositionY
            },
            this._getComponentAttrs()
          )
        )),
          this._isHorizontal
            ? this._component.setPreviewCallbackY1(this._dataToPositionY2)
            : this._component.setPreviewCallbackX1(this._dataToPositionX2),
          this._component.setStatePointToData(t => this._statePointToData(t)),
          this._component.setUpdateStateCallback((t, e) => {
            this._handleChange(t, e);
          }),
          n.add(this._component),
          this._updateScaleRange();
      }
    }
    _handleChange(t, e, i) {
      i && this._component && this._component.setStartAndEnd(t, e), (this._start = t), (this._end = e);
      this._handleStateChange(this._statePointToData(t), this._statePointToData(e)) &&
        this.event.emit(Gq.dataZoomChange, {
          model: this,
          value: {
            filterData: 'axis' !== this._filterMode,
            start: t,
            end: e,
            startValue: this._startValue,
            endValue: this._endValue,
            newDomain: this._newDomain
          }
        });
    }
    _handleDataCollectionChange() {
      var t;
      const e = this._data.getDataView();
      if (
        (e.reRunAllTransform(),
        null === (t = this._component) || void 0 === t || t.setPreviewData(e.latestData),
        this._valueScale)
      ) {
        const t = this._computeDomainOfValueScale();
        t && this._valueScale.domain(t);
      }
    }
    _initEvent() {}
    _getComponentAttrs() {
      var t, e, i, n, s, r, a, o, l, h, c, d, u, p, g, f, v, m, y, _, b, x, S, w, A;
      return {
        backgroundStyle: GJ(null === (t = this._spec.background) || void 0 === t ? void 0 : t.style),
        startHandlerStyle: GJ(null === (e = this._spec.startHandler) || void 0 === e ? void 0 : e.style),
        middleHandlerStyle: {
          visible:
            null !== (n = null === (i = this._spec.middleHandler) || void 0 === i ? void 0 : i.visible) &&
            void 0 !== n &&
            n,
          icon: GJ(
            null === (r = null === (s = this._spec.middleHandler) || void 0 === s ? void 0 : s.icon) || void 0 === r
              ? void 0
              : r.style
          ),
          background: {
            size:
              null === (o = null === (a = this._spec.middleHandler) || void 0 === a ? void 0 : a.background) ||
              void 0 === o
                ? void 0
                : o.size,
            style: GJ(null === (l = this._spec.middleHandler.background) || void 0 === l ? void 0 : l.style)
          }
        },
        endHandlerStyle: GJ(null === (h = this._spec.endHandler) || void 0 === h ? void 0 : h.style),
        startTextStyle: {
          padding: null === (c = this._spec.startText) || void 0 === c ? void 0 : c.padding,
          formatMethod: null === (d = this._spec.startText) || void 0 === d ? void 0 : d.formatMethod,
          textStyle: GJ(null === (u = this._spec.startText) || void 0 === u ? void 0 : u.style)
        },
        endTextStyle: {
          padding: null === (p = this._spec.endText) || void 0 === p ? void 0 : p.padding,
          formatMethod: null === (g = this._spec.endText) || void 0 === g ? void 0 : g.formatMethod,
          textStyle: GJ(null === (f = this._spec.endText) || void 0 === f ? void 0 : f.style)
        },
        selectedBackgroundStyle: GJ(this._spec.selectedBackground.style),
        dragMaskStyle: GJ(null === (v = this._spec.dragMask) || void 0 === v ? void 0 : v.style),
        backgroundChartStyle: {
          line: _J(
            GJ(
              null === (y = null === (m = this._spec.backgroundChart) || void 0 === m ? void 0 : m.line) || void 0 === y
                ? void 0
                : y.style
            ),
            { fill: !1 }
          ),
          area: Object.assign(
            { curveType: 'basis', visible: !0 },
            GJ(
              null === (b = null === (_ = this._spec.backgroundChart) || void 0 === _ ? void 0 : _.area) || void 0 === b
                ? void 0
                : b.style
            )
          )
        },
        selectedBackgroundChartStyle: {
          line: _J(
            GJ(
              null === (S = null === (x = this._spec.selectedBackgroundChart) || void 0 === x ? void 0 : x.line) ||
                void 0 === S
                ? void 0
                : S.style
            ),
            { fill: !1 }
          ),
          area: Object.assign(
            { curveType: 'basis', visible: !0 },
            GJ(
              null === (A = null === (w = this._spec.selectedBackgroundChart) || void 0 === w ? void 0 : w.area) ||
                void 0 === A
                ? void 0
                : A.style
            )
          )
        }
      };
    }
    clear() {
      this._component && (this._container.removeChild(this._component), (this._component = null)), super.clear();
    }
  }
  _6.type = xn.dataZoom;
  class b6 extends g6 {
    constructor() {
      super(...arguments),
        (this.type = xn.customMark),
        (this.layoutType = 'absolute'),
        (this.layoutZIndex = cZ.CustomMark),
        (this.layoutLevel = dZ.CustomMark);
    }
    static createComponent(t, e) {
      return t.customMark
        ? [new b6(t.customMark, Object.assign(Object.assign({}, e), { specIndex: 0, specKey: 'customMark' }))]
        : null;
    }
    created() {
      super.created(), this.initMarks(), this.initEvent();
    }
    initMarks() {
      this._spec &&
        this._spec.forEach((t, e) => {
          this._createExtensionMark(t, null, `${UV}_series_${this.id}_extensionMark`, e);
        });
    }
    _createExtensionMark(t, e, i, n) {
      var s;
      const r = this._createMark({ type: t.type, name: `${UV}_${n}` });
      if (
        r &&
        (l(e) ? this._marks.addMark(r) : e && e.addMark(r),
        this.initMarkStyleWithSpec(r, t),
        'group' === t.type &&
          ((i = `${i}_${n}`),
          null === (s = t.children) ||
            void 0 === s ||
            s.forEach((t, e) => {
              this._createExtensionMark(t, r, i, e);
            })),
        h(t.dataId) || _(t.dataIndex))
      ) {
        const e = this.getChart().getSeriesData(t.dataId, t.dataIndex);
        e &&
          (e.target.addListener('change', () => {
            r.getData().updateData();
          }),
          r.setDataView(e));
      }
    }
    initEvent() {}
    updateSpec(t, e) {
      const i = this._originalSpec,
        n = super.updateSpec(e);
      return z(i, e) || (n.reMake = !0), (n.change = !0), (n.reRender = !0), n;
    }
    changeRegions(t) {}
    onRender(t) {}
  }
  b6.type = xn.customMark;
  class x6 extends g6 {
    constructor() {
      super(...arguments),
        (this.layoutType = 'absolute'),
        (this.type = xn.brush),
        (this.name = xn.brush),
        (this.layoutZIndex = cZ.Brush),
        (this._linkedSeries = []),
        (this._itemMap = {}),
        (this._linkedItemMap = {}),
        (this._inBrushElementsMap = {}),
        (this._outOfBrushElementsMap = {}),
        (this._linkedInBrushElementsMap = {}),
        (this._linkedOutOfBrushElementsMap = {}),
        (this._needInitOutState = !0),
        (this._isFirstState = !0),
        (this._cacheInteractiveRangeAttrs = []);
    }
    static createComponent(t, e) {
      const i = t.brush || e.defaultSpec;
      if (!l(i) && !1 !== i.visible) return [new x6(i, Object.assign(Object.assign({}, e), { specKey: x6.speckey }))];
    }
    created() {
      super.created(), this.initEvent(), this._bindRegions(), this._bindLinkedSeries(), this._initNeedOperatedItem();
    }
    _extendDataInBrush(t) {
      const e = [];
      for (const i in t) for (const n in t[i]) e.push(t[i][n].data[0]);
      return e;
    }
    _extendDatumOutOfBrush(t) {
      const e = [];
      for (const i in t) e.push(t[i].data[0]);
      return e;
    }
    _getBrushInteractiveAttr(t) {
      const e = t.getLayoutStartPoint().x,
        i = e + t.getLayoutRect().width,
        n = t.getLayoutStartPoint().y,
        s = n + t.getLayoutRect().height;
      return { interactiveRange: { minY: n, maxY: s, minX: e, maxX: i }, xRange: [e, i], yRange: [n, s] };
    }
    _updateBrushComponent(t, e) {
      const i = this._getBrushInteractiveAttr(t),
        n = this._brushComponents[e];
      n.setAttributes(i),
        this._initMarkBrushState(e, ''),
        n.children[0].removeAllChild(),
        (this._needInitOutState = !0);
    }
    _createBrushComponent(t, e) {
      var i, n;
      const s = this._getBrushInteractiveAttr(t),
        r = new iK(
          Object.assign(
            Object.assign(
              {
                zIndex: this.layoutZIndex,
                brushStyle: GJ(null === (i = this._spec) || void 0 === i ? void 0 : i.style)
              },
              s
            ),
            this._spec
          )
        );
      (r.id = null !== (n = this._spec.id) && void 0 !== n ? n : `brush-${this.id}`), this.getContainer().add(r);
      const { brushMode: a = 'single' } = this._spec;
      this._brushComponents.push(r),
        this._cacheInteractiveRangeAttrs.push(s),
        r.setUpdateDragMaskCallback(i => {
          const { operateType: n, operateMask: s } = i;
          (this._isFirstState || (this._needInitOutState && 'single' === a && n === ZX.drawing)) &&
            this._initMarkBrushState(e, 'outOfBrush'),
            n === ZX.drawing && (this._needInitOutState = !1),
            n === ZX.drawEnd && (this._needInitOutState = !0),
            n === ZX.brushClear && (this._initMarkBrushState(e, ''), (this._needInitOutState = !0)),
            this._reconfigItem(s, t),
            this._reconfigLinkedItem(s, t);
          let r = Gq.brushChange;
          (r =
            n === ZX.drawStart || n === ZX.moveStart
              ? Gq.brushStart
              : n === ZX.drawEnd || n === ZX.moveEnd
              ? Gq.brushEnd
              : Gq.brushChange),
            this.event.emit(r, {
              model: this,
              value: {
                operateType: n,
                operateRegion: t,
                inBrushData: this._extendDataInBrush(this._inBrushElementsMap),
                outOfBrushData: this._extendDatumOutOfBrush(this._outOfBrushElementsMap),
                linkInBrushData: this._extendDataInBrush(this._linkedInBrushElementsMap),
                linkOutOfBrushData: this._extendDatumOutOfBrush(this._linkedOutOfBrushElementsMap),
                inBrushElementsMap: this._inBrushElementsMap,
                outOfBrushElementsMap: this._outOfBrushElementsMap,
                linkedInBrushElementsMap: this._linkedInBrushElementsMap,
                linkedOutOfBrushElementsMap: this._linkedOutOfBrushElementsMap
              }
            });
        });
    }
    _transformBrushedMarkAttr(t) {
      const e = {};
      return (
        (null == t ? void 0 : t.symbol) && (e.symbolType = t.symbol),
        (null == t ? void 0 : t.symbolSize) && (e.size = t.symbolSize),
        (null == t ? void 0 : t.color) && (e.fill = t.color),
        (null == t ? void 0 : t.colorAlpha) && (e.fillOpacity = t.colorAlpha),
        Object.assign(Object.assign({}, GJ(t)), e)
      );
    }
    _reconfigItem(t, e) {
      this._itemMap[e.id].forEach(e => {
        const i = e.getProduct();
        if (!i || !i.elements || !i.elements.length) return;
        i.elements.forEach(i => {
          var n, s, r;
          const a = i.getGraphicItem(),
            o = e.id + '_' + i.key;
          (null === (n = this._outOfBrushElementsMap) || void 0 === n ? void 0 : n[o]) && this._isBrushContainItem(t, a)
            ? (a.addState('inBrush'),
              this._inBrushElementsMap[null == t ? void 0 : t.name] ||
                (this._inBrushElementsMap[null == t ? void 0 : t.name] = {}),
              (this._inBrushElementsMap[null == t ? void 0 : t.name][o] = i),
              delete this._outOfBrushElementsMap[o])
            : (null ===
                (r =
                  null === (s = this._inBrushElementsMap) || void 0 === s ? void 0 : s[null == t ? void 0 : t.name]) ||
              void 0 === r
                ? void 0
                : r[o]) &&
              !this._isBrushContainItem(t, a) &&
              (a.removeState('inBrush'),
              a.addState('outOfBrush'),
              (this._outOfBrushElementsMap[o] = i),
              delete this._inBrushElementsMap[t.name][o]);
        });
      });
    }
    _reconfigLinkedItem(t, e) {
      const i = e.getSeries().map(t => t.id);
      this._linkedSeries.forEach(n => {
        if (!i.includes(n.id)) {
          const i = n.getRegion().getLayoutStartPoint().x - e.getLayoutStartPoint().x,
            s = n.getRegion().getLayoutStartPoint().y - e.getLayoutStartPoint().y;
          this._linkedItemMap[n.id].forEach(e => {
            const n = e.getProduct();
            if (!n || !n.elements || !n.elements.length) return;
            n.elements.forEach(n => {
              var r, a, o;
              const l = n.getGraphicItem(),
                h = e.id + '_' + n.key;
              (null === (r = this._linkedOutOfBrushElementsMap) || void 0 === r ? void 0 : r[h]) &&
              this._isBrushContainItem(t, l, { dx: i, dy: s })
                ? (l.addState('inBrush'),
                  this._linkedInBrushElementsMap[null == t ? void 0 : t.name] ||
                    (this._linkedInBrushElementsMap[null == t ? void 0 : t.name] = {}),
                  (this._linkedInBrushElementsMap[null == t ? void 0 : t.name][h] = n),
                  delete this._linkedOutOfBrushElementsMap[h])
                : (null ===
                    (o =
                      null === (a = this._linkedInBrushElementsMap) || void 0 === a
                        ? void 0
                        : a[null == t ? void 0 : t.name]) || void 0 === o
                    ? void 0
                    : o[h]) &&
                  !this._isBrushContainItem(t, l, { dx: i, dy: s }) &&
                  (l.removeState('inBrush'), l.addState('outOfBrush'), (this._linkedOutOfBrushElementsMap[h] = n));
            });
          });
        }
      });
    }
    _isBrushContainItem(t, e, i) {
      var n, s, r;
      if (
        !(null == t ? void 0 : t.globalTransMatrix) ||
        !(null === (n = null == t ? void 0 : t.attribute) || void 0 === n ? void 0 : n.points)
      )
        return !1;
      const a =
          null !== (r = null === (s = null == t ? void 0 : t.attribute) || void 0 === s ? void 0 : s.points) &&
          void 0 !== r
            ? r
            : [],
        { a: o, b: l, c: h, d: c, e: d, f: u } = t.globalTransMatrix,
        p = (null == i ? void 0 : i.dx) || 0,
        g = (null == i ? void 0 : i.dy) || 0,
        f = a.map(t => ({ x: o * t.x + h * t.y + d + p, y: l * t.x + c * t.y + u + g })),
        v = t.globalAABBBounds
          .clone()
          .set(
            t.globalAABBBounds.x1 + p,
            t.globalAABBBounds.y1 + g,
            t.globalAABBBounds.x2 + p,
            t.globalAABBBounds.y2 + g
          ),
        m = e.globalTransMatrix.e,
        y = e.globalTransMatrix.f;
      if ('symbol' === e.type) return v.contains(m, y) && We(f, m, y);
      if ('rect' === e.type) {
        const { width: t = 0, height: i = 0 } = null == e ? void 0 : e.attribute;
        return (function (t, e) {
          for (let i = 0; i < e.length; i++) {
            if (We(t, e[i].x, e[i].y)) return !0;
            if (i > 0 && Ve(e[i - 1].x, e[i - 1].y, e[i].x, e[i].y, t)) return !0;
          }
          return !1;
        })(f, [
          { x: m, y: y },
          { x: m + t, y: y },
          { x: m + t, y: y + i },
          { x: m, y: y + i }
        ]);
      }
      return t.globalAABBBounds.intersects(e.globalAABBBounds);
    }
    _bindRegions() {
      h(this._spec.regionId) && h(this._spec.regionIndex) && (this._relativeRegions = this._option.getAllRegions()),
        (this._relativeRegions = this._option.getRegionsInUserIdOrIndex(
          V(this._spec.regionId),
          V(this._spec.regionIndex)
        ));
    }
    _bindLinkedSeries() {
      (h(this._spec.brushLinkSeriesId) && h(this._spec.brushLinkSeriesIndex)) ||
        (this._linkedSeries = this._option.getSeriesInUserIdOrIndex(
          V(this._spec.brushLinkSeriesId),
          V(this._spec.brushLinkSeriesIndex)
        ));
    }
    _initNeedOperatedItem() {
      const t = this._spec.seriesId,
        e = this._spec.seriesIndex;
      this._relativeRegions.forEach(i => {
        const n = [];
        i.getSeries().forEach(s => {
          ((t && V(t).includes(s.userId.toString())) || (e && V(e).includes(s.getSpecIndex())) || (!e && !t)) &&
            n.push(...s.getMarksWithoutRoot()),
            (this._itemMap[i.id] = n);
        });
      }),
        this._linkedSeries.forEach(t => {
          this._linkedItemMap[t.id] = t.getMarksWithoutRoot();
        });
    }
    _initMarkBrushState(t, e) {
      var i, n;
      this._brushComponents.forEach((e, i) => {
        i !== t && e.children[0].removeAllChild();
      }),
        (this._inBrushElementsMap = {}),
        (this._outOfBrushElementsMap = {}),
        (this._linkedInBrushElementsMap = {}),
        (this._linkedOutOfBrushElementsMap = {});
      const s = this._transformBrushedMarkAttr(null === (i = this._spec) || void 0 === i ? void 0 : i.inBrush),
        r = this._transformBrushedMarkAttr(null === (n = this._spec) || void 0 === n ? void 0 : n.outOfBrush);
      this._option.getAllSeries().forEach(t => {
        t.getMarksWithoutRoot().forEach(t => {
          const i = t.getProduct();
          if (!i || !i.elements || !i.elements.length) return;
          i.elements.forEach(i => {
            const n = i.getGraphicItem(),
              a = t.id + '_' + i.key;
            (n.stateProxy = t => ('inBrush' === t ? s : 'outOfBrush' === t ? r : void 0)),
              n.addState(e),
              (this._outOfBrushElementsMap[a] = i),
              (this._linkedOutOfBrushElementsMap[a] = i);
          });
        });
      }),
        (this._isFirstState = !1);
    }
    initEvent() {}
    onRender(t) {}
    changeRegions(t) {}
    updateSpec(t) {
      this._brushComponents &&
        this._relativeRegions.forEach((t, e) => {
          this._updateBrushComponent(t, e);
        });
      const e = this._spec,
        i = super.updateSpec(t);
      return z(e, this._spec) || ((i.reRender = !0), (i.reMake = !0)), i;
    }
    onLayoutEnd(t) {
      var e;
      super.onLayoutEnd(t);
      (null === (e = this._spec.visible) || void 0 === e || e) &&
        (this._brushComponents
          ? this._relativeRegions.forEach((t, e) => {
              this._updateBrushComponent(t, e);
            })
          : ((this._brushComponents = []),
            this._relativeRegions.forEach((t, e) => {
              this._createBrushComponent(t, e);
            })));
    }
    clear() {
      this._brushComponents &&
        (this._container.removeChild(this._brushComponents),
        this._brushComponents.forEach(t => {
          t.releaseBrushEvents();
        }),
        (this._brushComponents = null)),
        super.clear();
    }
  }
  function S6(t, e, i = 0) {
    return i > Math.max(e.x1 - t.x2, t.x1 - e.x2, e.y1 - t.y2, t.y1 - e.y2);
  }
  function w6(t) {
    return { x1: t.x, x2: t.x + t.width, y1: t.y, y2: t.y + t.height };
  }
  function A6(t) {
    var e;
    if (!t || 0 === t.length) return [];
    if (1 === t.length) return [t[0].rect];
    const i = t.map(t => {
        var e;
        return Object.assign(Object.assign({}, t), {
          bound: w6(t.rect),
          anchorCandidates: P6(null !== (e = t.anchors) && void 0 !== e ? e : [], t.point, t.rect, t.offset)
        });
      }),
      n = [];
    n.push(i[0].bound);
    for (let t = 1; t <= i.length - 1; t++) {
      const s = i[t],
        r = s.bound;
      let a = n.some(t => S6(t, r));
      if (s.anchorCandidates)
        if (a && (null === (e = s.anchorCandidates) || void 0 === e ? void 0 : e.length) > 0) {
          for (let t = 0; t < s.anchorCandidates.length; t++) {
            const e = s.anchorCandidates[t],
              i = { x1: e.x, y1: e.y, x2: e.x + r.x2 - r.x1, y2: e.y + r.y2 - r.y1, anchor: e };
            if (!n.some(t => S6(t, i))) {
              n.push(i), (a = !1);
              break;
            }
          }
          a && n.push(s.bound);
        } else n.push(s.bound);
    }
    return n.map(t =>
      (function (t) {
        return { x: t.x1, y: t.y1, width: t.x2 - t.x1, height: t.y2 - t.y1 };
      })(t)
    );
  }
  function k6(t, e, i) {
    const n = t.map(t => t.pointCoord),
      { x1: s, x2: r, y1: a, y2: o } = He(n),
      l = i([(s + r) / 2, (a + o) / 2]);
    if (!l) return [];
    const h = t.map(t => {
      const n = t.rect,
        s = C6(e, t.pointCoord)
          ? i(
              (function (t, e, i, n = 200) {
                const s = 5621 / n;
                let r = e;
                for (let e = 1; e <= s; e++) {
                  const e = vn(r, n, i);
                  if (!C6(t, e)) return [e.x, e.y];
                  r = [e.x, e.y];
                }
                return e;
              })(e, [t.pointCoord.x, t.pointCoord.y], M6(T6(t.point, l)))
            )
          : t.point;
      s && ((n.x = s.x), (n.y = s.y));
      const r = M6(T6(t.point, l));
      let a;
      const o = [];
      return (
        r >= -45 && r < 45
          ? ((a = 'top'), o.push('left', 'right'))
          : r >= 45 && r < 135
          ? (a = 'right')
          : r >= -135 && r < -45
          ? ((a = 'left'), o.push('left'))
          : ((a = 'bottom'), o.push('left', 'right')),
        (t.anchors = o),
        (t.offset = 20),
        (t.rect = E6(t.rect, a, 0)),
        t
      );
    });
    return A6(h);
  }
  function M6(t) {
    return t > 180 ? t - 360 : t;
  }
  function T6(t, e) {
    return (180 * Math.atan2(t.y - e.y, t.x - e.x)) / Math.PI + 90;
  }
  function C6(t, e) {
    for (let i = 0; i < t.length; i++) {
      if (fn(e, t[i])) return !0;
    }
    return !1;
  }
  function E6(t, e, i = 0) {
    const n = Object.assign({}, t);
    return (
      'top' === e
        ? ((n.x -= t.width / 2), (n.y -= i + t.height / 2))
        : 'bottom' === e
        ? ((n.x -= t.width / 2), (n.y += i - t.height / 2))
        : 'left' === e
        ? ((n.x -= i + t.width), (n.y -= t.height / 2))
        : 'right' === e && ((n.x += i), (n.y -= t.height / 2)),
      n
    );
  }
  function P6(t, e, i, n = 0) {
    const s = [];
    return (
      t.forEach(t => {
        const { x: r, y: a } = E6(Object.assign(Object.assign({}, e), { width: i.width, height: i.height }), t, n);
        s.push({ x: r, y: a });
      }),
      s
    );
  }
  (x6.type = xn.brush), (x6.speckey = 'inBrush');
  class R6 extends g6 {
    constructor() {
      super(...arguments),
        (this.type = xn.mapLabel),
        (this.name = xn.mapLabel),
        (this.layoutType = 'absolute'),
        (this.layoutZIndex = cZ.MarkPoint),
        (this._activeDatum = []);
    }
    static createComponent(t, e) {
      const i = t.mapLabel;
      return i && i.visible && !h(i.series) ? new R6(i, e) : null;
    }
    setAttrFromSpec() {
      var t, e, i, n;
      (this.nameField =
        null !== (t = this._spec.nameField) && void 0 !== t
          ? t
          : null === (e = this._series) || void 0 === e
          ? void 0
          : e.getDimensionField()[0]),
        (this.valueField =
          null !== (i = this._spec.valueField) && void 0 !== i
            ? i
            : null === (n = this._series) || void 0 === n
            ? void 0
            : n.getMeasureField()[0]);
    }
    created() {
      super.created(), !1 != !!this._spec.visible && (this.initRelatedInfo(), this.initData(), this.initEvent());
    }
    initRelatedInfo() {
      var t, e, i, n, s, r, a, o;
      (this._series = this._option.getSeriesInUserIdOrIndex([this._spec.seriesId])[0]),
        'outer' === this._spec.position &&
          ((this._map =
            null ===
              (e =
                null === (t = this._regions[0].getSeriesInType('map')[0]) || void 0 === t
                  ? void 0
                  : t.getMapViewData()) || void 0 === e
              ? void 0
              : e.latestData),
          (this._longitudeField =
            null === (s = null === (n = (i = this._regions[0]).getSpec) || void 0 === n ? void 0 : n.call(i)) ||
            void 0 === s
              ? void 0
              : s.longitudeField),
          (this._latitudeField =
            null === (o = null === (a = (r = this._regions[0]).getSpec) || void 0 === a ? void 0 : a.call(r)) ||
            void 0 === o
              ? void 0
              : o.latitudeField));
    }
    initData() {
      const t = this._series;
      if (!t) return;
      const e = t.getViewData();
      if (e) {
        const t = new yo(this._option.dataSet);
        t.parse([e], { type: 'dataview' }),
          t.transform({ type: 'copyDataView' }, !1),
          (t.name = `${this.name}_data`),
          (this._data = new d0(this._option, t)),
          t.target.addListener('change', () => {
            'hover' !== this._spec.trigger &&
              'click' !== this._spec.trigger &&
              (this._activeDatum = this._data.getLatestData());
          });
      }
    }
    initEvent() {
      this.event.on('zoom', { filter: t => this._isRelativeModel(t.model) }, t => (this.handleZoom(t), !0)),
        this.event.on('panmove', { filter: t => this._isRelativeModel(t.model) }, t => (this.handlePan(t), !0));
      const t = this._spec.trigger;
      'none' !== t &&
        ('hover' === t
          ? (this.event.on('hovered', { filter: t => this._isRelativeSeries(t.model) }, t => {
              this._updateDatum(t.value);
            }),
            this.event.on('unhovered', () => {
              this._updateDatum([]);
            }))
          : 'click' === t &&
            (this.event.on('selected', { filter: t => this._isRelativeSeries(t.model) }, t => {
              this._updateDatum(t.value);
            }),
            this.event.on('unselected', () => {
              this._updateDatum([]);
            })));
    }
    handlePan(t) {
      const { delta: e } = t;
      this._markerComponents.forEach(t => {
        t.translate(e[0], e[1]);
      });
    }
    handleZoom(t) {
      this._updateMarkerLayoutAttribute();
    }
    _updateDatum(t) {
      (this._activeDatum = t),
        this._markerComponents.forEach((t, e) => {
          var i;
          const n = null === (i = this._data) || void 0 === i ? void 0 : i.getLatestData()[e];
          this._activeDatum.includes(n) ? t.setAttribute('visible', !0) : t.setAttribute('visible', !1);
        });
    }
    dataToPosition(t) {
      return this._series.dataToPosition(t);
    }
    updateLayoutAttribute() {
      var t;
      const e = null === (t = this._data) || void 0 === t ? void 0 : t.getLatestData();
      e && 0 !== e.length && (super.updateLayoutAttribute(), this._updateMarkerLayoutAttribute());
    }
    _updateMarkerLayoutAttribute() {
      var t;
      const e = [],
        i = [];
      this._markerComponents ||
        (this._markerComponents =
          null === (t = this._data) || void 0 === t
            ? void 0
            : t.getLatestData().map((t, e) => {
                var i;
                const n = new fX({ position: void 0 });
                return (
                  n &&
                    ((n.name = `${this.name}_marker_${e}`),
                    (n.id = null !== (i = this._spec.id) && void 0 !== i ? i : `${this.name}_marker_${this.id}`),
                    n.setAttribute('zIndex', this.layoutZIndex)),
                  n
                );
              }));
      this._markerComponents.forEach((t, n) => {
        t.removeAllChild();
        const { pairInfo: s, contentMarks: r } = this._evaluateMarker(this._data.getLatestData()[n], n);
        s && e.push(s), r && i.push(r);
      });
      const n = this._layoutLabels(e);
      this._layoutMarkers(n, i), this._renderMarkers();
    }
    _evaluateMarker(t, e) {
      var i, n, s, r, a, o, l, c, d, u, p, g;
      let f = 0,
        v = 0,
        m = 0,
        y = 0,
        _ = 0;
      const b = this._spec.position || 'top',
        x = this._spec.offset,
        S = _V(null === (i = this._spec.background) || void 0 === i ? void 0 : i.padding),
        w = this._spec.space || 0;
      (v += ((null == S ? void 0 : S.left) || 0) + ((null == S ? void 0 : S.right) || 0)),
        (m += ((null == S ? void 0 : S.top) || 0) + ((null == S ? void 0 : S.bottom) || 0));
      const A = {},
        k = this.dataToPosition(t),
        M = QO({});
      if (
        ((M.name = `${this.name}_marker_itemContainer_${e}`),
        (A.container = M),
        null === (n = this._spec.background) || void 0 === n ? void 0 : n.visible)
      ) {
        const t = iB(GJ(Object.assign({}, this._spec.background.style)));
        t.setAttributes(k), (A.labelBackground = t), M.appendChild(t);
      }
      if (null === (s = this._spec.icon) || void 0 === s ? void 0 : s.visible) {
        const t = rB(GJ(Object.assign({}, this._spec.icon.style)));
        t.setAttributes(k),
          t.setAttribute('symbolType', null === (r = this._spec.icon.style) || void 0 === r ? void 0 : r.shape);
        const e = t.AABBBounds,
          i = null !== (a = (null == e ? void 0 : e.y2) - (null == e ? void 0 : e.y1)) && void 0 !== a ? a : 0,
          n = null !== (o = (null == e ? void 0 : e.x2) - (null == e ? void 0 : e.x1)) && void 0 !== o ? o : 0;
        (A.icon = t), M.appendChild(t), (_ = i), (y += n), f++;
      }
      if (null === (l = this._spec.nameLabel) || void 0 === l ? void 0 : l.visible) {
        const e = sB(GJ(Object.assign({}, this._spec.nameLabel.style)));
        e.setAttributes(k), e.setAttribute('text', t[this.nameField]);
        const i = e.AABBBounds,
          n = null !== (c = (null == i ? void 0 : i.y2) - (null == i ? void 0 : i.y1)) && void 0 !== c ? c : 0,
          s = null !== (d = (null == i ? void 0 : i.x2) - (null == i ? void 0 : i.x1)) && void 0 !== d ? d : 0;
        (A.nameLabel = e), M.appendChild(e), (_ = Math.max(_, n)), (y += s), f++;
      }
      if ((null === (u = this._spec.valueLabel) || void 0 === u ? void 0 : u.visible) && h(t[this.valueField])) {
        const e = sB(GJ(Object.assign({}, this._spec.valueLabel.style)));
        e.setAttributes(k), e.setAttribute('text', t[this.valueField]);
        const i = e.AABBBounds,
          n = null !== (p = (null == i ? void 0 : i.y2) - (null == i ? void 0 : i.y1)) && void 0 !== p ? p : 0,
          s = null !== (g = (null == i ? void 0 : i.x2) - (null == i ? void 0 : i.x1)) && void 0 !== g ? g : 0;
        (A.valueLabel = e), M.appendChild(e), (_ = Math.max(_, n)), (y += s), f++;
      }
      const T = Object.values(A).find(t => !!t && 'group' !== t.type),
        C = {
          x: null == T ? void 0 : T.getComputedAttribute('x'),
          y: null == T ? void 0 : T.getComputedAttribute('y')
        },
        E = { x: C.x, y: C.y, width: 0, height: 0 };
      (E.width = v + y + (f - 1) * w), (E.height = m + _);
      const P = { rect: E, point: C, index: e };
      if ('outer' !== b) {
        const t = ['top', 'right', 'left', 'bottom'].filter(t => t !== b);
        (P.rect = E6(E, b, x)), (P.anchors = t), (P.offset = x);
      } else P.pointCoord = { x: +(null == t ? void 0 : t[this._longitudeField]), y: +(null == t ? void 0 : t[this._latitudeField]) };
      return { pairInfo: P, contentMarks: A };
    }
    _layoutMarkers(t, e) {
      var i, n, s;
      for (let r = 0; r < e.length; r++) {
        if (!t[r] || !e[r]) return;
        const { icon: a, nameLabel: o, valueLabel: l, labelBackground: h, container: c } = e[r],
          d = t[r],
          u = _V(null === (i = this._spec.background) || void 0 === i ? void 0 : i.padding),
          p = this._spec.space || 0,
          g = d.height / 2;
        let f = (null == u ? void 0 : u.left) || 0;
        [a, o, l].forEach((t, e) => {
          var i, n;
          if (t) {
            const s = t.AABBBounds;
            let r = 0;
            'symbol' === t.type && (r += (null !== (i = s.x2 - s.x1) && void 0 !== i ? i : 0) / 2),
              t.setAttributes({ x: f + r, y: g }),
              (f += null !== (n = s.x2 - s.x1) && void 0 !== n ? n : 0),
              2 !== e && (f += p);
          }
        }),
          null == h || h.setAttributes({ x: 0, y: 0, width: d.width, height: d.height }),
          null == c || c.setAttributes({ dx: -d.width / 2, dy: -d.height / 2 });
        const v = this._data.getLatestData()[r],
          m = this.dataToPosition(v),
          y = !(!(null === (n = this._spec.leader) || void 0 === n ? void 0 : n.visible) || !(a || o || l));
        this._markerComponents[r].setAttributes({
          x: this.getRegions()[0].getLayoutStartPoint().x,
          y: this.getRegions()[0].getLayoutStartPoint().y,
          position: m,
          visible: this._activeDatum.includes(v),
          itemContent: {
            refX: 0,
            type: 'custom',
            renderCustomCallback: () => c,
            autoRotate: !1,
            offsetX: d.x + d.width / 2 - m.x,
            offsetY: d.y + d.height / 2 - m.y
          },
          itemLine: {
            visible: y,
            type: 'type-po',
            lineStyle: GJ(Object.assign({}, null === (s = this._spec.leader) || void 0 === s ? void 0 : s.style)),
            startSymbol: { visible: !1 }
          }
        });
      }
    }
    _renderMarkers() {
      if (this._markerComponents && this._markerComponents.length)
        for (let t = 0; t < this._markerComponents.length; t++) this.getContainer().add(this._markerComponents[t]);
    }
    _layoutLabels(t) {
      return 'outer' === this._spec.position && this._map
        ? k6(t, this._map, t =>
            this._series.dataToPosition({ [this._longitudeField]: t[0], [this._latitudeField]: t[1] })
          )
        : A6(t);
    }
    _isRelativeModel(t) {
      var e, i, n;
      const s =
        null !== (i = null === (e = this._series.getXAxisHelper()) || void 0 === e ? void 0 : e.getAxisId()) &&
        void 0 !== i
          ? i
          : null === (n = this._series.getCoordinateHelper()) || void 0 === n
          ? void 0
          : n.getCoordinateId();
      return (null == t ? void 0 : t.id) === s;
    }
    _isRelativeSeries(t) {
      return (null == t ? void 0 : t.id) === this._series.id;
    }
    onRender(t) {}
    changeRegions() {}
  }
  function O6(t) {
    return 2 === t.length && _(t[0]) && _(t[1]) && t[1] >= t[0];
  }
  function B6(t, e) {
    const i = e[1] - e[0],
      n = e[1] * e[0] < 0;
    let s = e[0] <= 0 ? 0 - e[0] : 0,
      r = e[1] > 0 ? e[1] - 0 : 0;
    0 === i ? (e[0] < 0 ? ((s = 1), (r = 0)) : e[0] > 0 && ((s = 0), (r = 1))) : ((s /= i), (r /= i));
    const a = t.getDomainSpec();
    return {
      total: i,
      negative: s,
      positive: r,
      includeZero: n,
      domain: e,
      extendable_min: !_(a.min),
      extendable_max: !_(a.max)
    };
  }
  function I6(t, e) {
    const { positive: i, negative: n, extendable_min: s, extendable_max: r, domain: a } = t,
      { positive: o, negative: l, extendable_min: h, extendable_max: c, domain: d } = e;
    if (o > 0) {
      if (!h) return !1;
      let t = n / i;
      r && ((t = n / Math.max(i, o)), (a[1] = -a[0] / t)), (d[0] = -d[1] * t);
    } else if (l > 0) {
      if (!c) return !1;
      let t = i / n;
      s && ((t = i / Math.max(n, n)), (a[0] = -a[1] / t)), (d[1] = -d[0] * t);
    }
    return !0;
  }
  function D6(t, e) {
    const { extendable_min: i, extendable_max: n, domain: s } = t,
      { positive: r, negative: a, domain: o } = e;
    return (0 !== r || 0 !== a) && !(r > 0 && !n) && !(a > 0 && !i) && ((s[0] = o[0]), (s[1] = o[1]), !0);
  }
  function L6(t, e) {
    const { positive: i, negative: n, extendable_max: s, domain: r } = t,
      { positive: a, negative: o, extendable_min: l, domain: h } = e;
    if (s && l) {
      const t = Math.max(n, o) / Math.max(i, a);
      (r[1] = -r[0] / t), (h[0] = -h[1] * t);
    } else if (l) {
      const t = n / i;
      h[0] = -h[1] * t;
    } else {
      if (!s) return !1;
      {
        const t = o / a;
        r[1] = -r[0] / t;
      }
    }
    return !0;
  }
  function F6(t, e) {
    const { extendable_min: i, domain: n } = t,
      { extendable_max: s, domain: r } = e;
    return !(!i || !s) && ((n[0] = -n[1]), (r[1] = -r[0]), !0);
  }
  (R6.type = xn.mapLabel), (R6.speckey = 'mapLabel');
  class j6 {
    constructor(t = j6.Name) {
      (this.id = Ro()), (this.name = `${t}_${this.id}`);
    }
    onAdd(t) {
      this.service = t;
    }
  }
  const z6 = (t, e) => {
    var i, n, s, r, a;
    if (!t) return t;
    const o = null === (i = null == e ? void 0 : e.targetAxis) || void 0 === i ? void 0 : i.call(e);
    if (!o) return t;
    const l = null === (n = null == e ? void 0 : e.currentAxis) || void 0 === n ? void 0 : n.call(e);
    if (!l) return t;
    const h = null === (s = l.getTickData()) || void 0 === s ? void 0 : s.getDataView();
    if (!h) return t;
    if (!h.transformsArr.find(t => 'ticks' === t.type)) return t;
    const c = l.getScale();
    if (!c) return t;
    const d =
      null === (a = null === (r = o.getTickData()) || void 0 === r ? void 0 : r.getDataView()) || void 0 === a
        ? void 0
        : a.latestData;
    if (!(null == d ? void 0 : d.length)) return t;
    const u = o.getScale();
    if (!u) return t;
    const p = u.domain(),
      g = p[1] - p[0];
    if (0 === g) return t;
    const f = c.domain(),
      v = f[1] - f[0];
    if (0 === g) return t;
    const m = d.map(t => {
      const e = (t.value - p[0]) / g;
      return v * e + f[0];
    });
    return DN(m);
  };
  class H6 extends j6 {
    constructor() {
      super(H6.Name), (this.Name = 'AxisSyncPlugin');
    }
    _checkEnableSync(t) {
      if (!Zo(t.getScale().type)) return !1;
      const e = t.getSpec().sync;
      return !!(null == e ? void 0 : e.axisId) && e;
    }
    _getTargetAxis(t, e) {
      const i = t.getOption().getChart().getComponentByUserId(e.axisId);
      return (null == i ? void 0 : i.type.startsWith('cartesianAxis')) ? i : null;
    }
    onInit(t, e) {
      const i = this._checkEnableSync(e);
      if (!i) return;
      if (!i.zeroAlign) return;
      const n = this._getTargetAxis(e, i);
      n &&
        e.event.on(Gq.scaleDomainUpdate, { filter: ({ model: t }) => t.id === e.id }, () => {
          ((t, e) => {
            const i = t.getScale(),
              n = e.getScale();
            if (!i || !n) return;
            if (!Zo(i.type) || !Zo(n.type)) return;
            const s = [...i.domain()],
              r = [...n.domain()];
            if (!O6(s) || !O6(r)) return;
            const a = B6(t, s),
              o = B6(e, r),
              { positive: l, negative: h, extendable_min: c, extendable_max: d, includeZero: u } = a,
              { positive: p, negative: g, extendable_min: f, extendable_max: v, includeZero: m } = o;
            if (0 === l && 0 === h) {
              if (!D6(a, o)) return;
            } else if (0 === p && 0 === g) {
              if (!D6(o, a)) return;
            } else if (u || m)
              if (u && !m) {
                if (!I6(a, o)) return;
              } else if (m && !u) {
                if (!I6(o, a)) return;
              } else {
                if (h === g) return;
                if (h > g) {
                  if (!L6(a, o)) return;
                } else if (!L6(o, a)) return;
              }
            else {
              if (0 === h && 0 === p) {
                if (!F6(a, o)) return;
              } else if (0 === g && 0 === l && !F6(o, a)) return;
              if (0 === h && 0 === g)
                if (0 === s[0] && r[0] > 0) {
                  if (!f) return;
                  r[0] = 0;
                } else {
                  if (!(0 === r[0] && s[0] > 0)) return;
                  if (!c) return;
                  s[0] = 0;
                }
              if (0 === l && 0 === p)
                if (0 === s[1] && r[1] > 0) {
                  if (!v) return;
                  r[1] = 0;
                } else {
                  if (!(0 === r[1] && s[1] > 0)) return;
                  if (!d) return;
                  s[1] = 0;
                }
            }
            i.domain(s), n.domain(r);
          })(n, e);
        });
    }
    onDidCompile(t, e) {
      const i = this._checkEnableSync(e);
      if (!i) return;
      const n = this._getTargetAxis(e, i);
      if (n && i.tickAlign) {
        xQ(e.getOption().dataSet, 'tickAlign', z6);
        const t = { targetAxis: () => n, currentAxis: () => e };
        e.addTransformToTickData({ type: 'tickAlign', options: t, level: Number.MAX_SAFE_INTEGER }, !1);
      }
    }
  }
  var N6 = { AxisSyncPlugin: H6 };
  const V6 = t => t;
  class W6 extends g6 {
    getOrient() {
      return this._orient;
    }
    getScale() {
      return this._scale;
    }
    getScales() {
      return this._scales;
    }
    getTickData() {
      return this._tickData;
    }
    getStatisticsDomain() {
      return this._statisticsDomain;
    }
    get visible() {
      return this._visible;
    }
    constructor(t, e) {
      var i;
      super(t, Object.assign({}, e)),
        (this._scales = []),
        (this._statisticsDomain = { domain: [], index: {} }),
        (this._visible = !0),
        (this._tick = void 0),
        (this.computeStatisticsDomain = () => {
          const t = [];
          if (
            (tV(
              this._regions,
              e => {
                var i;
                const n = null === (i = e.getViewDataStatistics) || void 0 === i ? void 0 : i.call(e);
                n &&
                  this.getSeriesStatisticsField(e).forEach(e => {
                    var i;
                    (null === (i = n.latestData) || void 0 === i ? void 0 : i[e]) && t.push(n.latestData[e]);
                  });
              },
              { userId: this._seriesUserId, specIndex: this._seriesIndex }
            ),
            (this._statisticsDomain.domain = this.computeDomain(t)),
            !Zo(this._scale.type))
          ) {
            this._statisticsDomain.index = {};
            for (let t = 0; t < this._statisticsDomain.domain.length; t++)
              this._statisticsDomain.index[this._statisticsDomain.domain[t]] = t;
          }
        }),
        (this._visible = null === (i = t.visible) || void 0 === i || i);
    }
    created() {
      var t, e, i, n, s, r, o, l, c, d, u, p, g, f, v, m;
      if (
        (super.created(),
        this.setSeriesAndRegionsFromSpec(),
        this.initEvent(),
        this.initScales(),
        this.updateSeriesScale(),
        this._initData(),
        this._visible)
      ) {
        const y = this._createMark(
          { type: 'component', name: `axis-${this.getOrient()}` },
          { componentType: 'angle' === this.getOrient() ? 'circleAxis' : 'axis', mode: this._spec.mode }
        );
        if (
          ((this._axisMark = y),
          y.setZIndex(this.layoutZIndex),
          h(this._spec.id) && y.setUserId(this._spec.id),
          this._marks.addMark(y),
          null === (t = this._spec.grid) || void 0 === t ? void 0 : t.visible)
        ) {
          const t = this._createMark(
            { type: 'component', name: `axis-${this.getOrient()}-grid` },
            { componentType: 'angle' === this.getOrient() ? XW.circleAxisGrid : XW.lineAxisGrid, mode: this._spec.mode }
          );
          t.setZIndex(
            null !==
              (r =
                null !==
                  (n =
                    null === (i = null === (e = this._spec.grid) || void 0 === e ? void 0 : e.style) || void 0 === i
                      ? void 0
                      : i.zIndex) && void 0 !== n
                  ? n
                  : null === (s = this._spec.grid) || void 0 === s
                  ? void 0
                  : s.zIndex) && void 0 !== r
              ? r
              : cZ.Axis_Grid
          ),
            this._marks.addMark(t),
            (this._gridMark = t);
        }
        if (
          (a(this._spec.interactive) && this._marks.forEach(t => t.setInteractive(this._spec.interactive)),
          !1 !== this._option.animation &&
            !1 !== C(this._option.getChart().getSpec(), 'animation') &&
            !0 === this._spec.animation)
        ) {
          const t = w1(x1.axis(), {
            appear:
              null !==
                (l =
                  null !== (o = this._spec.animationAppear) && void 0 !== o
                    ? o
                    : C(this._option.getChart().getSpec(), 'animationAppear.axis')) && void 0 !== l
                ? l
                : C(this._option.getChart().getSpec(), 'animationAppear'),
            disappear:
              null !==
                (d =
                  null !== (c = this._spec.animationDisappear) && void 0 !== c
                    ? c
                    : C(this._option.getChart().getSpec(), 'animationDisappear.axis')) && void 0 !== d
                ? d
                : C(this._option.getChart().getSpec(), 'animationDisappear'),
            enter:
              null !==
                (p =
                  null !== (u = this._spec.animationEnter) && void 0 !== u
                    ? u
                    : C(this._option.getChart().getSpec(), 'animationEnter.axis')) && void 0 !== p
                ? p
                : C(this._option.getChart().getSpec(), 'animationEnter'),
            exit:
              null !==
                (f =
                  null !== (g = this._spec.animationExit) && void 0 !== g
                    ? g
                    : C(this._option.getChart().getSpec(), 'animationExit.axis')) && void 0 !== f
                ? f
                : C(this._option.getChart().getSpec(), 'animationExit'),
            update:
              null !==
                (m =
                  null !== (v = this._spec.animationUpdate) && void 0 !== v
                    ? v
                    : C(this._option.getChart().getSpec(), 'animationUpdate.axis')) && void 0 !== m
                ? m
                : C(this._option.getChart().getSpec(), 'animationUpdate')
          });
          (t.update[0].customParameters = { enter: t.enter[0] }), this._marks.forEach(e => e.setAnimationConfig(t));
        }
      }
    }
    isSeriesDataEnable() {
      let t = !0;
      return (
        tV(
          this._regions,
          e => {
            var i;
            f(null === (i = e.getViewDataStatistics()) || void 0 === i ? void 0 : i.latestData) && (t = !1);
          },
          { userId: this._seriesUserId, specIndex: this._seriesIndex }
        ),
        t
      );
    }
    setSeriesAndRegionsFromSpec() {
      const { seriesId: t, seriesIndex: e, regionId: i, regionIndex: n } = this._spec;
      h(t) && (this._seriesUserId = V(t)),
        h(i) && (this._regionUserId = V(i)),
        h(e) && (this._seriesIndex = V(e)),
        h(n) && (this._regionIndex = V(n)),
        (this._regions = this._option.getRegionsInUserIdOrIndex(this._regionUserId, this._regionIndex)),
        (this.layoutBindRegionID = this._regions.map(t => t.id));
    }
    getBindSeriesFilter() {
      return { userId: this._seriesUserId, specIndex: this._seriesIndex };
    }
    initEvent() {
      this.event.on(
        Gq.scaleUpdate,
        { filter: ({ model: t }) => (null == t ? void 0 : t.id) === this.id },
        this.effect.scaleUpdate.bind(this)
      );
      const t = eV(this._regions, { userId: this._seriesUserId, specIndex: this._seriesIndex })
        .map(t => t.getViewDataStatistics())
        .filter(t => !!t);
      this._option.dataSet.multipleDataViewAddListener(t, 'change', () => {
        this.updateScaleDomain();
      });
    }
    updateScaleDomain() {}
    computeData() {
      this._tickData.getDataView().reRunAllTransform(), this._tickData.updateData();
    }
    initScales() {
      this._scales = [this._scale];
      const t = [];
      if (
        (tV(
          this._regions,
          e => {
            const i = e.getGroups();
            i && t.push(i);
          },
          { userId: this._seriesUserId, specIndex: this._seriesIndex }
        ),
        0 !== t.length)
      ) {
        const e = Math.max(...t.map(t => t.fields.length));
        for (let t = 1; t < e; t++) {
          const t = this._scale.clone();
          this._scales.push(t);
        }
      }
    }
    updateSpec(t) {
      const e = this._originalSpec,
        i = super.updateSpec(t);
      return (i.reRender = !0), e.type !== t.type ? ((i.reMake = !0), i) : i;
    }
    getLabelFormatMethod() {
      return this._spec.label.formatMethod ? (t, e, i) => this._spec.label.formatMethod(e.rawValue, e) : null;
    }
    getLabelItems(t) {
      return f(this._tickData.getLatestData())
        ? [
            this._tickData
              .getLatestData()
              .map(e => ({
                id: e.value,
                label: e.value,
                value: 0 === t ? 0 : this.dataToPosition([e.value]) / t,
                rawValue: e.value
              }))
              .filter(t => t.value >= 0 && t.value <= 1)
          ]
        : [];
    }
    _delegateAxisContainerEvent(t) {
      t.addEventListener('*', (e, i) => this._delegateEvent(t, e, i));
    }
    _getAxisAttributes() {
      var t, e, i, n, s, r, a, h, c, d, u;
      const p = this._spec;
      let g,
        f = p.title.angle;
      ('left' !== p.orient && 'right' !== p.orient) ||
        ((null === (t = p.title) || void 0 === t ? void 0 : t.autoRotate) &&
          l(p.title.angle) &&
          ((f = 'left' === p.orient ? -90 : 90), (g = W3[p.orient])));
      const v = L(p.label, ['style', 'formatMethod', 'state']);
      return {
        orient: this.getOrient(),
        select: p.select,
        hover: p.hover,
        line: ((m = p.domainLine), ((m = NJ(m)).startSymbol = NJ(m.startSymbol)), (m.endSymbol = NJ(m.endSymbol)), m),
        label: Object.assign(
          {
            style: o(p.label.style)
              ? (t, e, i, n) => {
                  var s;
                  const r = this._prepareSpecAfterMergingTheme(p.label.style(t.rawValue, e, t, i, n));
                  return GJ(
                    this._prepareSpecAfterMergingTheme(
                      _J({}, null === (s = this._theme.label) || void 0 === s ? void 0 : s.style, r)
                    )
                  );
                }
              : GJ(p.label.style),
            formatMethod: p.label.formatMethod ? (t, e, i) => p.label.formatMethod(e.rawValue, e) : null,
            state: WJ(p.label.state)
          },
          v
        ),
        tick: {
          visible: p.tick.visible,
          length: p.tick.tickSize,
          inside: p.tick.inside,
          alignWithLabel: p.tick.alignWithLabel,
          style: o(p.tick.style)
            ? (t, e, i, n) => {
                var s;
                const r = this._prepareSpecAfterMergingTheme(p.tick.style(t, e, i, n));
                return GJ(
                  this._prepareSpecAfterMergingTheme(
                    _J({}, null === (s = this._theme.tick) || void 0 === s ? void 0 : s.style, r)
                  )
                );
              }
            : GJ(p.tick.style),
          state: VJ(p.tick.state),
          dataFilter: p.tick.dataFilter
        },
        subTick: {
          visible: p.subTick.visible,
          length: p.subTick.tickSize,
          inside: p.subTick.inside,
          count: p.subTick.tickCount,
          style: o(p.subTick.style)
            ? (t, e, i, n) => {
                var s;
                const r = p.subTick.style(t, e, i, n);
                return GJ(_J({}, null === (s = this._theme.subTick) || void 0 === s ? void 0 : s.style, r));
              }
            : GJ(p.subTick.style),
          state: VJ(p.subTick.state)
        },
        title: {
          visible: p.title.visible,
          position: p.title.position,
          space: p.title.space,
          autoRotate: !1,
          angle: f ? qt(f) : null,
          textStyle: _J({}, g, GJ(p.title.style)),
          padding: p.title.padding,
          shape: {
            visible: null === (e = p.title.shape) || void 0 === e ? void 0 : e.visible,
            space: null === (i = p.title.shape) || void 0 === i ? void 0 : i.space,
            style: GJ(null === (n = p.title.shape) || void 0 === n ? void 0 : n.style)
          },
          background: {
            visible: null === (s = p.title.background) || void 0 === s ? void 0 : s.visible,
            style: GJ(null === (r = p.title.background) || void 0 === r ? void 0 : r.style)
          },
          state: {
            text: VJ(p.title.state),
            shape: VJ(null === (a = p.title.shape) || void 0 === a ? void 0 : a.state),
            background: VJ(null === (h = p.title.background) || void 0 === h ? void 0 : h.state)
          }
        },
        panel: {
          visible: null === (c = p.background) || void 0 === c ? void 0 : c.visible,
          style: GJ(null === (d = p.background) || void 0 === d ? void 0 : d.style),
          state: VJ(null === (u = p.background) || void 0 === u ? void 0 : u.state)
        }
      };
      var m;
    }
    _getGridAttributes() {
      const t = this._spec;
      return {
        alternateColor: t.grid.alternateColor,
        alignWithLabel: t.grid.alignWithLabel,
        style: o(t.grid.style)
          ? () => (e, i) => {
              var n, s;
              const r = t.grid.style(null === (n = e.datum) || void 0 === n ? void 0 : n.rawValue, i, e.datum);
              return GJ(
                this._prepareSpecAfterMergingTheme(
                  _J({}, null === (s = this._theme.grid) || void 0 === s ? void 0 : s.style, r)
                )
              );
            }
          : GJ(t.grid.style),
        subGrid: {
          type: 'line',
          visible: t.subGrid.visible,
          alternateColor: t.subGrid.alternateColor,
          style: GJ(t.subGrid.style)
        }
      };
    }
    addTransformToTickData(t, e) {
      var i, n;
      null === (n = null === (i = this._tickData) || void 0 === i ? void 0 : i.getDataView()) ||
        void 0 === n ||
        n.transform(t, e);
    }
  }
  W6.specKey = 'axes';
  const G6 = [N6.AxisSyncPlugin];
  class U6 extends W6 {
    getOrient() {
      return this._orient;
    }
    get layoutOrient() {
      return this._layoutOrient;
    }
    set layoutOrient(t) {
      (this._orient = t), (this._layoutOrient = t);
    }
    getScales() {
      return this._scales;
    }
    getStatisticsDomain() {
      return this._statisticsDomain;
    }
    constructor(t, e) {
      super(t, Object.assign({}, e)),
        (this.type = xn.cartesianAxis),
        (this.name = xn.cartesianAxis),
        (this.layoutType = 'region-relative'),
        (this.layoutZIndex = cZ.Axis),
        (this.layoutLevel = dZ.Axis),
        (this._orient = 'left'),
        (this._scales = []),
        (this._statisticsDomain = { domain: [], index: {} }),
        (this._tick = void 0),
        (this._layoutCache = { width: 0, height: 0, _lastComputeOutBounds: { x1: 0, x2: 0, y1: 0, y2: 0 } }),
        (this.effect = {
          scaleUpdate: () => {
            this.computeData(),
              tV(
                this._regions,
                t => {
                  tQ(this.getOrient())
                    ? t.setXAxisHelper(this.axisHelper())
                    : eQ(this.getOrient())
                    ? t.setYAxisHelper(this.axisHelper())
                    : iQ(this.getOrient()) && t.setZAxisHelper(this.axisHelper());
                },
                { userId: this._seriesUserId, specIndex: this._seriesIndex }
              );
          }
        }),
        (this._fixAxisOnZero = () => {
          const { onZero: t, visible: e } = this._spec.domainLine;
          if (this.visible && t && !1 !== e) {
            const { onZeroAxisId: t, onZeroAxisIndex: e } = this._spec.domainLine,
              i = this._option.getComponentsByKey('axes'),
              n = tQ(this.getOrient()),
              s = t => {
                var e;
                return (
                  (n ? !tQ(t.orient) : tQ(t.orient)) &&
                  Zo(t.getScale().type) &&
                  (null === (e = t.getTickData().getLatestData()) || void 0 === e ? void 0 : e.find(t => 0 === t.value))
                );
              },
              r = i.filter(t => s(t));
            if (r.length) {
              let a;
              if (h(t)) a = r.find(e => e.id === t);
              else if (h(e)) {
                const t = i[e];
                s(t) && (a = t);
              } else a = r[0];
              if (a) {
                const t = this._axisMark.getProduct(),
                  e = a.valueToPosition(0);
                n
                  ? t.encode({
                      line: Object.assign(Object.assign({}, this._axisStyle.line), {
                        dy: 'bottom' === this._orient ? -(a.getScale().range()[0] - e) : e
                      })
                    })
                  : t.encode({
                      line: Object.assign(Object.assign({}, this._axisStyle.line), {
                        dx: 'left' === this._orient ? e : -(a.getScale().range()[1] - e)
                      })
                    });
              }
            }
          }
        }),
        (this._orient = nQ(t, ['z'])),
        iQ(this._orient) && (this.layoutType = 'absolute'),
        h(t.autoIndent) && (this._autoIndent = t.autoIndent),
        (this._layoutOrient = this._orient),
        (this._dataSet = e.dataSet);
    }
    static createAxis(t, e, i = !1) {
      var n;
      const s =
          null !== (n = t.type) && void 0 !== n
            ? n
            : (function (t, e) {
                return e ? (tQ(t) ? 'linear' : 'band') : tQ(t) ? 'band' : 'linear';
              })(t.orient, i),
        r = `${U6.type}-${s}`,
        a = UJ.getComponentInKey(r);
      if (a) {
        let n = t.inverse;
        return (
          i && !tQ(t.orient) && (n = !h(t.inverse) || !t.inverse),
          new a(Object.assign(Object.assign({}, t), { type: s, inverse: n }), e)
        );
      }
      return e.onError(`Component ${r} not found`), null;
    }
    static createComponent(t, e) {
      if (!this.type.startsWith(U6.type)) return null;
      if (e.getRegionsInIndex().find(t => 'cartesian' !== t.coordinate)) return null;
      let i = t[U6.specKey] || e.defaultSpec;
      if (!i) return null;
      const n = t.direction === JJ.horizontal;
      if (!f(i)) return Y3(i) ? U6.createAxis(i, e, n) : null;
      const s = i.filter(t => 'z' === t.orient)[0];
      let r = !0;
      if (s) {
        const t = i.filter(t => 'bottom' === t.orient)[0],
          e = i.filter(t => eQ(t.orient))[0];
        r = 3 === i.length && t && e;
      }
      r || (i = i.filter(t => 'z' !== t.orient));
      const a = [];
      return (
        i.forEach((t, i) => {
          Y3(t) &&
            a.push(U6.createAxis(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: U6.specKey }), n));
        }),
        a
      );
    }
    setLayout3dBox(t) {
      this.layout3dBox = t;
    }
    updateScaleRange() {
      let t = !1;
      const { width: e, height: i } = this.getLayoutRect(),
        n = this._spec.inverse;
      let s = [];
      tQ(this.getOrient())
        ? _(e) && (s = n ? [e, 0] : [0, e])
        : iQ(this.getOrient())
        ? _(e) && ((s = n ? [e, 0] : [0, e]), this._scale.range(s))
        : _(i) && (s = n ? [0, i] : [i, 0]);
      const [r, a] = this._scale.range();
      return (s[0] === r && s[1] === a) || ((t = !0), this._scale.range(s)), t;
    }
    init(t) {
      var e;
      super.init(t),
        null === (e = this.pluginService) || void 0 === e || e.load(G6.map(t => new t())),
        this.callPlugin(t => {
          this.pluginService && t.onInit && t.onInit(this.pluginService, this);
        });
    }
    setAttrFromSpec() {
      if ((super.setAttrFromSpec(), this.visible)) {
        tQ(this.getOrient())
          ? p(this._spec.maxHeight) && (this._spec.maxHeight = '30%')
          : p(this._spec.maxWidth) && (this._spec.maxWidth = '30%');
        const t = this._getAxisAttributes();
        (t.label.formatMethod = this.getLabelFormatMethod()),
          (t.verticalFactor = 'top' === this.getOrient() || 'right' === this.getOrient() ? -1 : 1),
          (this._axisStyle = t);
      }
      this._tick = this._spec.tick;
    }
    getSeriesStatisticsField(t) {
      let e;
      return (
        (e = tQ(this.getOrient()) ? t.fieldX : iQ(this.getOrient()) ? t.fieldZ : t.fieldY),
        Zo(this._scale.type) ? e : [e[0]]
      );
    }
    _initTickData(t) {
      SQ(this._option.dataSet, 'scale', V6), xQ(this._option.dataSet, 'ticks', UN);
      const e = this._spec.label || {},
        i = this._tick || {},
        n = new yo(this._option.dataSet).parse(this._scale, { type: 'scale' }).transform(
          {
            type: 'ticks',
            options: {
              sampling: t,
              tickCount: i.tickCount,
              forceTickCount: i.forceTickCount,
              tickStep: i.tickStep,
              tickMode: i.tickMode,
              noDecimals: i.noDecimals,
              axisOrientType: this._orient,
              coordinateType: 'cartesian',
              labelStyle: e.style,
              labelFormatter: e.formatMethod,
              labelGap: e.minGap,
              labelLastVisible: e.lastVisible,
              labelFlush: e.flush
            }
          },
          !1
        );
      n.target.addListener('change', this._forceLayout.bind(this)), (this._tickData = new d0(this._option, n));
    }
    _initData() {
      this._initTickData(!1 !== this._spec.sampling);
    }
    axisHelper() {
      return {
        isContinuous: Zo(this._scale.type),
        dataToPosition: this.dataToPosition.bind(this),
        getScale: (t = 0) => this._scales[t],
        getStatisticsDomain: () => this.getStatisticsDomain(),
        getAxisType: () => this.type,
        getAxisId: () => this.id,
        isInverse: () => !0 === this._spec.inverse
      };
    }
    afterCompile() {
      var t;
      const e = null === (t = this._axisMark) || void 0 === t ? void 0 : t.getProduct();
      e &&
        e.addEventListener(tG.AFTER_ELEMENT_ENCODE, () => {
          !1 === this._isLayout &&
            (tQ(this.getOrient())
              ? this.callPlugin(t => {
                  this.pluginService && t.onDidLayoutHorizontal && t.onDidLayoutHorizontal(this.pluginService, this);
                })
              : this.callPlugin(t => {
                  this.pluginService && t.onDidLayoutVertical && t.onDidLayoutVertical(this.pluginService, this);
                }),
            this._delegateAxisContainerEvent(e.getGroupGraphicItem()));
        }),
        this.callPlugin(t => {
          this.pluginService && t.onDidCompile && t.onDidCompile(this.pluginService, this);
        });
    }
    onLayoutEnd(t) {
      this.updateScaleRange() ? this.event.emit(Gq.scaleUpdate, { model: this }) : this.updateSeriesScale(),
        super.onLayoutEnd(t);
    }
    onRender(t) {}
    changeRegions(t) {}
    update(t) {}
    resize(t) {}
    collectScale() {
      const t = [];
      return (
        tV(
          this._regions,
          e => {
            t.push('left' === this.getOrient() || 'right' === this.getOrient() ? e.scaleY : e.scaleX);
          },
          { userId: this._seriesUserId, specIndex: this._seriesIndex }
        ),
        t
      );
    }
    collectData(t) {
      const e = [];
      return (
        tV(
          this._regions,
          i => {
            var n, s, r;
            let a;
            (a =
              t > 0
                ? null === (s = null === (n = i.getGroups()) || void 0 === n ? void 0 : n.fields) || void 0 === s
                  ? void 0
                  : s[t]
                : tQ(this.getOrient())
                ? i.fieldX2
                  ? [...i.fieldX, i.fieldX2]
                  : i.fieldX
                : iQ(this.getOrient())
                ? i.fieldZ
                : i.fieldY),
              (a = f(a) ? (Zo(this._scale.type) ? a : [a[0]]) : [a]),
              t || (this._dataFieldText = i.getFieldAlias(a[0]));
            const o = null === (r = i.getViewDataStatistics) || void 0 === r ? void 0 : r.call(i);
            a &&
              a.forEach(t => {
                var i;
                (null === (i = null == o ? void 0 : o.latestData) || void 0 === i ? void 0 : i[t]) &&
                  e.push(o.latestData[t]);
              });
          },
          { userId: this._seriesUserId, specIndex: this._seriesIndex }
        ),
        e
      );
    }
    updateSeriesScale() {
      tV(
        this._regions,
        t => {
          tQ(this.getOrient())
            ? (t.setScaleX(this._scale), t.setXAxisHelper(this.axisHelper()))
            : eQ(this.getOrient())
            ? (t.setScaleY(this._scale), t.setYAxisHelper(this.axisHelper()))
            : iQ(this.getOrient()) && (t.setScaleZ(this._scale), t.setZAxisHelper(this.axisHelper()));
        },
        { userId: this._seriesUserId, specIndex: this._seriesIndex }
      );
    }
    setLayoutStartPosition(t) {
      let { x: e, y: i } = t;
      _(e) && (e += Number('left' === this._orient) * this.getLayoutRect().width),
        _(i) && (i += Number('top' === this._orient) * this.getLayoutRect().height),
        super.setLayoutStartPosition({ x: e, y: i });
    }
    computeBoundsInRect(t) {
      const e = super.computeBoundsInRect(t);
      if (!this._visible) return e;
      const i = this._latestBounds.clone().translate(-this.getLayoutStartPoint().x, -this.getLayoutStartPoint().y);
      switch (this._layoutOrient) {
        case 'left':
          0 === this._layoutRectLevelMap.width && (e.width = i.x1 < 0 ? -i.x1 : 0);
          break;
        case 'right':
          0 === this._layoutRectLevelMap.width && (e.width = i.x2 > 0 ? i.x2 : 0);
          break;
        case 'top':
          0 === this._layoutRectLevelMap.height && (e.height = i.y1 < 0 ? -i.y1 : 0);
          break;
        case 'bottom':
          0 === this._layoutRectLevelMap.height && (e.height = i.y2 > 0 ? i.y2 : 0);
      }
      return (
        (e.width = Math.ceil(e.width)),
        (e.height = Math.ceil(e.height)),
        this._setRectInSpec(this._layoutCacheProcessing(e))
      );
    }
    _boundsInRect(t) {
      let e = { x1: 0, y1: 0, x2: 0, y2: 0 };
      if (!this._visible) return e;
      (this._verticalLimitSize = tQ(this.getOrient()) ? t.height : t.width),
        this.setLayoutRect(t),
        this.updateScaleRange(),
        this.computeData();
      const i = tQ(this.getOrient()),
        n = { skipLayout: !1 };
      i
        ? this.pluginService &&
          this.callPlugin(t => {
            t.onWillLayoutHorizontal && t.onWillLayoutHorizontal(this.pluginService, n, this);
          })
        : this.pluginService &&
          this.callPlugin(t => {
            t.onWillLayoutVertical && t.onWillLayoutVertical(this.pluginService, n, this);
          });
      const s = this._axisMark.getProduct();
      this._latestBounds = s.getBounds();
      {
        const t = this._getUpdateAttribute(!0),
          i = s
            .getGroupGraphicItem()
            .getBoundsWithoutRender(_J(Object.assign({}, this.getLayoutStartPoint()), this._axisStyle, t));
        isFinite(i.width()) && ((e = i), (this._latestBounds = i));
      }
      return e;
    }
    updateLayoutAttribute() {
      if (!this.visible) return;
      const t = this._getUpdateAttribute(!1),
        { grid: e } = t,
        i = mn(t, ['grid']),
        n = this._axisMark.getProduct(),
        s = _J(Object.assign({}, this.getLayoutStartPoint()), this._axisStyle, i);
      if ((n.encode(s), this._gridMark)) {
        this._gridMark
          .getProduct()
          .encode(_J(Object.assign({}, this.getLayoutStartPoint()), this._getGridAttributes(), e));
      }
      super.updateLayoutAttribute();
    }
    _getTitleLimit(t) {
      var e, i, n, s, r;
      if (
        this._spec.title.visible &&
        l(null === (e = this._spec.title.style) || void 0 === e ? void 0 : e.maxLineWidth)
      ) {
        const e =
          null !==
            (r =
              null !== (n = null === (i = this._axisStyle.title) || void 0 === i ? void 0 : i.angle) && void 0 !== n
                ? n
                : null === (s = this._spec.title.style) || void 0 === s
                ? void 0
                : s.angle) && void 0 !== r
            ? r
            : 0;
        if (t) {
          const t = this.getLayoutRect().width,
            i = Math.abs(Math.cos(e));
          return i < 1e-6 ? 1 / 0 : t / i;
        }
        const a = this.getLayoutRect().height,
          o = Math.abs(Math.sin(e));
        return o < 1e-6 ? 1 / 0 : a / o;
      }
      return null;
    }
    _getUpdateAttribute(t) {
      var e;
      let i = 0,
        n = 0;
      if (!t) {
        const t = this.getRegions();
        let { x: e, y: s } = t[0].getLayoutStartPoint(),
          r = e + t[0].getLayoutRect().width,
          a = s + t[0].getLayoutRect().height;
        for (let i = 1; i < t.length; i++) {
          const n = t[i],
            { x: o, y: l } = n.getLayoutStartPoint(),
            { width: h, height: c } = n.getLayoutRect();
          (e = Math.min(e, o)), (r = Math.max(r, h + o)), (s = Math.min(s, l)), (a = Math.max(a, c + l));
        }
        (i = Math.abs(a - s)), (n = Math.abs(r - e));
      }
      const { width: s, height: r } = this.getLayoutRect(),
        a = tQ(this._orient),
        o = eQ(this._orient),
        l = iQ(this._orient);
      let h = { x: 0, y: 0 },
        c = 0,
        d = 0;
      const u = this.layout3dBox ? this.layout3dBox.length : 0;
      if ((a ? ((h = { x: s, y: 0 }), (c = i), (d = s)) : o && ((h = { x: 0, y: r }), (c = n), (d = r)), l)) {
        const n = null !== (e = this.directionStr) && void 0 !== e ? e : 'r2l',
          r = this.layout3dBox ? this.layout3dBox.width : 0;
        let o = [0, 0],
          l = -Math.PI / 2,
          h = 0;
        'l2r' === n && ((h = this.layout3dBox.length), (o = [0, 0, 0]), (l = Math.PI / 2));
        const c = this.getLabelItems(s),
          d = {
            start: { x: 0, y: 0 },
            end: { x: u, y: 0 },
            z: h,
            alpha: l,
            anchor3d: o,
            title: { text: this._spec.title.text || this._dataFieldText, maxWidth: this._getTitleLimit(a) },
            items: c
          };
        return (
          t ||
            (d.grid = {
              type: 'line',
              start: { x: 0, y: 0 },
              end: { x: u, y: 0 },
              items: c[0],
              verticalFactor: this._axisStyle.verticalFactor,
              depth: r,
              length: i,
              z: h,
              alpha: l,
              anchor3d: o
            }),
          d
        );
      }
      let p = a ? this._minHeight : this._minWidth;
      ((a && 9 === this._layoutRectLevelMap.height) || (o && 9 === this._layoutRectLevelMap.width)) &&
        (p = this._verticalLimitSize);
      const g = this.getLabelItems(d),
        f = {
          start: { x: 0, y: 0 },
          end: h,
          title: { text: this._spec.title.text || this._dataFieldText, maxWidth: this._getTitleLimit(a) },
          items: g,
          verticalLimitSize: this._verticalLimitSize,
          verticalMinSize: p
        };
      return (
        t ||
          (f.grid = {
            type: 'line',
            start: { x: 0, y: 0 },
            end: h,
            items: g[0],
            verticalFactor: this._axisStyle.verticalFactor,
            depth: u,
            length: c
          }),
        f
      );
    }
    initEvent() {
      super.initEvent(),
        this.visible &&
          (this.event.on(Gq.layoutEnd, this._fixAxisOnZero),
          this.event.on(Gq.layoutRectUpdate, () => {
            this._clearLayoutCache();
          }));
    }
    _layoutCacheProcessing(t) {
      return (
        ['width', 'height'].forEach(e => {
          t[e] < this._layoutCache[e] ? (t[e] = this._layoutCache[e]) : (this._layoutCache[e] = t[e]);
        }),
        ['x1', 'x2', 'y1', 'y2'].forEach(t => {
          this._lastComputeOutBounds[t] < this._layoutCache._lastComputeOutBounds[t]
            ? (this._lastComputeOutBounds[t] = this._layoutCache._lastComputeOutBounds[t])
            : (this._layoutCache._lastComputeOutBounds[t] = this._lastComputeOutBounds[t]);
        }),
        t
      );
    }
    _clearLayoutCache() {
      (this._layoutCache.width = 0),
        (this._layoutCache.height = 0),
        (this._layoutCache._lastComputeOutBounds = { x1: 0, x2: 0, y1: 0, y2: 0 });
    }
    onDataUpdate() {
      this._clearLayoutCache();
    }
  }
  U6.type = xn.cartesianAxis;
  const Y6 = Math.sqrt(50),
    $6 = Math.sqrt(10),
    X6 = Math.sqrt(2);
  class K6 {
    constructor() {
      this._extend = {};
    }
    setExtraAttrFromSpec() {
      h(this._spec.nice) && (this._nice = this._spec.nice),
        h(this._spec.zero) && (this._zero = this._spec.zero),
        (this._expand = this._spec.expand),
        (this._domain = U3(this._spec));
    }
    transformScaleDomain() {
      this.setScaleNice();
    }
    setLinearScaleNice() {
      var t, e, i, n, s, r, a, o, c, d;
      let u =
        null !==
          (n =
            null !== (e = null === (t = this._spec.tick) || void 0 === t ? void 0 : t.forceTickCount) && void 0 !== e
              ? e
              : null === (i = this._spec.tick) || void 0 === i
              ? void 0
              : i.tickCount) && void 0 !== n
          ? n
          : 10;
      'accurateFirst' === this._spec.niceType && (u = Math.max(10, u)),
        l(null === (s = this._domain) || void 0 === s ? void 0 : s.min) &&
        l(null === (r = this._domain) || void 0 === r ? void 0 : r.max)
          ? this._nice && this._scale.nice(u)
          : h(null === (a = this._domain) || void 0 === a ? void 0 : a.min) &&
            l(null === (o = this._domain) || void 0 === o ? void 0 : o.max)
          ? this._nice && this._scale.niceMax(u)
          : l(null === (c = this._domain) || void 0 === c ? void 0 : c.min) &&
            h(null === (d = this._domain) || void 0 === d ? void 0 : d.max) &&
            this._nice &&
            this._scale.niceMin(u);
    }
    setLogScaleNice() {
      var t, e, i, n, s, r;
      l(null === (t = this._domain) || void 0 === t ? void 0 : t.min) &&
      l(null === (e = this._domain) || void 0 === e ? void 0 : e.max)
        ? this._nice && this._scale.nice()
        : h(null === (i = this._domain) || void 0 === i ? void 0 : i.min) &&
          l(null === (n = this._domain) || void 0 === n ? void 0 : n.max)
        ? this._nice && this._scale.niceMax()
        : l(null === (s = this._domain) || void 0 === s ? void 0 : s.min) &&
          h(null === (r = this._domain) || void 0 === r ? void 0 : r.max) &&
          this._nice &&
          this._scale.niceMin();
    }
    setScaleNice() {
      'log' === this._spec.type ? this.setLogScaleNice() : this.setLinearScaleNice();
    }
    dataToPosition(t, e) {
      return this.valueToPosition(t[0]);
    }
    valueToPosition(t) {
      return 'log' !== this._spec.type || (0 !== t && 0 !== t[0]) ? this._scale.scale(t) : this._scale.range()[0];
    }
    computeLinearDomain(t) {
      const e = [];
      return (
        t.forEach(t => {
          const { min: i, max: n } = t;
          (e[0] = void 0 === e[0] ? i : Math.min(e[0], i)), (e[1] = void 0 === e[1] ? n : Math.max(e[1], n));
        }),
        this.expandDomain(e),
        this.includeZero(e),
        this.setDomainMinMax(e),
        e
      );
    }
    expandDomain(t) {
      if (!this._expand) return;
      let e = t[0],
        i = t[t.length - 1];
      e === i && (0 === i ? (i = 1) : i > 0 ? (e = 0) : i < 0 && (i = 0)),
        h(this._expand.min) && (t[0] = e - (i - e) * this._expand.min),
        h(this._expand.max) && (t[t.length - 1] = i + (i - e) * this._expand.max);
    }
    niceDomain(t) {
      const { min: e, max: i } = U3(this._spec);
      if (h(e) || h(i) || 'linear' !== this._spec.type) return t;
      if (
        Math.abs(
          G(t) -
            (function (t) {
              if (t && f(t)) return t.reduce((t, e) => Math.max(t, e), -1 / 0);
            })(t)
        ) <= 1e-12
      ) {
        let e = t[0];
        const i = e >= 0 ? 1 : -1;
        if (((e = Math.abs(e)), e < 1)) (t[0] = 0), (t[1] = 1);
        else {
          let i = e / 5;
          const n = Math.floor(Math.log(i) / Math.LN10),
            s = i / Math.pow(10, n);
          (i = (s >= Y6 ? 10 : s >= $6 ? 5 : s >= X6 ? 2 : 1) * Math.pow(10, n)), (t[0] = 0), (t[1] = 10 * i);
        }
        i < 0 && (t.reverse(), (t[0] *= -1), (t[1] *= -1));
      }
      return t;
    }
    niceMinMax() {
      var t, e, i, n, s, r, a, o;
      if (this._nice) {
        let c =
          null !== (e = null !== (t = this._tick.forceTickCount) && void 0 !== t ? t : this._tick.tickCount) &&
          void 0 !== e
            ? e
            : 10;
        'accurateFirst' === this._spec.niceType && (c = Math.max(10, c)),
          l(null === (i = this._domain) || void 0 === i ? void 0 : i.min) &&
          l(null === (n = this._domain) || void 0 === n ? void 0 : n.max)
            ? this._scale.nice(c)
            : h(null === (s = this._domain) || void 0 === s ? void 0 : s.min) &&
              l(null === (r = this._domain) || void 0 === r ? void 0 : r.max)
            ? this._scale.niceMax(c)
            : l(null === (a = this._domain) || void 0 === a ? void 0 : a.min) &&
              h(null === (o = this._domain) || void 0 === o ? void 0 : o.max) &&
              this._scale.niceMin(c);
      }
    }
    includeZero(t) {
      this._zero && ((t[0] = Math.min(t[0], 0)), (t[t.length - 1] = Math.max(t[t.length - 1], 0)));
    }
    setExtendDomain(t, e) {
      if (void 0 === e) return void delete this._extend[t];
      this._extend[t] = e;
      const i = this._scale.domain();
      this.extendDomain(i),
        this.includeZero(i),
        this.setDomainMinMax(i),
        this.niceDomain(i),
        this._scale.domain(i, this._nice),
        this.niceMinMax(),
        this.event.emit(Gq.scaleUpdate, { model: this });
    }
    extendDomain(t) {
      let e;
      const i = t.length - 1,
        n = t[0] - t[i] > 0,
        s = n ? i : 0,
        r = n ? 0 : i;
      for (const i in this._extend) (e = this._extend[i]), e > t[r] && (t[r] = e), e < t[s] && (t[s] = e);
    }
    getDomainSpec() {
      return this._domain;
    }
    setDomainMinMax(t) {
      if (!this._domain) return;
      const { min: e, max: i } = this._domain;
      h(e) && (t[0] = e), h(i) && (t[1] = i);
    }
    setZero(t) {
      this._zero !== t && ((this._zero = t), this.updateScaleDomain());
    }
    updateScaleDomain() {
      if (!this.isSeriesDataEnable()) return;
      this.computeStatisticsDomain();
      const t = this.collectData(),
        e = this.computeDomain(t);
      this.updateScaleDomainByModel(e);
    }
    updateScaleDomainByModel(t) {
      (t = null != t ? t : this._scale.domain()),
        this.extendDomain(t),
        this.includeZero(t),
        this.setDomainMinMax(t),
        this.niceDomain(t),
        this._scale.domain(t, this._nice),
        this.niceMinMax(),
        this.event.emit(Gq.scaleDomainUpdate, { model: this }),
        this.event.emit(Gq.scaleUpdate, { model: this });
    }
  }
  class q6 extends U6 {
    constructor() {
      super(...arguments),
        (this.type = xn.cartesianLinearAxis),
        (this._zero = !0),
        (this._nice = !0),
        (this._extend = {}),
        (this._scale = new Vl());
    }
    setAttrFromSpec() {
      super.setAttrFromSpec(), this.setExtraAttrFromSpec();
    }
    initScales() {
      var t, e;
      super.initScales();
      const i = [0, 1];
      h(null === (t = this._domain) || void 0 === t ? void 0 : t.min) && (i[0] = this._domain.min),
        h(null === (e = this._domain) || void 0 === e ? void 0 : e.max) && (i[1] = this._domain.max),
        this._scale.domain(i),
        this.setScaleNice();
    }
    computeDomain(t) {
      return this.computeLinearDomain(t);
    }
    axisHelper() {
      const t = super.axisHelper();
      return (
        (t.setExtendDomain = this.setExtendDomain.bind(this)), (t.valueToPosition = this.valueToPosition.bind(this)), t
      );
    }
  }
  (q6.type = xn.cartesianLinearAxis), N(q6, K6);
  class Z6 {
    valueToPosition(t) {
      return this._scale.scale(t);
    }
    updateGroupScaleRange() {
      let t = this._scale;
      this._scales.forEach((e, i) => {
        i > 0 && (e.range([0, t.bandwidth()]), (t = e));
      });
    }
    getPosition(t) {
      let e = 0,
        i = this._scale;
      if (1 === this._scales.length || 1 === t.length) e = this.valueToPosition(t[0]);
      else {
        const n = Math.min(t.length, this._scales.length);
        for (let i = 0; i < n; i++) e += this._scales[i].scale(t[i]);
        i = this._scales[n - 1];
      }
      return { position: e, bandScale: i };
    }
    calcScales(t, e) {
      var i, n;
      const { bandPadding: s, paddingInner: r, paddingOuter: a } = this._spec,
        o = f(s),
        l = f(r),
        h = f(a);
      for (let c = 0; c < this._scales.length; c++) {
        const d = o ? s[c] : s,
          u = l ? r[c] : r,
          p = h ? a[c] : a;
        this._scales[c]
          .paddingInner(null !== (i = null != u ? u : d) && void 0 !== i ? i : t, !0)
          .paddingOuter(null !== (n = null != p ? p : d) && void 0 !== n ? n : e);
      }
    }
    computeBandDomain(t) {
      const e = new Set();
      for (let i = 0; i < t.length; i++) for (let n = 0; n < t[i].values.length; n++) e.add(t[i].values[n]);
      return Array.from(e);
    }
    updateScaleDomain() {
      if (!this.isSeriesDataEnable()) return;
      this.computeStatisticsDomain();
      const t = this._spec.domain;
      for (let e = 0; e < this._scales.length; e++)
        if (t && t.length && 0 === e) this._scales[e].domain(t);
        else {
          const t = this.collectData(e),
            i = this.computeDomain(t);
          this._scales[e].domain(i);
        }
      this.transformScaleDomain(),
        this.event.emit(Gq.scaleDomainUpdate, { model: this }),
        this.event.emit(Gq.scaleUpdate, { model: this });
    }
  }
  class J6 extends U6 {
    constructor() {
      super(...arguments), (this.type = xn.cartesianBandAxis), (this._scale = new xl());
    }
    computeDomain(t) {
      return this.computeBandDomain(t);
    }
    updateScaleRange() {
      const t = super.updateScaleRange();
      return this.updateGroupScaleRange(), t;
    }
    initScales() {
      super.initScales(), this.calcScales(0.1, 0.3);
    }
    axisHelper() {
      const t = t => this._scales[t];
      return {
        isContinuous: !1,
        dataToPosition: this.dataToPosition.bind(this),
        getScale: t,
        getBandwidth: e => t(e).bandwidth(),
        getStatisticsDomain: () => this.getStatisticsDomain(),
        getAxisType: () => this.type,
        getAxisId: () => this.id,
        isInverse: () => this._spec.inverse
      };
    }
    dataToPosition(t, e = {}) {
      var i;
      if (0 === t.length || 0 === this._scales.length) return 0;
      const { position: n, bandScale: s } = this.getPosition(t);
      return n + s.bandwidth() * (null !== (i = e.bandPosition) && void 0 !== i ? i : 0.5);
    }
    transformScaleDomain() {
      this.updateFixedWholeLength();
    }
    updateFixedWholeLength() {
      this._scale &&
        (this._spec.bandSize && this._scale.bandwidth(this._spec.bandSize),
        this._spec.maxBandSize && this._scale.maxBandwidth(this._spec.maxBandSize),
        this._spec.minBandSize && this._scale.minBandwidth(this._spec.minBandSize));
    }
  }
  (J6.type = xn.cartesianBandAxis), N(J6, Z6);
  class Q6 extends q6 {
    constructor() {
      super(...arguments),
        (this.type = xn.cartesianTimeAxis),
        (this._zero = !1),
        (this.effect = {
          scaleUpdate: () => {
            this.computeData(),
              tV(
                this._regions,
                t => {
                  tQ(this.getOrient()) ? t.setXAxisHelper(this.axisHelper()) : t.setYAxisHelper(this.axisHelper());
                },
                { userId: this._seriesUserId, specIndex: this._seriesIndex }
              );
          }
        });
    }
    setAttrFromSpec() {
      var t;
      super.setAttrFromSpec(),
        (this._tick = _J({}, this._spec.tick, null === (t = this._spec.layers) || void 0 === t ? void 0 : t[0]));
    }
    _initData() {
      var t, e, i, n, s, r, a;
      if ((super._initData(), null === (t = this._spec.layers) || void 0 === t ? void 0 : t[1])) {
        const t = this._spec.label || {},
          o = new yo(this._option.dataSet).parse(this._scale, { type: 'scale' }).transform(
            {
              type: 'ticks',
              options: {
                sampling: !1 !== this._spec.sampling,
                tickCount:
                  null === (i = null === (e = this._spec.layers) || void 0 === e ? void 0 : e[1]) || void 0 === i
                    ? void 0
                    : i.tickCount,
                forceTickCount:
                  null === (s = null === (n = this._spec.layers) || void 0 === n ? void 0 : n[1]) || void 0 === s
                    ? void 0
                    : s.forceTickCount,
                tickStep:
                  null === (a = null === (r = this._spec.layers) || void 0 === r ? void 0 : r[1]) || void 0 === a
                    ? void 0
                    : a.tickStep,
                axisOrientType: this._orient,
                coordinateType: 'cartesian',
                labelStyle: t.style,
                labelFormatter: t.formatMethod,
                labelGap: t.minGap,
                labelLastVisible: t.lastVisible,
                labelFlush: t.flush
              }
            },
            !1
          );
        this._layerTickData = new d0(this._option, o);
      }
    }
    computeData() {
      super.computeData(),
        this._layerTickData &&
          (this._layerTickData.getDataView().reRunAllTransform(), this._layerTickData.updateData());
    }
    getLabelFormatMethod() {
      var t, e, i, n, s, r, a, o, l, h, c, d;
      const u = _o.getInstance(),
        p =
          (null ===
            (i =
              null === (e = null === (t = this._spec) || void 0 === t ? void 0 : t.layers) || void 0 === e
                ? void 0
                : e[1]) || void 0 === i
            ? void 0
            : i.timeFormat) || '%Y%m%d',
        g =
          'local' ===
          ((null ===
            (r =
              null === (s = null === (n = this._spec) || void 0 === n ? void 0 : n.layers) || void 0 === s
                ? void 0
                : s[1]) || void 0 === r
            ? void 0
            : r.timeFormatMode) || 'local')
            ? u.timeFormat
            : u.timeUTCFormat,
        f =
          (null ===
            (l =
              null === (o = null === (a = this._spec) || void 0 === a ? void 0 : a.layers) || void 0 === o
                ? void 0
                : o[0]) || void 0 === l
            ? void 0
            : l.timeFormat) || '%Y%m%d',
        v =
          'local' ===
          ((null ===
            (d =
              null === (c = null === (h = this._spec) || void 0 === h ? void 0 : h.layers) || void 0 === c
                ? void 0
                : c[0]) || void 0 === d
            ? void 0
            : d.timeFormatMode) || 'local')
            ? u.timeFormat
            : u.timeUTCFormat;
      return (t, e, i, n, s) => {
        var r;
        let a;
        return (
          (a = 0 === s ? v(f, t) : g(p, t)),
          (null === (r = this._spec.label) || void 0 === r ? void 0 : r.formatMethod)
            ? this._spec.label.formatMethod(a, e)
            : a
        );
      };
    }
    getLabelItems(t) {
      const e = [];
      return (
        f(this._tickData.getLatestData()) &&
          e.push(
            this._tickData.getLatestData().map(e => ({
              id: e.value,
              label: e.value,
              value: 0 === t ? 0 : this.dataToPosition([e.value]) / t,
              rawValue: e.value
            }))
          ),
        this._layerTickData &&
          f(this._layerTickData.getLatestData()) &&
          e.push(
            this._layerTickData.getLatestData().map(e => {
              const i = this.dataToPosition([e.value]);
              return { id: e.value, label: e.value, value: i / t, rawValue: e.value };
            })
          ),
        e
      );
    }
    transformScaleDomain() {}
  }
  Q6.type = xn.cartesianTimeAxis;
  class t7 extends q6 {
    constructor() {
      super(...arguments), (this.type = xn.cartesianLogAxis), (this._zero = !1), (this._scale = new Gl());
    }
    initScales() {
      var t;
      super.initScales(), this._scale.base(null !== (t = this._spec.base) && void 0 !== t ? t : 10);
    }
    transformScaleDomain() {}
  }
  (t7.type = xn.cartesianLogAxis), N(t7, K6);
  class e7 extends q6 {
    constructor() {
      super(...arguments), (this.type = xn.cartesianSymlogAxis), (this._zero = !1), (this._scale = new ql());
    }
    initScales() {
      var t;
      super.initScales(), this._scale.constant(null !== (t = this._spec.constant) && void 0 !== t ? t : 10);
    }
    transformScaleDomain() {}
  }
  (e7.type = xn.cartesianSymlogAxis), N(e7, K6);
  class i7 extends W6 {
    constructor() {
      super(...arguments),
        (this.type = xn.polarAxis),
        (this.name = xn.polarAxis),
        (this.layoutType = 'absolute'),
        (this.layoutZIndex = cZ.Axis),
        (this._tick = void 0),
        (this._center = null),
        (this._startAngle = dW),
        (this._endAngle = uW),
        (this._orient = 'radius'),
        (this._groupScales = []),
        (this.effect = {
          scaleUpdate: () => {
            this.computeData(),
              tV(
                this._regions,
                t => {
                  'radius' === this.getOrient()
                    ? (t.radiusAxisHelper = this.axisHelper())
                    : (t.angleAxisHelper = this.axisHelper());
                },
                { userId: this._seriesUserId, specIndex: this._seriesIndex }
              );
          }
        });
    }
    get center() {
      return this._center;
    }
    get startAngle() {
      return this._startAngle;
    }
    get endAngle() {
      return this._endAngle;
    }
    getOrient() {
      return this._orient;
    }
    getGroupScales() {
      return this._groupScales;
    }
    setRefAngleAxis(t) {
      return (this._refAngleAxis = t), this;
    }
    static createAxis(t, e) {
      var i;
      const n = null !== (i = t.type) && void 0 !== i ? i : 'angle' === t.orient ? 'band' : 'linear',
        s = `${i7.type}-${n}`,
        r = UJ.getComponentInKey(s);
      return r
        ? new r(Object.assign(Object.assign({}, t), { type: n }), e)
        : (e.onError(`Component ${s} not found`), null);
    }
    static createComponent(t, e) {
      var i, n;
      if (!this.type.startsWith(i7.type)) return null;
      const s = t.axes || e.defaultSpec;
      if (!s) return null;
      if (!f(s))
        return $3(s)
          ? ((s.center = t.center),
            (s.startAngle = null !== (i = t.startAngle) && void 0 !== i ? i : pW),
            (s.endAngle = null !== (n = t.endAngle) && void 0 !== n ? n : h(t.startAngle) ? t.startAngle + 360 : gW),
            i7.createAxis(s, Object.assign(Object.assign({}, e), { specKey: 'axes' })))
          : null;
      const r = [];
      let a;
      const o = [];
      return (
        s.forEach((i, n) => {
          var s, l, c, d, u;
          if (!$3(i)) return;
          (i.center = t.center),
            (i.startAngle = null !== (s = t.startAngle) && void 0 !== s ? s : pW),
            (i.endAngle = null !== (l = t.endAngle) && void 0 !== l ? l : h(t.startAngle) ? t.startAngle + 360 : gW),
            (i.outerRadius =
              null !==
                (u =
                  null !== (d = null !== (c = i.radius) && void 0 !== c ? c : t.outerRadius) && void 0 !== d
                    ? d
                    : t.radius) && void 0 !== u
                ? u
                : fW);
          const p = i7.createAxis(i, Object.assign(Object.assign({}, e), { specIndex: n, specKey: 'axes' }));
          r.push(p), 'radius' === i.orient ? o.push(p) : (a = p);
        }),
        o.forEach(t => t.setRefAngleAxis(a)),
        r
      );
    }
    setAttrFromSpec() {
      var t, e;
      super.setAttrFromSpec(),
        this.visible && ((this._axisStyle = this._getAxisAttributes()), (this._gridStyle = this._getGridAttributes())),
        (this._tick = this._spec.tick),
        (this._orient = 'angle' === this._spec.orient ? 'angle' : 'radius'),
        (this._center = this._spec.center);
      const i = this.getChart().getSpec(),
        n = null !== (t = this._spec.startAngle) && void 0 !== t ? t : i.startAngle,
        s = null !== (e = this._spec.endAngle) && void 0 !== e ? e : i.endAngle;
      (this._startAngle = qt(null != n ? n : pW)), (this._endAngle = qt(null != s ? s : h(n) ? n + 360 : gW));
    }
    setLayoutStartPosition(t) {
      var e;
      const i = null === (e = this.getRegions()) || void 0 === e ? void 0 : e[0],
        n = i ? i.getLayoutStartPoint() : t;
      super.setLayoutStartPosition(n);
    }
    onLayoutEnd(t) {
      this.updateScaleRange(),
        this.updateSeriesScale(),
        this.event.emit(Gq.scaleUpdate, { model: this }),
        super.onLayoutEnd(t);
    }
    onRender(t) {}
    changeRegions() {}
    _initData() {
      SQ(this._option.dataSet, 'scale', V6), xQ(this._option.dataSet, 'ticks', UN);
      const t = this._spec.label || {},
        e = this._spec.tick || {},
        i = new yo(this._option.dataSet).parse(this._scale, { type: 'scale' }).transform(
          {
            type: 'ticks',
            options: {
              sampling: !1 !== this._spec.sampling,
              tickCount: e.tickCount,
              forceTickCount: e.forceTickCount,
              tickStep: e.tickStep,
              tickMode: e.tickMode,
              noDecimals: e.noDecimals,
              coordinateType: 'polar',
              axisOrientType: this._orient,
              startAngle: this.startAngle,
              labelStyle: t.style,
              labelFormatter: t.formatMethod,
              labelGap: t.minGap,
              labelOffset: G3(this._spec),
              getRadius: () => this.getOuterRadius()
            }
          },
          !1
        );
      i.target.addListener('change', this._forceLayout.bind(this)), (this._tickData = new d0(this._option, i));
    }
    afterCompile() {
      var t;
      const e = null === (t = this._axisMark) || void 0 === t ? void 0 : t.getProduct();
      e &&
        e.addEventListener(tG.AFTER_ELEMENT_ENCODE, () => {
          !1 === this._isLayout && this._delegateAxisContainerEvent(e.getGroupGraphicItem());
        });
    }
    updateScaleRange() {
      const t = this._spec.inverse;
      'radius' === this.getOrient()
        ? this._scale.range(
            t
              ? [this.computeLayoutOuterRadius(), this.computeLayoutInnerRadius()]
              : [this.computeLayoutInnerRadius(), this.computeLayoutOuterRadius()]
          )
        : this._scale.range(t ? [this._endAngle, this._startAngle] : [this._startAngle, this._endAngle]);
    }
    collectData(t) {
      const e = [];
      return (
        tV(
          this._regions,
          i => {
            var n, s, r;
            let a;
            (a =
              t > 0
                ? null === (s = null === (n = i.getGroups()) || void 0 === n ? void 0 : n.fields) || void 0 === s
                  ? void 0
                  : s[t]
                : 'radius' === this.getOrient()
                ? i.getRadiusField()
                : i.getAngleField()),
              (a = f(a) ? (Zo(this._scale.type) ? a : [a[0]]) : [a]),
              t || (this._dataFieldText = i.getFieldAlias(a[0]));
            const o = null === (r = i.getViewDataStatistics) || void 0 === r ? void 0 : r.call(i);
            a &&
              a.forEach(t => {
                var i;
                (null === (i = null == o ? void 0 : o.latestData) || void 0 === i ? void 0 : i[t]) &&
                  e.push(o.latestData[t]);
              });
          },
          { userId: this._seriesUserId, specIndex: this._seriesIndex }
        ),
        e
      );
    }
    updateSeriesScale() {
      tV(
        this._regions,
        t => {
          'radius' === this.getOrient()
            ? (t.setRadiusScale(this._scale), (t.radiusAxisHelper = this.axisHelper()))
            : (t.setAngleScale(this._scale), (t.angleAxisHelper = this.axisHelper()));
        },
        { userId: this._seriesUserId, specIndex: this._seriesIndex }
      );
    }
    getSeriesStatisticsField(t) {
      const e = 'radius' === this.getOrient() ? t.getRadiusField() : t.getAngleField();
      return Zo(this._scale.type) ? e : [e[0]];
    }
    initGroupScales() {}
    axisHelper() {
      return {
        isContinuous: Zo(this._scale.type),
        dataToPosition: this.dataToPosition.bind(this),
        coordToPoint: this.coordToPoint.bind(this),
        pointToCoord: this.pointToCoord.bind(this),
        center: this.getCenter.bind(this),
        getScale: t => this._scales[t],
        getAxisId: () => this.id
      };
    }
    dataToPosition(t) {
      return this._scale.scale(t);
    }
    positionToData(t) {
      const e = this.pointToCoord(t);
      if ('radius' === this.getOrient()) return this._scale.invert(e.radius);
      if ('band' === this._scale.type) {
        const t = this._scale.range(),
          i = t[t.length - 1] - t[0];
        if (t[0] < 0) {
          const n = ((e.angle + this._scale.bandwidth() / 2 + Math.abs(t[0])) % i) - Math.abs(t[0]);
          return this._scale.invert(n);
        }
        return this._scale.invert((e.angle + this._scale.bandwidth() / 2) % i);
      }
      return this._scale.invert(e.angle);
    }
    coordToPoint(t) {
      const e = t.angle,
        { x: i, y: n } = this.getCenter(),
        s = YN({ angle: e, radius: t.radius });
      return { x: s.x + i, y: s.y + n };
    }
    pointToCoord(t) {
      const { x: e, y: i } = this.getCenter();
      let n = t.x - e,
        s = t.y - i;
      const r = this._startAngle,
        a = this._endAngle,
        o = Math.sqrt(n * n + s * s);
      (n /= o), (s /= o);
      let l = Math.atan2(s, n);
      if (l < r) for (; l <= r; ) l += 2 * Math.PI;
      if (l > a) for (; l >= a; ) l -= 2 * Math.PI;
      return { radius: o, angle: l };
    }
    getCenter() {
      var t, e;
      return {
        x: (null === (t = this._center) || void 0 === t ? void 0 : t.x) || this.getRefLayoutRect().width / 2,
        y: (null === (e = this._center) || void 0 === e ? void 0 : e.y) || this.getRefLayoutRect().height / 2
      };
    }
    getOuterRadius() {
      return this.computeLayoutOuterRadius();
    }
    getInnerRadius() {
      return this.computeLayoutInnerRadius();
    }
    tickValues() {
      return this._tickData.getLatestData() || [];
    }
    updateLayoutAttribute() {
      this._visible && ('radius' === this.getOrient() ? this._layoutRadiusAxis() : this._layoutAngleAxis()),
        super.updateLayoutAttribute();
    }
    _layoutAngleAxis() {
      const t = this.getCenter(),
        e = this.computeLayoutOuterRadius(),
        i = this.computeLayoutInnerRadius(),
        n = this._endAngle - this._startAngle,
        s = f(this._tickData.getLatestData())
          ? this._tickData.getLatestData().map(t => {
              const e = this.dataToPosition([t.value]);
              return { id: t.value, label: t.value, value: (e - this._startAngle) / n, rawValue: t.value };
            })
          : [],
        r = Object.assign(Object.assign({}, this.getLayoutStartPoint()), {
          inside: this._spec.inside,
          center: t,
          radius: e,
          innerRadius: i,
          startAngle: this._startAngle,
          endAngle: this._endAngle
        }),
        a = Object.assign(Object.assign({}, r), {
          title: { text: this._spec.title.text || this._dataFieldText },
          items: s.length ? [s] : []
        });
      this._spec.grid.visible && (a.grid = Object.assign({ type: 'line', smoothLink: !0, items: s }, r)),
        this._update(a);
    }
    _layoutRadiusAxis() {
      var t, e;
      const i = this.getCenter(),
        n = this.computeLayoutOuterRadius(),
        s = this.computeLayoutInnerRadius(),
        r = this.coordToPoint({ angle: this._startAngle, radius: n }),
        a = this.coordToPoint({ angle: this._startAngle, radius: s }),
        o = Yt.distancePP(a, r),
        l = f(this._tickData.getLatestData())
          ? this._tickData.getLatestData().map(t => {
              const e = this.dataToPosition([t.value]);
              return { id: t.value, label: t.value, value: (e - s) / o, rawValue: t.value };
            })
          : [],
        h = Object.assign(Object.assign({}, this.getLayoutStartPoint()), { start: a, end: r, verticalFactor: -1 }),
        c = Object.assign(Object.assign({}, h), {
          title: { text: this._spec.title.text || this._dataFieldText },
          items: l.length ? [l] : []
        });
      (null === (t = this._spec.grid) || void 0 === t ? void 0 : t.visible) &&
        (c.grid = Object.assign(
          {
            items: l,
            type: (null === (e = this._spec.grid) || void 0 === e ? void 0 : e.smooth) ? 'circle' : 'polygon',
            center: i,
            closed: !0,
            sides: this._refAngleAxis.tickValues().length,
            startAngle: this._startAngle,
            endAngle: this._endAngle
          },
          h
        )),
        this._update(c);
    }
    computeLayoutOuterRadius() {
      var t;
      const e = null !== (t = this._spec.outerRadius) && void 0 !== t ? t : this._spec.radius,
        i = null != e ? e : this.getRefSeriesRadius().outerRadius,
        { width: n, height: s } = this.getRefLayoutRect();
      return (Math.min(n, s) / 2) * i;
    }
    computeLayoutInnerRadius() {
      var t;
      const e = null !== (t = this._spec.innerRadius) && void 0 !== t ? t : this.getRefSeriesRadius().innerRadius,
        { width: i, height: n } = this.getRefLayoutRect();
      return (Math.min(i, n) / 2) * e;
    }
    getRefLayoutRect() {
      return this.getRegions()[0].getLayoutRect();
    }
    getRefSeriesRadius() {
      let t = fW,
        e = 0;
      const i = this.getChart().getSpec();
      return (
        tV(
          this.getRegions(),
          n => {
            const s = n;
            if (
              (function (t) {
                return [DZ.rose, DZ.radar, DZ.circularProgress].includes(t);
              })(s.type)
            ) {
              const { outerRadius: n = i.outerRadius, innerRadius: r = i.innerRadius } = s;
              _(n) && (t = n), _(r) && (e = r);
            }
          },
          { userId: this._seriesUserId, specIndex: this._seriesIndex }
        ),
        { outerRadius: t, innerRadius: e }
      );
    }
    _update(t) {
      const { grid: e } = t,
        i = mn(t, ['grid']);
      if ((this._axisMark.getProduct().encode(_J({}, this._axisStyle, i)), this._gridMark)) {
        this._gridMark.getProduct().encode(_J({}, this._gridStyle, e));
      }
    }
  }
  i7.type = xn.polarAxis;
  class n7 extends i7 {
    constructor() {
      super(...arguments),
        (this.type = xn.polarLinearAxis),
        (this._zero = !0),
        (this._nice = !0),
        (this._scale = new Vl());
    }
    setAttrFromSpec() {
      super.setAttrFromSpec(), this.setExtraAttrFromSpec();
    }
    initScales() {
      super.initScales(), this.setScaleNice();
    }
    computeDomain(t) {
      return this.computeLinearDomain(t);
    }
  }
  (n7.type = xn.polarLinearAxis), N(n7, K6);
  class s7 extends i7 {
    constructor() {
      super(...arguments), (this.type = xn.polarBandAxis), (this._scale = new xl());
    }
    computeDomain(t) {
      return this.computeBandDomain(t);
    }
    dataToPosition(t) {
      if (0 === t.length || 0 === this._scales.length) return 0;
      const { position: e } = this.getPosition(t);
      return e;
    }
    updateScaleRange() {
      super.updateScaleRange(), this.updateGroupScaleRange();
    }
    axisHelper() {
      const t = super.axisHelper();
      return Object.assign(Object.assign({}, t), { getBandwidth: e => t.getScale(e).bandwidth() });
    }
    initScales() {
      super.initScales(), this.calcScales(0, 0);
    }
    transformScaleDomain() {}
  }
  (s7.type = xn.polarBandAxis), N(s7, Z6);
  const r7 = (t, e) => {
      const i = [],
        n = {},
        { series: s, seriesField: r } = e;
      return (
        s().forEach(t => {
          const e = r(t);
          let s;
          (s = e === t.getSeriesField() ? t.getSeriesInfoList() : t.getSeriesInfoInField(e)),
            s.forEach(t => {
              n[t.key] || ((n[t.key] = !0), i.push(t));
            });
        }),
        i
      );
    },
    a7 = (t, e) => {
      var i, n, s;
      const { selected: r, field: a, data: o } = e,
        l = r(),
        c = o();
      if (0 === l.length && c.length) return [];
      if (l.length === c.length) return t;
      const d = {};
      l.forEach(t => {
        d[t] = !0;
      });
      const u = null !== (i = a()) && void 0 !== i ? i : qq;
      return (
        f(t) && (null === (n = t[0]) || void 0 === n ? void 0 : n.nodes)
          ? ((t[0].nodes = t[0].nodes.filter(t => !0 === d[t.key])),
            (null === (s = t[0]) || void 0 === s ? void 0 : s.links) &&
              (t[0].links = t[0].links.filter(t => !0 === d[t.source] && !0 === d[t.target])))
          : h(u) && (t = t.filter(t => !0 === d[t[u]])),
        t
      );
    };
  class o7 extends g6 {
    constructor() {
      super(...arguments),
        (this.layoutType = 'normal'),
        (this.layoutZIndex = cZ.Legend),
        (this.layoutLevel = dZ.Legend),
        (this._orient = 'left'),
        (this._visible = !0),
        (this._position = 'middle'),
        (this._preSelectedData = []),
        (this._selectedData = []),
        (this.effect = {
          onSelectedDataChange: () => {
            tV(
              this._regions,
              t => {
                var e;
                null === (e = t.getViewDataFilter()) || void 0 === e || e.markRunning();
              },
              { userId: this._seriesUserId, specIndex: this._seriesIndex }
            ),
              tV(
                this._regions,
                t => {
                  t.reFilterViewData();
                },
                { userId: this._seriesUserId, specIndex: this._seriesIndex }
              );
          }
        });
    }
    get orient() {
      return this._orient;
    }
    get visible() {
      return this._visible;
    }
    get position() {
      return this._position;
    }
    get layoutOrient() {
      return this._orient;
    }
    set layoutOrient(t) {
      this._orient = t;
    }
    getLegendData() {
      return this._legendData.getLatestData();
    }
    getSelectedData() {
      return this._selectedData;
    }
    setAttrFromSpec() {
      var t;
      super.setAttrFromSpec(),
        (this._orient = gV(this._spec.orient) ? this._spec.orient : 'left'),
        (this._position = null !== (t = this._spec.position) && void 0 !== t ? t : 'middle'),
        (this._visible = !1 !== this._spec.visible);
      const { regionId: e, regionIndex: i, seriesId: n, seriesIndex: s } = this._spec;
      h(n) && (this._seriesUserId = V(n)),
        h(e) && (this._regionUserId = V(e)),
        h(s) && (this._seriesIndex = V(s)),
        h(i) && (this._regionUserIndex = V(i)),
        (this._regions = this._option.getRegionsInUserIdOrIndex(this._regionUserId, this._regionUserIndex));
    }
    created() {
      super.created(), this.initData();
    }
    onRender(t) {}
    updateSpec(t) {
      const e = this._originalSpec,
        i = super.updateSpec(t);
      return (i.reRender = !0), t.orient !== e.orient ? ((i.reMake = !0), i) : i;
    }
    changeRegions(t) {}
    _bindLegendDataChange() {
      (this._preSelectedData = [...this._selectedData]), this._initSelectedData();
    }
    initData() {
      const t = this._initLegendData();
      t.target.addListener('change', this._bindLegendDataChange.bind(this)),
        (this._legendData = new d0(this._option, t)),
        this._initSelectedData(),
        tV(
          this._regions,
          t => {
            t.event.on(
              Gq.rawDataStatisticsUpdate,
              { filter: ({ model: e }) => (null == e ? void 0 : e.id) === t.id },
              () => {
                this._legendData.getDataView().reRunAllTransform();
              }
            );
          },
          { userId: this._seriesUserId, specIndex: this._seriesIndex }
        );
    }
    setSelectedData(t) {
      var e, i, n;
      const s = this._selectedData;
      l(t) ||
        JSON.stringify(s) === JSON.stringify(t) ||
        ((this._selectedData = [...t]),
        null === (i = (e = this.effect).onSelectedDataChange) || void 0 === i || i.call(e),
        this.event.emit(Gq.legendSelectedDataChange, { model: this }),
        null === (n = this._legendComponent) || void 0 === n || n.setSelected(this._selectedData));
    }
    setLayoutStartPosition(t) {
      if ((super.setLayoutStartPosition(t), this._legendComponent)) {
        const { x: e, y: i } = t;
        _(e * i) && this._legendComponent.setAttributes({ x: e, y: i });
      }
    }
    _boundsInRect(t, e) {
      if (!this._visible) return { x1: 0, y1: 0, x2: 0, y2: 0 };
      const i = { x1: this.getLayoutStartPoint().x, y1: this.getLayoutStartPoint().y, x2: 0, y2: 0 },
        n = this._getLegendAttributes(t);
      if (this._legendComponent)
        z(n, this._cacheAttrs) ||
          this._legendComponent.setAttributes(_J({}, n, { defaultSelected: this._selectedData }));
      else {
        const t = new (this._getLegendConstructor())(_J({}, n, { defaultSelected: this._selectedData }));
        (t.name = 'legend'), (this._legendComponent = t);
        this.getContainer().add(t),
          this._initEvent(),
          t.on('*', (t, e) => this._delegateEvent(this._legendComponent, t, e));
      }
      this._cacheAttrs = n;
      const s = isFinite(this._legendComponent.AABBBounds.width()) ? this._legendComponent.AABBBounds.width() : 0,
        r = isFinite(this._legendComponent.AABBBounds.height()) ? this._legendComponent.AABBBounds.height() : 0,
        a = 'bottom' === this.layoutOrient || 'top' === this.layoutOrient ? 'horizontal' : 'vertical',
        o = this._position,
        { width: l, height: h } = e;
      let c = 0,
        d = 0;
      return (
        'horizontal' === a
          ? 'middle' === o
            ? (c = (l - s) / 2)
            : 'end' === o && (c = l - s)
          : 'middle' === o
          ? (d = (h - r) / 2)
          : 'end' === o && (d = h - r),
        this._legendComponent.setAttributes({ dx: c, dy: d }),
        (i.x2 = i.x1 + s),
        (i.y2 = i.y1 + r),
        i
      );
    }
    onDataUpdate() {
      var t, e;
      if (JSON.stringify(this._preSelectedData) !== JSON.stringify(this._selectedData)) {
        if (this._legendComponent) {
          const t = this._getLegendAttributes(this.getLayoutRect());
          z(t, this._cacheAttrs) ||
            this._legendComponent.setAttributes(_J({}, t, { defaultSelected: this._selectedData }));
        }
        null === (e = (t = this.effect).onSelectedDataChange) || void 0 === e || e.call(t),
          this.event.emit(Gq.legendSelectedDataChange, { model: this });
      }
    }
    clear() {
      this._legendComponent && (this._container.removeChild(this._legendComponent), (this._legendComponent = null)),
        (this._cacheAttrs = null),
        (this._preSelectedData = null),
        super.clear();
    }
  }
  class l7 extends o7 {
    constructor() {
      super(...arguments), (this.type = xn.discreteLegend), (this.name = xn.discreteLegend);
    }
    static createComponent(t, e) {
      const i = t.legends || e.defaultSpec;
      if (!i) return;
      if (!f(i))
        return i.type && 'discrete' !== i.type
          ? void 0
          : new l7(i, Object.assign(Object.assign({}, e), { specIndex: 0, specKey: 'legends' }));
      const n = [];
      return (
        i.forEach((t, i) => {
          (t.type && 'discrete' !== t.type) ||
            n.push(new l7(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: 'legends' })));
        }),
        n
      );
    }
    init(t) {
      super.init(t),
        tV(
          this._regions,
          t => {
            t.addViewDataFilter({
              type: 'discreteLegendFilter',
              options: {
                selected: () => this._selectedData,
                field: () => this._getSeriesLegendField(t),
                data: () => this._legendData.getLatestData().map(t => t.key)
              }
            });
          },
          { userId: this._seriesUserId, specIndex: this._seriesIndex }
        );
    }
    _initLegendData() {
      xQ(this._option.dataSet, 'discreteLegendFilter', a7), xQ(this._option.dataSet, 'discreteLegendDataMake', r7);
      const t = new yo(this._option.dataSet);
      return (
        t.transform({
          type: 'discreteLegendDataMake',
          options: {
            series: () => {
              const t = [];
              return (
                tV(
                  this._regions,
                  e => {
                    t.push(e);
                  },
                  { specIndex: this._spec.seriesIndex, userId: this._spec.seriesId }
                ),
                t
              );
            },
            seriesField: t => this._getSeriesLegendField(t)
          }
        }),
        t
      );
    }
    _getSeriesLegendField(t) {
      var e, i;
      const n = t.getSeriesField();
      if (!this._spec.scaleName) return n;
      if (!t.getRawData()) return n;
      const s = this._option.globalScale.getScaleSpec(this._spec.scaleName);
      if (!s) return n;
      if (this._spec.field) return this._spec.field;
      if (!Bo(s.domain)) return n;
      const r = s.domain.find(e => e.dataId === t.getRawData().name);
      return r && null !== (i = null === (e = r.fields) || void 0 === e ? void 0 : e[0]) && void 0 !== i ? i : n;
    }
    _initSelectedData() {
      this._spec.defaultSelected
        ? (this._selectedData = [...this._spec.defaultSelected])
        : (this._selectedData = this._legendData.getLatestData().map(t => t.key));
    }
    _addDefaultTitleText(t) {
      var e, i, n, s;
      if (
        (null === (e = t.title) || void 0 === e ? void 0 : e.visible) &&
        l(t.title.text) &&
        l(null === (i = t.title.style) || void 0 === i ? void 0 : i.text)
      ) {
        const e =
          null === (s = null === (n = this._regions) || void 0 === n ? void 0 : n[0]) || void 0 === s
            ? void 0
            : s.getSeries()[0];
        if (!e) return;
        t.title.text = jJ(e.getRawData(), e.getSeriesField());
      }
    }
    _getLegendAttributes(t) {
      const e = 'bottom' === this.layoutOrient || 'top' === this.layoutOrient ? 'horizontal' : 'vertical',
        i = Object.assign(
          Object.assign(
            { layout: e, items: this._getLegendItems(), zIndex: this.layoutZIndex },
            (function (t, e) {
              const i = _J({}, t),
                {
                  title: n = {},
                  item: s = {},
                  pager: r = {},
                  background: a = {},
                  type: o,
                  id: l,
                  visible: c,
                  orient: d,
                  position: u,
                  data: p,
                  filter: g,
                  regionId: f,
                  regionIndex: v,
                  seriesIndex: m,
                  seriesId: y,
                  padding: _
                } = i,
                b = mn(i, [
                  'title',
                  'item',
                  'pager',
                  'background',
                  'type',
                  'id',
                  'visible',
                  'orient',
                  'position',
                  'data',
                  'filter',
                  'regionId',
                  'regionIndex',
                  'seriesIndex',
                  'seriesId',
                  'padding'
                ]);
              return (
                n.visible && (b.title = d6(n)),
                T(s.focusIconStyle) || GJ(s.focusIconStyle),
                (s.shape = NJ(s.shape)),
                (s.label = NJ(s.label)),
                (s.value = NJ(s.value)),
                (s.background = NJ(s.background)),
                vV(s.maxWidth) &&
                  (s.maxWidth = (Number(s.maxWidth.substring(0, s.maxWidth.length - 1)) * e.width) / 100),
                vV(s.width) && (s.width = (Number(s.width.substring(0, s.width.length - 1)) * e.width) / 100),
                vV(s.height) && (s.height = (Number(s.height.substring(0, s.height.length - 1)) * e.width) / 100),
                (b.item = s),
                T(r.textStyle) || GJ(r.textStyle),
                NJ(r.handler),
                (b.pager = r),
                a.visible && !T(a.style) && (_J(b, a.style), h(a.padding) && (b.padding = a.padding)),
                b
              );
            })(this._spec, t)
          ),
          { maxWidth: t.width, maxHeight: t.height }
        );
      return this._addDefaultTitleText(i), i;
    }
    _getLegendConstructor() {
      return TX;
    }
    _initEvent() {
      if (this._legendComponent) {
        const t = !1 !== this._spec.filter;
        this._legendComponent.addEventListener(SX.legendItemClick, e => {
          const i = C(e, 'detail.currentSelected');
          t && this.setSelectedData(i), this.event.emit(Gq.legendItemClick, { model: this, value: i, event: e });
        }),
          this._legendComponent.addEventListener(SX.legendItemHover, t => {
            const e = C(t, 'detail');
            this.event.emit(Gq.legendItemHover, { model: this, value: e, event: t });
          }),
          this._legendComponent.addEventListener(SX.legendItemUnHover, t => {
            const e = C(t, 'detail');
            this.event.emit(Gq.legendItemUnHover, { model: this, value: e, event: t });
          });
      }
    }
    _getLegendItems() {
      const t = (this._legendData.getLatestData() || []).map(t => {
        var e;
        const i = t.style('fill') || t.style('stroke'),
          n = t.style('stroke'),
          s = t.style('lineWidth'),
          r = t.style('symbolType'),
          a = t.style('fillOpacity'),
          o = t.style('strokeOpacity'),
          l = t.style('opacity'),
          h = t.style('texture'),
          c = t.style('textureColor'),
          d = t.style('outerBorder'),
          u = t.style('innerBorder');
        return {
          label: t.key,
          shape: {
            fill: i,
            symbolType: null !== (e = null != r ? r : t.shapeType) && void 0 !== e ? e : 'circle',
            stroke: 0 === s || i === n ? null : n,
            fillOpacity: _(a) ? a : 1,
            strokeOpacity: _(o) ? o : 1,
            opacity: _(l) ? l : 1,
            texture: h,
            texturePadding: h ? 1 : null,
            textureSize: h ? 4 : null,
            textureColor: c,
            innerBorder: u,
            outerBorder: d
          }
        };
      });
      return o(this._spec.data)
        ? this._spec.data(t, this._option.globalScale.getScale('color'), this._option.globalScale)
        : t;
    }
  }
  l7.type = xn.discreteLegend;
  const h7 = (t, e) => {
      const { series: i, field: n, scale: s } = e,
        r = n();
      if (n && r) {
        let t = Number.MAX_VALUE,
          e = Number.MIN_VALUE;
        return (
          i().forEach(i => {
            var n, s;
            const a = i.getRawDataStatistics().latestData,
              o = null === (n = null == a ? void 0 : a[r]) || void 0 === n ? void 0 : n.min,
              l = null === (s = null == a ? void 0 : a[r]) || void 0 === s ? void 0 : s.max;
            _(o) && (t = o), _(l) && (e = l);
          }),
          [t, e]
        );
      }
      if (s) {
        const t = s();
        return t ? t.domain() : [];
      }
      return [];
    },
    c7 = (t, e) => {
      const { selected: i, field: n, data: s } = e,
        r = i(),
        a = n();
      if (r === s()) return t;
      if (a && !T(r)) {
        const [e, i] = r;
        return t.filter(t => t[a] >= e && t[a] <= i);
      }
      return t;
    };
  function d7(t) {
    return 'color' === t || 'size' === t;
  }
  const u7 = { color: OX, size: IX },
    p7 = ['#C4E7FF', '#98CAFF', '#75ACFF', '#518FF9', '#2775DC', '#005CBE', '#00429F', '#00287E'],
    g7 = [2, 10];
  class f7 extends o7 {
    static createComponent(t, e) {
      const i = t.legends || e.defaultSpec;
      if (!i) return;
      if (!f(i))
        return d7(i.type)
          ? new f7(i, Object.assign(Object.assign({}, e), { specIndex: 0, specKey: 'legends' }))
          : void 0;
      const n = [];
      return (
        i.forEach((t, i) => {
          d7(t.type) && n.push(new f7(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: 'legends' })));
        }),
        n
      );
    }
    constructor(t, e) {
      super(t, e), (this.type = xn.colorLegend), (this.name = xn.colorLegend);
      const i = 'color' === this._spec.type ? xn.colorLegend : xn.sizeLegend;
      (this.type = i), (this.name = i);
    }
    setAttrFromSpec() {
      super.setAttrFromSpec(), (this._field = this._spec.field), (this._legendType = this._spec.type);
    }
    init(t) {
      super.init(t),
        tV(
          this._regions,
          t => {
            t.addViewDataFilter({
              type: 'continuousLegendFilter',
              options: {
                selected: () => this._selectedData,
                field: () => this._field,
                data: () => this._legendData.getLatestData()
              }
            });
          },
          { userId: this._seriesUserId, specIndex: this._seriesIndex }
        );
    }
    _getScaleInGlobal() {
      const t = this._option.globalScale;
      let e = this._spec.scale;
      return e || (e = this._legendType), t.getScale(e);
    }
    _initLegendData() {
      xQ(this._option.dataSet, 'continuousLegendFilter', c7), xQ(this._option.dataSet, 'continuousLegendDataMake', h7);
      const t = new yo(this._option.dataSet);
      return (
        t.transform({
          type: 'continuousLegendDataMake',
          options: {
            series: () => this._regions.reduce((t, e) => (t.push(...e.getSeries()), t), []),
            field: () => this._field,
            scale: this._getScaleInGlobal.bind(this)
          }
        }),
        t
      );
    }
    _initSelectedData() {
      this._spec.defaultSelected
        ? (this._selectedData = [...this._spec.defaultSelected])
        : (this._selectedData = this._legendData.getLatestData());
    }
    _addDefaultTitleText(t) {
      var e, i, n, s;
      if (
        (null === (e = t.title) || void 0 === e ? void 0 : e.visible) &&
        l(t.title.text) &&
        l(null === (i = t.title.style) || void 0 === i ? void 0 : i.text)
      ) {
        const e = this._field;
        if (e) {
          const i =
            null === (s = null === (n = this._regions) || void 0 === n ? void 0 : n[0]) || void 0 === s
              ? void 0
              : s.getSeries()[0];
          if (!i) return;
          return void (t.title.text = jJ(i.getRawData(), e));
        }
        let i = this._spec.scale;
        i || (i = this._legendType);
        const r = this._option.globalScale.getScaleSpec(i);
        if (!Bo(null == r ? void 0 : r.domain)) return;
        const a = r.domain[0];
        if (0 === a.fields.length) return;
        t.title.text = jJ(this._option.dataSet.getDataView(a.dataId), a.fields[0]);
      } else;
    }
    _getLegendAttributes(t) {
      var e, i;
      const n = 'bottom' === this.layoutOrient || 'top' === this.layoutOrient ? 'horizontal' : 'vertical',
        s = 'horizontal' === n ? 'bottom' : this.layoutOrient;
      let r = [];
      const a = this._getScaleInGlobal();
      a && 'linear' === a.type && (r = a.range()), T(r) && (r = 'color' === this._legendType ? p7 : g7);
      let o = null !== (e = this._legendData.getLatestData()[0]) && void 0 !== e ? e : 0,
        l = null !== (i = this._legendData.getLatestData()[1]) && void 0 !== i ? i : 1;
      this._legendData.getLatestData()[0] === this._legendData.getLatestData()[1] &&
        ((o = Math.min(0, this._legendData.getLatestData()[0])),
        (l = 0 === this._legendData.getLatestData()[0] ? 1 : Math.max(0, this._legendData.getLatestData()[0])));
      const c = Object.assign(
        Object.assign(
          {},
          (function (t) {
            const e = _J({}, t),
              {
                title: i = {},
                handler: n = {},
                rail: s = {},
                track: r = {},
                startText: a,
                endText: o,
                handlerText: l,
                sizeBackground: c,
                background: d = {},
                type: u,
                id: p,
                visible: g,
                orient: f,
                position: v,
                data: m,
                defaultSelected: y,
                field: _,
                filter: b,
                regionId: x,
                regionIndex: S,
                seriesIndex: w,
                seriesId: A,
                padding: k
              } = e,
              M = mn(e, [
                'title',
                'handler',
                'rail',
                'track',
                'startText',
                'endText',
                'handlerText',
                'sizeBackground',
                'background',
                'type',
                'id',
                'visible',
                'orient',
                'position',
                'data',
                'defaultSelected',
                'field',
                'filter',
                'regionId',
                'regionIndex',
                'seriesIndex',
                'seriesId',
                'padding'
              ]);
            return (
              i.visible && (M.title = d6(i)),
              (M.showHandler = !1 !== n.visible),
              T(n.style) || (M.handlerStyle = GJ(n.style)),
              h(s.width) && (M.railWidth = s.width),
              h(s.height) && (M.railHeight = s.height),
              T(s.style) || (M.railStyle = GJ(s.style)),
              T(r.style) || (M.trackStyle = GJ(r.style)),
              (M.startText = NJ(a)),
              (M.endText = NJ(o)),
              (M.handlerText = NJ(l)),
              T(c) || (M.sizeBackground = GJ(c)),
              d.visible && !T(d.style) && (_J(M, d.style), h(d.padding) && (M.padding = d.padding)),
              M
            );
          })(this._spec)
        ),
        {
          layout: n,
          align: s,
          zIndex: this.layoutZIndex,
          min: o,
          max: l,
          value: this._spec.defaultSelected,
          ['color' === this._legendType ? 'colors' : 'sizeRange']: r
        }
      );
      return this._addDefaultTitleText(c), c;
    }
    _getLegendConstructor() {
      return u7[this._legendType];
    }
    _initEvent() {
      if (this._legendComponent) {
        const t = !1 !== this._spec.filter;
        this._legendComponent.addEventListener(
          'change',
          mt(e => {
            const i = C(e, 'detail.value');
            t && this.setSelectedData(i), this.event.emit(Gq.legendFilter, { model: this, value: i, event: e });
          }, 30)
        );
      }
    }
  }
  f7.type = xn.continuousLegend;
  const v7 = (t, e) => {
    const { datum: i, title: n, content: s } = e,
      r = [],
      a = i.call(null);
    return (
      n.visible && r.push({ type: 'title', index: 0, datum: a, spec: n }),
      V(s).forEach((t, e) => {
        t.visible && r.push({ type: 'content', index: e, datum: a, spec: t });
      }),
      r
    );
  };
  class m7 extends g6 {
    constructor() {
      super(...arguments),
        (this.type = xn.indicator),
        (this.name = xn.indicator),
        (this.layoutType = 'absolute'),
        (this.layoutZIndex = cZ.Indicator),
        (this.layoutLevel = dZ.Indicator),
        (this._gap = 0),
        (this._activeDatum = null);
    }
    static createComponent(t, e) {
      if (this.type !== m7.type) return null;
      const i = V(t.indicator || e.defaultSpec)
        .filter(t => t && !1 !== t.visible)
        .map((t, i) => new m7(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: m7.speckey })));
      return i;
    }
    created() {
      super.created(), this.initData(), this.initEvent();
    }
    setAttrFromSpec() {
      super.setAttrFromSpec(),
        (this._gap = this._spec.gap || 0),
        (this._title = this._spec.title),
        (this._content = V(this._spec.content)),
        (this._regions = this._option.getRegionsInUserIdOrIndex(V(this._spec.regionId), V(this._spec.regionIndex)));
    }
    onRender(t) {}
    changeRegions(t) {}
    initEvent() {
      'none' !== this._spec.trigger &&
        ('hover' === this._spec.trigger
          ? (this.event.on('hovered', t => {
              (t.model && !this.isRelativeModel(t.model)) || this.updateDatum(t.value[0]);
            }),
            this.event.on('unhovered', t => {
              (t.model && !this.isRelativeModel(t.model)) || this.updateDatum(null);
            }))
          : (this.event.on('selected', t => {
              (t.model && !this.isRelativeModel(t.model)) || this.updateDatum(t.value[0]);
            }),
            this.event.on('unselected', t => {
              (t.model && !this.isRelativeModel(t.model)) || this.updateDatum(null);
            })));
    }
    updateDatum(t) {
      (this._activeDatum = t), this._displayData.updateData();
      const e = this._getIndicatorAttrs();
      this._createOrUpdateIndicatorComponent(e);
    }
    initData() {
      xQ(this._option.dataSet, 'indicatorFilter', v7);
      const t = new yo(this._option.dataSet);
      t.transform({
        type: 'indicatorFilter',
        options: { title: this._title, content: this._content, datum: () => this._activeDatum }
      }),
        t.target.addListener('change', this.updateDatum.bind(this)),
        (this._displayData = new d0(this._option, t));
    }
    updateLayoutAttribute() {
      const t = this._getIndicatorAttrs();
      this._createOrUpdateIndicatorComponent(t), super.updateLayoutAttribute();
    }
    _getIndicatorAttrs() {
      const t = this._regions[0],
        { width: e, height: i } = t.getLayoutRect(),
        { x: n, y: s } = t.getLayoutStartPoint(),
        r = [];
      return (
        V(this._spec.content).forEach(t => {
          const e = _J({}, this._theme.content, t);
          r.push({
            visible: !1 !== e.visible && (!e.field || null !== this._activeDatum),
            space: e.space || this._gap,
            autoLimit: e.autoLimit,
            autoFit: e.autoFit,
            fitPercent: e.fitPercent,
            style: Object.assign(Object.assign({}, GJ(e.style)), { text: this._createText(e.field, e.style.text) })
          });
        }),
        {
          visible: !1 !== this._spec.visible && (!1 !== this._spec.fixed || null !== this._activeDatum),
          size: { width: e, height: i },
          zIndex: this.layoutZIndex,
          x: n,
          y: s,
          dx: this._spec.offsetX ? xV(this._spec.offsetX, this._computeLayoutRadius()) : 0,
          dy: this._spec.offsetY ? xV(this._spec.offsetY, this._computeLayoutRadius()) : 0,
          limitRatio: this._spec.limitRatio || 1 / 0,
          title: {
            visible: !1 !== this._spec.title.visible && (!h(this._spec.title.field) || null !== this._activeDatum),
            space: this._spec.title.space || this._gap,
            autoLimit: this._spec.title.autoLimit,
            autoFit: this._spec.title.autoFit,
            fitPercent: this._spec.title.fitPercent,
            style: Object.assign(Object.assign({}, GJ(this._spec.title.style)), {
              text: this._createText(this._spec.title.field, this._spec.title.style.text)
            })
          },
          content: r
        }
      );
    }
    _createOrUpdateIndicatorComponent(t) {
      if (this._indicatorComponent) z(t, this._cacheAttrs) || this._indicatorComponent.setAttributes(t);
      else {
        const e = this.getContainer(),
          i = new FX(t);
        (i.name = 'indicator'),
          e.add(i),
          (this._indicatorComponent = i),
          this._indicatorComponent.on('*', (t, e) => this._delegateEvent(this._indicatorComponent, t, e));
      }
      return (this._cacheAttrs = t), this._indicatorComponent;
    }
    _createText(t, e) {
      var i;
      return t
        ? this._activeDatum
          ? this._activeDatum[t]
          : ''
        : o(e)
        ? null !== (i = e(this._activeDatum, void 0)) && void 0 !== i
          ? i
          : ''
        : null != e
        ? e
        : '';
    }
    _computeLayoutRadius() {
      const t = this._regions[0],
        { width: e, height: i } = t.getLayoutRect();
      return Math.min(e / 2, i / 2);
    }
    isRelativeModel(t) {
      return tV(this._regions, e => t === e) || this._regions.includes(t);
    }
    clear() {
      this._indicatorComponent &&
        (this._container.removeChild(this._indicatorComponent), (this._indicatorComponent = null)),
        (this._cacheAttrs = null),
        super.clear();
    }
  }
  (m7.speckey = 'indicator'), (m7.type = xn.indicator);
  class y7 extends g6 {
    get orient() {
      return this._orient;
    }
    get layoutOrient() {
      return this._layoutOrient;
    }
    set layoutOrient(t) {
      (this._orient = t), (this._layoutOrient = t);
    }
    constructor(t, e) {
      super(t, Object.assign({}, e)),
        (this.type = xn.title),
        (this.layoutType = 'normal'),
        (this.layoutZIndex = cZ.Title),
        (this.layoutLevel = dZ.Title),
        (this._orient = 'top'),
        (this._orient = gV(t.orient) ? t.orient : 'top'),
        (this._layoutOrient = this._orient);
    }
    static createComponent(t, e) {
      const i = t.title;
      if (!i || !1 === i.visible) return null;
      if (!f(i)) return new y7(i, Object.assign(Object.assign({}, e), { specKey: 'title' }));
      const n = [];
      return (
        i.forEach((t, i) => {
          !1 !== t.visible &&
            n.push(new y7(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: 'title' })));
        }),
        n
      );
    }
    onRender(t) {}
    updateSpec(t) {
      const e = this._originalSpec,
        i = super.updateSpec(t);
      return e.orient !== t.orient && (i.reMake = !0), (i.change = !0), (i.reRender = !0), i;
    }
    changeRegions(t) {}
    update(t) {}
    resize(t) {}
    setLayoutStartPosition(t) {
      const { x: e, y: i } = t;
      _(e) && this._titleComponent && this._titleComponent.setAttribute('x', e),
        _(i) && this._titleComponent && this._titleComponent.setAttribute('y', i),
        super.setLayoutStartPosition({ x: e, y: i });
    }
    _boundsInRect(t) {
      let e = {};
      this.setLayoutRect(t);
      const i = this._getTitleAttrs();
      this._createOrUpdateTitleComponent(i), (e = this._getTitleLayoutRect());
      const { x: n, y: s } = this.getLayoutStartPoint();
      return { x1: n, y1: s, x2: n + e.width, y2: s + e.height };
    }
    _getTitleLayoutRect() {
      const t = this._titleComponent.AABBBounds;
      return {
        width: this._spec.width ? this._spec.width : _(t.width()) ? t.width() : 0,
        height: this._spec.height ? this._spec.height : _(t.height()) ? t.height() : 0
      };
    }
    _getTitleAttrs() {
      var t, e, i, n, s, r, a;
      const o = Math.max(0, null !== (t = this._spec.width) && void 0 !== t ? t : this.getLayoutRect().width);
      return {
        text: null !== (e = this._spec.text) && void 0 !== e ? e : '',
        subtext: null !== (i = this._spec.subtext) && void 0 !== i ? i : '',
        x: null !== (n = this._spec.x) && void 0 !== n ? n : 0,
        y: null !== (s = this._spec.y) && void 0 !== s ? s : 0,
        width: o,
        height: this._spec.height,
        minWidth: this._spec.minWidth,
        maxWidth: this._spec.maxWidth,
        minHeight: this._spec.minHeight,
        maxHeight: this._spec.maxHeight,
        padding: this._spec.innerPadding,
        align: null !== (r = this._spec.align) && void 0 !== r ? r : 'left',
        verticalAlign: null !== (a = this._spec.verticalAlign) && void 0 !== a ? a : 'top',
        textStyle: Object.assign({ width: o }, this._spec.textStyle),
        subtextStyle: Object.assign({ width: o }, this._spec.subtextStyle)
      };
    }
    _createOrUpdateTitleComponent(t) {
      if (this._titleComponent) z(t, this._cacheAttrs) || this._titleComponent.setAttributes(t);
      else {
        const e = this.getContainer(),
          i = new DX(t);
        (i.name = 'title'), e.add(i), (this._titleComponent = i), i.on('*', (t, e) => this._delegateEvent(i, t, e));
      }
      return (this._cacheAttrs = t), this._titleComponent;
    }
    clear() {
      this._titleComponent && (this._container.removeChild(this._titleComponent), (this._titleComponent = null)),
        (this._cacheAttrs = null),
        super.clear();
    }
  }
  y7.type = xn.title;
  class _7 {
    constructor(t) {
      this.projection = c5(t.type)();
    }
    fit(t, e, i) {
      const n = { type: 'FeatureCollection', features: i };
      this.projection.fitExtent([t, e], n);
    }
    center(t) {
      var e, i;
      null === (i = null === (e = this.projection) || void 0 === e ? void 0 : e.center) || void 0 === i || i.call(e, t);
    }
    project(t) {
      var e;
      return null === (e = this.projection) || void 0 === e ? void 0 : e.call(this, t);
    }
    shape(t) {
      var e, i;
      return null === (i = null === (e = this.projection) || void 0 === e ? void 0 : e.path) || void 0 === i
        ? void 0
        : i.call(e, t);
    }
    invert(t) {
      var e, i;
      return null === (i = null === (e = this.projection) || void 0 === e ? void 0 : e.invert) || void 0 === i
        ? void 0
        : i.call(e, t);
    }
    scale(t) {
      var e, i, n, s;
      if (void 0 === t)
        return null === (s = null === (n = this.projection) || void 0 === n ? void 0 : n.scale) || void 0 === s
          ? void 0
          : s.call(n);
      null === (i = null === (e = this.projection) || void 0 === e ? void 0 : e.scale) || void 0 === i || i.call(e, t);
    }
    translate(t) {
      var e, i, n, s;
      if (void 0 === t)
        return null === (s = null === (n = this.projection) || void 0 === n ? void 0 : n.translate) || void 0 === s
          ? void 0
          : s.call(n);
      null === (i = null === (e = this.projection) || void 0 === e ? void 0 : e.translate) ||
        void 0 === i ||
        i.call(e, t);
    }
    evaluate(t, e, i) {
      const n = this.projection.copy();
      return null == n ? void 0 : n.fitExtent([t, e], { type: 'FeatureCollection', features: i });
    }
  }
  function b7(t, e) {
    return `${UV}_${e}_${t}`;
  }
  class x7 extends g6 {
    constructor() {
      super(...arguments),
        (this.type = xn.geoCoordinate),
        (this.name = xn.geoCoordinate),
        (this.layoutType = 'absolute'),
        (this._projectionSpec = { name: b7(this.type, this.id), type: 'mercator' }),
        (this._actualScale = 1),
        (this._evaluated = !1),
        (this._lastHeight = 0),
        (this._lastWidth = 0),
        (this.effect = {
          scaleUpdate: () => {
            this.coordinateHelper();
          }
        }),
        (this._handleChartZoom = (t, e) => {
          var i, n, s, r, a, o;
          let l = t.zoomDelta;
          const h = this._actualScale;
          return (
            (this._actualScale *= l),
            this._actualScale < (null === (i = this._spec.zoomLimit) || void 0 === i ? void 0 : i.min)
              ? ((this._actualScale = null === (n = this._spec.zoomLimit) || void 0 === n ? void 0 : n.min),
                (l = (null === (s = this._spec.zoomLimit) || void 0 === s ? void 0 : s.min) / h))
              : this._actualScale > (null === (r = this._spec.zoomLimit) || void 0 === r ? void 0 : r.max) &&
                ((this._actualScale = null === (a = this._spec.zoomLimit) || void 0 === a ? void 0 : a.max),
                (l = (null === (o = this._spec.zoomLimit) || void 0 === o ? void 0 : o.max) / h)),
            e && (e.zoomDelta = l),
            this.zoom(l, [t.zoomX, t.zoomY]),
            l
          );
        }),
        (this.pan = (t = [0, 0]) => {
          var e, i, n;
          const s =
            null !== (i = null === (e = this._projection) || void 0 === e ? void 0 : e.translate()) && void 0 !== i
              ? i
              : [0, 0];
          let r = s[0],
            a = s[1];
          (r += t[0]), (a += t[1]), null === (n = this._projection) || void 0 === n || n.translate([r, a]);
        });
    }
    get longitudeField() {
      return this._longitudeField;
    }
    get latitudeField() {
      return this._latitudeField;
    }
    get projectionSpec() {
      return this._projectionSpec;
    }
    setProjection(t) {
      this._projectionSpec = Object.assign(Object.assign({}, t), { name: this._projectionSpec.name });
    }
    getScale() {
      return this._actualScale;
    }
    static createComponent(t, e) {
      if (l(t)) return null;
      const i = [];
      return (
        t.region.forEach((t, n) => {
          if ('geo' === t.coordinate) {
            const s = Object.assign(Object.assign({}, t), { padding: 0 }),
              r = new x7(s, e);
            (r._regions = e.getRegionsInIndex([n])), i.push(r);
          }
        }),
        i
      );
    }
    setAttrFromSpec() {
      var t, e;
      super.setAttrFromSpec(),
        this._spec.roam && this.initZoomable(this.event, this._option.mode),
        (this._projectionSpec = _J(this._projectionSpec, this._spec.projection)),
        this._projectionSpec.zoom > (null === (t = this._spec.zoomLimit) || void 0 === t ? void 0 : t.max) &&
          (this._projectionSpec.zoom = this._spec.zoomLimit.max),
        this._projectionSpec.zoom < (null === (e = this._spec.zoomLimit) || void 0 === e ? void 0 : e.min) &&
          (this._projectionSpec.zoom = this._spec.zoomLimit.min),
        (this._longitudeField = this._spec.longitudeField),
        (this._latitudeField = this._spec.latitudeField);
    }
    created() {
      super.created(), this.initProjection(), this.coordinateHelper(), this.initEvent(), this._initCenterCache();
    }
    dispatchZoom(t, e) {
      const i = e || {
          x: this.getLayoutStartPoint().x + this.getLayoutRect().width / 2,
          y: this.getLayoutStartPoint().y + this.getLayoutRect().height / 2
        },
        n = this._handleChartZoom({ zoomDelta: t, zoomX: i.x, zoomY: i.y });
      1 !== n && this.event.emit('zoom', { scale: n, scaleCenter: i, model: this });
    }
    initEvent() {
      this.event.on(
        Gq.scaleUpdate,
        { filter: ({ model: t }) => (null == t ? void 0 : t.id) === this.id },
        this.effect.scaleUpdate.bind(this)
      ),
        this._spec.roam &&
          (this.initZoomEventOfRegions(this._regions, null, this._handleChartZoom),
          this.initDragEventOfRegions(this._regions, () => !0, this.pan),
          this._regions.forEach(t => {
            t.getSeries().forEach(t => {
              t.event.on('zoom', e => (t.handleZoom(e), !0)), t.event.on('panmove', e => (t.handlePan(e), !0));
            });
          }));
    }
    initProjection() {
      var t;
      (this._projection = new _7(this._projectionSpec)),
        null !== this._projection.projection ||
          null === (t = this._option) ||
          void 0 === t ||
          t.onError('unsupported projection type!');
    }
    coordinateHelper() {
      const t = {
        longitudeField: this._longitudeField,
        latitudeField: this._latitudeField,
        dataToPosition: this.dataToPosition.bind(this),
        dataToLongitude: this.dataToLongitude.bind(this),
        dataToLatitude: this.dataToLatitude.bind(this),
        shape: this.shape.bind(this),
        getCoordinateId: () => this.id
      };
      this._regions.forEach(e => {
        e.getSeries().forEach(e => {
          e.type === DZ.map
            ? e.setCoordinateHelper(t)
            : (e.setXAxisHelper(
                Object.assign(Object.assign({}, t), {
                  isContinuous: !0,
                  dataToPosition: (t, i) => {
                    var n;
                    let s = t[0];
                    if (l(s) && (null == i ? void 0 : i.datum)) {
                      const t = i.datum[e.getDimensionField()[0]];
                      s = null === (n = this._centerCache.get(t)) || void 0 === n ? void 0 : n.x;
                    }
                    return this.dataToLongitude(s);
                  },
                  valueToPosition: (t, i) => {
                    var n;
                    if (l(t) && (null == i ? void 0 : i.datum)) {
                      const s = i.datum[e.getDimensionField()[0]];
                      t = null === (n = this._centerCache.get(s)) || void 0 === n ? void 0 : n.x;
                    }
                    return this.dataToLongitude(t);
                  },
                  getFields: () => [this._longitudeField],
                  getAxisType: () => this.type,
                  getAxisId: () => this.id,
                  isInverse: () => !1
                })
              ),
              e.setYAxisHelper(
                Object.assign(Object.assign({}, t), {
                  isContinuous: !0,
                  dataToPosition: (t, i) => {
                    var n;
                    let s = t[0];
                    if (l(s) && (null == i ? void 0 : i.datum)) {
                      const t = i.datum[e.getDimensionField()[0]];
                      s = null === (n = this._centerCache.get(t)) || void 0 === n ? void 0 : n.y;
                    }
                    return this.dataToLatitude(s);
                  },
                  valueToPosition: (t, i) => {
                    var n;
                    if (l(t) && (null == i ? void 0 : i.datum)) {
                      const s = i.datum[e.getDimensionField()[0]];
                      t = null === (n = this._centerCache.get(s)) || void 0 === n ? void 0 : n.y;
                    }
                    return this.dataToLatitude(t);
                  },
                  getFields: () => [this._latitudeField],
                  getAxisType: () => this.type,
                  getAxisId: () => this.id,
                  isInverse: () => !1
                })
              ));
        });
      });
    }
    onLayoutEnd(t) {
      this.setLayoutRect(this._regions[0].getLayoutRect()),
        this.setLayoutStartPosition(this._regions[0].getLayoutStartPoint());
      const { width: e, height: i } = this.getLayoutRect();
      if (this._evaluated) {
        const t = (e - this._lastWidth) / 2,
          n = (i - this._lastHeight) / 2;
        this.pan([t, n]),
          tV(this._regions, e => {
            e.type === DZ.map && e.handlePan({ delta: [t, n] });
          });
      } else {
        const { translate: t, scale: n, center: s } = this.evaluateProjection([0, 0], [e, i]);
        t && this._projection.translate(t),
          n && this._projection.scale(n),
          s && this._projection.center(s),
          (this._evaluated = !0);
      }
      (this._lastWidth = e), (this._lastHeight = i), super.onLayoutEnd(t);
    }
    onRender(t) {}
    changeRegions(t) {}
    collectFeatures() {
      const t = [];
      return (
        this._regions.forEach(e => {
          e.getSeries().forEach(e => {
            var i, n;
            e.type === DZ.map &&
              t.push(
                ...(null !== (n = null === (i = e.getMapViewData()) || void 0 === i ? void 0 : i.latestData) &&
                void 0 !== n
                  ? n
                  : [])
              );
          });
        }),
        t
      );
    }
    dataToPosition(t = []) {
      var e;
      const i = null === (e = this._projection) || void 0 === e ? void 0 : e.project([t[0], t[1]]);
      return { x: null == i ? void 0 : i[0], y: null == i ? void 0 : i[1] };
    }
    dataToLatitude(t) {
      var e;
      const i = null === (e = this._projection) || void 0 === e ? void 0 : e.project([0, t]);
      return null == i ? void 0 : i[1];
    }
    dataToLongitude(t) {
      var e;
      const i = null === (e = this._projection) || void 0 === e ? void 0 : e.project([t, 0]);
      return null == i ? void 0 : i[0];
    }
    zoom(t, e = [0, 0]) {
      var i, n, s, r, a, o;
      let l =
        null !== (n = null === (i = this._projection) || void 0 === i ? void 0 : i.scale()) && void 0 !== n ? n : 0;
      const h =
        null !== (r = null === (s = this._projection) || void 0 === s ? void 0 : s.translate()) && void 0 !== r
          ? r
          : [0, 0];
      let c = h[0],
        d = h[1];
      (l *= t),
        (c -= (e[0] - c) * (t - 1)),
        (d -= (e[1] - d) * (t - 1)),
        null === (a = this._projection) || void 0 === a || a.scale(l),
        null === (o = this._projection) || void 0 === o || o.translate([c, d]);
    }
    shape(t) {
      return this._projection.shape(t);
    }
    invert(t) {
      return this._projection.invert(t);
    }
    evaluateProjection(t, e) {
      var i;
      const n = this._projection.evaluate(t, e, this.collectFeatures());
      let s = n.translate();
      const r = n.scale() * (null !== (i = this._projectionSpec.zoom) && void 0 !== i ? i : 1),
        a = this._projectionSpec.center;
      return a && (s = [e[0] / 2, e[1] / 2]), { translate: s, scale: r, center: a };
    }
    _initCenterCache() {
      this._centerCache || (this._centerCache = new Map()),
        this._regions.forEach(t => {
          t.getSeries().forEach(t => {
            var e, i;
            if ('map' === t.type) {
              (null !== (i = null === (e = t.getMapViewData()) || void 0 === e ? void 0 : e.latestData) && void 0 !== i
                ? i
                : []
              ).forEach((e = {}) => {
                const i = e[t.getDimensionField()[0]] || e[_5],
                  { centroidX: n, centroidY: s } = e;
                i && h(n * s) && this._centerCache.set(i, { x: n, y: s });
              });
            }
          });
        });
    }
    release() {
      super.release(), this._centerCache && this._centerCache.clear(), (this._centerCache = null);
    }
  }
  (x7.type = xn.geoCoordinate), N(x7, z4);
  const S7 = {
      [t.RenderModeEnum['desktop-browser']]: {
        click: 'pointertap',
        hover: 'pointermove',
        hoverOut: 'pointerleave',
        clickOut: 'pointerleave'
      },
      [t.RenderModeEnum['desktop-miniApp']]: {
        click: 'pointertap',
        hover: 'pointermove',
        hoverOut: 'pointerleave',
        clickOut: 'pointerleave'
      },
      [t.RenderModeEnum['mobile-browser']]: {
        click: 'tap',
        hover: ['pointerdown', 'pointermove'],
        hoverOut: 'pointerleave',
        clickOut: 'pointerleave'
      },
      [t.RenderModeEnum.miniApp]: {
        click: 'tap',
        hover: ['pointerdown', 'pointermove'],
        hoverOut: 'pointerleave',
        clickOut: 'pointerleave'
      },
      [t.RenderModeEnum.lynx]: {
        click: 'tap',
        hover: ['pointerdown', 'pointermove'],
        hoverOut: 'pointerleave',
        clickOut: 'pointerleave'
      }
    },
    w7 = { x: ['top', 'bottom'], y: ['left', 'right'], category: ['angle'], value: ['radius'] };
  class A7 extends g6 {
    get enableRemain() {
      return 'none' === this.triggerOff;
    }
    constructor(t, e) {
      super(t, Object.assign({}, e)),
        (this.layoutType = 'absolute'),
        (this.gridZIndex = cZ.CrossHair_Grid),
        (this.labelZIndex = cZ.CrossHair),
        (this.trigger = 'hover'),
        (this.triggerOff = 'hover'),
        (this._handleEvent = yt(t => {
          const { event: e } = t,
            i = e.viewX - this.getLayoutStartPoint().x,
            n = e.viewY - this.getLayoutStartPoint().y;
          (this.showDefault = !1), this._layoutCrosshair(i, n);
        }, 10)),
        (this.enable = !0),
        (this.showDefault = !0);
    }
    _getLimitBounds() {
      var t, e;
      if (!this._limitBounds) {
        const { width: i, height: n } =
          null !==
            (e = null === (t = this._option.globalInstance.getChart()) || void 0 === t ? void 0 : t.getCanvasRect()) &&
          void 0 !== e
            ? e
            : { width: 0, height: 0 };
        this._limitBounds = { x1: 0, y1: 0, x2: i, y2: n };
      }
      return this._limitBounds;
    }
    setAttrFromSpec() {
      super.setAttrFromSpec(), (this._crosshairConfig = this._spec), this._parseCrosshairSpec();
    }
    created() {
      super.created(), this._initEvent();
    }
    updateSpec(t) {
      const e = super.updateSpec(t);
      return (e.reRender = !0), (e.reMake = !0), e;
    }
    _initEvent() {
      if (this._getTriggerEvent()) {
        const { in: t, out: e } = this._getTriggerEvent();
        f(t) ? t.forEach((t, i) => this._registerEvent(t, f(e) ? e[i] : e)) : this._registerEvent(t, e);
      }
    }
    _registerEvent(t, e) {
      this.event.on(t, { source: Uq.chart }, this._handleEvent),
        this.event.on(e, { level: Yq.chart }, (...t) => {
          this.enableRemain || this.hide();
        });
    }
    _eventOff(t) {
      this.event.off(t, this._handleEvent);
    }
    updateLayoutAttribute() {
      (this._limitBounds = null), this._showDefaultCrosshair();
    }
    _getTriggerEvent() {
      const { mode: e = t.RenderModeEnum['desktop-browser'] } = this._option;
      if (S7[e]) {
        const t = this.trigger || 'hover',
          i = t => ('click' === t ? 'clickOut' : 'hoverOut');
        if (f(t)) {
          let n = [],
            s = [];
          return (
            t.forEach(t => {
              (n = n.concat(S7[e][t])), (s = s.concat(S7[e][i(t)]));
            }),
            { in: n, out: s }
          );
        }
        return { in: S7[e][t], out: S7[e][i(t)] };
      }
      return null;
    }
    _getAxisInfoByField(t) {
      var e, i;
      const n =
        null === (i = null === (e = this._option) || void 0 === e ? void 0 : e.getComponentsByKey) || void 0 === i
          ? void 0
          : i.call(e, 'axes');
      if (!(null == n ? void 0 : n.length)) return null;
      let s = C(this._spec, `${t}Field.bindingAxesIndex`);
      if (
        (s ||
          ((s = []),
          n.forEach((e, i) => {
            w7[t].includes(e.getOrient()) && s.push(i);
          })),
        !s.length)
      )
        return null;
      const r = new Map();
      let a = 1 / 0,
        o = 1 / 0,
        l = -1 / 0,
        h = -1 / 0;
      const { x: c, y: d } = this.getLayoutStartPoint();
      return (
        s.forEach(t => {
          (a = 1 / 0), (o = 1 / 0), (l = -1 / 0), (h = -1 / 0);
          const e = n.find(e => e.getSpecIndex() === t);
          if (!e) return;
          e.getRegions().forEach(t => {
            (a = Math.min(a, t.getLayoutStartPoint().x - c)),
              (o = Math.min(o, t.getLayoutStartPoint().y - d)),
              (l = Math.max(l, t.getLayoutStartPoint().x + t.getLayoutRect().width - c)),
              (h = Math.max(h, t.getLayoutStartPoint().y + t.getLayoutRect().height - d));
          }),
            r.set(t, { x1: a, y1: o, x2: l, y2: h, axis: e });
        }),
        r
      );
    }
    changeRegions(t) {}
    onLayoutEnd(t) {
      this.setLayoutRect(this._regions[0].getLayoutRect()),
        this.setLayoutStartPosition(this._regions[0].getLayoutStartPoint()),
        super.onLayoutEnd(t);
    }
    onRender(t) {}
    _releaseEvent() {
      if (this._getTriggerEvent()) {
        const { in: t, out: e } = this._getTriggerEvent();
        f(t) ? t.forEach(t => this._eventOff(t)) : this._eventOff(t),
          f(e) ? e.forEach(t => this._eventOff(t)) : this._eventOff(e);
      }
    }
    _firstSeries() {
      for (let t = 0; t < this._regions.length; t++) {
        const e = this._regions[t].getSeries();
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          if (i) return i;
        }
      }
      return null;
    }
    _parseCrosshairSpec() {
      this._parseFieldInfo();
      const { trigger: t, triggerOff: e, labelZIndex: i, gridZIndex: n } = this._crosshairConfig;
      t && (this.trigger = t),
        (this.triggerOff = e || this.trigger),
        void 0 !== i && (this.labelZIndex = i),
        void 0 !== n && (this.gridZIndex = n);
    }
    _parseField(t, e) {
      var i, n, s, r;
      const o = {},
        { line: l, label: h, visible: c } = t;
      (o.visible = c), (o.type = (null == l ? void 0 : l.type) || 'line');
      const d = (null == l ? void 0 : l.style) || {},
        { strokeOpacity: u, fillOpacity: p, opacity: g, stroke: f, fill: v, lineWidth: m } = d,
        _ = mn(d, ['strokeOpacity', 'fillOpacity', 'opacity', 'stroke', 'fill', 'lineWidth']),
        b = 'line' === o.type;
      let x = b ? u : p;
      if (
        (y(g) && (x = (null != x ? x : 1) * g),
        (o.style = Object.assign(
          { opacity: x, pickable: !1, visible: !a(null == l ? void 0 : l.visible) || l.visible },
          _
        )),
        b)
      )
        (o.style.stroke = f || v), (o.style.lineWidth = (null == l ? void 0 : l.width) || m || 2);
      else if (
        ((o.style.fill = v || f),
        (null ===
          (s =
            null === (n = null === (i = this._originalSpec[e]) || void 0 === i ? void 0 : i.line) || void 0 === n
              ? void 0
              : n.style) || void 0 === s
          ? void 0
          : s.stroke) && (o.style.stroke = this._originalSpec[e].line.style.stroke),
        'string' == typeof l.width)
      ) {
        const t = parseInt(l.width.substring(0, l.width.length - 1), 10) / 100;
        o.style.sizePercent = t;
      } else 'number' == typeof (null == l ? void 0 : l.width) && (o.style.size = l.width);
      const S = null == h ? void 0 : h.labelBackground,
        w = (null == h ? void 0 : h.style) || {},
        A = (null == S ? void 0 : S.style) || {},
        { fill: k = 'rgba(47, 59, 82, 0.9)', stroke: M } = A,
        T = mn(A, ['fill', 'stroke']);
      return (
        (o.label = {
          visible: !!(null == h ? void 0 : h.visible),
          formatMethod: null == h ? void 0 : h.formatMethod,
          minWidth: null == S ? void 0 : S.minWidth,
          maxWidth: null == S ? void 0 : S.maxWidth,
          padding: null == S ? void 0 : S.padding,
          textStyle: Object.assign(Object.assign({ fontSize: 14, pickable: !1 }, w), {
            fill: null !== (r = null == w ? void 0 : w.fill) && void 0 !== r ? r : '#fff',
            stroke: C(w, 'stroke')
          }),
          panel: Object.assign(
            {
              visible: a(null == S ? void 0 : S.visible) ? (null == S ? void 0 : S.visible) : !!S,
              pickable: !1,
              fill: k,
              stroke: M
            },
            T
          ),
          zIndex: this.labelZIndex,
          childrenPickable: !1,
          pickable: !1
        }),
        o
      );
    }
    _filterAxisByPoint(t, e, i) {
      return (
        t &&
          t.forEach((n, s) => {
            const r = n.axis;
            var a, o, l;
            if (
              ((o = e),
              (l = i),
              ((a = n).x1 > o || a.x2 < o || a.y1 > l || a.y2 < l) && t.delete(r.getSpecIndex()),
              r.type.startsWith('polarAxis'))
            ) {
              const n = r.getCenter(),
                s = r.getInnerRadius(),
                a = r.getOuterRadius(),
                o = Yt.distancePP({ x: e, y: i }, n);
              (o > a || o < s) && t.delete(r.getSpecIndex());
            }
          }),
        t
      );
    }
  }
  var k7, M7;
  !(function (t) {
    (t[(t.ALL = 3)] = 'ALL'),
      (t[(t.HORIZONTAL = 2)] = 'HORIZONTAL'),
      (t[(t.VERTICAL = 1)] = 'VERTICAL'),
      (t[(t.NONE = 0)] = 'NONE');
  })(k7 || (k7 = {}));
  class T7 extends A7 {
    static createComponent(t, e) {
      const i = t.crosshair || e.defaultSpec;
      if (l(i)) return;
      if (!f(i))
        return i.xField || i.yField ? new T7(i, Object.assign(Object.assign({}, e), { specKey: 'crosshair' })) : void 0;
      const n = [];
      return (
        i.forEach((t, i) => {
          (t.xField || t.yField) &&
            n.push(new T7(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: 'crosshair' })));
        }),
        n
      );
    }
    constructor(t, e) {
      super(t, Object.assign({}, e)),
        (this.type = xn.cartesianCrosshair),
        (this.name = xn.cartesianCrosshair),
        (this.currValueX = new Map()),
        (this.currValueY = new Map());
    }
    _showDefaultCrosshair() {
      if (!this.showDefault) return;
      const { xField: t = {}, yField: e = {} } = this._spec;
      if ((null == t ? void 0 : t.visible) && t.defaultSelect) {
        const { axisIndex: e, datum: i } = t.defaultSelect;
        this.defaultCrosshair(e, i, k7.VERTICAL, !0), this.layoutByValue(k7.VERTICAL);
      }
      if ((null == e ? void 0 : e.visible) && e.defaultSelect) {
        const { axisIndex: t, datum: i } = e.defaultSelect;
        this.defaultCrosshair(t, i, k7.HORIZONTAL, !1), this.layoutByValue(k7.HORIZONTAL);
      }
    }
    defaultCrosshair(t, e, i, n) {
      const s = this._option.getComponentsByKey('axes').find(e => e.getSpecIndex() === t);
      s &&
        (n
          ? (this.currValueX.clear(), this.currValueX.set(t, { axis: s, v: e }))
          : (this.currValueY.clear(), this.currValueY.set(t, { axis: s, v: e })));
    }
    findAllAxisContains(t, e) {
      const i = this._getAxisInfoByField('x'),
        n = this._getAxisInfoByField('y');
      return { xAxisMap: this._filterAxisByPoint(i, t, e), yAxisMap: this._filterAxisByPoint(n, t, e) };
    }
    getValueAt(t, e) {
      let i = t.getScale().invert(e);
      return Zo(t.getScale().type) && _(+i) && (i = (+i).toFixed(2)), i;
    }
    clearAxisValue() {
      this.currValueX.clear(), this.currValueY.clear();
    }
    setAxisValue(t, e) {
      tQ(e.getOrient()), this.currValueX.set(e.getSpecIndex(), { v: t, axis: e });
    }
    getAllAxisValues(t, e, i, n) {
      let s = !1;
      return (
        t.forEach(t => {
          Qo(t.axis.getScale().type) && (s ? (this.enable = !1) : (s = !0));
        }),
        !!this.enable &&
          (t.forEach((t, s) => {
            const r = t.axis;
            i.set(s, {
              v: this.getValueAt(
                r,
                e -
                  (n
                    ? r.getLayoutStartPoint().x - this.getLayoutStartPoint().x
                    : r.getLayoutStartPoint().y - this.getLayoutStartPoint().y)
              ),
              axis: r
            });
          }),
          !0)
      );
    }
    _layoutCrosshair(t, e) {
      const { xAxisMap: i, yAxisMap: n } = this.findAllAxisContains(t, e);
      if (i && 0 === i.size && n && 0 === n.size) {
        if (this.enableRemain) return;
        this.hide();
      } else this.currValueX.clear(), this.currValueY.clear(), i && i.size && this.getAllAxisValues(i, t, this.currValueX, !0), n && n.size && this.getAllAxisValues(n, e, this.currValueY, !1), this.layoutByValue(k7.ALL);
    }
    hide() {
      this._xCrosshair && this._xCrosshair.hideAll(),
        this._xTopLabel && this._xTopLabel.hideAll(),
        this._xBottomLabel && this._xBottomLabel.hideAll(),
        this._yCrosshair && this._yCrosshair.hideAll(),
        this._yLeftLabel && this._yLeftLabel.hideAll(),
        this._yRightLabel && this._yRightLabel.hideAll();
    }
    layoutByValue(t = k7.ALL) {
      var e, i, n, s;
      if (!this.enable) return;
      const r = this._firstSeries();
      if (!r) return;
      let a = {
          height: 0,
          leftPos: 0,
          topPos: 0,
          x: 0,
          bottom: { visible: !1, text: '', dx: 0, dy: 0 },
          top: { visible: !1, text: '', dx: 0, dy: 0 },
          visible: !1
        },
        o = {
          width: 0,
          leftPos: 0,
          topPos: 0,
          y: 0,
          left: { visible: !1, text: '', dx: 0, dy: 0 },
          right: { visible: !1, text: '', dx: 0, dy: 0 },
          visible: !1
        };
      const l = (t, e) => {
        e.forEach(({ axis: e }) => {
          e.getRegions().forEach(e => {
            (t.x1 = Math.min(t.x1, e.getLayoutStartPoint().x)),
              (t.y1 = Math.min(t.y1, e.getLayoutStartPoint().y)),
              (t.x2 = Math.max(t.x2, e.getLayoutStartPoint().x + e.getLayoutRect().width)),
              (t.y2 = Math.max(t.y2, e.getLayoutStartPoint().y + e.getLayoutRect().height));
          });
        });
      };
      let c = 0,
        d = 0;
      if (this.currValueX.size) {
        const t = Array.from(this.currValueX.values())[0];
        c = t.axis.getScale().scale(t.v) + t.axis.getLayoutStartPoint().x - this.getLayoutStartPoint().x;
      }
      if (this.currValueY.size) {
        const t = Array.from(this.currValueY.values())[0];
        d = t.axis.getScale().scale(t.v) + t.axis.getLayoutStartPoint().y - this.getLayoutStartPoint().y;
      }
      (a.visible = !!this.currValueX.size && Number.isFinite(c)),
        (o.visible = !!this.currValueY.size && Number.isFinite(d));
      const u = { x1: 1 / 0, y1: 1 / 0, x2: -1 / 0, y2: -1 / 0 },
        p = { x1: 1 / 0, y1: 1 / 0, x2: -1 / 0, y2: -1 / 0 };
      let g, f;
      if (
        (l(u, this.currValueX),
        l(p, this.currValueY),
        this.xHair &&
          this.currValueX.forEach(({ axis: t, v: e }) => {
            var i, n, s;
            e = null != e ? e : '';
            const o = t.getScale();
            if (Qo(o.type)) {
              const e = o._step;
              g = t
                ? null === (n = (i = r.getXAxisHelper()).getBandwidth) || void 0 === n
                  ? void 0
                  : n.call(i, 0)
                : e;
            } else if (Zo(o.type)) {
              const t = r.fieldX[0],
                i = r.fieldX2,
                n = c6(r.getViewData().latestData, +e, t, i);
              if (n) {
                const s = r.dataToPositionX(n);
                i ? ((g = Math.abs(s - r.dataToPositionX1(n))), (e = `${n[t]} ~ ${n[i]}`)) : (g = 1), (c = s);
              }
            }
            if (null === (s = this.xHair.label) || void 0 === s ? void 0 : s.visible) {
              const i = G3(t.getSpec());
              'bottom' === t.getOrient()
                ? ((a.bottom.visible = !0), (a.bottom.text = e), (a.bottom.dx = 0), (a.bottom.dy = i))
                : 'top' === t.getOrient() && ((a.top.visible = !0), (a.top.text = e), (a.top.dx = 0), (a.top.dy = -i));
            }
          }),
        this.yHair &&
          this.currValueY.forEach(({ axis: t, v: e }) => {
            var i, n, s;
            e = null != e ? e : '';
            const a = t.getScale();
            if (Qo(a.type)) {
              const t = a._step;
              f = a
                ? null === (n = (i = r.getYAxisHelper()).getBandwidth) || void 0 === n
                  ? void 0
                  : n.call(i, 0)
                : t;
            } else if (Zo(a.type)) {
              const t = r.fieldY[0],
                i = r.fieldY2,
                n = c6(r.getViewData().latestData, +e, t, i);
              if (n) {
                const s = r.dataToPositionY(n);
                i ? ((f = Math.abs(s - r.dataToPositionY1(n))), (e = `${n[t]} ~ ${n[i]}`)) : (f = 1), (d = s);
              }
            }
            if (null === (s = this.yHair.label) || void 0 === s ? void 0 : s.visible) {
              const i = G3(t.getSpec());
              'left' === t.getOrient()
                ? ((o.left.visible = !0), (o.left.text = e), (o.left.dx = -i), (o.left.dy = 0))
                : 'right' === t.getOrient() &&
                  ((o.right.visible = !0), (o.right.text = e), (o.right.dx = i), (o.right.dy = 0));
            }
          }),
        this.enableRemain && !a.visible && h(this._cacheXCrossHairInfo))
      )
        a = this._cacheXCrossHairInfo;
      else if (
        ((a.leftPos = u.x1),
        (a.topPos = u.y1),
        (a.height = u.y2 - u.y1),
        (a.x = c + this.getLayoutStartPoint().x),
        null === (i = null === (e = this.xHair) || void 0 === e ? void 0 : e.label) || void 0 === i
          ? void 0
          : i.formatMethod)
      ) {
        const { top: t, bottom: e } = a;
        e.visible && (e.text = this.xHair.label.formatMethod(e.text, 'bottom')),
          t.visible && (t.text = this.xHair.label.formatMethod(t.text, 'top'));
      }
      if (this.enableRemain && !o.visible && h(this._cacheYCrossHairInfo)) o = this._cacheYCrossHairInfo;
      else if (
        ((o.leftPos = p.x1),
        (o.topPos = p.y1),
        (o.width = p.x2 - p.x1),
        (o.y = d + this.getLayoutStartPoint().y),
        null === (s = null === (n = this.yHair) || void 0 === n ? void 0 : n.label) || void 0 === s
          ? void 0
          : s.formatMethod)
      ) {
        const { left: t, right: e } = o;
        t.visible && (t.text = this.yHair.label.formatMethod(t.text, 'left')),
          e.visible && (e.text = this.yHair.label.formatMethod(e.text, 'right'));
      }
      t &&
        (k7.HORIZONTAL && this._layoutHorizontal(o, null != f ? f : 0),
        k7.VERTICAL && this._layoutVertical(a, null != g ? g : 0)),
        this.enableRemain &&
          ((this._cacheXCrossHairInfo = Object.assign(Object.assign({}, a), { _isCache: !0 })),
          (this._cacheYCrossHairInfo = Object.assign(Object.assign({}, o), { _isCache: !0 })));
    }
    _layoutVertical(t, e) {
      var i, n, s, r, a, o;
      if ((t._isCache && this.enableRemain) || !this.xHair) return;
      const { x: l, topPos: h, height: c, top: d, bottom: u, visible: p } = t;
      if (p) {
        let t = 0;
        (
          null === (n = null === (i = this.xHair) || void 0 === i ? void 0 : i.style) || void 0 === n
            ? void 0
            : n.sizePercent
        )
          ? (t = (this.xHair.style.sizePercent - 1) * e)
          : 'number' ==
              typeof (null === (r = null === (s = this.xHair) || void 0 === s ? void 0 : s.style) || void 0 === r
                ? void 0
                : r.size) && (t = this.xHair.style.size - e);
        const p = this.xHair.type;
        let g;
        if (
          ('line' === p
            ? (g = { start: { x: l + e / 2 - t / 2, y: h }, end: { x: l + e / 2 + t / 2, y: h + c } })
            : 'rect' === p && (g = { start: { x: l - t / 2, y: h }, end: { x: l + e + t / 2, y: h + c } }),
          this._updateCrosshair('x', p, g),
          d.visible)
        ) {
          const t = Object.assign(Object.assign(Object.assign({ x: l + e / 2, y: h }, d), this.xHair.label), {
            textStyle: Object.assign(
              Object.assign({}, null === (a = this.xHair.label) || void 0 === a ? void 0 : a.textStyle),
              { textAlign: 'center', textBaseline: 'bottom' }
            ),
            zIndex: this.labelZIndex
          });
          this._updateCrosshairLabel(this._xTopLabel, t, t => {
            (t.name = 'crosshair-x-top-label'), (this._xTopLabel = t);
          });
        } else this._xTopLabel && this._xTopLabel.hideAll();
        if (u.visible) {
          const t = Object.assign(Object.assign(Object.assign({ x: l + e / 2, y: h + c }, u), this.xHair.label), {
            textStyle: Object.assign(
              Object.assign({}, null === (o = this.xHair.label) || void 0 === o ? void 0 : o.textStyle),
              { textAlign: 'center', textBaseline: 'top' }
            ),
            zIndex: this.labelZIndex
          });
          this._updateCrosshairLabel(this._xBottomLabel, t, t => {
            (t.name = 'crosshair-x-bottom-label'), (this._xBottomLabel = t);
          });
        } else this._xBottomLabel && this._xBottomLabel.hideAll();
      }
    }
    _layoutHorizontal(t, e) {
      var i, n, s, r, a, o;
      if ((t._isCache && this.enableRemain) || !this.yHair) return;
      const { leftPos: l, width: h, y: c, left: d, right: u, visible: p } = t;
      if (p) {
        let t = 0;
        (
          null === (n = null === (i = this.yHair) || void 0 === i ? void 0 : i.style) || void 0 === n
            ? void 0
            : n.sizePercent
        )
          ? (t = (this.yHair.style.sizePercent - 1) * e)
          : 'number' ==
              typeof (null === (r = null === (s = this.yHair) || void 0 === s ? void 0 : s.style) || void 0 === r
                ? void 0
                : r.size) && (t = this.yHair.style.size - e);
        const p = this.yHair.type;
        let g;
        if (
          ('line' === p
            ? (g = { start: { x: l, y: c + e / 2 }, end: { x: l + h, y: c + e / 2 } })
            : 'rect' === p && (g = { start: { x: l, y: c - t / 2 }, end: { x: l + h, y: c + e + t / 2 } }),
          this._updateCrosshair('y', p, g),
          d.visible)
        ) {
          const t = Object.assign(Object.assign(Object.assign({ x: l, y: c + e / 2 }, d), this.yHair.label), {
            textStyle: Object.assign(
              Object.assign({}, null === (a = this.yHair.label) || void 0 === a ? void 0 : a.textStyle),
              { textAlign: 'right', textBaseline: 'middle' }
            ),
            zIndex: this.labelZIndex
          });
          this._updateCrosshairLabel(this._yLeftLabel, t, t => {
            (t.name = 'crosshair-y-left-label'), (this._yLeftLabel = t);
          });
        } else this._yLeftLabel && this._yLeftLabel.hideAll();
        if (u.visible) {
          const t = Object.assign(Object.assign(Object.assign({ x: l + h, y: c + e }, u), this.yHair.label), {
            textStyle: Object.assign(
              Object.assign({}, null === (o = this.yHair.label) || void 0 === o ? void 0 : o.textStyle),
              { textAlign: 'left', textBaseline: 'middle' }
            ),
            zIndex: this.labelZIndex
          });
          this._updateCrosshairLabel(this._yRightLabel, t, t => {
            (t.name = 'crosshair-y-right-label'), (this._yRightLabel = t);
          });
        } else this._yRightLabel && this._yRightLabel.hideAll();
      }
    }
    _parseFieldInfo() {
      const { xField: t, yField: e } = this._crosshairConfig;
      t && t.visible && (this.xHair = this._parseField(t, 'xField')),
        e && e.visible && (this.yHair = this._parseField(e, 'yField'));
    }
    _updateCrosshair(t, e, i) {
      const n = this.getContainer();
      let s, r;
      'x' === t ? ((s = this._xCrosshair), (r = this.xHair.style)) : ((s = this._yCrosshair), (r = this.yHair.style)),
        s
          ? s.setAttributes(i)
          : ('line' === e
              ? (s = new YY(Object.assign(Object.assign({}, i), { lineStyle: r, zIndex: this.gridZIndex + 1 })))
              : 'rect' === e &&
                (s = new $Y(Object.assign(Object.assign({}, i), { rectStyle: r, zIndex: this.gridZIndex }))),
            null == n || n.add(s),
            'x' === t ? (this._xCrosshair = s) : (this._yCrosshair = s));
    }
    _updateCrosshairLabel(t, e, i) {
      const n = this.getContainer();
      t ? t.setAttributes(e) : (i((t = new BY(e))), n.add(t)), h6(t, this._getLimitBounds());
    }
    clear() {
      [
        this._xCrosshair,
        this._xTopLabel,
        this._xBottomLabel,
        this._yCrosshair,
        this._yLeftLabel,
        this._yRightLabel
      ].forEach(t => {
        var e;
        t && (null === (e = this._container) || void 0 === e || e.removeChild(t), (t = null));
      }),
        super.clear();
    }
  }
  (T7.type = xn.cartesianCrosshair),
    (function (t) {
      (t[(t.ALL = 3)] = 'ALL'),
        (t[(t.HORIZONTAL = 2)] = 'HORIZONTAL'),
        (t[(t.VERTICAL = 1)] = 'VERTICAL'),
        (t[(t.NONE = 0)] = 'NONE');
    })(M7 || (M7 = {}));
  class C7 extends A7 {
    static createComponent(t, e) {
      const i = t.crosshair || e.defaultSpec;
      if (l(i)) return;
      if (!f(i))
        return i.categoryField || i.valueField
          ? new C7(i, Object.assign(Object.assign({}, e), { specKey: 'crosshair' }))
          : void 0;
      const n = [];
      return (
        i.forEach((t, i) => {
          (t.categoryField || t.valueField) &&
            n.push(new C7(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: 'crosshair' })));
        }),
        n
      );
    }
    constructor(t, e) {
      super(t, Object.assign({}, e)),
        (this.type = xn.polarCrosshair),
        (this.name = xn.polarCrosshair),
        (this.currValueX = new Map()),
        (this.currValueY = new Map());
    }
    _showDefaultCrosshair() {
      this.showDefault;
    }
    hide() {
      this._radiusCrosshair && this._radiusCrosshair.hideAll(),
        this._radiusLabelCrosshair && this._radiusLabelCrosshair.hideAll(),
        this._angleCrosshair && this._angleCrosshair.hideAll(),
        this._angleLabelCrosshair && this._angleLabelCrosshair.hideAll();
    }
    findAllAxisContains(t, e) {
      const i = this._getAxisInfoByField('category'),
        n = this._getAxisInfoByField('value');
      return { xAxisMap: this._filterAxisByPoint(i, t, e), yAxisMap: this._filterAxisByPoint(n, t, e) };
    }
    getAllAxisValues(t, e, i) {
      let n = !1;
      return (
        t.forEach(t => {
          Qo(t.axis.getScale().type) && (n ? (this.enable = !1) : (n = !0));
        }),
        !!this.enable &&
          (t.forEach((t, n) => {
            const s = t.axis,
              { x: r, y: a } = t.axis.getLayoutStartPoint(),
              { x: o, y: l } = this.getLayoutStartPoint();
            let h = s.positionToData({ x: e.x - (r - o), y: e.y - (a - l) });
            Zo(s.getScale().type) && _(+h) && (h = (+h).toFixed(2));
            const c = {
              x: s.getCenter().x + this.getLayoutStartPoint().x,
              y: s.getCenter().y + this.getLayoutStartPoint().y
            };
            i.set(n, {
              v: h,
              axis: t.axis,
              center: c,
              innerRadius: s.getInnerRadius(),
              radius: s.getOuterRadius(),
              startAngle: s.startAngle,
              endAngle: s.endAngle,
              distance: Yt.distancePP(e, s.getCenter()),
              coord: s.pointToCoord(e),
              point: e
            });
          }),
          !0)
      );
    }
    _layoutCrosshair(t, e) {
      const { xAxisMap: i, yAxisMap: n } = this.findAllAxisContains(t, e);
      if (0 !== i.size || 0 !== n.size)
        this.currValueX.clear(),
          this.currValueY.clear(),
          i && this.getAllAxisValues(i, { x: t, y: e }, this.currValueX),
          n && this.getAllAxisValues(n, { x: t, y: e }, this.currValueY),
          this.layoutByValue(M7.ALL);
      else {
        if (this.enableRemain) return;
        this.hide();
      }
    }
    layoutByValue(t) {
      var e, i, n, s;
      if (!this.enable) return;
      const r = this._firstSeries();
      if (!r) return;
      let a = {
          x: 0,
          y: 0,
          center: { x: 0, y: 0 },
          radius: 0,
          distance: 0,
          startAngle: 0,
          endAngle: 0,
          innerRadius: 0,
          visible: !1,
          label: { visible: !1, text: '', offset: 0 }
        },
        o = {
          x: 0,
          y: 0,
          center: { x: 0, y: 0 },
          radius: 0,
          distance: 0,
          startAngle: 0,
          endAngle: 0,
          innerRadius: 0,
          visible: !1,
          sides: r.angleAxisHelper.getScale(0).ticks().length,
          label: { visible: !1, text: '', offset: 0 }
        };
      if (this.xHair) {
        a.visible = !!this.currValueX.size;
        const t = r.angleAxisHelper.getBandwidth(0);
        this.currValueX.forEach(e => {
          var i,
            { axis: n, v: s, coord: o } = e,
            l = mn(e, ['axis', 'v', 'coord']);
          (s = null != s ? s : ''), _J(a, l);
          const h = r.angleAxisHelper.dataToPosition([s]);
          (a.angle = h),
            (null === (i = this.xHair.label) || void 0 === i ? void 0 : i.visible) &&
              ((a.label.visible = !0), (a.label.text = s), (a.label.offset = G3(n.getSpec()))),
            (a.startAngle = h - t / 2),
            (a.endAngle = h + t / 2);
        });
      }
      if (
        (this.yHair &&
          ((o.visible = !!this.currValueY.size),
          this.currValueY.forEach(t => {
            var e,
              { axis: i, v: n, coord: s } = t,
              r = mn(t, ['axis', 'v', 'coord']);
            (n = null != n ? n : ''),
              (null === (e = this.yHair.label) || void 0 === e ? void 0 : e.visible) &&
                ((o.label.visible = !0), (o.label.text = n), (o.label.offset = G3(i.getSpec()))),
              (o.angle = s.angle),
              (o.axis = i),
              _J(o, r);
          })),
        this.enableRemain && !a.visible && h(this._cacheXCrossHairInfo))
      )
        a = this._cacheXCrossHairInfo;
      else if (
        (null === (i = null === (e = this.xHair) || void 0 === e ? void 0 : e.label) || void 0 === i
          ? void 0
          : i.formatMethod) &&
        a.label.visible
      ) {
        const { label: t } = a;
        t.text = this.xHair.label.formatMethod(t.text, 'angle');
      }
      if (this.enableRemain && !o.visible && h(this._cacheYCrossHairInfo)) o = this._cacheYCrossHairInfo;
      else if (
        (null === (s = null === (n = this.yHair) || void 0 === n ? void 0 : n.label) || void 0 === s
          ? void 0
          : s.formatMethod) &&
        o.label.visible
      ) {
        const { label: t } = o;
        t.text = this.yHair.label.formatMethod(t.text, 'radius');
      }
      t && (M7.HORIZONTAL && this._layoutHorizontal(o), M7.VERTICAL && this._layoutVertical(a)),
        this.enableRemain &&
          ((this._cacheXCrossHairInfo = Object.assign(Object.assign({}, a), { _isCache: !0 })),
          (this._cacheYCrossHairInfo = Object.assign(Object.assign({}, o), { _isCache: !0 })));
    }
    _layoutVertical(t) {
      var e;
      if (t._isCache && this.enableRemain) return;
      const i = this.getContainer(),
        { angle: n, innerRadius: s, radius: r, label: a, startAngle: o, endAngle: l, center: h, visible: c } = t;
      if (c) {
        const t = 'rect' === this.xHair.type ? 'sector' : 'line';
        let c;
        if (
          ((c =
            'sector' === t
              ? { center: h, innerRadius: s, radius: r, startAngle: o, endAngle: l }
              : { start: te(h, s, n), end: te(h, r, n) }),
          this._angleCrosshair)
        )
          this._angleCrosshair.setAttributes(c);
        else {
          let e;
          'line' === t
            ? (e = new YY(
                Object.assign(Object.assign({}, c), { lineStyle: this.xHair.style, zIndex: this.gridZIndex })
              ))
            : 'sector' === t &&
              (e = new KY(
                Object.assign(Object.assign({}, c), { sectorStyle: this.xHair.style, zIndex: this.gridZIndex })
              )),
            (this._angleCrosshair = e),
            i.add(e);
        }
        if (a.visible) {
          const t = IN(n),
            i = Object.assign(
              Object.assign(Object.assign(Object.assign({}, te(h, r + a.offset, n)), this.xHair.label), a),
              {
                textStyle: Object.assign(
                  Object.assign({}, null === (e = this.xHair.label) || void 0 === e ? void 0 : e.textStyle),
                  { textAlign: t.align, textBaseline: t.baseline }
                ),
                zIndex: this.labelZIndex
              }
            );
          this._updateCrosshairLabel(this._angleLabelCrosshair, i, t => {
            (t.name = 'crosshair-angle-label'), (this._angleLabelCrosshair = t);
          });
        } else this._angleLabelCrosshair && this._angleLabelCrosshair.hideAll();
      }
    }
    _layoutHorizontal(t) {
      var e;
      if (t._isCache && this.enableRemain) return;
      const {
          center: i,
          startAngle: n,
          endAngle: s,
          distance: r,
          sides: a,
          axis: o,
          label: l,
          point: h,
          radius: c,
          innerRadius: d,
          visible: u
        } = t,
        p = this.getContainer();
      if (u) {
        const t = this.yHair.smooth ? 'circle' : 'polygon';
        let u = r;
        if ('polygon' === t) {
          const t = o.getCenter(),
            e = ee(t, h),
            i = (s - n) / a,
            l = Math.floor((e - n) / i),
            p = l * i + n,
            g = Math.min((l + 1) * i + n, s),
            f = te(t, r, p),
            v = te(t, r, g),
            m = Te([v.x, v.y], [f.x, f.y], [t.x, t.y], [h.x, h.y]);
          m && (u = pt(Yt.distancePN(h, m[0], m[1]) + r, d, c));
        }
        const g = { center: i, startAngle: n, endAngle: s, radius: u, sides: a };
        if (this._radiusCrosshair) this._radiusCrosshair.setAttributes(g);
        else {
          let e;
          (e =
            'polygon' === t
              ? new qY(
                  Object.assign(Object.assign({}, g), { lineStyle: this.yHair.style, zIndex: this.gridZIndex + 1 })
                )
              : new XY(Object.assign(Object.assign({}, g), { lineStyle: this.yHair.style, zIndex: this.gridZIndex }))),
            (this._radiusCrosshair = e),
            p.add(e);
        }
        if (l.visible) {
          const t = (function (t) {
              let e = 'center',
                i = 'middle';
              return (
                (e =
                  (t = BN(t)) >= Math.PI * (7 / 6) && t <= Math.PI * (11 / 6)
                    ? 'right'
                    : t >= Math.PI * (1 / 6) && t <= Math.PI * (5 / 6)
                    ? 'left'
                    : 'center'),
                (i =
                  t >= Math.PI * (5 / 3) || t <= Math.PI * (1 / 3)
                    ? 'bottom'
                    : t >= Math.PI * (2 / 3) && t <= Math.PI * (4 / 3)
                    ? 'top'
                    : 'middle'),
                { align: e, baseline: i }
              );
            })(n),
            s = Object.assign(Object.assign(Object.assign(Object.assign({}, te(i, u, n)), this.yHair.label), l), {
              textStyle: Object.assign(
                Object.assign({}, null === (e = this.yHair.label) || void 0 === e ? void 0 : e.textStyle),
                { textAlign: t.align, textBaseline: t.baseline }
              ),
              zIndex: this.labelZIndex
            });
          this._updateCrosshairLabel(this._radiusLabelCrosshair, s, t => {
            (t.name = 'crosshair-radius-label'), (this._radiusLabelCrosshair = t);
          });
        } else this._radiusLabelCrosshair && this._radiusLabelCrosshair.hideAll();
      }
    }
    _parseFieldInfo() {
      var t;
      const { categoryField: e, valueField: i } = this._crosshairConfig;
      e && e.visible && (this.xHair = this._parseField(e, 'categoryField')),
        i &&
          i.visible &&
          ((this.yHair = this._parseField(i, 'valueField')),
          (this.yHair.smooth = null === (t = null == i ? void 0 : i.line) || void 0 === t ? void 0 : t.smooth));
    }
    _updateCrosshairLabel(t, e, i) {
      const n = this.getContainer();
      t ? t.setAttributes(e) : ((t = new BY(e)), n.add(t), i(t)), h6(t, this._getLimitBounds());
    }
    clear() {
      [(this._radiusCrosshair, this._radiusLabelCrosshair, this._angleCrosshair, this._angleLabelCrosshair)].forEach(
        t => {
          var e;
          t && (null === (e = this._container) || void 0 === e || e.removeChild(t), (t = null));
        }
      ),
        super.clear();
    }
  }
  C7.type = xn.polarCrosshair;
  const E7 = t => GJ(Object.assign({}, t)),
    P7 = t => Object.assign(Object.assign({}, t), { style: Object.assign({}, GJ(t.style)) }),
    R7 = t => {
      var e, i, n, s, r, a, o, l, h, c, d, u, p, g;
      const f = E7(
          null !== (i = null === (e = null == t ? void 0 : t.slider) || void 0 === e ? void 0 : e.trackStyle) &&
            void 0 !== i
            ? i
            : {}
        ),
        v = E7(
          null !== (s = null === (n = null == t ? void 0 : t.slider) || void 0 === n ? void 0 : n.railStyle) &&
            void 0 !== s
            ? s
            : {}
        ),
        m =
          ((y =
            null !== (a = null === (r = null == t ? void 0 : t.slider) || void 0 === r ? void 0 : r.handlerStyle) &&
            void 0 !== a
              ? a
              : {}),
          GJ(Object.assign({}, y)));
      var y;
      const _ = P7(
          null !== (l = null === (o = null == t ? void 0 : t.controller) || void 0 === o ? void 0 : o.start) &&
            void 0 !== l
            ? l
            : {}
        ),
        b = P7(
          null !== (c = null === (h = null == t ? void 0 : t.controller) || void 0 === h ? void 0 : h.pause) &&
            void 0 !== c
            ? c
            : {}
        ),
        x = P7(
          null !== (u = null === (d = null == t ? void 0 : t.controller) || void 0 === d ? void 0 : d.backward) &&
            void 0 !== u
            ? u
            : {}
        ),
        S = P7(
          null !== (g = null === (p = null == t ? void 0 : t.controller) || void 0 === p ? void 0 : p.forward) &&
            void 0 !== g
            ? g
            : {}
        );
      return Object.assign(Object.assign({}, t), {
        direction: t.direction,
        interval: t.interval,
        visible: t.visible,
        orient: t.orient,
        slider: Object.assign(Object.assign({}, t.slider), { trackStyle: f, railStyle: v, handlerStyle: m }),
        controller: Object.assign(Object.assign({}, t.controller), { start: _, pause: b, backward: x, forward: S })
      });
    },
    O7 = t => 'left' === t || 'right' === t,
    B7 = t => 'top' === t || 'bottom' === t;
  class I7 extends g6 {
    constructor() {
      super(...arguments),
        (this.layoutZIndex = cZ.Player),
        (this.layoutLevel = dZ.Player),
        (this.type = xn.player),
        (this.specKey = 'player'),
        (this._orient = 'bottom'),
        (this._getPlayerAttrs = () => {
          var t, e;
          const i = this._spec.type,
            n = {
              size: { width: this._width, height: this._height },
              dx: null !== (t = this._spec.dx) && void 0 !== t ? t : 0 + this._dx,
              dy: null !== (e = this._spec.dy) && void 0 !== e ? e : 0 + this._dy
            };
          return 'discrete' === i
            ? Object.assign(
                Object.assign(
                  {},
                  ((t, e) => Object.assign(Object.assign({}, R7(t)), { data: e, type: 'discrete' }))(
                    this._spec,
                    this._specs
                  )
                ),
                n
              )
            : Object.assign(
                Object.assign(
                  {},
                  ((t, e) => Object.assign(Object.assign({}, R7(t)), { data: e, type: 'continuous' }))(
                    this._spec,
                    this._specs
                  )
                ),
                n
              );
        }),
        (this._createOrUpdatePlayerComponent = () => {
          const t = Object.assign({}, this._getPlayerAttrs()),
            e = this.getContainer();
          this._playerComponent
            ? z(t, this._cacheAttrs) || ((this._cacheAttrs = t), this._playerComponent.setAttributes(t))
            : ('discrete' === t.type ? (this._playerComponent = new qX(t)) : (this._playerComponent = new QX(t)),
              (this._cacheAttrs = t),
              (this._playerComponent.name = 'player'),
              e.add(this._playerComponent),
              this._initEvent());
        }),
        (this._maxSize = () => {
          var t, e, i, n, s, r, a, o, l;
          return Math.max(
            ...V(
              null === (e = null === (t = this._spec.controller.start) || void 0 === t ? void 0 : t.style) ||
                void 0 === e
                ? void 0
                : e.size
            ),
            ...V(
              null === (n = null === (i = this._spec.controller.pause) || void 0 === i ? void 0 : i.style) ||
                void 0 === n
                ? void 0
                : n.size
            ),
            ...V(
              null === (r = null === (s = this._spec.controller.backward) || void 0 === s ? void 0 : s.style) ||
                void 0 === r
                ? void 0
                : r.size
            ),
            ...V(
              null === (o = null === (a = this._spec.controller.forward) || void 0 === a ? void 0 : a.style) ||
                void 0 === o
                ? void 0
                : o.size
            ),
            null !== (l = O7(this._orient) ? this._spec.slider.railStyle.width : this._spec.slider.railStyle.height) &&
              void 0 !== l
              ? l
              : 10
          );
        }),
        (this._sliderExceededSize = () => {
          var t, e, i, n, s, r, a, o, l;
          const h =
              null !==
                (t = O7(this._orient) ? this._spec.slider.railStyle.width : this._spec.slider.railStyle.height) &&
              void 0 !== t
                ? t
                : 10,
            c = Math.max(
              ...V(
                null === (i = null === (e = this._spec.controller.start) || void 0 === e ? void 0 : e.style) ||
                  void 0 === i
                  ? void 0
                  : i.size
              ),
              ...V(
                null === (s = null === (n = this._spec.controller.pause) || void 0 === n ? void 0 : n.style) ||
                  void 0 === s
                  ? void 0
                  : s.size
              ),
              ...V(
                null === (a = null === (r = this._spec.controller.backward) || void 0 === r ? void 0 : r.style) ||
                  void 0 === a
                  ? void 0
                  : a.size
              ),
              ...V(
                null === (l = null === (o = this._spec.controller.forward) || void 0 === o ? void 0 : o.style) ||
                  void 0 === l
                  ? void 0
                  : l.size
              )
            );
          return h >= c ? h - c : 0;
        }),
        (this._initEvent = () => {
          this._option.globalInstance.on(Gq.rendered, () => {
            this._spec.auto && this._playerComponent.play();
          }),
            this._playerComponent.addEventListener(UX.OnEnd, () => {
              this.event.emit(Gq.playerEnd, { model: this }),
                this._alternate &&
                  'discrete' === this._spec.type &&
                  ((this._direction = 'default' === this._direction ? 'reverse' : 'default'),
                  this._playerComponent.setAttributes({
                    direction: this._direction,
                    dataIndex: 'reverse' === this._direction ? this._specs.length - 2 : 1
                  })),
                this._spec.loop && this._playerComponent.play();
            }),
            this._playerComponent.addEventListener(UX.OnChange, t => {
              const { index: e } = t.detail,
                i = this._specs[e];
              V(i.data).forEach(t => {
                var e, i;
                null === (i = null === (e = this._option) || void 0 === e ? void 0 : e.globalInstance) ||
                  void 0 === i ||
                  i.updateData(t.id, t.values);
              }),
                this.event.emit(Gq.playerChange, { model: this, value: { spec: i, index: e, specs: this._specs } });
            }),
            this._playerComponent.addEventListener(UX.OnBackward, t => {
              const { index: e } = t.detail,
                i = this._specs[e];
              this.event.emit(Gq.playerBackward, { model: this, value: { spec: i, index: e, specs: this._specs } });
            }),
            this._playerComponent.addEventListener(UX.OnForward, t => {
              const { index: e } = t.detail,
                i = this._specs[e];
              this.event.emit(Gq.playerForward, { model: this, value: { spec: i, index: e, specs: this._specs } });
            }),
            this._playerComponent.addEventListener(UX.OnPlay, t => {
              const { index: e } = t.detail,
                i = this._specs[e];
              this.event.emit(Gq.playerPlay, { model: this, value: { spec: i, index: e, specs: this._specs } });
            }),
            this._playerComponent.addEventListener(UX.OnPause, t => {
              const { index: e } = t.detail,
                i = this._specs[e];
              this.event.emit(Gq.playerPause, { model: this, value: { spec: i, index: e, specs: this._specs } });
            });
        });
    }
    get orient() {
      return this._orient;
    }
    get layoutOrient() {
      return this._orient;
    }
    set layoutOrient(t) {
      this._orient = t;
    }
    setAttrFromSpec() {
      var t, e, i, n, s, r, a;
      super.setAttrFromSpec(),
        (this._orient = null !== (t = this._spec.orient) && void 0 !== t ? t : 'bottom'),
        (this._specs = null !== (e = this._spec.specs) && void 0 !== e ? e : []),
        (this._direction = null !== (i = this._spec.direction) && void 0 !== i ? i : 'default'),
        (this._alternate = null !== (n = this._spec.alternate) && void 0 !== n && n),
        (this._dx = null !== (s = this._spec.dx) && void 0 !== s ? s : 0),
        (this._dy = null !== (r = this._spec.dy) && void 0 !== r ? r : 0),
        (this._position = null !== (a = this._spec.position) && void 0 !== a ? a : 'middle');
    }
    setLayoutStartPosition(t) {
      if ((super.setLayoutStartPosition(t), _(t.x))) {
        const e = O7(this._orient) ? t.x + this._sliderExceededSize() / 2 : t.x;
        this._playerComponent && this._playerComponent.setAttribute('x', e);
      }
      if (_(t.y)) {
        const e = B7(this._orient) ? t.y + this._sliderExceededSize() / 2 : t.y;
        this._playerComponent && this._playerComponent.setAttribute('y', e);
      }
    }
    _boundsInRect(t, e) {
      (this._width = this._computeWidth(t)),
        (this._height = this._computeHeight(t)),
        (this._dx = this._computeDx(e)),
        (this._dy = this._computeDy(e));
      const i = this._computeLayoutRect(t, this._width, this._height);
      return this._createOrUpdatePlayerComponent(), i;
    }
    changeRegions(t) {}
    onRender(t) {}
    clear() {
      super.clear(), (this._playerComponent = null);
    }
    _computeLayoutRect(t, e, i) {
      switch (this._orient) {
        case 'top':
        case 'left':
          return { x1: 0, y1: 0, x2: e, y2: i };
        case 'right':
          return { x1: t.width - e, y1: 0, x2: t.width, y2: t.height };
        default:
          return { x1: 0, y1: t.height - i, x2: t.width, y2: t.height };
      }
    }
    _computeWidth(t) {
      return y(this._spec.width)
        ? Math.min(t.width, Number(this._spec.width))
        : O7(this._orient)
        ? this._maxSize()
        : t.width;
    }
    _computeHeight(t) {
      return y(this._spec.height)
        ? ((this._height = this._spec.height), Math.min(t.height, Number(this._spec.height)))
        : B7(this._orient)
        ? this._maxSize()
        : t.height;
    }
    _computeDx(t) {
      return O7(this._orient) || 'start' === this._position
        ? 0
        : 'middle' === this._position
        ? (t.width - this._width) / 2
        : t.width - this._width;
    }
    _computeDy(t) {
      return B7(this._orient) || 'start' === this._position
        ? 0
        : 'middle' === this._position
        ? (t.height - this._height) / 2
        : t.height - this._height;
    }
  }
  (I7.type = xn.player),
    (I7.createComponent = (t, e) => {
      const i = t.player;
      return l(i) || !1 === i.visible ? null : new I7(i, e);
    });
  const D7 = (t, e) => $N(t[0].latestData, e.field),
    L7 = (t, e) => XN(t[0].latestData, e.field);
  function F7(t, e) {
    return KN(t[0].latestData, e.field);
  }
  function j7(t, e) {
    return qN(t[0].latestData, e.field);
  }
  function z7(t, e) {
    return ZN(t[0].latestData, e.field);
  }
  function H7(t, e) {
    return (function (t, e) {
      return Math.sqrt(ZN(t, e));
    })(t[0].latestData, e.field);
  }
  function N7(t, e) {
    return (function (t, e) {
      return Q(t.map(t => t[e]));
    })(t[0].latestData, e.field);
  }
  function V7(t, e) {
    const i = { min: D7, max: L7, sum: F7, average: j7, variance: z7, standardDeviation: H7, median: N7 },
      n = [];
    return (
      e.forEach(e => {
        const s = { x: null, y: null },
          r = e.getRelativeSeries().getData().getLatestData(),
          a = e.getStartRelativeSeries().getData().getLatestData(),
          l = e.getEndRelativeSeries().getData().getLatestData();
        if (h(e.x)) {
          let n = e.x;
          if ((o(n) && (n = n(r, a, l)), 'string' == typeof n || 'number' == typeof n)) s.x = n;
          else {
            const { aggrType: e, field: r } = n;
            s.x = i[e](t, { field: r });
          }
        }
        if (h(e.y)) {
          let n = e.y;
          if ((o(n) && (n = n(r, a, l)), 'string' == typeof n || 'number' == typeof n)) s.y = n;
          else {
            const { aggrType: e, field: r } = n;
            s.y = i[e](t, { field: r });
          }
        }
        e.getRefRelativeSeries && (s.getRefRelativeSeries = e.getRefRelativeSeries), n.push(s);
      }),
      n
    );
  }
  function W7(t, e, i, n, s) {
    const r = e.getRegion(),
      a = r.getLayoutStartPoint(),
      o = i.getRegion(),
      l = o.getLayoutStartPoint(),
      c = [],
      d = t.latestData[0].latestData ? t.latestData[0].latestData : t.latestData,
      u = n.getXAxisHelper().getScale(0).domain();
    return (
      d.forEach(t => {
        var e, i;
        if (h(t.x)) {
          y(t.x) &&
            Y7(u, t.x, s) &&
            (null === (i = null == n ? void 0 : (e = n.getXAxisHelper()).setExtendDomain) ||
              void 0 === i ||
              i.call(e, 'marker_xAxis_extend', t.x));
          const h = n.getXAxisHelper().dataToPosition([t.x]) + a.x,
            d = Math.max(a.y + r.getLayoutRect().height, l.y + o.getLayoutRect().height),
            p = Math.min(a.y, l.y);
          c.push([
            { x: h, y: d },
            { x: h, y: p }
          ]);
        }
      }),
      c
    );
  }
  function G7(t, e, i, n, s) {
    const r = e.getRegion(),
      a = r.getLayoutStartPoint(),
      o = i.getRegion(),
      l = o.getLayoutStartPoint(),
      c = [],
      d = t.latestData[0].latestData ? t.latestData[0].latestData : t.latestData,
      u = n.getYAxisHelper().getScale(0).domain();
    return (
      d.forEach(t => {
        var e, i;
        if (h(t.y)) {
          y(t.y) &&
            Y7(u, t.y, s) &&
            (null === (i = null === (e = n.getYAxisHelper()) || void 0 === e ? void 0 : e.setExtendDomain) ||
              void 0 === i ||
              i.call(e, 'marker_yAxis_extend', t.y));
          const h = Math.min(a.x, l.x),
            d = n.getYAxisHelper().dataToPosition([t.y]) + a.y,
            p = Math.max(a.x + r.getLayoutRect().width, l.x + o.getLayoutRect().width);
          c.push([
            { x: h, y: d },
            { x: p, y: d }
          ]);
        }
      }),
      c
    );
  }
  function U7(t, e, i) {
    const n = [];
    return (
      (t.latestData[0].latestData ? t.latestData[0].latestData : t.latestData).forEach(t => {
        var s, r, a, o;
        const l = (null == t ? void 0 : t.getRefRelativeSeries) ? t.getRefRelativeSeries() : e,
          h = l.getRegion().getLayoutStartPoint(),
          c = l.getXAxisHelper().getScale(0).domain(),
          d = l.getYAxisHelper().getScale(0).domain();
        y(t.x) &&
          Y7(c, t.x, i) &&
          (null === (r = null === (s = l.getXAxisHelper()) || void 0 === s ? void 0 : s.setExtendDomain) ||
            void 0 === r ||
            r.call(s, 'marker_xAxis_extend', t.x)),
          y(t.y) &&
            Y7(d, t.y, i) &&
            (null === (o = null === (a = l.getYAxisHelper()) || void 0 === a ? void 0 : a.setExtendDomain) ||
              void 0 === o ||
              o.call(a, 'marker_yAxis_extend', t.y)),
          n.push({
            x: l.getXAxisHelper().dataToPosition([t.x]) + h.x,
            y: l.getYAxisHelper().dataToPosition([t.y]) + h.y
          });
      }),
      n
    );
  }
  function Y7(t, e, i) {
    if (!i) return !1;
    const n = Math.min(...t),
      s = Math.max(...t);
    return e < n || e > s;
  }
  const $7 = ['sum', 'average', 'min', 'max', 'variance', 'standardDeviation', 'median'];
  class X7 extends g6 {
    constructor() {
      super(...arguments), (this.layoutType = 'absolute');
    }
    created() {
      super.created(), this.initEvent(), this._bindSeries(), this._initDataView();
    }
    _isSpecAggr(t) {
      return $7.includes(t);
    }
    _getAllRelativeSeries() {
      return {
        getRelativeSeries: () => this._relativeSeries,
        getStartRelativeSeries: () => this._startRelativeSeries,
        getEndRelativeSeries: () => this._endRelativeSeries
      };
    }
    _processSpecX(t) {
      const e = this._relativeSeries;
      let i;
      return this._isSpecAggr(t)
        ? ((i = t), Object.assign({ x: { field: e.getSpec().xField, aggrType: i } }, this._getAllRelativeSeries()))
        : Object.assign({ x: t }, this._getAllRelativeSeries());
    }
    _processSpecY(t) {
      const e = this._relativeSeries;
      let i;
      return this._isSpecAggr(t)
        ? ((i = t), Object.assign({ y: { field: e.getSpec().yField, aggrType: i } }, this._getAllRelativeSeries()))
        : Object.assign({ y: t }, this._getAllRelativeSeries());
    }
    _processSpecCoo(t) {
      var e;
      return (null !== (e = t.coordinates) && void 0 !== e ? e : V(t.coordinate)).map(t => {
        const e = this._getSeriesByIdOrIndex(t.refRelativeSeriesId, t.refRelativeSeriesIndex),
          { xField: i, yField: n } = e.getSpec(),
          { [i]: s, [n]: r } = t,
          a = Object.assign({ x: void 0, y: void 0 }, this._getAllRelativeSeries());
        return (
          this._isSpecAggr(s) ? (a.x = { field: i, aggrType: s }) : (a.x = s),
          this._isSpecAggr(r) ? (a.y = { field: n, aggrType: r }) : (a.y = r),
          (a.getRefRelativeSeries = () => e),
          a
        );
      });
    }
    updateLayoutAttribute() {
      var t;
      (null === (t = this._spec.visible) || void 0 === t || t) &&
        (this._markerComponent ||
          (this._createMarkerComponent(),
          this._markerComponent.on('*', (t, e) => this._delegateEvent(this._markerComponent, t, e))),
        this._markerLayout()),
        super.updateLayoutAttribute();
    }
    _getSeriesByIdOrIndex(t, e) {
      var i, n;
      let s;
      return (
        (s = null === (i = this._option.getSeriesInUserIdOrIndex(V(t), [e])) || void 0 === i ? void 0 : i[0]),
        s || (s = null !== (n = this._relativeSeries) && void 0 !== n ? n : this.getFirstSeries()),
        s
      );
    }
    _bindSeries() {
      const t = this._spec;
      (this._relativeSeries = this._getSeriesByIdOrIndex(t.relativeSeriesId, t.relativeSeriesIndex)),
        (this._startRelativeSeries = this._getSeriesByIdOrIndex(t.startRelativeSeriesId, t.startRelativeSeriesIndex)),
        (this._endRelativeSeries = this._getSeriesByIdOrIndex(t.endRelativeSeriesId, t.endRelativeSeriesIndex));
    }
    _computeClipRange(t) {
      let e = 1 / 0,
        i = -1 / 0,
        n = 1 / 0,
        s = -1 / 0;
      return (
        t.forEach(t => {
          t.getLayoutStartPoint().x < e && (e = t.getLayoutStartPoint().x),
            t.getLayoutStartPoint().x + t.getLayoutRect().width > i &&
              (i = t.getLayoutStartPoint().x + t.getLayoutRect().width),
            t.getLayoutStartPoint().y < n && (n = t.getLayoutStartPoint().y),
            t.getLayoutStartPoint().y + t.getLayoutRect().height > s &&
              (s = t.getLayoutStartPoint().y + t.getLayoutRect().height);
        }),
        { minX: e, maxX: i, minY: n, maxY: s }
      );
    }
    initEvent() {}
    onRender(t) {}
    changeRegions(t) {}
    getFirstSeries() {
      var t;
      for (let t = 0; t < this._regions.length; t++) {
        const e = this._regions[t].getSeries();
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          if (i) return i;
        }
      }
      return null === (t = this._option) || void 0 === t || t.onError('need at least one series'), null;
    }
    clear() {
      this._markerComponent && (this._container.removeChild(this._markerComponent), (this._markerComponent = null)),
        super.clear();
    }
  }
  function K7(t, e) {
    return (function (t, e, i) {
      const { predict: n } = Ko(
          t,
          t => t[e],
          t => t[i]
        ),
        s = $N(t, e),
        r = XN(t, e),
        a = n(s),
        o = n(r);
      return [
        { [e]: s, [i]: a },
        { [e]: r, [i]: o }
      ];
    })(t[0].latestData, e.fieldX, e.fieldY);
  }
  class q7 extends X7 {
    constructor() {
      super(...arguments), (this.type = xn.markLine), (this.name = xn.markLine), (this.layoutZIndex = cZ.MarkLine);
    }
    static createComponent(t, e) {
      const i = t.markLine || e.defaultSpec;
      if (l(i)) return;
      if (!f(i) && !1 !== i.visible) return new q7(i, Object.assign(Object.assign({}, e), { specKey: q7.speckey }));
      const n = [];
      return (
        i.forEach((t, i) => {
          !1 !== t.visible &&
            n.push(new q7(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: q7.speckey })));
        }),
        n
      );
    }
    _createMarkerComponent() {
      var t, e, i, n, s, r, a, o, l, h, c, d, u, p, g, f, v, m, y, _;
      const b = new pX({
        zIndex: this.layoutZIndex,
        interactive: null !== (t = this._spec.interactive) && void 0 !== t && t,
        points: [
          { x: 0, y: 0 },
          { x: 0, y: 0 }
        ],
        lineStyle: GJ(null === (e = this._spec) || void 0 === e ? void 0 : e.line.style),
        startSymbol: Object.assign(
          Object.assign({}, null === (i = this._spec) || void 0 === i ? void 0 : i.startSymbol),
          {
            visible: null === (n = this._spec.startSymbol) || void 0 === n ? void 0 : n.visible,
            style: GJ(null === (s = this._spec.startSymbol) || void 0 === s ? void 0 : s.style)
          }
        ),
        endSymbol: Object.assign(Object.assign({}, null === (r = this._spec) || void 0 === r ? void 0 : r.endSymbol), {
          visible: null === (a = this._spec.endSymbol) || void 0 === a ? void 0 : a.visible,
          style: GJ(null === (o = this._spec.endSymbol) || void 0 === o ? void 0 : o.style)
        }),
        label: Object.assign(Object.assign({}, this._spec.label), {
          padding:
            null === (h = null === (l = this._spec.label) || void 0 === l ? void 0 : l.labelBackground) || void 0 === h
              ? void 0
              : h.padding,
          shape: Object.assign(
            Object.assign({}, GJ(null === (c = this._spec.label) || void 0 === c ? void 0 : c.shape)),
            {
              visible:
                null !==
                  (p =
                    null === (u = null === (d = this._spec.label) || void 0 === d ? void 0 : d.shape) || void 0 === u
                      ? void 0
                      : u.visible) &&
                void 0 !== p &&
                p
            }
          ),
          panel: Object.assign(
            Object.assign({}, GJ(null === (g = this._spec.label) || void 0 === g ? void 0 : g.labelBackground.style)),
            {
              visible:
                null ===
                  (m =
                    null === (v = null === (f = this._spec.label) || void 0 === f ? void 0 : f.labelBackground) ||
                    void 0 === v
                      ? void 0
                      : v.visible) ||
                void 0 === m ||
                m
            }
          ),
          textStyle: GJ(null === (y = this._spec.label) || void 0 === y ? void 0 : y.style)
        })
      });
      (this._markerComponent = b),
        (this._markerComponent.name = 'markLine'),
        (this._markerComponent.id = null !== (_ = this._spec.id) && void 0 !== _ ? _ : `markLine-${this.id}`),
        this.getContainer().add(this._markerComponent);
    }
    _markerLayout() {
      var t, e, i, n, s, r;
      const a = this._spec,
        o = this._markerData,
        l = this._startRelativeSeries,
        c = this._endRelativeSeries,
        d = this._relativeSeries,
        u = h(a.x) || (h(a.coordinates) && h(a.process) && h(a.process.x)),
        p = h(a.y) || (h(a.coordinates) && h(a.process) && h(a.process.y)),
        g = h(a.coordinates) && (!h(a.process) || ('process' in a && 'xy' in a.process)),
        f = h(a.positions),
        v = null !== (t = null == a ? void 0 : a.autoRange) && void 0 !== t && t,
        m = null !== (e = null == a ? void 0 : a.clip) && void 0 !== e && e;
      let y = [];
      u ? (y = W7(o, l, c, d, v)[0]) : p ? (y = G7(o, l, c, d, v)[0]) : g ? (y = U7(o, d, v)) : f && (y = a.positions);
      const _ = o.latestData[0].latestData ? o.latestData[0].latestData : o.latestData;
      let b;
      if (m) {
        const {
          minX: t,
          maxX: e,
          minY: i,
          maxY: n
        } = this._computeClipRange([l.getRegion(), c.getRegion(), d.getRegion()]);
        b = { x: t, y: i, width: e - t, height: n - i };
      }
      null === (i = this._markerComponent) ||
        void 0 === i ||
        i.setAttributes({
          points: y,
          label: Object.assign(
            Object.assign({}, null === (n = this._markerComponent.attribute) || void 0 === n ? void 0 : n.label),
            {
              text: this._spec.label.formatMethod
                ? this._spec.label.formatMethod(_)
                : null === (r = null === (s = this._markerComponent.attribute) || void 0 === s ? void 0 : s.label) ||
                  void 0 === r
                ? void 0
                : r.text
            }
          ),
          clipRange: b
        });
    }
    _initDataView() {
      const t = this._spec,
        e = this._relativeSeries,
        i = 'x' in t,
        n = 'y' in t,
        s = 'coordinates' in t;
      if (!i && !n && !s) return;
      let r,
        a,
        o = !1,
        l = !1;
      xQ(this._option.dataSet, 'markerAggregation', V7),
        xQ(this._option.dataSet, 'markerRegression', K7),
        i
          ? ((r = [this._processSpecX(t.x)]), (a = e.getViewData()), (o = !0))
          : n
          ? ((r = [this._processSpecY(t.y)]), (a = e.getViewData()), (o = !0))
          : s &&
            ((r = this._processSpecCoo(t)),
            (a = new yo(this._option.dataSet)
              .parse([e.getViewData()], { type: 'dataview' })
              .transform({ type: 'markerAggregation', options: r })),
            t.process && 'x' in t.process && ((r = [this._processSpecX(t.process.x)]), (o = !0)),
            t.process && 'y' in t.process && ((r = [this._processSpecY(t.process.y)]), (o = !0)),
            t.process &&
              'xy' in t.process &&
              ((r = { fieldX: e.getSpec().xField, fieldY: e.getSpec().yField }), (l = !0)));
      const h = new yo(this._option.dataSet);
      h.parse([a], { type: 'dataview' }),
        o && h.transform({ type: 'markerAggregation', options: r }),
        l && h.transform({ type: 'markerRegression', options: r }),
        h.target.on('change', () => {
          this._markerLayout();
        }),
        (this._markerData = h);
    }
  }
  (q7.type = xn.markLine), (q7.speckey = 'markLine');
  class Z7 extends X7 {
    constructor() {
      super(...arguments), (this.type = xn.markArea), (this.name = xn.markArea), (this.layoutZIndex = cZ.MarkArea);
    }
    static createComponent(t, e) {
      const i = t.markArea || e.defaultSpec;
      if (l(i)) return;
      if (!f(i) && !1 !== i.visible) return new Z7(i, Object.assign(Object.assign({}, e), { specKey: Z7.speckey }));
      const n = [];
      return (
        i.forEach((t, i) => {
          !1 !== t.visible &&
            n.push(new Z7(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: Z7.speckey })));
        }),
        n
      );
    }
    _createMarkerComponent() {
      var t, e, i, n, s, r, a, o, l, h, c, d, u, p, g;
      const f = new gX({
        zIndex: this.layoutZIndex,
        interactive: null !== (t = this._spec.interactive) && void 0 !== t && t,
        points: [{ x: 0, y: 0 }],
        areaStyle: GJ(null === (e = this._spec.area) || void 0 === e ? void 0 : e.style),
        label: Object.assign(Object.assign({}, this._spec.label), {
          padding:
            null === (n = null === (i = this._spec.label) || void 0 === i ? void 0 : i.labelBackground) || void 0 === n
              ? void 0
              : n.padding,
          shape: Object.assign(
            Object.assign({}, GJ(null === (s = this._spec.label) || void 0 === s ? void 0 : s.shape)),
            {
              visible:
                null !==
                  (o =
                    null === (a = null === (r = this._spec.label) || void 0 === r ? void 0 : r.shape) || void 0 === a
                      ? void 0
                      : a.visible) &&
                void 0 !== o &&
                o
            }
          ),
          panel: Object.assign(
            Object.assign(
              {},
              GJ(
                null === (h = null === (l = this._spec.label) || void 0 === l ? void 0 : l.labelBackground) ||
                  void 0 === h
                  ? void 0
                  : h.style
              )
            ),
            {
              visible:
                null ===
                  (u =
                    null === (d = null === (c = this._spec.label) || void 0 === c ? void 0 : c.labelBackground) ||
                    void 0 === d
                      ? void 0
                      : d.visible) ||
                void 0 === u ||
                u
            }
          ),
          textStyle: GJ(null === (p = this._spec.label) || void 0 === p ? void 0 : p.style)
        })
      });
      (this._markerComponent = f),
        (this._markerComponent.name = 'markArea'),
        (this._markerComponent.id = null !== (g = this._spec.id) && void 0 !== g ? g : `markArea-${this.id}`),
        this.getContainer().add(this._markerComponent);
    }
    _markerLayout() {
      var t, e, i, n, s, r;
      const a = this._spec,
        o = this._markerData,
        l = this._startRelativeSeries,
        c = this._endRelativeSeries,
        d = this._relativeSeries,
        u = h(a.x) && h(a.x1),
        p = h(a.y) && h(a.y1),
        g = h(a.coordinates),
        f = h(a.positions),
        v = null !== (t = null == a ? void 0 : a.autoRange) && void 0 !== t && t,
        m = null !== (e = null == a ? void 0 : a.clip) && void 0 !== e && e;
      let y = [],
        _ = [];
      u
        ? ((_ = W7(o, l, c, d, v)), (y = [..._[0], _[1][1], _[1][0]]))
        : p
        ? ((_ = G7(o, l, c, d, v)), (y = [..._[0], _[1][1], _[1][0]]))
        : g
        ? (y = U7(o, d, v))
        : f && (y = a.positions);
      const b = o.latestData[0].latestData ? o.latestData[0].latestData : o.latestData;
      let x;
      if (m) {
        const {
          minX: t,
          maxX: e,
          minY: i,
          maxY: n
        } = this._computeClipRange([l.getRegion(), c.getRegion(), d.getRegion()]);
        x = { x: t, y: i, width: e - t, height: n - i };
      }
      null === (i = this._markerComponent) ||
        void 0 === i ||
        i.setAttributes({
          points: y,
          label: Object.assign(
            Object.assign({}, null === (n = this._markerComponent.attribute) || void 0 === n ? void 0 : n.label),
            {
              text: this._spec.label.formatMethod
                ? this._spec.label.formatMethod(b)
                : null === (r = null === (s = this._markerComponent.attribute) || void 0 === s ? void 0 : s.label) ||
                  void 0 === r
                ? void 0
                : r.text
            }
          ),
          clipRange: x
        });
    }
    _initDataView() {
      const t = this._spec,
        e = this._relativeSeries,
        i = h(t.x) && h(t.x1),
        n = h(t.y) && h(t.y1),
        s = h(t.coordinates);
      if (!i && !n && !s) return null;
      let r;
      xQ(this._option.dataSet, 'markerAggregation', V7),
        xQ(this._option.dataSet, 'markerRegression', K7),
        i
          ? (r = [this._processSpecX(t.x), this._processSpecX(t.x1)])
          : n
          ? (r = [this._processSpecY(t.y), this._processSpecY(t.y1)])
          : s && (r = this._processSpecCoo(t));
      const a = new yo(this._option.dataSet);
      a.parse([e.getViewData()], { type: 'dataview' }),
        a.transform({ type: 'markerAggregation', options: r }),
        a.target.on('change', () => {
          this._markerLayout();
        }),
        (this._markerData = a);
    }
  }
  (Z7.type = xn.markArea), (Z7.speckey = 'markArea');
  class J7 extends X7 {
    constructor() {
      super(...arguments), (this.type = xn.markPoint), (this.name = xn.markPoint), (this.layoutZIndex = cZ.MarkPoint);
    }
    static createComponent(t, e) {
      const i = t.markPoint || e.defaultSpec;
      if (l(i)) return;
      if (!f(i) && !1 !== i.visible) return new J7(i, Object.assign(Object.assign({}, e), { specKey: J7.speckey }));
      const n = [];
      return (
        i.forEach((t, i) => {
          !1 !== t.visible &&
            n.push(new J7(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: J7.speckey })));
        }),
        n
      );
    }
    _createMarkerComponent() {
      var t, e, i, n, s, r, a, o, l, h, c, d, u, p, g, f, v, m, y, _, b, x, S, w, A, k, M, T, C;
      const E = new fX({
        zIndex: this.layoutZIndex,
        interactive: null !== (t = this._spec.interactive) && void 0 !== t && t,
        position: { x: 0, y: 0 },
        itemLine: Object.assign(
          {
            lineStyle: GJ(
              null === (i = null === (e = this._spec.itemLine) || void 0 === e ? void 0 : e.line) || void 0 === i
                ? void 0
                : i.style
            )
          },
          this._spec.itemLine
        ),
        itemContent: Object.assign(
          {
            symbolStyle: GJ(
              null === (s = null === (n = this._spec.itemContent) || void 0 === n ? void 0 : n.symbol) || void 0 === s
                ? void 0
                : s.style
            ),
            imageStyle:
              null === (a = null === (r = this._spec.itemContent) || void 0 === r ? void 0 : r.image) || void 0 === a
                ? void 0
                : a.style,
            textStyle: Object.assign(
              Object.assign({}, null === (o = this._spec.itemContent) || void 0 === o ? void 0 : o.text),
              {
                padding:
                  null ===
                    (c =
                      null === (h = null === (l = this._spec.itemContent) || void 0 === l ? void 0 : l.text) ||
                      void 0 === h
                        ? void 0
                        : h.labelBackground) || void 0 === c
                    ? void 0
                    : c.padding,
                shape: Object.assign(
                  Object.assign(
                    {},
                    GJ(
                      null === (u = null === (d = this._spec.itemContent) || void 0 === d ? void 0 : d.text) ||
                        void 0 === u
                        ? void 0
                        : u.shape
                    )
                  ),
                  {
                    visible:
                      null !==
                        (v =
                          null ===
                            (f =
                              null === (g = null === (p = this._spec.itemContent) || void 0 === p ? void 0 : p.text) ||
                              void 0 === g
                                ? void 0
                                : g.shape) || void 0 === f
                            ? void 0
                            : f.visible) &&
                      void 0 !== v &&
                      v
                  }
                ),
                panel: Object.assign(
                  Object.assign(
                    {},
                    GJ(
                      null ===
                        (_ =
                          null === (y = null === (m = this._spec.itemContent) || void 0 === m ? void 0 : m.text) ||
                          void 0 === y
                            ? void 0
                            : y.labelBackground) || void 0 === _
                        ? void 0
                        : _.style
                    )
                  ),
                  {
                    visible:
                      null ===
                        (w =
                          null ===
                            (S =
                              null === (x = null === (b = this._spec.itemContent) || void 0 === b ? void 0 : b.text) ||
                              void 0 === x
                                ? void 0
                                : x.labelBackground) || void 0 === S
                            ? void 0
                            : S.visible) ||
                      void 0 === w ||
                      w
                  }
                ),
                textStyle: GJ(
                  null === (k = null === (A = this._spec.itemContent) || void 0 === A ? void 0 : A.text) || void 0 === k
                    ? void 0
                    : k.style
                )
              }
            ),
            richTextStyle:
              null === (T = null === (M = this._spec.itemContent) || void 0 === M ? void 0 : M.richText) || void 0 === T
                ? void 0
                : T.style
          },
          this._spec.itemContent
        )
      });
      (this._markerComponent = E),
        (this._markerComponent.name = 'markPoint'),
        (this._markerComponent.id = null !== (C = this._spec.id) && void 0 !== C ? C : `markPoint-${this.id}`),
        this.getContainer().add(this._markerComponent);
    }
    _markerLayout() {
      var t, e, i, n, s, r, a, o, l, h;
      const c = this._spec,
        d = this._markerData,
        u = this._relativeSeries,
        p = 'coordinate' in c,
        g = 'position' in c,
        f = null !== (t = null == c ? void 0 : c.autoRange) && void 0 !== t && t,
        v = null !== (e = null == c ? void 0 : c.clip) && void 0 !== e && e;
      let m;
      p ? (m = U7(d, u, f)[0]) : g && (m = c.position);
      const y = d.latestData[0].latestData ? d.latestData[0].latestData : d.latestData;
      let _;
      if (v) {
        const { minX: t, maxX: e, minY: i, maxY: n } = this._computeClipRange([u.getRegion()]);
        _ = { x: t, y: i, width: e - t, height: n - i };
      }
      null === (i = this._markerComponent) ||
        void 0 === i ||
        i.setAttributes({
          position: m,
          itemContent: Object.assign(
            Object.assign({}, null === (n = this._markerComponent.attribute) || void 0 === n ? void 0 : n.itemContent),
            {
              textStyle: Object.assign(
                Object.assign(
                  {},
                  null ===
                    (r = null === (s = this._markerComponent.attribute) || void 0 === s ? void 0 : s.itemContent) ||
                    void 0 === r
                    ? void 0
                    : r.textStyle
                ),
                {
                  text: (null === (a = this._spec.itemContent.text) || void 0 === a ? void 0 : a.formatMethod)
                    ? this._spec.itemContent.text.formatMethod(y)
                    : null ===
                        (h =
                          null ===
                            (l =
                              null === (o = this._markerComponent.attribute) || void 0 === o
                                ? void 0
                                : o.itemContent) || void 0 === l
                            ? void 0
                            : l.textStyle) || void 0 === h
                    ? void 0
                    : h.text
                }
              )
            }
          ),
          clipRange: _
        });
    }
    _initDataView() {
      const t = this._spec,
        e = this._relativeSeries;
      if (!h(t.coordinate)) return;
      xQ(this._option.dataSet, 'markerAggregation', V7);
      const i = this._processSpecCoo(t),
        n = new yo(this._option.dataSet);
      n.parse([e.getViewData()], { type: 'dataview' }),
        n.transform({ type: 'markerAggregation', options: i }),
        n.target.on('change', () => {
          this._markerLayout();
        }),
        (this._markerData = n);
    }
  }
  (J7.type = xn.markPoint), (J7.speckey = 'markPoint');
  const Q7 = (t, e, i) => (l(t) ? t : o(t) ? t(e, i) : t),
    t9 = (t, e, i) => {
      if (l(t)) return t;
      if (f(t)) {
        const n = [];
        return (
          t.forEach(t => {
            if (o(t)) {
              const s = t(e, i);
              h(s) && n.push(s);
            } else n.push(t);
          }),
          n
        );
      }
      return o(t) ? t(e, i) : t;
    };
  const e9 = (t, e) =>
      t
        ? (e || (e = t.getBoundingClientRect()),
          t.offsetWidth > 0 ? e.width / t.offsetWidth : e.height / t.offsetHeight)
        : 1,
    i9 = 'vchart-tooltip-container',
    n9 = 20,
    s9 = { key: '其他', value: '...' },
    r9 = {
      offsetX: 10,
      offsetY: 10,
      sanitize: function (t) {
        return String(t)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/\(/g, '&#40;')
          .replace(/  /g, ' &nbsp;');
      }
    };
  class a9 {}
  (a9.dom = `${UV}_TOOLTIP_HANDLER_DOM`), (a9.canvas = `${UV}_TOOLTIP_HANDLER_CANVAS`);
  const o9 = (t, e, i) => {
      const n = Q7(e.key, t, i),
        s = Q7(e.value, t, i),
        r = !1 !== Q7(e.visible, t, i) && (h(n) || h(s)),
        a = Q7(e.isKeyAdaptive, t, i),
        o = Q7(e.shapeType, t, i),
        l = Q7(e.shapeColor, t, i),
        c = Q7(e.keyStyle, t, i),
        d = Q7(e.valueStyle, t, i);
      return {
        key: n,
        value: s,
        visible: r,
        isKeyAdaptive: a,
        hasShape: e.hasShape,
        shapeType: o,
        shapeHollow: e.shapeHollow,
        shapeColor: l,
        keyStyle: c,
        valueStyle: d
      };
    },
    l9 = (t, e, i) => {
      var n, s;
      return null !==
        (s = null === (n = t.tooltipHelper) || void 0 === n ? void 0 : n.getDefaultTooltipPattern(e, i)) && void 0 !== s
        ? s
        : null;
    },
    h9 = (t, e, i) => {
      var n;
      let s = {};
      if ('mark' === t && e) s = null !== (n = l9(e, 'mark')) && void 0 !== n ? n : {};
      else if ('dimension' === t && (null == i ? void 0 : i.length)) {
        const t = [];
        i[0].data.forEach(e => {
          const { series: n } = e,
            s = [Object.assign(Object.assign({}, i[0]), { data: [e] })],
            r = l9(n, 'dimension', s);
          r && t.push(r);
        });
        const e = [];
        t.forEach(({ content: t }) => {
          o(t) ? e.push(t) : e.push(...V(t));
        }),
          (s = Object.assign(Object.assign({}, t[0]), { content: e }));
      }
      return s;
    },
    c9 = (t, e, i) => {
      var n, s;
      let r = {};
      if ('mark' === t && e) {
        const t =
          null !== (s = null === (n = e.tooltipHelper) || void 0 === n ? void 0 : n.spec) && void 0 !== s ? s : {};
        r = t.mark ? R(t.mark) : {};
      } else if ('dimension' === t && (null == i ? void 0 : i.length)) {
        const t = d9(i)
          .filter(t => {
            var e;
            const i = null === (e = t.tooltipHelper) || void 0 === e ? void 0 : e.spec;
            return h(null == i ? void 0 : i.dimension) && j1(i).includes('dimension');
          })
          .map(t => t.tooltipHelper.spec.dimension);
        if (t.length) {
          let e = [];
          t.every(({ content: t }) => l(t))
            ? (e = void 0)
            : t.forEach(({ content: t }) => {
                l(t) || (o(t) ? null == e || e.push(t) : null == e || e.push(...V(t)));
              }),
            (r = Object.assign(Object.assign({}, t[0]), { content: e }));
        }
      }
      return r;
    },
    d9 = ct(t => t.reduce((t, e) => t.concat(e.data.map(t => t.series).filter(h)), [])),
    u9 = t => {
      const e = {};
      return (
        t.forEach(t => {
          var i;
          const n = null !== (i = t.seriesId) && void 0 !== i ? i : 0;
          e[n] || (e[n] = t);
        }),
        e
      );
    },
    p9 = (t, e, i, n) => {
      var s, r;
      const a =
          null !==
            (r = null == i ? void 0 : i[null !== (s = null == t ? void 0 : t.seriesId) && void 0 !== s ? s : 0]) &&
          void 0 !== r
            ? r
            : null == i
            ? void 0
            : i[0],
        o = {};
      return (
        ['hasShape', 'shapeType', 'shapeColor'].forEach(i => {
          var s, r, l;
          const h =
            null !==
              (l =
                null !==
                  (r = null !== (s = null == t ? void 0 : t[i]) && void 0 !== s ? s : null == e ? void 0 : e[i]) &&
                void 0 !== r
                  ? r
                  : null == a
                  ? void 0
                  : a[i]) && void 0 !== l
              ? l
              : null == n
              ? void 0
              : n[i];
          void 0 !== h && (o[i] = h);
        }),
        o
      );
    },
    g9 = (t, e) => {
      let i;
      if (h(t))
        if (y(t)) i = t;
        else if (o(t)) {
          const n = t(e);
          y(n) && (i = n);
        }
      return i;
    },
    f9 = { fontFamily: AV, spacing: 10, multiLine: !1, wordBreak: 'break-word' };
  function v9(t = {}, e, i) {
    var n, s;
    return Object.assign(Object.assign({}, null != i ? i : f9), {
      fill: null !== (n = t.fill) && void 0 !== n ? n : t.fontColor,
      textAlign: t.textAlign,
      textBaseline: t.textBaseline,
      fontFamily: null !== (s = t.fontFamily) && void 0 !== s ? s : null == e ? void 0 : e.fontFamily,
      fontSize: t.fontSize,
      fontWeight: t.fontWeight,
      lineHeight: t.lineHeight,
      spacing: t.spacing,
      multiLine: t.multiLine,
      maxWidth: t.maxWidth,
      wordBreak: t.wordBreak
    });
  }
  const m9 = (t, e) => {
    var i;
    const n = ON(e, s, r, { fontFamily: AV, fontSize: kV });
    var s, r;
    if (!e.multiLine) {
      const { width: e, height: i } = n.fullMeasure(t);
      return { width: e, height: i, text: t };
    }
    let a = t.split('\n');
    a = a.map((t, e) => (e < a.length - 1 ? t + '\n' : t));
    const { width: o, height: l } = n.fullMeasure(a);
    if (e.maxWidth && e.maxWidth <= o) {
      const t = (function (t) {
        return uB.setAttributes(t), uB.AABBBounds;
      })({
        wordBreak: null !== (i = e.wordBreak) && void 0 !== i ? i : 'break-word',
        maxWidth: e.maxWidth,
        width: 0,
        height: 0,
        textConfig: a.map((t, i) => Object.assign(Object.assign({}, e), { text: t }))
      });
      return { width: t.width(), height: t.height(), text: a };
    }
    return { width: o, height: l, text: a };
  };
  var y9;
  !(function (t) {
    (t[(t.success = 0)] = 'success'), (t[(t.failed = 1)] = 'failed');
  })(y9 || (y9 = {}));
  class _9 {
    get id() {
      return this._id;
    }
    get env() {
      return this._env;
    }
    constructor(t, e) {
      (this._visible = !0),
        (this._id = ''),
        (this._attributeCache = null),
        (this.showTooltip = (t, e, i) => {
          var n;
          let s = !!i.changePositionOnly;
          return (
            (i.changePositionOnly &&
              (null === (n = this._cacheActualTooltip) || void 0 === n ? void 0 : n.activeType) === t) ||
              ((s = !1), (this._cacheViewSpec = void 0), (this._cacheActualTooltip = void 0)),
            s && this._cacheViewSpec && this._cacheActualTooltip
              ? this.changeTooltipPosition(s, this._cacheActualTooltip, this._cacheViewSpec, t, e, i)
              : this.changeTooltip(!0, i, s, t, e)
          );
        }),
        (this._changeTooltip = (t, e, i, n, s) => {
          var r, a, c, d, u, p, g, f, v;
          const m = this._component.getSpec();
          if (!m) return y9.failed;
          if (!t)
            return (
              (this._cacheViewSpec = void 0),
              (this._cacheActualTooltip = void 0),
              m.handler
                ? null !== (c = null === (a = (r = m.handler).hideTooltip) || void 0 === a ? void 0 : a.call(r, e)) &&
                  void 0 !== c
                  ? c
                  : y9.success
                : (this._updateTooltip(!1, e), y9.success)
            );
          if (l(n) || l(s)) return y9.failed;
          let y;
          if (
            (i && this._cacheViewSpec
              ? (y = this._cacheViewSpec)
              : ((y = ((t, e, i, n) => {
                  var s, r, a, l, c, d, u;
                  const p = Object.assign(Object.assign({}, e), { activeType: t });
                  if ('mark' === t && i) {
                    const t =
                      null !== (r = null === (s = i.tooltipHelper) || void 0 === s ? void 0 : s.spec) && void 0 !== r
                        ? r
                        : {};
                    if (
                      (h(t.visible) || h(t.activeType)
                        ? (p.visible = j1(t).includes('mark'))
                        : h(e.visible) || h(e.activeType)
                        ? (p.visible = j1(e).includes('mark'))
                        : (p.visible = !0),
                      (p.handler =
                        null !== (l = null !== (a = t.handler) && void 0 !== a ? a : e.handler) && void 0 !== l
                          ? l
                          : void 0),
                      null === (c = p.handler) || void 0 === c ? void 0 : c.showTooltip)
                    )
                      return p;
                  } else if (
                    'dimension' === t &&
                    (null == n ? void 0 : n.length) &&
                    (d9(n).every(t => {
                      var e;
                      return !j1(null === (e = t.tooltipHelper) || void 0 === e ? void 0 : e.spec).includes(
                        'dimension'
                      );
                    })
                      ? (p.visible = !1)
                      : h(e.visible) || h(e.activeType)
                      ? (p.visible = j1(e).includes('dimension'))
                      : (p.visible = !0),
                    (p.handler = null !== (d = e.handler) && void 0 !== d ? d : void 0),
                    null === (u = p.handler) || void 0 === u ? void 0 : u.showTooltip)
                  )
                    return p;
                  const g = h9(t, i, n),
                    f = c9(t, i, n),
                    v = _J({}, R(e[t]), f),
                    m = g.title,
                    y = p9(void 0, v, void 0, m);
                  if (h(v.title))
                    if (o(v.title)) {
                      const t = v.title;
                      v.title = (e, i) => {
                        var n;
                        const s = null !== (n = t(e, i)) && void 0 !== n ? n : {};
                        return Object.assign(Object.assign({}, y), s);
                      };
                    } else v.title = Object.assign(Object.assign(Object.assign({}, g.title), y), v.title);
                  else v.title = Object.assign(Object.assign({}, g.title), y);
                  const _ = V(g.content);
                  if (h(v.content)) {
                    const t = u9(_);
                    if (o(v.content)) {
                      const e = v.content;
                      v.content = (i, n) => {
                        var s;
                        const r = [];
                        return (
                          V(null !== (s = e(i, n)) && void 0 !== s ? s : []).forEach(e => {
                            r.push(Object.assign(Object.assign({}, p9(e, v, t)), e));
                          }),
                          r
                        );
                      };
                    } else {
                      const e = [];
                      V(v.content).forEach(i => {
                        e.push(Object.assign(Object.assign({}, p9(i, v, t)), i));
                      }),
                        (v.content = e);
                    }
                  } else v.content = _.map(t => Object.assign(Object.assign({}, t), p9(void 0, v, void 0, t)));
                  return (p[t] = Object.assign(Object.assign(Object.assign({}, g), v), { activeType: t })), p;
                })(n, m, e.model, e.dimensionInfo)),
                (this._cacheViewSpec = y)),
            !1 === y.visible)
          )
            return y9.failed;
          if (y.handler)
            return null !==
              (p = null === (u = (d = y.handler).showTooltip) || void 0 === u ? void 0 : u.call(d, n, s, e)) &&
              void 0 !== p
              ? p
              : y9.success;
          const _ = y[n];
          if (!_) return y9.failed;
          let b;
          return (
            i && this._cacheActualTooltip
              ? (b = this._cacheActualTooltip)
              : ((b = this._getActualTooltipContent(_, s, e)),
                _.updateTitle && (b.title = _.updateTitle(b.title, s, e)),
                _.updateContent && (b.content = _.updateContent(b.content, s, e))),
            l(null === (g = b.title) || void 0 === g ? void 0 : g.key) &&
            l(null === (f = b.title) || void 0 === f ? void 0 : f.value) &&
            !(null === (v = b.content) || void 0 === v ? void 0 : v.length)
              ? y9.failed
              : ((this._cacheActualTooltip = b), this._changeTooltipPosition(!!i, b, y, n, s, e))
          );
        }),
        (this._changeTooltipPosition = (t, e, i, n, s, r) => {
          var a, o, l;
          const h = r.event;
          if (i.handler)
            return null !==
              (l = null === (o = (a = i.handler).showTooltip) || void 0 === o ? void 0 : o.call(a, n, s, r)) &&
              void 0 !== l
              ? l
              : y9.success;
          const c = i[n];
          if (!c) return y9.failed;
          const d = this._getActualTooltipPosition(e, t9(c.position, s, r), r, this._getParentElement(i), t);
          (e.position = d), c.updatePosition && (e.position = c.updatePosition(e.position, s, r));
          let u = !1 !== (null == c ? void 0 : c.visible);
          return (
            (s && 'pointerout' !== h.type && e.visible && (e.title || e.content)) || (u = !1),
            this._updateTooltip(u, Object.assign(Object.assign({}, r), { changePositionOnly: t }), e),
            y9.success
          );
        }),
        (this._getActualTooltipContent = (t, e, i) => {
          const n = t9(t.visible, e, i);
          let s = null;
          s = ((t, e, i) => {
            var n, s, r, a, o;
            if (!e || 'mouseout' === (null === (n = null == i ? void 0 : i.event) || void 0 === n ? void 0 : n.type))
              return null;
            const h = t9(t.title, e, i),
              c = V(t9(t.content, e, i)),
              d = {
                title: {
                  value: null === (s = null == h ? void 0 : h.value) || void 0 === s ? void 0 : s.toString(),
                  hasShape: !1,
                  shapeType: void 0,
                  shapeHollow: void 0
                },
                content: []
              },
              { maxLineCount: u = n9 } = t,
              p = !1 !== Q7(null == h ? void 0 : h.visible, e, i);
            if (h && p) {
              const t = (function (t) {
                var e;
                const i = (null === (e = t[0]) || void 0 === e ? void 0 : e.series) ? [{ data: t, value: '' }] : t;
                for (const { data: t } of i)
                  for (const { datum: e } of t) for (const t of null != e ? e : []) if (t) return t;
              })(e);
              d.title = {
                value: Q7(null == h ? void 0 : h.value, t, i),
                valueStyle: Q7(null == h ? void 0 : h.valueStyle, t, i),
                hasShape: h.hasShape,
                shapeHollow: h.shapeHollow
              };
            } else d.title = { hasShape: !1, visible: !1 };
            if ('mark' === t.activeType)
              for (const t of null != c ? c : []) {
                const n = o9(null === (r = e[0]) || void 0 === r ? void 0 : r.datum[0], t, i);
                if (!1 !== n.visible) {
                  if (d.content.length === u - 1) {
                    d.content.push(Object.assign(Object.assign({}, n), s9));
                    break;
                  }
                  if (!(d.content.length < u)) break;
                  d.content.push(n);
                }
              }
            else if ('dimension' === t.activeType)
              for (const { data: t } of e) {
                for (const { datum: e, series: n } of t) {
                  if (!j1(null === (a = n.tooltipHelper) || void 0 === a ? void 0 : a.spec).includes('dimension'))
                    continue;
                  const t =
                    null !== (o = null == c ? void 0 : c.filter(t => l(t.seriesId) || t.seriesId === n.id)) &&
                    void 0 !== o
                      ? o
                      : [];
                  for (const n of e) {
                    for (const e of t) {
                      const t = o9(n, e, i);
                      if (!1 !== t.visible) {
                        if (d.content.length === u - 1) {
                          d.content.push(Object.assign(Object.assign({}, t), s9));
                          break;
                        }
                        if (!(d.content.length < u)) break;
                        d.content.push(t);
                      }
                    }
                    if (d.content.length >= u) break;
                  }
                  if (d.content.length >= u) break;
                }
                if (d.content.length >= u) break;
              }
            return (
              d.title &&
                (d.content.length > 0 && d.content[0].shapeType
                  ? (l(d.title.shapeType) && (d.title.shapeType = d.content[0].shapeType),
                    l(d.title.shapeColor) && (d.title.shapeColor = d.content[0].shapeColor))
                  : (d.title.hasShape = !1)),
              d
            );
          })(t, e, i);
          return Object.assign(Object.assign({}, s), { visible: !!h(s) && !1 !== n, activeType: t.activeType });
        }),
        (this._getActualTooltipPosition = (t, e, i, n, s) => {
          var r, a, o, l, d, u;
          const p = i.event,
            { width: g = 0, height: f = 0 } = null !== (r = this._getTooltipBoxSize(t, s)) && void 0 !== r ? r : {},
            v = { x: 1 / 0, y: 1 / 0 },
            { offsetX: m, offsetY: y } = this._option,
            b = this._component.getSpec();
          if (!b) return v;
          const x = 'canvas' === b.renderMode,
            S = null === (a = null == i ? void 0 : i.chart) || void 0 === a ? void 0 : a.getCanvasRect(),
            w = null !== (o = null == S ? void 0 : S.width) && void 0 !== o ? o : YV,
            A = null !== (l = null == S ? void 0 : S.height) && void 0 !== l ? l : $V;
          let k,
            M,
            T,
            C,
            E,
            P,
            R = !1;
          if (c(e)) {
            const { left: t, right: i, top: n, bottom: s } = e;
            (k = g9(t, p)), (M = g9(n, p)), (T = g9(i, p)), (C = g9(s, p));
          } else if (h(e) && 'mark' === t.activeType) {
            R = !0;
            const t = i.item,
              n = i.model,
              s = null == t ? void 0 : t.getBounds(),
              r = null == n ? void 0 : n.getLayoutStartPoint();
            if (s && r) {
              let { x1: t, y1: i, x2: n, y2: a } = s;
              switch (((t += r.x), (n += r.x), (i += r.y), (a += r.y), e)) {
                case QJ.left:
                  (k = t - g - m), (M = (i + a) / 2 - f / 2);
                  break;
                case QJ.right:
                  (k = n + m), (M = (i + a) / 2 - f / 2);
                  break;
                case QJ.top:
                  (k = (t + n) / 2 - g / 2), (M = i - f - y);
                  break;
                case QJ.bottom:
                  (k = (t + n) / 2 - g / 2), (M = a + y);
                  break;
                case QJ.inside:
                  (k = (t + n) / 2 - g / 2), (M = (i + a) / 2 - f / 2);
              }
            }
          }
          const O = { width: 0, height: 0 },
            B = (t = 0) => ({ x: t, y: t });
          let I = B(),
            D = B(),
            L = 1,
            F = 1;
          if (To(this._env) && !b.confine) {
            if (((O.width = window.innerWidth), (O.height = window.innerHeight), !x)) {
              D = null !== (d = null == n ? void 0 : n.getBoundingClientRect()) && void 0 !== d ? d : v;
              const t = null !== (u = this._compiler.getCanvas()) && void 0 !== u ? u : this._chartContainer,
                e = null == t ? void 0 : t.getBoundingClientRect();
              (I = { x: e.x - D.x, y: e.y - D.y }), (L = e9(t, e)), (F = e9(n, D));
            }
          } else (O.width = w), (O.height = A);
          const { canvasX: j, canvasY: z } = p;
          (E = _(k) ? k : _(T) ? w - g - T : j + m),
            (P = _(M) ? M : _(C) ? A - f - C : z + y),
            (E *= L),
            (P *= L),
            To(this._env) && ((E += I.x), (P += I.y)),
            (E /= F),
            (P /= F);
          const { width: H, height: N } = O;
          return (
            (E + g) * F + D.x > H && (R ? (E = (H - D.x) / F - g) : (E -= 2 * m + g)),
            (P + f) * F + D.y > N && (R ? (P = (N - D.y) / F - f) : (P -= 2 * y + f)),
            E * F + D.x < 0 && (E = 0 - D.x / F),
            P * F + D.y < 0 && (P = 0 - D.y / F),
            { x: E, y: P }
          );
        }),
        (this._component = e),
        (this._chartOption = e.getOption()),
        (this._env = this._chartOption.mode),
        (this._chartContainer = this._chartOption.globalInstance.getContainer()),
        (this._compiler = e.getCompiler()),
        (this._id = t),
        this._initFromSpec();
    }
    hideTooltip(t) {
      return this.changeTooltip(!1, t);
    }
    release() {
      var t, e, i;
      (this._cacheViewSpec = void 0), (this._cacheActualTooltip = void 0);
      const n = null !== (t = this._component.getSpec()) && void 0 !== t ? t : {};
      n.handler ? null === (i = (e = n.handler).release) || void 0 === i || i.call(e) : this._removeTooltip();
    }
    _throttle(t) {
      const e = this._component.getSpec();
      let i;
      return (
        (i = y(e.throttleInterval) ? e.throttleInterval : 'html' === e.renderMode && e.transitionDuration ? 50 : 10),
        yt(t, i)
      );
    }
    _getDefaultOption() {
      var t, e;
      const { offset: i } = this._component.getSpec();
      return Object.assign(Object.assign({}, r9), {
        offsetX: null !== (t = null == i ? void 0 : i.x) && void 0 !== t ? t : r9.offsetX,
        offsetY: null !== (e = null == i ? void 0 : i.y) && void 0 !== e ? e : r9.offsetY
      });
    }
    _getTooltipBoxSize(t, e) {
      var i, n, s, r;
      return (
        (e && !l(this._attributeCache)) ||
          (this._attributeCache = ((t, e) => {
            const { spaceRow: i, padding: n, title: s, shape: r, key: a, value: o } = e,
              l = Object.assign(Object.assign({}, e), {
                title: {},
                content: [],
                titleStyle: { value: s, spaceRow: i },
                contentStyle: { shape: r, key: a, value: o, spaceRow: i },
                hasContentShape: !1,
                keyWidth: 0,
                valueWidth: 0
              });
            ['key', 'value', 'shape'].forEach(t => {
              delete l[t];
            });
            const { title: c = {}, content: d = [] } = t;
            let u = 0,
              p = n.top + n.bottom,
              g = 0;
            const {
              visible: f = !0,
              value: v = '',
              valueStyle: m,
              hasShape: y,
              shapeType: _ = '',
              shapeHollow: b,
              shapeColor: x
            } = c;
            if (((l.title.visible = f), f)) {
              const t = _J({}, s, v9(m, void 0, {})),
                { text: e, width: i, height: n } = m9(v, t);
              if (
                ((l.title.value = Object.assign(Object.assign({ width: i, height: n }, t), { text: e })),
                (u = i),
                (g = n),
                y && YR[_])
              ) {
                const t = { symbolType: _ };
                b ? (t.stroke = x) : (t.fill = x),
                  (l.title.shape = t),
                  (u += r.size + r.spacing),
                  (g = Math.max(r.size, g));
              }
              (l.title.width = u), (l.title.height = g), (p += g);
            }
            if (d.length) {
              const t = d.filter(t => (t.key || t.value) && !1 !== t.visible);
              if (t.length) {
                f && (p += i);
                let e = !1;
                const n = [],
                  s = [],
                  c = [];
                l.content = t.map((l, d) => {
                  const u = { height: 0, spaceRow: i };
                  let g = 0;
                  const {
                    hasShape: f,
                    key: v,
                    shapeColor: m,
                    shapeHollow: y,
                    shapeType: _ = '',
                    value: b,
                    isKeyAdaptive: x
                  } = l;
                  if (h(v)) {
                    const t = _J({}, a, v9(l.keyStyle, void 0, {})),
                      { width: e, height: i, text: r } = m9(v, t);
                    (u.key = Object.assign(Object.assign({ width: e, height: i }, t), { text: r })),
                      x ? s.push(e) : n.push(e),
                      (g = Math.max(g, i));
                  }
                  if (h(b)) {
                    const t = _J({}, o, v9(l.valueStyle, void 0, {})),
                      { width: e, height: i, text: n } = m9(b, t);
                    (u.value = Object.assign(Object.assign({ width: e, height: i }, t), { text: n })),
                      c.push(e),
                      (g = Math.max(g, i));
                  }
                  if (f && YR[_]) {
                    e = !0;
                    const t = { visible: !0, symbolType: _ };
                    y ? (t.stroke = m) : (t.fill = m), (g = Math.max(r.size, g)), (u.shape = t);
                  } else u.shape = { visible: !1 };
                  return (u.height = g), (p += g), d < t.length - 1 && (p += i), u;
                });
                const d = n.length ? Math.max(...n) : 0,
                  g = s.length ? Math.max(...s) : 0,
                  v = c.length ? Math.max(...c) : 0,
                  m = e ? r.size + r.spacing : 0;
                (u = Math.max(d + v + a.spacing + o.spacing + m, g + m, u)),
                  (l.hasContentShape = e),
                  (l.keyWidth = d),
                  (l.valueWidth = v);
              }
            }
            const S = { width: u + n.left + n.right, height: p };
            return (l.panel.width = S.width), (l.panel.height = S.height), l;
          })(t, this._style)),
        {
          width:
            null === (n = null === (i = this._attributeCache) || void 0 === i ? void 0 : i.panel) || void 0 === n
              ? void 0
              : n.width,
          height:
            null === (r = null === (s = this._attributeCache) || void 0 === s ? void 0 : s.panel) || void 0 === r
              ? void 0
              : r.height
        }
      );
    }
    _getStyle() {
      var t, e, i, n, s;
      const r = this._component.getSpec(),
        { style: a = {}, enterable: o, transitionDuration: l } = r,
        { panel: c = {}, titleLabel: d, shape: u, keyLabel: p, valueLabel: g, spaceRow: f } = a,
        { backgroundColor: v, border: m, shadow: y, padding: _ } = c,
        b = { lineWidth: null !== (t = null == m ? void 0 : m.width) && void 0 !== t ? t : 0, shadow: !!y };
      (null == m ? void 0 : m.color) && (b.stroke = m.color),
        v && (b.fill = v),
        y &&
          ((b.shadowColor = y.color),
          (b.shadowBlur = y.blur),
          (b.shadowOffsetX = y.x),
          (b.shadowOffsetY = y.y),
          (b.shadowSpread = y.spread));
      const { radius: x } = null != m ? m : {};
      h(x) && (b.cornerRadius = [x, x, x, x]);
      const S = null === (i = (e = this._chartOption).getTheme) || void 0 === i ? void 0 : i.call(e);
      return {
        panel: b,
        title: v9(d, S),
        shape: {
          fill: !0,
          size: null !== (n = null == u ? void 0 : u.size) && void 0 !== n ? n : 8,
          spacing: null !== (s = null == u ? void 0 : u.spacing) && void 0 !== s ? s : 6
        },
        key: v9(p, S),
        value: v9(g, S),
        padding: _,
        spaceRow: f,
        enterable: o,
        transitionDuration: l
      };
    }
    _getParentElement(t) {
      return t.parentElement;
    }
    getTooltipContainer() {
      return this._container;
    }
    _initFromSpec() {
      (this._option = this._getDefaultOption()),
        (this._style = this._getStyle()),
        (this.changeTooltip = this._throttle(this._changeTooltip)),
        (this.changeTooltipPosition = this._throttle(this._changeTooltipPosition));
    }
    reInit() {
      this._initFromSpec();
    }
  }
  const b9 = (t, e) => (h(t) ? (f(t) ? t.map(t => `${t}px`).join(' ') : `${t}px`) : null != e ? e : 'initial');
  function x9(t, e) {
    var i, n, s, r, a, o, l, c, d, u;
    const {
        panel: {
          fill: p,
          shadow: g,
          shadowBlur: f,
          shadowColor: v,
          shadowOffsetX: m,
          shadowOffsetY: y,
          shadowSpread: _,
          cornerRadius: b,
          stroke: x,
          lineWidth: S = 0
        },
        padding: w,
        key: A,
        value: k,
        title: M,
        shape: T,
        enterable: C,
        spaceRow: E,
        transitionDuration: P
      } = t,
      R = p,
      O = (function (t, e) {
        if (!t) return;
        const { size: i } = _J({}, e, t),
          n = {};
        return (n.width = b9(i)), n;
      })(T),
      B = S9(A),
      I = S9(k),
      D = {
        panel: {
          width: b9(
            (null !== (n = null === (i = null == e ? void 0 : e.panel) || void 0 === i ? void 0 : i.width) &&
            void 0 !== n
              ? n
              : 0) +
              2 * S
          ),
          minHeight: b9(
            (null !== (r = null === (s = null == e ? void 0 : e.panel) || void 0 === s ? void 0 : s.height) &&
            void 0 !== r
              ? r
              : 0) +
              2 * S
          ),
          paddingBottom: b9(w.bottom),
          paddingLeft: b9(w.left),
          paddingRight: b9(w.right),
          paddingTop: b9(w.top),
          borderColor: x,
          borderWidth: b9(S),
          borderRadius: b9(b),
          backgroundColor: R ? `${R}` : 'transparent',
          boxShadow: g ? `${m}px ${y}px ${f}px ${_}px ${v}` : 'initial',
          pointerEvents: C ? 'auto' : 'none',
          transitionDuration: P ? `${P}ms` : 'initial',
          transitionProperty: P ? 'transform' : 'initial',
          transitionTimingFunction: P ? 'ease-out' : 'initial'
        },
        title: S9(_J({}, M, null === (a = null == e ? void 0 : e.title) || void 0 === a ? void 0 : a.value)),
        content: {},
        shapeColumn: {
          common: O,
          items: [],
          width: b9(T.size),
          marginRight: b9(null !== (o = T.spacing) && void 0 !== o ? o : 8)
        },
        keyColumn: {
          common: B,
          items:
            null === (l = null == e ? void 0 : e.content) || void 0 === l
              ? void 0
              : l.map(({ key: t }) =>
                  Object.assign(
                    Object.assign(Object.assign({}, B), S9(t)),
                    (null == t ? void 0 : t.multiLine) ? { width: b9(Math.ceil(t.width)) } : void 0
                  )
                ),
          width: b9(null == e ? void 0 : e.keyWidth),
          marginRight: b9(null !== (c = A.spacing) && void 0 !== c ? c : 26)
        },
        valueColumn: {
          common: I,
          items:
            null === (d = null == e ? void 0 : e.content) || void 0 === d
              ? void 0
              : d.map(({ value: t }) =>
                  Object.assign(
                    Object.assign(Object.assign({}, I), S9(t)),
                    (null == t ? void 0 : t.multiLine) ? { width: b9(Math.ceil(t.width)) } : void 0
                  )
                ),
          width: b9(null == e ? void 0 : e.valueWidth),
          marginRight: b9(null !== (u = k.spacing) && void 0 !== u ? u : 0)
        },
        spaceRow: b9(E)
      };
    if (h(E)) {
      const t = E / 2;
      [D.shapeColumn.common, D.keyColumn.common, D.valueColumn.common].forEach(e => {
        (e.marginTop = b9(t)), (e.marginBottom = e.marginTop);
      }),
        (D.content.marginTop = b9(-t)),
        (D.content.marginBottom = D.content.marginTop);
    } else
      [D.content, D.shapeColumn.common, D.keyColumn.common, D.valueColumn.common].forEach(t => {
        (t.marginTop = 'initial'), (t.marginBottom = 'initial');
      });
    return D;
  }
  function S9(t, e) {
    if (!t) return;
    const {
        fontFamily: i,
        fontSize: n,
        fill: s,
        textAlign: r,
        lineHeight: a,
        fontWeight: o,
        multiLine: l,
        wordBreak: h,
        maxWidth: c
      } = _J({}, e, t),
      d = {};
    return (
      (d.fontFamily = i),
      (d.fontSize = b9(n)),
      (d.color = s),
      (d.textAlign = r),
      (d.lineHeight = b9(a)),
      (d.fontWeight = o),
      (d.whiteSpace = l ? 'initial' : 'nowrap'),
      (d.wordBreak = h),
      (d.maxWidth = b9(c)),
      d
    );
  }
  class w9 {
    static isInstance(t) {
      return !!t && t.type === w9.type;
    }
    setOption(t) {
      (this._option = t), Object.values(this.children).forEach(e => e.setOption(t));
    }
    getParentEl() {
      return w9.isInstance(this.parent) ? this.parent.product : this.parent;
    }
    constructor(t, e, i) {
      (this.type = w9.type),
        (this._renderContentCache = null),
        (this.children = {}),
        (this.parent = t),
        (this._option = e),
        (this.childIndex = null != i ? i : 0);
    }
    init(t, e) {}
    initAll() {
      this.init(), Object.values(this.children).forEach(t => t.initAll());
    }
    setStyle(t) {
      this.product &&
        t &&
        Object.keys(t).forEach(e => {
          this.product.style[e] !== t[e] && (this.product.style[e] = t[e]);
        });
    }
    setContent(t) {}
    setVisibility(t) {
      if (!this.product) return;
      const { style: e } = this.product;
      (e.visibility = t ? 'visible' : 'hidden'), Object.values(this.children).forEach(e => e.setVisibility(t));
    }
    getVisibility() {
      var t, e;
      return (
        !!(null === (e = null === (t = this.product) || void 0 === t ? void 0 : t.style) || void 0 === e
          ? void 0
          : e.visibility) && 'hidden' !== this.product.style.visibility
      );
    }
    release() {
      var t;
      Object.values(this.children).forEach(t => t.release()),
        (this.children = {}),
        this.product &&
          (null === (t = this.getParentEl()) || void 0 === t || t.removeChild(this.product), (this.product = null));
    }
    createElement(t, e, i, n) {
      const s = null == Mo ? void 0 : Mo.createElement(t),
        r = this.getParentEl();
      if (!s || !r) return;
      e && s.classList.add(...e),
        i &&
          Object.keys(i).forEach(t => {
            s.style[t] = i[t];
          }),
        n && (s.id = n);
      let a = this.childIndex;
      if (w9.isInstance(this.parent)) {
        let t = Number.MAX_VALUE;
        for (let e = 0; e < r.children.length; e++) {
          const i = Object.values(this.parent.children).find(t => t.product === r.children[e]);
          i.childIndex > this.childIndex && i.childIndex < t && ((t = i.childIndex), (a = e));
        }
      }
      return a >= r.children.length ? r.appendChild(s) : r.insertBefore(s, r.children[a]), s;
    }
  }
  w9.type = 'tooltipModel';
  const A9 = { fontSize: '13px', marginBottom: '0px', fontWeight: 'normal' },
    k9 = { boxSizing: 'border-box' },
    M9 = { display: 'flex', whiteSpace: 'nowrap' },
    T9 = { display: 'flex', flexDirection: 'column', justifyContent: 'space-around', fontSize: '0' },
    C9 = { paddingTop: '0px', paddingBottom: '0px', textAlign: 'left', fontWeight: 'normal' },
    E9 = { paddingTop: '0px', paddingBottom: '0px', textAlign: 'left', fontWeight: 'normal' },
    P9 = { paddingTop: '0px', paddingBottom: '0px', textAlign: 'right', fontWeight: 'normal' },
    R9 = { lineHeight: 'normal' };
  class O9 extends w9 {
    init(t, e, i) {
      if (!this.product) {
        const n = this.createElement(null != i ? i : 'div', [...(null != t ? t : []), 'shape'], void 0, e);
        this.product = n;
      }
    }
    setStyle(t, e) {
      super.setStyle(t), this.setSvg(e);
    }
    setContent(t) {
      this.setSvg(t);
    }
    setSvg(t) {
      const e = (function (t) {
        var e, i, n, s, r, a, o;
        if (!(null == t ? void 0 : t.hasShape) || !t.shapeType || !YR[t.shapeType]) return '';
        const { shapeType: l, size: h, color: d, hollow: u = !1, marginTop: p = '0px' } = t,
          f = YR[l].pathStr;
        let v = 'currentColor';
        if (!d || g(d) || u)
          return (
            (v = u ? 'none' : null !== (e = d) && void 0 !== e ? e : 'currentColor'),
            `\n    <svg width="${h}" height="${h}" viewBox="-0.5 -0.5 1 1"\n      style="display: inline-block; vertical-align: middle; margin-top: ${p};">\n      <path fill="${v}" d="${f}" style="fill: ${v};">\n      </path>\n    </svg>`
          );
        if (c(d)) {
          v = 'gradientColor';
          let t = '';
          return (
            'radial' === d.gradient
              ? (t = `\n      <radialGradient id="${v}" cx="50%" cy="50%" r="50%" fx="0%" fy="0%">\n        ${(null !==
                  (i = d.stops) && void 0 !== i
                  ? i
                  : []
                ).map(t => `<stop offset="${t.offset}" stop-color="${t.color}"/>`)}\n     \t</radialGradient>\n      `)
              : 'linear' === d.gradient &&
                (t = `\n      <linearGradient id="${v}" x1="${
                  100 * (null !== (n = d.x0) && void 0 !== n ? n : 0)
                }%" y1="${100 * (null !== (s = d.y0) && void 0 !== s ? s : 0)}%" x2="${
                  100 * (null !== (r = d.x1) && void 0 !== r ? r : 0)
                }%" y2="${100 * (null !== (a = d.y1) && void 0 !== a ? a : 0)}%">\n        ${(null !== (o = d.stops) &&
                void 0 !== o
                  ? o
                  : []
                ).map(t => `<stop offset="${t.offset}" stop-color="${t.color}"/>`)}\n      </linearGradient>\n      `),
            `\n    <svg width="${h}" height="${h}" viewBox="-0.5 -0.5 1 1"\n      style="display: inline-block; vertical-align: middle; margin-top: ${p};">\n      ${t}\n      <path fill="url(#${v})" d="${f}" style="fill: url(#${v});">\n      </path>\n    </svg>`
          );
        }
        return '';
      })(t);
      this.product && e !== this._svgHtmlCache && ((this._svgHtmlCache = e), (this.product.innerHTML = e));
    }
    release() {
      super.release(), (this._svgHtmlCache = '');
    }
  }
  class B9 extends w9 {
    init(t, e, i) {
      this.product || (this.product = this.createElement(null != i ? i : 'span', t, void 0, e));
    }
    setContent(t, e) {
      if (!this.product) return;
      let i = this._option.valueToHtml(t);
      e && (i = i.replaceAll('\n', '<br>')), i !== this.product.innerHTML && (this.product.innerHTML = i);
    }
  }
  class I9 extends w9 {
    constructor(t, e, i, n) {
      super(t, e, n), (this.className = i);
    }
    init() {
      var t, e;
      this.product || (this.product = this.createElement('div', [this.className]));
      const i =
        null !== (e = null === (t = this._option.getTooltipActual()) || void 0 === t ? void 0 : t.content) &&
        void 0 !== e
          ? e
          : [];
      if ('shape-box' !== this.className || i.some(t => t.hasShape && t.shapeType)) {
        Object.keys(this.children).forEach(t => {
          const e = q(t);
          e >= i.length && (this.children[e].release(), delete this.children[e]);
        });
        for (let t = 0; t < i.length; t++)
          if (!this.children[t])
            if ('key-box' === this.className || 'value-box' === this.className) {
              const e = new B9(this.product, this._option, t);
              e.init([this.className.substring(0, this.className.indexOf('-'))], void 0, 'div'), (this.children[t] = e);
            } else if ('shape-box' === this.className) {
              const e = new O9(this.product, this._option, t);
              e.init(['shape'], void 0, 'div'), (this.children[t] = e);
            }
      } else
        Object.keys(this.children).forEach(t => {
          const e = q(t);
          this.children[e].release(), delete this.children[e];
        });
    }
    setStyle() {
      var t, e, i, n;
      const s = this._option.getTooltipStyle();
      super.setStyle(_J({}, T9, s.content, this._getContentColumnStyle()));
      const r =
          null !== (e = null === (t = this._option.getTooltipActual()) || void 0 === t ? void 0 : t.content) &&
          void 0 !== e
            ? e
            : [],
        a =
          null !== (n = null === (i = this._option.getTooltipAttributes()) || void 0 === i ? void 0 : i.content) &&
          void 0 !== n
            ? n
            : [];
      r.forEach((t, e) => {
        var i, n, r, o, l;
        let h = {};
        if ('key-box' === this.className) {
          const { key: r, isKeyAdaptive: o } = t;
          h = _J(
            {},
            o ? E9 : C9,
            Object.assign(
              Object.assign({ height: b9(a[e].height) }, s.keyColumn.common),
              null === (i = s.keyColumn.items) || void 0 === i ? void 0 : i[e]
            )
          );
          (g(r) && '' !== (null === (n = null == r ? void 0 : r.trim) || void 0 === n ? void 0 : n.call(r))) ||
          y(r) ||
          h.visibility
            ? (h.visibility = 'visible')
            : (h.visibility = 'hidden'),
            this.children[e].setStyle(h);
        } else
          'value-box' === this.className
            ? ((h = _J(
                {},
                P9,
                Object.assign(
                  Object.assign({ height: b9(a[e].height) }, s.valueColumn.common),
                  null === (r = s.valueColumn.items) || void 0 === r ? void 0 : r[e]
                )
              )),
              this.children[e].setStyle(h))
            : 'shape-box' === this.className &&
              ((h = _J(
                {},
                R9,
                Object.assign(
                  Object.assign({ height: b9(a[e].height) }, s.shapeColumn.common),
                  null === (o = s.shapeColumn.items) || void 0 === o ? void 0 : o[e]
                )
              )),
              null === (l = this.children[e]) || void 0 === l || l.setStyle(h, this._getShapeSvgOption(t, e)));
      });
    }
    setContent() {
      var t, e, i, n;
      const s =
          null !== (e = null === (t = this._option.getTooltipActual()) || void 0 === t ? void 0 : t.content) &&
          void 0 !== e
            ? e
            : [],
        r =
          null !== (n = null === (i = this._option.getTooltipAttributes()) || void 0 === i ? void 0 : i.content) &&
          void 0 !== n
            ? n
            : [];
      s.forEach((t, e) => {
        var i, n, s, a, o, l, h;
        let c;
        if ('key-box' === this.className) {
          const a = t.key;
          (c =
            (g(a) && '' !== (null === (i = null == a ? void 0 : a.trim) || void 0 === i ? void 0 : i.call(a))) || y(a)
              ? a
              : ''),
            null === (n = this.children[e]) ||
              void 0 === n ||
              n.setContent(c, null === (s = r[e].key) || void 0 === s ? void 0 : s.multiLine);
        } else if ('value-box' === this.className) {
          const i = t.value;
          (c =
            (g(i) && '' !== (null === (a = null == i ? void 0 : i.trim) || void 0 === a ? void 0 : a.call(i))) || y(i)
              ? i
              : ''),
            null === (o = this.children[e]) ||
              void 0 === o ||
              o.setContent(c, null === (l = r[e].value) || void 0 === l ? void 0 : l.multiLine);
        } else
          'shape-box' === this.className &&
            ((c = this._getShapeSvgOption(t, e)), null === (h = this.children[e]) || void 0 === h || h.setContent(c));
      });
    }
    _getContentColumnStyle() {
      var t, e;
      const i = this._option.getTooltipStyle();
      switch (this.className) {
        case 'shape-box':
          const n =
            null !== (e = null === (t = this._option.getTooltipActual()) || void 0 === t ? void 0 : t.content) &&
            void 0 !== e
              ? e
              : [];
          return Object.assign(
            Object.assign({}, i.shapeColumn),
            'shape-box' !== this.className || n.some(t => t.hasShape && t.shapeType) ? {} : { display: 'none' }
          );
        case 'key-box':
          return i.keyColumn;
        case 'value-box':
          return i.valueColumn;
      }
    }
    _getShapeSvgOption(t, e) {
      var i, n, s, r, a;
      const o = this._option.getTooltipStyle(),
        l = Object.assign(
          Object.assign({}, o.shapeColumn),
          null === (i = o.shapeColumn.items) || void 0 === i ? void 0 : i[e]
        ),
        h = Object.assign(
          Object.assign({}, o.keyColumn),
          null === (n = o.keyColumn.items) || void 0 === n ? void 0 : n[e]
        );
      return {
        hasShape: t.hasShape,
        shapeType: t.shapeType,
        size: l.width,
        color: t.shapeColor,
        hollow: t.shapeHollow,
        marginTop: `calc((${
          null !== (r = null !== (s = h.lineHeight) && void 0 !== s ? s : h.fontSize) && void 0 !== r ? r : '18px'
        } - ${null !== (a = l.width) && void 0 !== a ? a : '8px'}) / 2)`
      };
    }
  }
  class D9 extends w9 {
    init() {
      this.product || (this.product = this.createElement('div', ['container-box'])),
        this.shapeBox || this._initShapeBox(),
        this.keyBox || this._initKeyBox(),
        this.valueBox || this._initValueBox();
    }
    _initShapeBox() {
      const t = new I9(this.product, this._option, 'shape-box', 0);
      t.init(), (this.shapeBox = t), (this.children[t.childIndex] = t);
    }
    _initKeyBox() {
      const t = new I9(this.product, this._option, 'key-box', 1);
      t.init(), (this.keyBox = t), (this.children[t.childIndex] = t);
    }
    _initValueBox() {
      const t = new I9(this.product, this._option, 'value-box', 2);
      t.init(), (this.valueBox = t), (this.children[t.childIndex] = t);
    }
    setStyle(t) {
      super.setStyle(_J({}, M9, t)),
        Object.values(this.children).forEach(t => {
          t.setStyle();
        });
    }
    setContent() {
      Object.values(this.children).forEach(t => {
        t.setContent();
      });
    }
    release() {
      super.release(), (this.shapeBox = null), (this.keyBox = null), (this.valueBox = null);
    }
  }
  class L9 extends w9 {
    init() {
      const t = this._option.getTooltipActual();
      this.product || (this.product = this.createElement('h2'));
      const { title: e } = t;
      (null == e ? void 0 : e.hasShape) && (null == e ? void 0 : e.shapeType)
        ? this.shape || this._initShape()
        : this.shape && this._releaseShape(),
        this.textSpan || this._initTextSpan();
    }
    _initShape() {
      const t = new O9(this.product, this._option, 0);
      t.init(), (this.shape = t), (this.children[t.childIndex] = t);
    }
    _releaseShape() {
      this.shape && (this.shape.release(), delete this.children[this.shape.childIndex], (this.shape = null));
    }
    _initTextSpan() {
      const t = new B9(this.product, this._option, 1);
      t.init(), (this.textSpan = t), (this.children[t.childIndex] = t);
    }
    setStyle(t) {
      var e, i, n;
      const s = this._option.getTooltipStyle(),
        r = this._option.getTooltipActual(),
        { title: a } = r;
      super.setStyle(_J({}, A9, s.title, t)),
        null === (e = this.shape) ||
          void 0 === e ||
          e.setStyle(
            { paddingRight: null === (i = s.shapeColumn.common) || void 0 === i ? void 0 : i.marginRight },
            {
              hasShape: null == a ? void 0 : a.hasShape,
              shapeType: null == a ? void 0 : a.shapeType,
              size: null === (n = s.shapeColumn.common) || void 0 === n ? void 0 : n.width,
              color: null == a ? void 0 : a.shapeColor,
              hollow: null == a ? void 0 : a.shapeHollow
            }
          );
    }
    setContent() {
      var t, e, i, n, s;
      const r = this._option.getTooltipStyle(),
        a = this._option.getTooltipActual(),
        o = this._option.getTooltipAttributes(),
        { title: l } = a;
      this.init(),
        null === (t = this.shape) ||
          void 0 === t ||
          t.setStyle(void 0, {
            hasShape: null == l ? void 0 : l.hasShape,
            shapeType: null == l ? void 0 : l.shapeType,
            size: null === (e = r.shapeColumn.common) || void 0 === e ? void 0 : e.width,
            color: null == l ? void 0 : l.shapeColor,
            hollow: null == l ? void 0 : l.shapeHollow
          }),
        null === (i = this.textSpan) ||
          void 0 === i ||
          i.setContent(
            null == l ? void 0 : l.value,
            null === (s = null === (n = o.title) || void 0 === n ? void 0 : n.value) || void 0 === s
              ? void 0
              : s.multiLine
          );
    }
    release() {
      super.release(), (this.shape = null), (this.textSpan = null);
    }
  }
  class F9 extends w9 {
    constructor(t, e, i, n) {
      super(t, e, 0), (this.title = null), (this.content = null), (this._classList = i), (this._id = n);
    }
    setVisibility(t) {
      if ((super.setVisibility(t), !this.product)) return;
      const { classList: e } = this.product;
      t ? e.add('visible') : e.remove('visible');
    }
    init() {
      var t;
      const e = this._option.getTooltipActual();
      this.product || this._initPanel(this._classList, this._id);
      const { title: i } = e;
      !1 !== (null == i ? void 0 : i.visible) && h(null == i ? void 0 : i.value)
        ? this.title || this._initTitle()
        : this.title && this._releaseTitle();
      (null !== (t = e.content) && void 0 !== t ? t : []).length > 0
        ? this.content || this._initContent()
        : this.content && this._releaseContent();
    }
    _initPanel(t, e) {
      const i = this.createElement(
        'div',
        t,
        {
          left: '0',
          top: '0',
          pointerEvents: 'none',
          padding: '12px',
          position: 'absolute',
          zIndex: '99999999999999',
          fontFamily: 'sans-serif',
          fontSize: '11px',
          borderRadius: '3px',
          borderStyle: 'solid',
          lineHeight: 'initial',
          background: '#fff',
          boxShadow: '2px 2px 4px rgba(0, 0, 0, 0.1)',
          maxWidth: '100wh',
          maxHeight: '100vh'
        },
        e
      );
      this.product = i;
    }
    _initTitle() {
      const t = new L9(this.product, this._option, 0);
      t.init(), (this.title = t), (this.children[t.childIndex] = t);
    }
    _releaseTitle() {
      this.title && (this.title.release(), delete this.children[this.title.childIndex], (this.title = null));
    }
    _initContent() {
      const t = new D9(this.product, this._option, 1);
      t.init(), (this.content = t), (this.children[t.childIndex] = t);
    }
    _releaseContent() {
      this.content && (this.content.release(), delete this.children[this.content.childIndex], (this.content = null));
    }
    setStyle() {
      const t = this._option.getTooltipStyle();
      super.setStyle(_J({}, k9, t.panel)),
        Object.values(this.children).forEach((e, i) => {
          e.setStyle(i > 0 ? { marginTop: t.spaceRow } : { marginTop: '0px' });
        });
    }
    setContent() {
      Object.values(this.children).forEach(t => {
        t.setContent();
      });
    }
    release() {
      super.release(), (this.title = null), (this.content = null);
    }
  }
  class j9 extends _9 {
    getVisibility() {
      var t;
      return !!(null === (t = this.model) || void 0 === t ? void 0 : t.getVisibility());
    }
    setVisibility(t) {
      var e;
      t !== this.getVisibility() && (null === (e = this.model) || void 0 === e || e.setVisibility(t));
    }
    constructor(t, e) {
      super(t, e),
        (this.type = a9.dom),
        (this._tooltipContainer = null == Mo ? void 0 : Mo.body),
        this._initStyle(),
        this.initEl();
    }
    initEl() {
      const t = this._component.getSpec(),
        e = t.parentElement;
      if (Mo && e) {
        for (let t = 0; t < e.children.length; t++)
          if (e.children[t].classList.contains(i9)) {
            this._container = e.children[t];
            break;
          }
        this._container ||
          ((this._container = Mo.createElement('div')),
          (this._container.style.position = 'relative'),
          this._container.classList.add(i9),
          e.appendChild(this._container)),
          (this.model = new F9(
            this._container,
            {
              valueToHtml: this._option.sanitize,
              getTooltipStyle: () => this._domStyle,
              getTooltipActual: () => this._tooltipActual,
              getTooltipAttributes: () => this._attributeCache
            },
            [t.className],
            this.id
          ));
      }
    }
    _removeTooltip() {
      var t;
      null === (t = this.model) || void 0 === t || t.release(), (this._container = null);
    }
    _updateTooltip(t, e, i) {
      var n;
      if (t && this.model) {
        e.changePositionOnly ||
          ((this._tooltipActual = i),
          this._initStyle(),
          this.model.initAll(),
          this.model.setStyle(),
          this.model.setContent()),
          this.setVisibility(t);
        const { x: s = 0, y: r = 0 } = null !== (n = i.position) && void 0 !== n ? n : {},
          a = this.model.product;
        a && (a.style.transform = `translate3d(${s}px, ${r}px, 0)`);
      } else this.setVisibility(t);
    }
    _initStyle() {
      this._domStyle = x9(this._style, this._attributeCache);
    }
    _getParentElement(t) {
      var e;
      return null !== (e = this._container) && void 0 !== e ? e : super._getParentElement(t);
    }
    isTooltipShown() {
      return this.getVisibility();
    }
    reInit() {
      super.reInit(), this._initStyle();
    }
  }
  class z9 extends _9 {
    constructor(t, e) {
      var i;
      super(t, e),
        (this.type = a9.canvas),
        (this._tooltipCanvasId =
          null === (i = this._chartOption.modeParams) || void 0 === i ? void 0 : i.tooltipCanvasId);
    }
    _initTooltipComponent(t) {
      const e = this._getLayer(t);
      (this._tooltipComponent = new oK({ autoCalculatePosition: !1, autoMeasure: !1 })), e.add(this._tooltipComponent);
    }
    _getLayer(t) {
      if (this._layer) return this._layer;
      this._layer = t.createLayer(this._tooltipCanvasId);
      const e = this._layer.layerHandler.canvas.nativeCanvas;
      return e && e.style && ((e.style.touchAction = 'none'), (e.style.pointerEvents = 'none')), this._layer;
    }
    _removeTooltip() {
      this._layer && this._layer.removeAllChild(), (this._attributeCache = null);
    }
    _updateTooltip(t, e, i) {
      this._visible = t;
      const n = this._compiler.getStage();
      if (!n) return;
      if (!t)
        return void (
          this._tooltipComponent &&
          this._tooltipComponent.attribute.visible &&
          (this._tooltipComponent.hideAll(), this._tooltipComponent.setAttributes({ visibleAll: !1 }))
        );
      this._tooltipComponent || this._initTooltipComponent(n);
      const s = null == i ? void 0 : i.position;
      e.changePositionOnly
        ? h(s) && this._tooltipComponent.setAttributes(s)
        : this._tooltipComponent.setAttributes(Object.assign(Object.assign({}, this._attributeCache), s)),
        this._tooltipComponent.attribute.visible ||
          (this._tooltipComponent.showAll(), this._tooltipComponent.setAttributes({ visibleAll: !0 }));
    }
    isTooltipShown() {
      var t;
      return null === (t = this._tooltipComponent) || void 0 === t ? void 0 : t.attribute.visibleAll;
    }
    release() {
      var t;
      super.release(), null === (t = this._layer) || void 0 === t || t.release();
    }
  }
  class H9 {
    constructor(t) {
      (this._showTooltipByHandler = (t, e) => {
        var i, n;
        return (
          this.component.event.emit(
            Gq.tooltipShow,
            Object.assign(Object.assign({}, e), {
              tooltipData: t,
              activeType: this.activeType,
              tooltip: this.component
            })
          ),
          (null === (i = this.component.tooltipHandler) || void 0 === i ? void 0 : i.showTooltip) && h(t)
            ? null !== (n = this.component.tooltipHandler.showTooltip(this.activeType, t, e)) && void 0 !== n
              ? n
              : y9.success
            : y9.failed
        );
      }),
        (this.component = t);
    }
    _preprocessDimensionInfo(t) {
      const e = [];
      if (
        (null == t ||
          t.forEach(t => {
            const i = Object.assign(Object.assign({}, t), {
              data: t.data.filter(({ series: t }) => {
                var e, i;
                return (
                  !1 !==
                  (null === (i = null === (e = t.getSpec()) || void 0 === e ? void 0 : e.tooltip) || void 0 === i
                    ? void 0
                    : i.visible)
                );
              })
            });
            i.data.length > 0 && e.push(i);
          }),
        e.length > 0)
      )
        return e;
    }
    _getDimensionInfo(t) {
      var e, i, n;
      let s;
      const r = t.event.viewX,
        a = t.event.viewY,
        o = this.component.getChart(),
        l = { x: r, y: a };
      if (
        ((s = [
          ...(null !== (e = hQ(o, l)) && void 0 !== e ? e : []),
          ...(null !== (i = pQ(o, l)) && void 0 !== i ? i : [])
        ]),
        0 === s.length)
      )
        s = void 0;
      else if (s.length > 1) {
        const t =
          null !==
            (n = s.filter(t => {
              var e;
              const i = t.axis;
              if (!Qo(i.getScale().type)) return !1;
              let n;
              for (const t of null !== (e = null == i ? void 0 : i.getRegions()) && void 0 !== e ? e : []) {
                for (const e of t.getSeries())
                  if ('cartesian' === e.coordinate) {
                    n = e;
                    break;
                  }
                if (h(n)) break;
              }
              return h(n) && n.getDimensionField()[0] === n.fieldY[0]
                ? 'left' === i.getOrient() || 'right' === i.getOrient()
                : 'bottom' === i.getOrient() || 'top' === i.getOrient();
            })[0]) && void 0 !== n
            ? n
            : s[0];
        s = [t];
      }
      return s;
    }
  }
  class N9 extends H9 {
    constructor() {
      super(...arguments), (this.activeType = 'dimension');
    }
    showTooltip(t, e, i) {
      const n = Object.assign(Object.assign({}, e), {
        dimensionInfo: this._preprocessDimensionInfo(t),
        changePositionOnly: i
      });
      return this._showTooltipByHandler(t, n);
    }
    shouldHandleTooltip(t, e) {
      var i, n;
      const { tooltipInfo: s } = e;
      if (l(s)) return !1;
      const r = null === (i = t.model) || void 0 === i ? void 0 : i.tooltipHelper;
      return !!(
        null !== (n = null == r ? void 0 : r.activeType) && void 0 !== n ? n : this.component.getSpec().activeType
      ).includes('dimension');
    }
    getMouseEventData(t) {
      var e;
      return {
        tooltipInfo: this._getDimensionInfo(t),
        ignore: [...(null !== (e = this.component.getOption().getAllSeries()) && void 0 !== e ? e : [])].some(e => {
          var i;
          const n = null === (i = e.tooltipHelper) || void 0 === i ? void 0 : i.ignoreTriggerSet.dimension;
          return (t.model && (null == n ? void 0 : n.has(t.model))) || (t.mark && (null == n ? void 0 : n.has(t.mark)));
        })
      };
    }
  }
  class V9 extends H9 {
    constructor() {
      super(...arguments), (this.activeType = 'mark');
    }
    showTooltip(t, e, i) {
      const { datum: n, series: s, dimensionInfo: r } = t,
        a = [{ datum: [n], series: s }],
        o = Object.assign(Object.assign({}, e), {
          dimensionInfo: this._preprocessDimensionInfo(r),
          changePositionOnly: i
        });
      return this._showTooltipByHandler(a, o);
    }
    shouldHandleTooltip(t, e) {
      var i;
      const { tooltipInfo: n } = e;
      if (l(n)) return !1;
      const s = null === (i = t.model) || void 0 === i ? void 0 : i.tooltipHelper;
      return !!(null == s ? void 0 : s.activeType.includes('mark'));
    }
    getMouseEventData(t) {
      var e;
      let i, n;
      if ('series' === (null === (e = t.model) || void 0 === e ? void 0 : e.modelType)) {
        const e = t.model,
          s = e.tooltipHelper,
          r = null == s ? void 0 : s.activeTriggerSet.mark,
          a = null == s ? void 0 : s.ignoreTriggerSet.mark;
        (null == r ? void 0 : r.has(t.model)) || (null == r ? void 0 : r.has(t.mark))
          ? (i = { mark: t.mark, datum: t.datum, series: e, dimensionInfo: this._getDimensionInfo(t) })
          : ((null == a ? void 0 : a.has(t.model)) || (null == a ? void 0 : a.has(t.mark))) && (n = !0);
      }
      return { tooltipInfo: i, ignore: n };
    }
  }
  const W9 = t => h(t) && !f(t),
    G9 = t => h(t) && f(t);
  class U9 extends g6 {
    constructor() {
      super(...arguments),
        (this.type = xn.tooltip),
        (this.name = xn.tooltip),
        (this.layoutType = 'absolute'),
        (this._alwaysShow = !1),
        (this._eventList = []),
        (this._isTooltipShown = !1),
        (this._mountEvent = (t, e, i) => {
          this.event.on(t, e, i), this._eventList.push({ eventType: t, handler: i });
        }),
        (this._getMouseOutHandler = t => e => {
          var i, n;
          if (this._alwaysShow) return;
          if (
            !this._isTooltipShown &&
            !(null === (n = null === (i = this.tooltipHandler) || void 0 === i ? void 0 : i.isTooltipShown) ||
            void 0 === n
              ? void 0
              : n.call(i))
          )
            return;
          const s = To(this._option.mode),
            { clientX: r, clientY: a } = e.event;
          (s && this._isPointerOnTooltip(e)) ||
            (s && t && this._isPointerInChart({ x: r, y: a })) ||
            this._handleChartMouseOut(e);
        }),
        (this._handleChartMouseOut = t => {
          this._alwaysShow ||
            ('none' !== this._spec.triggerOff &&
              (this._hideTooltipByHandler(Object.assign({}, t)), (this._cacheInfo = void 0)));
        }),
        (this._handleMouseMove = t => {
          if ((this.tooltipHandler || this._initHandler(), this._processor || this._initProcessor(), this._alwaysShow))
            return;
          if (this._isPointerOnTooltip(t)) return;
          const e = this._getMouseEventData(t),
            {
              tooltipInfo: { dimension: i },
              ignore: { mark: n, dimension: s }
            } = e;
          let r = !1,
            a = !1;
          (r = this._showTooltipByMouseEvent('mark', e, t)),
            r || (a = this._showTooltipByMouseEvent('dimension', e, t)),
            r ||
              a ||
              (function (t) {
                return l(t.mark) && l(t.model) && l(t.datum);
              })(t) ||
              (n && W9(this._cacheInfo)
                ? (r = this._showTooltipByMouseEvent('mark', e, t, !0))
                : s && G9(this._cacheInfo)
                ? (a = this._showTooltipByMouseEvent('dimension', e, t, !0))
                : h(i) && (a = this._showTooltipByMouseEvent('dimension', e, t))),
            r || (a && !l(i)) || this._handleChartMouseOut(t);
        }),
        (this._showTooltipByMouseEvent = (t, e, i, n) => {
          const s = this._processor[t];
          if (!s.shouldHandleTooltip(i, { tooltipInfo: e.tooltipInfo[t], ignore: e.ignore[t] })) return !1;
          let r;
          if (n) r = !s.showTooltip(this._cacheInfo, i, !0);
          else {
            const n = e.tooltipInfo[t],
              a = this._isSameAsCacheInfo(n);
            (r = !s.showTooltip(n, i, a)), r && (this._cacheInfo = n);
          }
          r && (this._isTooltipShown = !0);
          const a = this._option.globalInstance;
          return r && NQ.globalConfig.uniqueTooltip && NQ.hideTooltip(a.id), r;
        }),
        (this._getMouseEventData = t => {
          const e = { tooltipInfo: {}, ignore: {} };
          return (
            Object.keys(this._processor).forEach(i => {
              const { tooltipInfo: n, ignore: s } = this._processor[i].getMouseEventData(t);
              (e.tooltipInfo[i] = n), (e.ignore[i] = s);
            }),
            e
          );
        }),
        (this._hideTooltipByHandler = t => {
          var e, i, n;
          if (
            !this._isTooltipShown &&
            !(null === (i = null === (e = this.tooltipHandler) || void 0 === e ? void 0 : e.isTooltipShown) ||
            void 0 === i
              ? void 0
              : i.call(e))
          )
            return y9.success;
          if (
            (this.event.emit(Gq.tooltipHide, Object.assign(Object.assign({}, t), { tooltip: this })),
            null === (n = this.tooltipHandler) || void 0 === n ? void 0 : n.hideTooltip)
          ) {
            const e = this.tooltipHandler.hideTooltip(t);
            return e || (this._isTooltipShown = !1), e;
          }
          return y9.failed;
        });
    }
    static createComponent(t, e) {
      const i = t.tooltip;
      if (!i) return null;
      if (!f(i)) return new U9(i, Object.assign(Object.assign({}, e), { specKey: 'tooltip' }));
      const n = [];
      return (
        i.forEach((t, i) => {
          n.push(new U9(t, Object.assign(Object.assign({}, e), { specIndex: i, specKey: 'tooltip' })));
        }),
        n
      );
    }
    isTooltipShown() {
      return this._isTooltipShown;
    }
    changeRegions(t) {}
    _registerEvent() {}
    _releaseEvent() {}
    onLayout(t) {}
    onLayoutEnd(t) {}
    onRender(t) {}
    created() {
      super.created(), (this._regions = this._option.getAllRegions()), this._initEvent();
    }
    release() {
      var t, e;
      this.event.emit(Gq.tooltipHide, { tooltip: this }),
        this.event.emit(Gq.tooltipRelease, { tooltip: this }),
        super.release(),
        this._eventList.forEach(({ eventType: t, handler: e }) => {
          this.event.off(t, e);
        }),
        (this._eventList = []),
        null === (e = null === (t = this.tooltipHandler) || void 0 === t ? void 0 : t.release) ||
          void 0 === e ||
          e.call(t),
        (this._isTooltipShown = !1);
    }
    _initHandler() {
      var t, e, i;
      const n = null !== (t = this._spec.renderMode) && void 0 !== t ? t : 'html',
        s = this._option.globalInstance.getTooltipHandlerByUser();
      if (s) this.tooltipHandler = s;
      else {
        const t = 'canvas' === n ? z9 : j9,
          s = `${this._spec.className}-${null !== (e = this._option.globalInstance.id) && void 0 !== e ? e : 0}-${
            null !== (i = this._option.specIndex) && void 0 !== i ? i : 0
          }`;
        this.tooltipHandler = new t(s, this);
      }
    }
    _initProcessor() {
      this._processor = { mark: new V9(this), dimension: new N9(this) };
    }
    _initEvent() {
      var t;
      const e = null !== (t = this._spec.trigger) && void 0 !== t ? t : 'hover',
        i = this._option.mode;
      'hover' === e
        ? (this._mountEvent('pointermove', { level: Yq.chart }, this._handleMouseMove),
          (Co(i) || Eo(i)) &&
            (this._mountEvent('pointerdown', { level: Yq.chart }, this._handleMouseMove),
            this._mountEvent('pointerup', { source: 'window' }, this._getMouseOutHandler(!0))),
          this._mountEvent('pointerout', { source: 'canvas' }, this._getMouseOutHandler(!1)))
        : 'click' === e &&
          (this._mountEvent('pointertap', { level: Yq.chart }, this._handleMouseMove),
          this._mountEvent('pointerup', { source: 'window' }, this._getMouseOutHandler(!0)));
    }
    _initTheme(t) {
      super._initTheme(t),
        (this._spec.style = this._prepareSpecAfterMergingTheme(_J({}, this._theme, this._originalSpec.style)));
    }
    _shouldMergeThemeToSpec() {
      return !1;
    }
    reInit(t) {
      var e, i;
      super.reInit(t),
        this.tooltipHandler
          ? null === (i = (e = this.tooltipHandler).reInit) || void 0 === i || i.call(e)
          : this._initHandler();
    }
    setAttrFromSpec() {
      var t;
      super.setAttrFromSpec();
      const e = this._spec;
      (this._spec = Object.assign(Object.assign({}, e), {
        visible: !h(e.visible) || e.visible,
        activeType: j1(e),
        renderMode: 'html',
        trigger: h(e.trigger) ? e.trigger : 'hover',
        className: h(e.className) ? e.className : 'vchart-tooltip-element',
        enterable: !!h(e.enterable) && e.enterable,
        transitionDuration: h(e.transitionDuration) ? e.transitionDuration : 150
      })),
        (this._spec.triggerOff = h(e.triggerOff) ? e.triggerOff : this._spec.trigger),
        h(e.renderMode)
          ? (this._spec.renderMode = e.renderMode)
          : Eo(this._option.mode) && (this._spec.renderMode = 'canvas'),
        h(e.mark) && (this._spec.mark = Object.assign(Object.assign({}, R(e.mark)), { activeType: 'mark' })),
        h(e.dimension) &&
          (this._spec.dimension = Object.assign(Object.assign({}, R(e.dimension)), { activeType: 'dimension' })),
        h(e.parentElement)
          ? g(e.parentElement)
            ? (this._spec.parentElement =
                null === (t = globalThis.document) || void 0 === t ? void 0 : t.getElementById(e.parentElement))
            : (this._spec.parentElement = e.parentElement)
          : To(this._option.mode) && (this._spec.parentElement = null == Mo ? void 0 : Mo.body),
        h(e.confine) ? (this._spec.confine = e.confine) : (this._spec.confine = 'canvas' === this._spec.renderMode);
    }
    showTooltip(t, e) {
      var i;
      if (
        (this.tooltipHandler || this._initHandler(),
        this._processor || this._initProcessor(),
        !(null === (i = this.tooltipHandler) || void 0 === i ? void 0 : i.showTooltip))
      )
        return !1;
      const n = F1(t, e, this.tooltipHandler, this._option);
      return 'none' !== n && (this._alwaysShow = !!(null == e ? void 0 : e.alwaysShow)), n;
    }
    hideTooltip() {
      const t = { changePositionOnly: !1, item: void 0, datum: void 0, source: Uq.chart };
      return (this._alwaysShow = !1), !this._hideTooltipByHandler(t);
    }
    _isSameAsCacheInfo(t) {
      if (t === this._cacheInfo) return !0;
      if (l(this._cacheInfo) || l(t)) return !1;
      if (G9(t)) {
        if (W9(this._cacheInfo)) return !1;
        const e = this._cacheInfo;
        return e.length === t.length && t.every((t, i) => $J(t, e[i]));
      }
      if (G9(this._cacheInfo)) return !1;
      const e = this._cacheInfo;
      return (
        (null == t ? void 0 : t.datum) === e.datum &&
        (null == t ? void 0 : t.mark) === e.mark &&
        (null == t ? void 0 : t.series) === e.series
      );
    }
    _isPointerInChart(t) {
      const e = this._option.globalInstance;
      if (!e.getChart()) return !1;
      const { x: i, y: n } = t,
        s = e.getCanvas(),
        { x: r, y: a, width: o, height: l } = s.getBoundingClientRect();
      return i >= r && i <= r + o && n >= a && n <= a + l;
    }
    _isPointerOnTooltip(t) {
      var e, i;
      if (this._spec.enterable && 'html' === this._spec.renderMode) {
        const { event: n } = t;
        let s;
        if (h(n.nativeEvent)) {
          const t = n.nativeEvent;
          (s = t.target), t.composedPath && t.composedPath().length > 0 && (s = t.composedPath()[0]);
        } else s = n.target;
        const r =
          null === (i = null === (e = this.tooltipHandler) || void 0 === e ? void 0 : e.getTooltipContainer) ||
          void 0 === i
            ? void 0
            : i.call(e);
        if (
          h(r) &&
          h(s) &&
          (function (t, e) {
            let i = t.parentNode;
            for (; null !== i; ) {
              if (i === e) return !0;
              i = i.parentNode;
            }
            return !1;
          })(s, r)
        )
          return !0;
      }
      return !1;
    }
    getVisible() {
      return !0 === this._spec.visible;
    }
  }
  U9.type = xn.tooltip;
  class Y9 extends g6 {
    constructor(t, e) {
      super(t, e),
        (this.type = xn.label),
        (this.name = xn.label),
        (this.layoutType = 'absolute'),
        (this.layoutZIndex = cZ.Label),
        (this._regions = e.getRegionsInIndex([e.specIndex])),
        (this.layoutBindRegionID = this._regions.map(t => t.id));
    }
    _interactiveConfig(t) {
      const { interactive: e } = t;
      if (!0 !== e) return { hover: !1, select: !1 };
      const i = { hover: !1, select: !1, state: t.state },
        { hover: n, select: s } = this._option.getChart().getSpec();
      return (!1 === n && !1 === n.enable) || (i.hover = !0), (!1 === s && !1 === s.enable) || (i.select = !0), i;
    }
    setLayoutStartPosition() {}
    updateSpec(t) {
      const e = super.updateSpec(t);
      return (e.reRender = !0), (e.reMake = !0), e;
    }
    onRender(t) {}
    changeRegions(t) {}
  }
  Y9.type = xn.label;
  class $9 extends i2 {
    constructor() {
      super(...arguments), (this.skipEncode = !1);
    }
    getRule() {
      return this._rule;
    }
    setRule(t) {
      this._rule = t;
    }
    getTarget() {
      return this._target;
    }
    setTarget(t) {
      this._target = t;
    }
    getComponent() {
      return this._component;
    }
    setComponent(t) {
      this._component = t;
    }
  }
  ($9.type = jZ.text), ($9.constructorType = jZ.label), NQ.useMark([$9]);
  class X9 extends Y9 {
    constructor(t, e) {
      super(t, e),
        (this.type = xn.label),
        (this.name = xn.label),
        (this.layoutType = 'absolute'),
        (this.layoutZIndex = cZ.Label),
        (this._layoutRule = t.labelLayout || 'series');
    }
    static createComponent(t, e) {
      const i = e.getAllRegions(),
        n = [];
      for (let s = 0; s < i.length; s++) {
        const r = i[s]
          .getSeries()
          .map(t => t.getMarksWithoutRoot())
          .flat();
        r.some(t => {
          var e;
          return null === (e = t.getLabelSpec()) || void 0 === e ? void 0 : e.some(t => t.visible);
        }) && n.push(new X9(t, Object.assign(Object.assign({}, e), { specIndex: s, specKey: 'label' })));
      }
      return n;
    }
    init(t) {
      super.init(t), this.initEvent(), this._initTextMark(), this._initLabelComponent(), this._initTextMarkStyle();
    }
    initEvent() {
      this.event.on(Gq.dataZoomChange, () => {
        this._labelComponentMap.forEach((t, e) => {
          const i = e.getProduct().getGroupGraphicItem();
          i && i.disableAnimation();
        }),
          this.event.on(tG.AFTER_MARK_RENDER_END, t);
      });
      const t = () => {
        this._labelComponentMap.forEach((t, e) => {
          const i = e.getProduct().getGroupGraphicItem();
          i && i.enableAnimation();
        }),
          this.event.off(tG.AFTER_MARK_RENDER_END, t);
      };
      this.event.on('afterElementEncode', t => {
        var e;
        const i = t.item;
        !1 === this._option.getChart().getLayoutTag() &&
          (null === (e = i.context) || void 0 === e ? void 0 : e.model) === this &&
          this._delegateLabelEvent(i.getGroupGraphicItem());
      });
    }
    _delegateLabelEvent(t) {
      const e = null == t ? void 0 : t.findAll(t => 'text' === t.type, !0).filter(t => !t.__vchart_event);
      e &&
        e.length > 0 &&
        e.forEach(e => {
          (e.__vchart_event = !0), e.addEventListener('*', (i, n) => this._delegateEvent(t, i, n, e, e.attribute.data));
        });
    }
    _initTextMark() {
      this._labelInfoMap || (this._labelInfoMap = new Map()),
        this._labelComponentMap || (this._labelComponentMap = new Map()),
        tV(this._regions, t => {
          var e;
          const i = t.getMarks(),
            n = t.getRegion();
          this._labelInfoMap.get(n) || this._labelInfoMap.set(n, []);
          for (let s = 0; s < i.length; s++) {
            const r = i[s];
            (null === (e = r.getLabelSpec()) || void 0 === e ? void 0 : e.length) > 0 &&
              r.getLabelSpec().forEach((e, i) => {
                if (e.visible) {
                  const s = this._labelInfoMap.get(n),
                    a = this._createMark({ type: jZ.label, name: `${r.name}-label-${i}` });
                  a.setTarget(r), s.push({ labelMark: a, baseMark: r, series: t, labelSpec: e });
                }
              });
          }
        });
    }
    _initLabelComponent() {
      this._labelInfoMap.forEach((t, e) => {
        if ('region' === this._layoutRule) {
          const i = this._createMark(
            { type: jZ.component, name: `${e.getGroupMark().name}-label-component` },
            { componentType: 'label', support3d: this._spec.support3d }
          );
          i && (this._marks.addMark(i), this._labelComponentMap.set(i, t));
        } else
          t.forEach(t => {
            const e = this._createMark(
              { type: jZ.component, name: `${t.labelMark.name}-component` },
              { componentType: 'label', support3d: t.baseMark.getSupport3d() }
            );
            e && (this._marks.addMark(e), this._labelComponentMap.set(e, t), t.labelMark.setComponent(e));
          });
      });
    }
    _initTextMarkStyle() {
      this._labelInfoMap.forEach(t => {
        t.forEach(t => {
          var e;
          const { labelMark: i, labelSpec: n, series: s } = t;
          this.initMarkStyleWithSpec(i, n), null === (e = s.initLabelMarkStyle) || void 0 === e || e.call(s, i);
        });
      });
    }
    updateLayoutAttribute() {
      super.updateLayoutAttribute(),
        this._labelComponentMap.forEach((t, e) => {
          f(t) ? this._updateMultiLabelAttribute(t, e) : this._updateSingleLabelAttribute(t, e);
        });
    }
    _updateMultiLabelAttribute(t, e) {
      this._updateLabelComponentAttribute(
        e.getProduct(),
        t.map(({ baseMark: t }) => t.getProduct()),
        t[0]
      );
    }
    _updateSingleLabelAttribute(t, e) {
      const { baseMark: i } = t;
      this._updateLabelComponentAttribute(e.getProduct(), i.getProduct(), t);
    }
    _updateLabelComponentAttribute(t, e, i) {
      const { baseMark: n, labelSpec: s, series: r, labelMark: a } = i,
        o = this._option.getAllComponents().filter(t => 'totalLabel' === t.type);
      t.target(e)
        .configure({ interactive: !1 })
        .depend(o.map(t => t.getMarks()[0].getProduct()))
        .labelStyle(() => {
          var t, e, r;
          const o = a.getRule() || n.type,
            l = null !== (t = $4[o]) && void 0 !== t ? t : $4.point,
            h = this._interactiveConfig(s),
            c = L(s, ['position', 'style', 'state']),
            d =
              null !== (r = null === (e = this._spec) || void 0 === e ? void 0 : e.centerOffset) && void 0 !== r
                ? r
                : 0;
          return _J(
            {
              textStyle: Object.assign({ pickable: !0 === s.interactive }, s.style),
              overlap: {
                avoidMarks: this._option
                  .getAllComponents()
                  .filter(t => 'totalLabel' === t.type)
                  .map(t => t.getMarks()[0].getProductId())
              }
            },
            l(i),
            Object.assign(Object.assign(Object.assign({}, c), h), { centerOffset: d })
          );
        })
        .encode(t => (a.skipEncode ? { data: t } : K4(i, t, s.formatMethod)))
        .size(() => r.getRegion().getLayoutRect());
    }
    compileMarks() {
      this.getMarks().forEach(t => {
        var e;
        const i = this._labelComponentMap.get(t);
        let n;
        (n = f(i)
          ? i[0].series.getRegion().getGroupMark().getProduct()
          : i.series.getRegion().getGroupMark().getProduct()),
          t.compile({ group: n }),
          null === (e = t.getProduct()) || void 0 === e || e.configure({ context: { model: this, labelInfo: i } });
      });
    }
  }
  X9.type = xn.label;
  class K9 extends Y9 {
    constructor() {
      super(...arguments),
        (this.type = xn.totalLabel),
        (this.name = xn.totalLabel),
        (this.layoutType = 'absolute'),
        (this.layoutZIndex = cZ.Label);
    }
    static createComponent(t, e) {
      const i = e.getAllRegions(),
        n = [];
      for (let t = 0; t < i.length; t++) {
        eV(i).forEach(i => {
          var s, r;
          if (
            null === (r = null === (s = i.getSpec()) || void 0 === s ? void 0 : s.totalLabel) || void 0 === r
              ? void 0
              : r.visible
          ) {
            const s = new K9(
              i.getSpec().totalLabel,
              Object.assign(Object.assign({}, e), { specIndex: t, specKey: 'totalLabel' })
            );
            (s.series = i), n.push(s);
          }
        });
      }
      return n;
    }
    init(t) {
      super.init(t), this._initTextMark(), this._initLabelComponent();
    }
    _initTextMark() {
      var t;
      if (null === (t = this.series.getSpec().totalLabel) || void 0 === t ? void 0 : t.visible) {
        const t = this.series.getMarksInType([jZ.rect, jZ.symbol])[0],
          e = this._createMark({ type: jZ.label, name: `${t.name}-total-label` });
        (this._baseMark = t), (this._textMark = e), this._initTextMarkStyle();
      }
    }
    _initTextMarkStyle() {
      super.initMarkStyleWithSpec(this._textMark, this._spec),
        this.setMarkStyle(this._textMark, { text: t => t[rZ] }, 'normal', Jq.Default);
    }
    _initLabelComponent() {
      const t = this._createMark(
        { type: jZ.component, name: `${this.series.name}-total-label-component` },
        { componentType: 'label', support3d: this._spec.support3d }
      );
      t && this._marks.addMark(t);
    }
    updateLayoutAttribute() {
      super.updateLayoutAttribute(),
        this._marks.forEach((t, e) => {
          t.getProduct()
            .target(this._baseMark.getProduct())
            .configure({ interactive: !1 })
            .labelStyle(() => {
              if (this._baseMark) {
                const { offset: t, animation: e, overlap: i } = this._spec,
                  n = this._interactiveConfig(this._spec);
                return _J(
                  {
                    textStyle: { pickable: !0 === this._spec.interactive },
                    position: q9(this.series, this._baseMark.type)
                  },
                  Object.assign({ offset: t, animation: e, overlap: i, dataFilter: t => t.filter(t => t.data[oZ]) }, n)
                );
              }
            })
            .encode(t =>
              K4(
                {
                  baseMark: this._baseMark,
                  labelMark: this._textMark,
                  series: this.series,
                  labelSpec: this.series.getSpec().totalLabel
                },
                t,
                this._spec.formatMethod
              )
            )
            .size(() => this._regions[0].getLayoutRect());
        });
    }
    compileMarks() {
      this.getMarks().forEach(t => {
        var e;
        const i = this._regions[0].getGroupMark().getProduct();
        t.compile({ group: i }),
          null === (e = t.getProduct()) || void 0 === e || e.configure({ context: { model: this } });
      });
    }
  }
  function q9(t, e) {
    let i;
    if ('rect' === e) i = 'horizontal' === t.direction ? 'right' : 'top';
    else i = 'top';
    return i;
  }
  K9.type = xn.totalLabel;
  class Z9 {
    constructor(t, e) {
      (this._chartLayoutRect = { x: 0, y: 0, width: 1, height: 1 }),
        (this._col = 1),
        (this._row = 1),
        (this._elementMap = new Map()),
        this.standardizationSpec(t),
        (this._gridInfo = t),
        (this._col = t.col),
        (this._row = t.row),
        (this._colSize = new Array(this._col).fill(null)),
        (this._rowSize = new Array(this._row).fill(null)),
        (this._colElements = new Array(this._col).fill([])),
        (this._rowElements = new Array(this._row).fill([])),
        (this._onError = null == e ? void 0 : e.onError),
        this.initUserSetting();
    }
    standardizationSpec(t) {
      var e, i, n;
      (t.col = null !== (e = t.col) && void 0 !== e ? e : 1),
        (t.row = null !== (i = t.row) && void 0 !== i ? i : 1),
        (t.elements = null !== (n = t.elements) && void 0 !== n ? n : []);
    }
    initUserSetting() {
      this._gridInfo.colWidth &&
        this.setSizeFromUserSetting(this._gridInfo.colWidth, this._colSize, this._col, this._chartLayoutRect.width),
        this._gridInfo.rowHeight &&
          this.setSizeFromUserSetting(this._gridInfo.rowHeight, this._rowSize, this._row, this._chartLayoutRect.height),
        this._colSize.forEach((t, e) => {
          t || (this._colSize[e] = { value: 0, isUserSetting: !1, isLayoutSetting: !1 });
        }),
        this._rowSize.forEach((t, e) => {
          t || (this._rowSize[e] = { value: 0, isUserSetting: !1, isLayoutSetting: !1 });
        });
    }
    setSizeFromUserSetting(t, e, i, n) {
      t.forEach(t => {
        (t.index < 0 && t.index >= i) ||
          (_(t.size)
            ? (e[t.index] = { value: +t.size, isUserSetting: !0, isLayoutSetting: !1 })
            : o(t.size) && (e[t.index] = { value: t.size(n), isUserSetting: !0, isLayoutSetting: !1 }));
      });
    }
    clearLayoutSize() {
      this._colSize.forEach(t => {
        (t.isLayoutSetting = !1), t.isUserSetting || (t.value = 0);
      }),
        this._rowSize.forEach(t => {
          (t.isLayoutSetting = !1), t.isUserSetting || (t.value = 0);
        });
    }
    getItemGridInfo(t) {
      var e;
      const i = this._elementMap.get(t);
      if (i) return i;
      const n = t;
      let s;
      return (
        (s =
          null === (e = this._gridInfo.elements) || void 0 === e
            ? void 0
            : e.find(t => {
                if ('modelId' in t && h(t.modelId)) {
                  if (h(n.userId) && n.userId === t.modelId) return !0;
                } else if (
                  'modelKey' in t &&
                  h(t.modelKey) &&
                  'modelIndex' in t &&
                  h(t.modelIndex) &&
                  n.specKey === t.modelKey &&
                  n.getSpecIndex() === t.modelIndex
                )
                  return !0;
                return !1;
              })),
        s || (s = { col: 0, colSpan: 1, row: 0, rowSpan: 1 }),
        this._elementMap.set(t, s),
        s
      );
    }
    getSizeFromGird(t, e) {
      var i;
      const n = 'col' === e ? this._colSize : this._rowSize;
      let s = 0;
      for (let r = t[e]; r < t[e] + (null !== (i = t[`${e}Span`]) && void 0 !== i ? i : 1); r++) s += n[r].value;
      return s;
    }
    getSizeFromUser(t, e) {
      var i;
      const n = 'col' === e ? this._colSize : this._rowSize;
      if (!n[t[e]].isUserSetting) return;
      let s = 0;
      for (let r = t[e]; r < t[e] + (null !== (i = t[`${e}Span`]) && void 0 !== i ? i : 1); r++) {
        if (!n[r].isUserSetting) return;
        s += n[r].value;
      }
      return s;
    }
    setItemLayoutSizeToGrid(t, e) {
      if (J9(t)) {
        if (e.colSpan && e.colSpan > 1) return;
        if (this._colSize[e.col].isUserSetting) return;
        (this._colSize[e.col].value = Math.max(
          this._colSize[e.col].value,
          t.getLayoutRect().width + t.layoutPaddingLeft + t.layoutPaddingRight
        )),
          (this._colSize[e.col].isLayoutSetting = !0);
      } else {
        if (e.rowSpan && e.rowSpan > 1) return;
        if (this._rowSize[e.row].isUserSetting) return;
        (this._rowSize[e.row].value = Math.max(
          this._rowSize[e.row].value,
          t.getLayoutRect().height + t.layoutPaddingTop + t.layoutPaddingBottom
        )),
          (this._rowSize[e.row].isLayoutSetting = !0);
      }
    }
    layoutGrid(t) {
      const e = 'col' === t ? this._colSize : this._rowSize;
      let i = 'col' === t ? this._chartLayoutRect.width : this._chartLayoutRect.height;
      const n = [];
      e.forEach(t => {
        t.isUserSetting || t.isLayoutSetting ? (i -= t.value) : n.push(t);
      }),
        i < 0 && console.warn(`layout content ${t} size bigger than chart`),
        n.forEach(t => (t.value = i / n.length));
    }
    getItemPosition(t) {
      const e = this.getItemGridInfo(t),
        i = { x: this._chartLayoutRect.x, y: this._chartLayoutRect.y };
      for (let t = 0; t < e.col; t++) i.x += this._colSize[t].value;
      for (let t = 0; t < e.row; t++) i.y += this._rowSize[t].value;
      return (i.x += t.layoutPaddingLeft + t.layoutOffsetX), (i.y += t.layoutPaddingTop + t.layoutOffsetY), i;
    }
    getItemLayoutRect(t) {
      var e, i;
      const n = this.getItemGridInfo(t);
      return {
        width:
          (null !== (e = this.getSizeFromGird(n, 'col')) && void 0 !== e ? e : this._chartLayoutRect.width) -
          t.layoutPaddingLeft -
          t.layoutPaddingRight,
        height:
          (null !== (i = this.getSizeFromGird(n, 'row')) && void 0 !== i ? i : this._chartLayoutRect.height) -
          t.layoutPaddingTop -
          t.layoutPaddingBottom
      };
    }
    layoutItems(t, e, i, n) {
      (this._chartLayoutRect = i),
        (this._chartViewBox = n),
        this.clearLayoutSize(),
        e.sort((t, e) => e.layoutLevel - t.layoutLevel);
      const s = e.filter(t => 'normal' === t.layoutType),
        r = s.filter(t => J9(t)),
        a = s.filter(t => !J9(t));
      s.forEach(t => {
        this.layoutOneItem(t, 'user', !1);
      });
      const o = e.filter(t => 'region-relative' === t.layoutType),
        l = o.filter(t => J9(t)),
        h = o.filter(t => !J9(t));
      l.forEach(t => this.layoutOneItem(t, 'user', !1)),
        this.layoutGrid('col'),
        a.forEach(t => this.layoutOneItem(t, 'colGrid', !1)),
        h.forEach(t => {
          this.layoutOneItem(t, 'colGrid', !1);
        }),
        this.layoutGrid('row'),
        h.forEach(t => {
          this.layoutOneItem(t, 'grid', !1);
        }),
        r.forEach(t => this.layoutOneItem(t, 'grid', !1)),
        l.forEach(t => {
          this.layoutOneItem(t, 'grid', !0);
        }),
        this.layoutGrid('col'),
        e.filter(t => 'region' === t.layoutType).forEach(t => this.layoutOneItem(t, 'grid', !1)),
        this.layoutAbsoluteItems(e.filter(t => 'absolute' === t.layoutType)),
        e
          .filter(t => 'absolute' !== t.layoutType)
          .forEach(t => {
            t.setLayoutStartPosition(this.getItemPosition(t));
          });
    }
    layoutAbsoluteItems(t) {
      t.forEach(t => {
        t.absoluteLayoutInRect(this._chartLayoutRect);
      });
    }
    layoutOneItem(t, e, i) {
      var n, s;
      const r = 'rowGrid' === e || 'grid' === e ? this.getSizeFromGird.bind(this) : this.getSizeFromUser.bind(this),
        a = 'colGrid' === e || 'grid' === e ? this.getSizeFromGird.bind(this) : this.getSizeFromUser.bind(this),
        o = this.getItemGridInfo(t),
        l = {
          width:
            (null !== (n = a(o, 'col')) && void 0 !== n ? n : this._chartLayoutRect.width) -
            t.layoutPaddingLeft -
            t.layoutPaddingRight,
          height:
            (null !== (s = r(o, 'row')) && void 0 !== s ? s : this._chartLayoutRect.height) -
            t.layoutPaddingTop -
            t.layoutPaddingBottom
        },
        h = t.computeBoundsInRect(l);
      _(h.width) || (h.width = l.width),
        _(h.height) || (h.height = l.height),
        t.setLayoutRect('grid' !== e ? h : l),
        this.setItemLayoutSizeToGrid(t, o);
    }
  }
  function J9(t) {
    return 'left' === t.layoutOrient || 'right' === t.layoutOrient;
  }
  class Q9 extends o0 {
    layoutItems(t, e, i, n) {
      (this._chartLayoutRect = i),
        (this._chartViewBox = n),
        (this._leftCurrent = i.x),
        (this._topCurrent = i.y),
        (this._rightCurrent = i.x + i.width),
        (this._bottomCurrent = i.height + i.y),
        e.sort((t, e) => e.layoutLevel - t.layoutLevel),
        this.layoutNormalItems(e.filter(t => 'normal' === t.layoutType));
      const s = this._leftCurrent,
        r = this._topCurrent,
        a = this._rightCurrent,
        o = this._bottomCurrent,
        l = e.filter(t => 'region' === t.layoutType),
        h = e.filter(t => 'region-relative' === t.layoutType),
        c = e.filter(t => 'absolute' === t.layoutType),
        d = c.filter(t => 'z' === t.layoutOrient);
      let u = { width: 0, height: 0 };
      if (d.length) {
        u = d[0].getLayoutRect();
      }
      (this._leftCurrent += u.width / 8),
        (this._rightCurrent -= u.width / 8),
        (this._topCurrent += u.height / 8),
        (this._bottomCurrent -= u.height / 8);
      if (
        (this.layoutRegionItems(l, h, { offsetBottom: 0, offsetTop: 0, offsetLeft: 0, offsetRight: 0 }),
        h.some(t => t.getAutoIndent()))
      ) {
        const { top: t, bottom: e, left: i, right: n } = this._checkAutoIndent(h);
        (t || e || i || n) &&
          ((this._topCurrent = r + t),
          (this._bottomCurrent = o - e),
          (this._leftCurrent = s + i),
          (this._rightCurrent = a - n),
          this.layoutRegionItems(l, h));
      }
      const p = c.filter(t => 'z' !== t.layoutOrient);
      this.layoutAbsoluteItems(p);
      const g = h.filter(t => t.specKey && 'axes' === t.specKey && tQ(t.layoutOrient))[0],
        f = h.filter(t => t.specKey && 'axes' === t.specKey && eQ(t.layoutOrient))[0];
      if (g && d.length) {
        const t = g.getLayoutStartPoint(),
          e = g.getLayoutRect(),
          i = {
            x: 'left' === f.layoutOrient ? t.x + e.width : t.x,
            y: t.y,
            width: this._chartLayoutRect.width,
            height: this._chartLayoutRect.height
          };
        d[0].directionStr = 'left' === f.layoutOrient ? 'r2l' : 'l2r';
        const n = g.getLayoutRect(),
          s = f.getLayoutRect(),
          r = { length: d[0].getLayoutRect().width, width: n.width, height: s.height };
        g.setLayout3dBox && g.setLayout3dBox(r),
          f.setLayout3dBox && f.setLayout3dBox(r),
          d[0].setLayout3dBox && d[0].setLayout3dBox(r),
          this.layoutZAxisItems(d, i);
      }
    }
    layoutZAxisItems(t, e) {
      t.forEach(t => {
        t.absoluteLayoutInRect(e);
      });
    }
    layoutRegionItems(t, e, i) {
      let n = this._rightCurrent - this._leftCurrent,
        s = this._bottomCurrent - this._topCurrent;
      i || (i = { offsetLeft: 0, offsetRight: 0, offsetTop: 0, offsetBottom: 0 }),
        e
          .filter(t => 'left' === t.layoutOrient || 'right' === t.layoutOrient)
          .forEach(t => {
            const e = this.getItemComputeLayoutRect(t, i),
              n = t.computeBoundsInRect(e);
            t.setLayoutRect({ width: n.width }),
              'left' === t.layoutOrient
                ? (t.setLayoutStartPosition({
                    x: this._leftCurrent + t.layoutOffsetX + t.layoutPaddingLeft + i.offsetLeft
                  }),
                  (this._leftCurrent += n.width + t.layoutPaddingLeft + t.layoutPaddingRight + i.offsetLeft))
                : 'right' === t.layoutOrient &&
                  ((this._rightCurrent -= n.width + t.layoutPaddingLeft + t.layoutPaddingRight + i.offsetRight),
                  t.setLayoutStartPosition({ x: this._rightCurrent + t.layoutOffsetX + t.layoutPaddingLeft }));
          }),
        (n = this._rightCurrent - this._leftCurrent),
        e
          .filter(t => 'top' === t.layoutOrient || 'bottom' === t.layoutOrient)
          .forEach(t => {
            const e = this.getItemComputeLayoutRect(t, i),
              n = t.computeBoundsInRect(e);
            t.setLayoutRect({ height: n.height }),
              'top' === t.layoutOrient
                ? (t.setLayoutStartPosition({
                    y: this._topCurrent + t.layoutOffsetY + t.layoutPaddingTop + i.offsetTop
                  }),
                  (this._topCurrent += n.height + t.layoutPaddingTop + t.layoutPaddingBottom))
                : 'bottom' === t.layoutOrient &&
                  ((this._bottomCurrent -= n.height + t.layoutPaddingTop + t.layoutPaddingBottom + i.offsetBottom),
                  t.setLayoutStartPosition({ y: this._bottomCurrent + t.layoutOffsetY + t.layoutPaddingTop }));
          }),
        (s = this._bottomCurrent - this._topCurrent),
        t.forEach(t => {
          t.setLayoutRect({ width: n, height: s }),
            t.setLayoutStartPosition({
              x: this._leftCurrent + t.layoutOffsetX + t.layoutPaddingLeft,
              y: this._topCurrent + t.layoutOffsetY + t.layoutPaddingTop
            });
        }),
        e.forEach(e => {
          if (['left', 'right'].includes(e.layoutOrient)) {
            const i = this.filterRegionsWithID(t, e.layoutBindRegionID[0]);
            e.setLayoutRect({ height: i.getLayoutRect().height }),
              e.setLayoutStartPosition({ y: i.getLayoutStartPoint().y + e.layoutOffsetY + e.layoutPaddingTop });
          } else if (['top', 'bottom'].includes(e.layoutOrient)) {
            const i = this.filterRegionsWithID(t, e.layoutBindRegionID[0]);
            e.setLayoutRect({ width: i.getLayoutRect().width }),
              e.setLayoutStartPosition({ x: i.getLayoutStartPoint().x + e.layoutOffsetX + e.layoutPaddingLeft });
          }
        });
    }
    getItemComputeLayoutRect(t, e) {
      e || (e = { offsetLeft: 0, offsetRight: 0, offsetTop: 0, offsetBottom: 0 });
      return {
        width:
          this._rightCurrent -
          this._leftCurrent -
          t.layoutPaddingLeft -
          t.layoutPaddingRight -
          (e.offsetLeft + e.offsetRight),
        height:
          this._bottomCurrent -
          this._topCurrent -
          t.layoutPaddingTop -
          t.layoutPaddingBottom -
          (e.offsetTop + e.offsetBottom)
      };
    }
  }
  sk.load(GY),
    NQ.useChart([
      u2,
      o5,
      f2,
      y2,
      A4,
      M5,
      O5,
      D5,
      i4,
      G5,
      p3,
      R4,
      s5,
      r5,
      F5,
      r6,
      o6,
      B3,
      L3,
      H5,
      J5,
      t4,
      D4,
      u3,
      N4,
      Q4,
      k2,
      m4,
      J3,
      X5,
      i5
    ]),
    NQ.useComponent([
      q6,
      J6,
      Q6,
      t7,
      e7,
      s7,
      n7,
      l7,
      f7,
      U9,
      T7,
      C7,
      _6,
      y6,
      m7,
      x7,
      q7,
      y7,
      Z7,
      I7,
      K9,
      X9,
      J7,
      x6,
      b6,
      R6
    ]),
    UJ.registerLayout('grid', Z9),
    UJ.registerLayout('layout3d', Q9),
    (t.Arc3dMark = B5),
    (t.ArcMark = c3),
    (t.AreaChart = u2),
    (t.AreaMark = e2),
    (t.AreaSeries = a2),
    (t.Bar3dChart = y2),
    (t.Bar3dSeries = m2),
    (t.BarChart = f2),
    (t.BarSeries = g2),
    (t.BaseChart = h2),
    (t.BaseMark = g0),
    (t.BaseSeries = q1),
    (t.BoxPlotChart = k2),
    (t.BoxPlotMark = w2),
    (t.BoxPlotSeries = A2),
    (t.Brush = x6),
    (t.CartesianAxis = U6),
    (t.CartesianBandAxis = J6),
    (t.CartesianChart = c2),
    (t.CartesianCrossHair = T7),
    (t.CartesianLinearAxis = q6),
    (t.CartesianLogAxis = t7),
    (t.CartesianSeries = J1),
    (t.CartesianSymlogAxis = e7),
    (t.CartesianTimeAxis = Q6),
    (t.CellMark = t5),
    (t.CirclePackingChart = u3),
    (t.CirclePackingSeries = d3),
    (t.CircularProgressChart = F5),
    (t.CircularProgressSeries = L5),
    (t.CommonChart = p3),
    (t.ComponentMark = v0),
    (t.ContinuousLegend = f7),
    (t.CustomMark = b6),
    (t.DataZoom = _6),
    (t.DiscreteLegend = l7),
    (t.DotSeries = P4),
    (t.Factory = UJ),
    (t.Funnel3dChart = L3),
    (t.Funnel3dSeries = D3),
    (t.FunnelChart = B3),
    (t.FunnelSeries = O3),
    (t.GaugeChart = J3),
    (t.GaugePointerSeries = H3),
    (t.GaugeSeries = V3),
    (t.GeoCoordinate = x7),
    (t.GridLayout = Z9),
    (t.GroupMark = f0),
    (t.HeatmapChart = i5),
    (t.HeatmapSeries = e5),
    (t.Histogram3dChart = r5),
    (t.HistogramChart = s5),
    (t.Indicator = m7),
    (t.Label = X9),
    (t.Layout = o0),
    (t.Layout3d = Q9),
    (t.LineChart = o5),
    (t.LineMark = t2),
    (t.LineSeries = a5),
    (t.LinearProgressChart = H5),
    (t.LinearProgressSeries = z5),
    (t.LinkPathMark = f4),
    (t.LinkSeries = M4),
    (t.MapChart = M5),
    (t.MapLabelComponent = R6),
    (t.MapSeries = k5),
    (t.MarkArea = Z7),
    (t.MarkLine = q7),
    (t.MarkPoint = J7),
    (t.PathMark = z3),
    (t.Pie3dChart = D5),
    (t.Pie3dSeries = I5),
    (t.PieChart = O5),
    (t.PieSeries = P5),
    (t.Player = I7),
    (t.PolarAxis = i7),
    (t.PolarBandAxis = s7),
    (t.PolarChart = q3),
    (t.PolarCrossHair = C7),
    (t.PolarLinearAxis = n7),
    (t.PolarSeries = F3),
    (t.PolygonMark = P3),
    (t.ProgressArcMark = N3),
    (t.ProgressLikeChart = Z3),
    (t.ProgressLikeSeries = j3),
    (t.Pyramid3dMark = I3),
    (t.RadarChart = G5),
    (t.RadarSeries = V5),
    (t.RangeAreaChart = X5),
    (t.RangeAreaSeries = $5),
    (t.RangeColumn3dChart = t4),
    (t.RangeColumn3dSeries = Q5),
    (t.RangeColumnChart = J5),
    (t.RangeColumnSeries = Z5),
    (t.Rect3dMark = v2),
    (t.RectMark = p2),
    (t.RoseChart = i4),
    (t.RoseLikeChart = W5),
    (t.RoseLikeSeries = N5),
    (t.RoseSeries = e4),
    (t.RuleMark = R3),
    (t.SankeyChart = m4),
    (t.SankeySeries = v4),
    (t.ScatterChart = A4),
    (t.ScatterSeries = w4),
    (t.ScrollBar = y6),
    (t.SequenceChart = R4),
    (t.SunburstChart = D4),
    (t.SunburstSeries = I4),
    (t.SymbolMark = s2),
    (t.TextMark = i2),
    (t.ThemeManager = EJ),
    (t.Title = y7),
    (t.Tooltip = U9),
    (t.TotalLabel = K9),
    (t.TreemapChart = N4),
    (t.TreemapSeries = H4),
    (t.VChart = NQ),
    (t.WaterfallChart = Q4),
    (t.WaterfallSeries = J4),
    (t.WordCloud3dChart = o6),
    (t.WordCloud3dSeries = a6),
    (t.WordCloudChart = r6),
    (t.WordCloudSeries = s6),
    (t.default = NQ),
    (t.version = '1.3.1'),
    (t.vglobal = gN),
    Object.defineProperty(t, '__esModule', { value: !0 });
});
