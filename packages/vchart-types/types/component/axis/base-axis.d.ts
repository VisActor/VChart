import type { ITickDataOpt } from '@visactor/vrender-components';
import type { IBaseScale } from '@visactor/vscale';
import type { IGroup, IGraphic } from '@visactor/vrender-core';
import type { IOrientType, IPolarOrientType, StringOrNumber, CoordinateType } from '../../typings';
import { BaseComponent } from '../base/base-component';
import { CompilableData } from '../../compile/data';
import type { IAxis, ICommonAxisSpec, ITick } from './interface';
import type { IComponentOption } from '../interface';
import type { ISeries } from '../../series/interface';
import type { ITransformOptions } from '@visactor/vdataset';
import { DataView } from '@visactor/vdataset';
import type { IComponentMark } from '../../mark/component';
export declare abstract class AxisComponent<T extends ICommonAxisSpec & Record<string, any> = any> extends BaseComponent<T> implements IAxis {
    static specKey: string;
    specKey: string;
    protected _orient: IPolarOrientType | IOrientType;
    getOrient(): IOrientType | IPolarOrientType;
    protected _scale: IBaseScale;
    getScale(): IBaseScale;
    protected _scales: IBaseScale[];
    getScales(): IBaseScale[];
    protected _tickData: CompilableData[];
    getTickData(index?: number): CompilableData;
    protected _seriesUserId?: StringOrNumber[];
    protected _seriesIndex?: number[];
    protected _regionUserId?: StringOrNumber[];
    protected _regionIndex?: number[];
    protected _visible: boolean;
    get visible(): boolean;
    protected _inverse: boolean;
    getInverse(): boolean;
    protected _tick: ITick | undefined;
    protected abstract computeDomain(data: {
        min: number;
        max: number;
        values: any[];
    }[]): StringOrNumber[];
    abstract valueToPosition(value: any): number;
    protected abstract axisHelper(): any;
    protected abstract getSeriesStatisticsField(s: ISeries): string[];
    protected abstract updateSeriesScale(): void;
    protected abstract collectSeriesField(depth: number, series: ISeries): string | string[];
    abstract transformScaleDomain(): void;
    protected abstract updateScaleRange(): boolean;
    protected _dataFieldText: string;
    protected _axisMark: IComponentMark;
    protected _gridMark: IComponentMark;
    protected _coordinateType: CoordinateType;
    getCoordinateType(): CoordinateType;
    constructor(spec: T, options: IComponentOption);
    protected _getNeedClearVRenderComponents(): IGraphic[];
    getVRenderComponents(): any[];
    created(): void;
    protected _shouldComputeTickData(): boolean;
    protected _initData(): void;
    protected collectData(depth: number, rawData?: boolean): {
        min: number;
        max: number;
        values: any[];
    }[];
    protected isSeriesDataEnable(): boolean;
    protected setSeriesAndRegionsFromSpec(): void;
    getBindSeriesFilter(): {
        userId: StringOrNumber[];
        specIndex: number[];
    };
    protected initEvent(): void;
    protected updateScaleDomain(): void;
    protected _clearRawDomain(): void;
    onLayoutEnd(ctx: any): void;
    protected computeData(updateType?: 'domain' | 'range' | 'force'): void;
    protected initScales(): void;
    _compareSpec(spec: T, prevSpec: T): {
        change: boolean;
        reMake: boolean;
        reRender: boolean;
        reSize: boolean;
        reCompile: boolean;
    };
    protected _delegateAxisContainerEvent(component: IGroup): void;
    protected _getAxisAttributes(): any;
    protected _getGridAttributes(): {
        alternateColor: any;
        alignWithLabel: any;
        style: any;
        subGrid: {
            visible: boolean;
            type?: undefined;
            alternateColor?: undefined;
            style?: undefined;
        } | {
            type: string;
            visible: any;
            alternateColor: any;
            style: any;
        };
    };
    protected _getLabelFormatMethod(): (value: any, datum: any, index: number) => any;
    protected _initTickDataSet<T extends ITickDataOpt>(options: T, index?: number): DataView;
    protected _tickTransformOption(): ITickDataOpt;
    addTransformToTickData(options: ITransformOptions, execute?: boolean): void;
    dataToPosition(values: any[]): number;
}
export declare const registerAxis: () => void;
