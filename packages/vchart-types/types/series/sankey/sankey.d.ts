import { CartesianSeries } from '../cartesian/cartesian';
import type { SeriesMarkMap } from '../interface';
import { SeriesTypeEnum } from '../interface/type';
import type { ITextMark } from '../../mark/text';
import type { Datum, StringOrNumber } from '../../typings';
import { SeriesData } from '../base/series-data';
import type { ISankeySeriesSpec } from './interface';
import type { ExtendEventParam } from '../../event/interface';
import type { IElement, IGlyphElement, IMark as IVgrammarMark } from '@visactor/vgrammar-core';
import type { IMark } from '../../mark/interface';
import { SankeySeriesSpecTransformer } from './sankey-transformer';
export declare class SankeySeries<T extends ISankeySeriesSpec = ISankeySeriesSpec> extends CartesianSeries<T> {
    static readonly type: string;
    type: SeriesTypeEnum;
    static readonly transformerConstructor: any;
    readonly transformerConstructor: typeof SankeySeriesSpecTransformer;
    static readonly mark: SeriesMarkMap;
    private _nodeMark;
    private _linkMark;
    private _nodeLayoutZIndex;
    private _labelLayoutZIndex;
    private _labelLimit;
    protected _nodesSeriesData?: SeriesData;
    protected _linksSeriesData?: SeriesData;
    private _viewBox;
    protected _categoryField: string;
    private _colorScale;
    private _nodeList;
    get direction(): "vertical" | "horizontal";
    getCategoryField(): string;
    setCategoryField(f: string): string;
    protected _valueField: string;
    getValueField(): string;
    setValueField(f: string): string;
    setAttrFromSpec(): void;
    initData(): void;
    initMark(): void;
    protected _buildMarkAttributeContext(): void;
    valueToNode(value: StringOrNumber | StringOrNumber[]): any;
    valueToLink(value: StringOrNumber | StringOrNumber[]): any;
    valueToPositionX(value: StringOrNumber | StringOrNumber[]): any;
    valueToPositionY(value: StringOrNumber | StringOrNumber[]): any;
    initMarkStyle(): void;
    protected _initNodeMarkStyle(): void;
    protected _fillByNode: (datum: Datum) => any;
    protected _fillByLink: (datum: Datum) => any;
    protected _initLinkMarkStyle(): void;
    initLabelMarkStyle(textMark: ITextMark): void;
    private _createText;
    initAnimation(): void;
    protected initEvent(): void;
    private nodesSeriesDataUpdate;
    private linksSeriesDataUpdate;
    protected _handleEmphasisElement: (params: ExtendEventParam) => void;
    protected _handleClearEmpty: () => void;
    protected _handleNodeAdjacencyClick: (element: IElement) => void;
    protected _handleLinkAdjacencyClick: (element: IGlyphElement) => void;
    protected _handleNodeRelatedClick: (element: IElement) => void;
    protected _handleLinkRelatedClick: (element: IGlyphElement) => void;
    protected _highLightElements(vGrammarElements: IVgrammarMark['elements'], highlightNodes: string[]): void;
    protected initTooltip(): void;
    _setNodeOrdinalColorScale(): void;
    getNodeList(): any;
    _getNodeNameFromData(datum: Datum): any;
    extractNamesFromTree(tree: any, categoryName: string): Set<unknown>;
    extractNamesFromLink(links: any[]): Set<unknown>;
    getDimensionField(): string[];
    getMeasureField(): string[];
    getRawDataStatisticsByField(field: string, isNumeric?: boolean): {
        values?: any[];
        min?: number;
        max?: number;
    };
    private _collectByField;
    onLayoutEnd(ctx: any): void;
    getDefaultShapeType(): string;
    protected _noAnimationDataKey(datum: Datum, index: number): unknown | undefined;
    getActiveMarks(): IMark[];
}
export declare const registerSankeySeries: () => void;
