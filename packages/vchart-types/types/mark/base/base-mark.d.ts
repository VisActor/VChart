import { type IModelMarkAttributeContext } from '../../compile/mark/interface';
import type { Datum, IMarkSpec, ICommonSpec, ValueType, StringOrNumber, Maybe } from '../../typings';
import type { DataView } from '@visactor/vdataset';
import { MarkTypeEnum } from '../interface';
import type { IMarkRaw, IMarkStateStyle, IMarkStyle, IMark, IMarkOption, StyleConvert, MarkInputStyle, GroupedData, IAttrs, IMarkGraphic, ProgressiveContext, IProgressiveTransformResult, MarkType, AnimationStateValues } from '../interface';
import type { ICompilableMark, IMarkCompileOption, IMarkConfig, IMarkStateManager, StateValueType } from '../../compile/mark/interface';
import type { ICompilableInitOption } from '../../compile/interface';
import type { IGroupGraphicAttribute, IGroup, IGraphic } from '@visactor/vrender-core';
import { GrammarItem } from '../../compile/grammar-item';
import type { IModel } from '../../model/interface';
import type { ICompilableData } from '../../compile/data/interface';
import { type MarkAnimationSpec } from '../../animation/interface';
export type ExChannelCall = (key: string | number | symbol, datum: Datum, states: StateValueType, baseValue: unknown) => unknown;
export declare class BaseMark<T extends ICommonSpec> extends GrammarItem implements IMarkRaw<T> {
    readonly type: MarkType;
    readonly name: string;
    readonly key: ICompilableMark['key'];
    protected _markConfig: IMarkConfig;
    protected _isCommited?: boolean;
    commit(render?: boolean, recursion?: boolean): void;
    uncommit(): void;
    isCommited(): boolean;
    getMarkConfig(): IMarkConfig;
    setMarkConfig(config: IMarkConfig): void;
    protected _visible: boolean;
    getVisible(): boolean;
    setVisible(visible: boolean): void;
    protected _userId: StringOrNumber;
    getUserId(): StringOrNumber;
    setUserId(userId: StringOrNumber): void;
    readonly model: IModel;
    protected _data: ICompilableData;
    getDataView(): DataView | undefined;
    setDataView(d?: DataView): void;
    getData(): ICompilableData;
    setData(d?: ICompilableData): void;
    stateStyle: IMarkStateStyle<T>;
    state: IMarkStateManager;
    protected _unCompileChannel: {
        [key in string]: boolean;
    };
    hasState(state: string): boolean;
    getState(state: string): unknown;
    protected _animationConfig: Partial<MarkAnimationSpec>;
    getAnimationConfig(): Partial<MarkAnimationSpec>;
    setAnimationConfig(config: Partial<MarkAnimationSpec>): void;
    private _skipBeforeLayouted;
    setSkipBeforeLayouted(skip: boolean): void;
    protected _groupKey?: string;
    setGroupKey(groupKey: string): void;
    protected _stateSort?: (stateA: string, stateB: string) => number;
    protected _product: Maybe<IGroup>;
    getProduct(): IGroup;
    protected _lastMark?: IMark;
    protected initMarkData(option: ICompilableInitOption): void;
    protected _compileProduct(option?: IMarkCompileOption): void;
    protected _initProduct(group?: IGroup): void;
    generateProductId(): string;
    layout(layout: () => void): void;
    compileData(): void;
    compileEncode(): void;
    compileState(): void;
    compileAnimation(): void;
    _context: any;
    compileContext(extraContext?: any): void;
    getContext(): any;
    protected compileTransform(): void;
    updateState(newState: Record<string, unknown>, noRender?: boolean): void;
    getMarks(): IMark[];
    runAnimationByState(state?: string): void;
    stopAnimationByState(state?: string): void;
    pauseAnimationByState(state?: string): void;
    resumeAnimationByState(state?: string): void;
    removeProduct(): void;
    release(): void;
    protected _simpleStyle: T;
    setSimpleStyle(s: T): void;
    getSimpleStyle(): T;
    protected _option: IMarkOption;
    protected _attributeContext: IModelMarkAttributeContext;
    protected _encoderOfState: Record<string, Record<string, (datum: Datum) => any>>;
    _extensionChannel: {
        [key: string | number | symbol]: string[];
    };
    _computeExChannel: {
        [key: string | number | symbol]: ExChannelCall;
    };
    constructor(name: string, option: IMarkOption);
    created(): void;
    initStyleWithSpec(spec: IMarkSpec<T>): void;
    protected _transformStyleValue<T>(styleConverter: StyleConvert<T>, transform: (value: ValueType<T>) => ValueType<T>): StyleConvert<any>;
    convertAngleToRadian(styleConverter: StyleConvert<number>): any;
    isUserLevel(level: number): boolean;
    setStyle<U extends keyof T>(style: Partial<IMarkStyle<T>>, state?: StateValueType, level?: number): void;
    getStyle(key: string, state?: StateValueType): any;
    protected _filterAttribute<U extends keyof T>(attr: U, style: MarkInputStyle<T[U]>, state: StateValueType, level: number, isUserLevel: boolean): StyleConvert<T[U]>;
    setReferer<U extends keyof T>(mark: IMarkRaw<T>, styleKey?: U, state?: StateValueType): void;
    setPostProcess<U extends keyof T>(key: U, postProcessFunc: any, state?: StateValueType): void;
    getAttribute<U extends keyof T>(key: U, datum: Datum, state?: StateValueType): any;
    getAttributesOfState(datum: Datum, state?: StateValueType): any;
    setAttribute<U extends keyof T>(attr: U, style: MarkInputStyle<T[U]>, state?: StateValueType, level?: number): void;
    protected _getDefaultStyle(): IMarkStyle<T>;
    protected _styleConvert<U extends keyof T>(style?: MarkInputStyle<T[U]>): StyleConvert<T[U]> | undefined;
    protected _computeAttribute<U extends keyof T>(key: U, state: StateValueType): any;
    protected _computeStateAttribute<U extends keyof T>(stateStyle: any, key: U, state: StateValueType): any;
    private _initStyle;
    private _initSpecStyle;
    private _computeGradientAttr;
    private _computeBorderAttr;
    protected _dataByGroup: GroupedData<Datum>;
    protected _dataByKey: GroupedData<Datum>;
    protected _prevDataByKey: GroupedData<Datum>;
    protected _graphicMap: Map<string, IMarkGraphic>;
    protected _graphics: IMarkGraphic[];
    protected _keyGetter: (datum: Datum) => string;
    protected _groupKeyGetter: (datum: Datum) => string;
    protected renderContext?: {
        parameters?: any;
        progressive?: ProgressiveContext;
        beforeTransformProgressive?: IProgressiveTransformResult;
    };
    protected _attrsByGroup?: Record<string, T>;
    protected _getDataByKey(data: Datum[]): GroupedData<Datum>;
    protected _getCommonContext(): {
        markType: MarkTypeEnum;
        markId: number;
        modelId: number;
        markUserId: StringOrNumber;
        modelUserId: StringOrNumber;
    };
    prepareMorph(mark: IMark): void;
    reuse(mark: IMark): void;
    private _parseProgressiveContext;
    getGraphics(): IMarkGraphic[];
    protected _createGraphic(attrs?: any): IGraphic;
    protected _runGroupData(data: Datum[]): void;
    protected createAnimationStateList(type: string, animationConfig: Partial<MarkAnimationSpec>): any;
    protected tryRunMorphing(graphics: IMarkGraphic[]): boolean;
    protected _runStateAnimation(graphics: IMarkGraphic[]): void;
    protected _runJoin(data: Datum[]): void;
    _runEncoderOfGraphic(styles: Record<string, (datum: Datum) => any>, g: IMarkGraphic, attrs?: any): any;
    _runGroupEncoder(groupStyles: Record<string, (datum: Datum) => any>): any;
    protected _transformGraphicAttributes(g: IMarkGraphic, attrs: any, groupAttrs?: any): any;
    protected _separateNormalStyle(normalStyle: Partial<IAttrs<T>>): {
        updateStyles: {};
        groupStyles: {};
    };
    protected _getEncoderOfStyle: (stateName: string, style: Partial<IAttrs<T>>) => Record<string, (datum: Datum) => any>;
    protected _setGraphicFromMarkConfig: (g: IMarkGraphic) => void;
    protected _setStateOfGraphic: (g: IMarkGraphic) => void;
    protected _addProgressiveGraphic(parent: IGroup, g: IMarkGraphic): void;
    protected _runEncoder(graphics: IMarkGraphic[], noGroupEncode?: boolean): void;
    protected _runApplyGraphic(graphics: IMarkGraphic[]): void;
    protected _updateEncoderByState(): void;
    protected _runState(graphics: IMarkGraphic[]): void;
    protected _getAttrsFromConfig(attrs?: IGroupGraphicAttribute): IGroupGraphicAttribute;
    protected _updateAttrsOfGroup(): void;
    protected _runBeforeTransform(data: Datum[]): Datum[];
    protected _runEncoderTransform(data: Datum[], isProgressive: boolean): Datum[];
    protected _runMainTasks(): void;
    render(): void;
    updateMarkState(key: string): void;
    clearExitGraphics(): void;
    isProgressive(): boolean;
    canAnimateAfterProgressive(): boolean;
    isDoingProgressive(): boolean;
    clearProgressive(): void;
    restartProgressive(): void;
    private _runBeforeProgressive;
    protected _runProgressiveJoin(): {
        graphicsByGroup?: Record<string, IMarkGraphic[]>;
        graphics?: IMarkGraphic[];
        needUpdate?: boolean;
    };
    protected _createIncrementalGraphics(): void;
    protected _setCommonAttributesToTheme(g: IMarkGraphic): void;
    protected _runProgressiveEncoder(graphics: IMarkGraphic[]): void;
    protected _runProgressiveApplyGraphic(graphics: IMarkGraphic[]): void;
    protected _runProgressiveStep(): void;
    renderProgressive(): void;
    updateAnimationState(callback: (graphic: IMarkGraphic) => AnimationStateValues): void;
    hasAnimationByState(state: keyof MarkAnimationSpec): boolean;
    hasAnimation(): boolean;
    runAnimation(): void;
}
