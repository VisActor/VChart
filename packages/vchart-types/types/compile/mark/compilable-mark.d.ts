import type { IElement, IGroupMark, IMark, IMarkConfig, MarkAnimationSpec, MarkFunctionCallback, Nil, TransformSpec } from '@visactor/vgrammar-core';
import type { DataView } from '@visactor/vdataset';
import { GrammarItem } from '../grammar-item';
import type { Maybe, Datum, StringOrNumber } from '../../typings';
import type { IMarkStateStyle, MarkType } from '../../mark/interface';
import type { IModel } from '../../model/interface';
import { MarkStateManager } from './mark-state-manager';
import type { ICompilableMark, IMarkDataInitOption, ICompilableMarkOption, StateValueType, IMarkCompileOption, IAttributeOpt, IMarkData } from './interface';
import { GrammarType } from '../interface/compilable-item';
import type { IEvent } from '../../event/interface';
export declare abstract class CompilableMark extends GrammarItem implements ICompilableMark {
    readonly grammarType = GrammarType.mark;
    readonly type: MarkType;
    readonly name: string;
    readonly key: ICompilableMark['key'];
    protected _markConfig: IMarkConfig;
    getMarkConfig(): IMarkConfig;
    setMarkConfig(config: IMarkConfig): void;
    protected _visible: boolean;
    getVisible(): boolean;
    setVisible(visible: boolean): void;
    protected _userId: StringOrNumber;
    getUserId(): StringOrNumber;
    setUserId(userId: StringOrNumber): void;
    readonly model: IModel;
    protected _data: IMarkData;
    getDataView(): DataView | undefined;
    setDataView(d?: DataView, productId?: string): void;
    getData(): IMarkData;
    setData(d?: IMarkData): void;
    stateStyle: IMarkStateStyle<any>;
    state: MarkStateManager;
    protected _unCompileChannel: {
        [key in string]: boolean;
    };
    hasState(state: string): boolean;
    getState(state: string): unknown;
    protected _event: IEvent;
    protected _animationConfig: Partial<MarkAnimationSpec>;
    getAnimationConfig(): Partial<MarkAnimationSpec>;
    setAnimationConfig(config: Partial<MarkAnimationSpec>): void;
    private _skipBeforeLayouted;
    setSkipBeforeLayouted(skip: boolean): void;
    getSkipBeforeLayouted(): boolean;
    protected _groupKey?: string;
    getGroupKey(): string;
    setGroupKey(groupKey: string): void;
    protected _stateSort?: (stateA: string, stateB: string) => number;
    setStateSortCallback(stateSort: (stateA: string, stateB: string) => number): void;
    protected _option: ICompilableMarkOption;
    constructor(option: ICompilableMarkOption, name: string, model: IModel);
    protected _product: Maybe<IMark>;
    getProduct: () => Maybe<IMark>;
    protected _transform: TransformSpec[] | Nil;
    setTransform(transform: TransformSpec[] | Nil): void;
    protected initMarkData(option: IMarkDataInitOption): void;
    protected stateKeyToSignalName(key: string): string;
    getAttribute(key: any, datum: any, state: StateValueType, opt?: IAttributeOpt): void;
    protected _compileProduct(option?: IMarkCompileOption): void;
    protected _initProduct(group?: string | IGroupMark): void;
    generateProductId(): string;
    compileData(): void;
    updateStaticEncode(): void;
    protected _separateStyle(): {
        enterStyles: Record<string, any>;
        updateStyles: Record<string, any>;
    };
    compileEncode(): void;
    compileState(): void;
    compileAnimation(): void;
    compileContext(extraContext?: any): void;
    compileSignal(): void;
    protected _computeAttribute(key: string, state: StateValueType): (datum: Datum, opt: IAttributeOpt) => any;
    protected compileCommonAttributeCallback(key: string, state: string): MarkFunctionCallback<any>;
    protected compileTransform(): void;
    protected _lookupGrammar(id: string): IMark;
    updateState(newState: Record<string, unknown>, noRender?: boolean): void;
    updateLayoutState(noRender?: boolean, recursion?: boolean): void;
    updateMarkState(key: string): void;
    getMarks(): ICompilableMark[];
    runAnimationByState(state?: string): import("@visactor/vgrammar-core").IAnimateArranger;
    stopAnimationByState(state?: string): import("@visactor/vgrammar-core").IAnimate;
    pauseAnimationByState(state?: string): import("@visactor/vgrammar-core").IAnimate;
    resumeAnimationByState(state?: string): import("@visactor/vgrammar-core").IAnimate;
    getProductElements(): IElement[];
    release(): void;
}
