import type { IEvent } from '../event/interface';
import type { IEffect, IModel, IModelInitOption, IModelOption, IModelEvaluateOption, IModelSpec, IModelMarkInfo, IModelSpecInfo } from './interface';
import type { CoordinateType } from '../typings/coordinate';
import type { AnimationStateValues, ICompileMarkConfig, IMark, IMarkGraphic, IMarkOption, IMarkRaw, IMarkStyle } from '../mark/interface';
import type { Datum, StateValueType, ConvertToMarkStyleSpec, ICommonSpec, StringOrNumber, IRect, ILayoutRect } from '../typings';
import { MarkSet } from '../mark/mark-set';
import type { ILayoutItem } from '../layout/interface';
import { CompilableBase } from '../compile/compilable-base';
import { BaseModelSpecTransformer } from './base-model-transformer';
import type { IGroup } from '@visactor/vrender-core';
import type { ICompilableData } from '../compile/data/interface';
export declare abstract class BaseModel<T extends IModelSpec> extends CompilableBase implements IModel {
    readonly transformerConstructor: typeof BaseModelSpecTransformer;
    protected _spec: T;
    getSpec(): T;
    getSpecPath(): (string | number)[];
    getSpecInfoPath(): (string | number)[];
    readonly type: string;
    readonly modelType: string;
    readonly id: number;
    userId: StringOrNumber | undefined;
    readonly event: IEvent;
    readonly effect: IEffect;
    protected _data: ICompilableData;
    getData(): ICompilableData;
    protected _layout?: ILayoutItem;
    get layout(): ILayoutItem;
    readonly specKey: string;
    protected _option: IModelOption;
    getOption(): IModelOption;
    protected _marks: MarkSet;
    getMarks(): IMark[];
    getMarkNameMap(): Record<string, IMark>;
    getMarkSet(): MarkSet;
    getChart(): import("..").IChart;
    protected get _theme(): any;
    protected _lastLayoutRect: ILayoutRect;
    constructor(spec: T, option: IModelOption);
    coordinate?: CoordinateType;
    protected _releaseEvent(): void;
    created(): void;
    init(option: IModelInitOption): void;
    afterInit(): void;
    getVisible(): boolean;
    onLayoutStart(layoutRect: IRect, viewRect: ILayoutRect): void;
    onLayoutEnd(): void;
    onEvaluateEnd(ctx: IModelEvaluateOption): void;
    onBeforeRender(): void;
    onDataUpdate(): void;
    beforeRelease(): void;
    clear(): void;
    release(): void;
    updateSpec(spec: T): {
        change: boolean;
        reMake: boolean;
        reRender: boolean;
        reSize: boolean;
        reCompile: boolean;
    };
    protected _compareSpec(spec: T, prevSpec: T): {
        change: boolean;
        reMake: boolean;
        reRender: boolean;
        reSize: boolean;
        reCompile: boolean;
    };
    reInit(spec?: T): void;
    updateLayoutAttribute(): void;
    setAttrFromSpec(): void;
    protected _convertMarkStyle<T extends ICommonSpec = ICommonSpec>(style: Partial<IMarkStyle<T> | ConvertToMarkStyleSpec<T>>): Partial<IMarkStyle<T> | ConvertToMarkStyleSpec<T>>;
    setMarkStyle<T extends ICommonSpec>(mark: IMarkRaw<T>, style?: Partial<IMarkStyle<T> | ConvertToMarkStyleSpec<T>>, state?: StateValueType, level?: number): void;
    initMarkStyleWithSpec(mark?: IMark, spec?: any): void;
    protected stateKeyToSignalName(key: string, opt?: string): string;
    compileData(): void;
    compileMarks(group?: IGroup): void;
    protected _createMark<T extends IMark>(markInfo: IModelMarkInfo, option?: Partial<IMarkOption>, config?: ICompileMarkConfig): T;
    protected _getDataIdKey(): string | ((datum: Datum) => string) | undefined;
    getColorScheme(): any;
    getSpecInfo(): IModelSpecInfo<any>;
    getSpecIndex(): number;
    private _aniamtionStateCallback;
    updateAnimateStateCallback(callback: (graphic: IMarkGraphic) => AnimationStateValues): void;
    getAnimationStateCallback(): (graphic: IMarkGraphic) => AnimationStateValues;
}
